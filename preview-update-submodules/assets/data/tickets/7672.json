{"id": 7672, "title": "Ticket #7672: schedd should not block when asking negotiator to reschedule", "description": "<blockquote>\nGregT and ToddT found the following evidence of the schedd blocking:\n\n<p></p><div class=\"code\">\n<pre class=\"code\">06/02/20 09:40:52 (pid:2188) (D_ALWAYS) Can't find address for negotiator cm0.cs.wisc.edu\n06/02/20 09:40:52 (pid:2188) (D_ALWAYS|D_FAILURE) Failed to send RESCHEDULE to negotiator cm0.cs.wisc.edu:\n06/02/20 09:41:52 (pid:2188) (D_ALWAYS) attempt to connect to &lt;128.104.109.26:9618&gt; failed: timed out after 60 seconds.\n</pre></div>\n\n\n<p>Note that <strong>128.104.109.26</strong> is <em>vultur.ssec.wisc.edu</em>, not <em>cm0.cs.wisc.edu</em>.\n\n</p><p></p><hr/>\n<em>(description updated to match commentary)</em>\n\n<p>Turning the debugging all the way up, this is happening as a result of a blocking lookup of the negotiator in question in its collector.  Details of the code are below, but it looks like <em>all</em> collector queries are blocking.\n\n</p><p>The assumption that collector queries are blocking is baked pretty deep into the daemon client (among, presumably, others), and it seems like it would be quite difficult to correct the problem generally (because of language limitations).  Instead, it might be easier to avoid the problem and implement a non-blocking variant of <code>Daemon::locate()</code>; it would have to accept a callback.\n\n</p><p>GregT wisely observes that we could minimize the need for these collector queries by caching the results.</p></blockquote>", "remarks": "<blockquote>\n<em>2020-Jun-03 13:54:42 by bbockelm:</em> <br/>\n\nThe other thing to note is getting the negotiator sinful from the collector is blocking.\n\n<p>Many years back when I did more profiling this would bubble up into the top uses of the schedd's time.\n\n</p><p></p><hr/>\n<em>2020-Jun-03 14:01:45 by tlmiller:</em> <br/>\n\nYeah, I just figured that out. :(  I'll confirm by twisting the QUERY_TIMEOUT knob, but I'm pretty sure this is the low debug level being deceptive, and the blocking is actually happening in the collector query.\n\n<p></p><hr/>\n<em>2020-Jun-03 14:07:46 by tlmiller:</em> <br/>\n\nOK, twisting the knob didn't change the timeout messages to the number I set the knob too, but they did shrink considerably from the 60 second default for QUERY_TIMEOUT, so I'm calling that confirmation.\n\n<p></p><hr/>\n<em>2020-Jun-03 14:59:26 by tlmiller:</em> <br/>\n\n<div class=\"code\">\n<pre class=\"code\">    // condor_daemon_client/daemon.cpp:1350; _pool is the entry in FLOCK_COLLECTOR_HOSTS\n    // which corresponds to the flocked negotiator we're asking to reschedule.\n    CollectorList * collectors = CollectorList::create(_pool);\n    if (collectors-&gt;query (query, ads) != Q_OK) {\n\n    // This goes to condor_daemon_client/daemon_list.cpp:352 --\n    result = cQuery.processAds (callback, pv, daemon-&gt;addr(), errstack);\n\n    // which calls condor_utils/condor_query.cpp:248 --\n    int mytimeout = param_integer (\"QUERY_TIMEOUT\",60);\n    if (!(sock = my_collector.startCommand(command, Stream::reli_sock, mytimeout, errstack)) ||\n        !putClassAd (sock, queryAd) || !sock-&gt;end_of_message()) {\n</pre></div>\n\n\n<p>So I'm guessing it's probably least disruptive to make a nonblocking variant of Daemon::locate() available (one that takes a callback, I guess, to invoke when the locate succeeds, fails, or times out); that seems like the least-painful way to proceed.\n\n</p><p></p><hr/>\n<em>2020-Jun-03 15:13:22 by tlmiller:</em> <br/>\n\nI should explicitly state: as far as I can tell from reviewing the log with higher debug levels set, the reschedule itself is correctly sent non-blocking.\n\n<p></p><hr/>\n<em>2020-Jun-17 11:56:24 by tlmiller:</em> <br/>\n\nMiron wants a document with:\n<ul>\n<li>what blocking calls to a collector does the schedd make?\n</li><li>which of those calls are done to a collector to which the schedd is flocking?</li></ul>\n</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "defect", "last_change": "2020-Jun-17 11:56", "status": "new", "created": "2020-Jun-03 11:09", "fixed_version": "2020-Jun-03 11:09", "broken_version": "", "priority": "2", "subsystem": "DaemonsSubmitNode", "assigned_to": "tlmiller", "derived_from": "", "creator": "tlmiller", "rust": "", "customer_group": "other", "visibility": "public", "notify": "tlmiller@cs.wisc.edu, tannenba@cs.wisc.edu", "due_date": ""}