{"id": 705, "title": "Ticket #705: GCB causes daemons to hang", "description": "<blockquote>\nTwo users found their GCBized schedds hanging when they upgraded.  Disabling GCB fixes the problem.\n\n<p><strong>The problem: GCB assumes that read (and a _bunch_ of other functions) return int (32 bits on Linux 32 and Linux 64).  read returns ssize_t, and on 64-bit Linux that is a 64-bit quantity.</strong>  (Returning int is the <em>old</em> POSIX standard.)\n\n</p><p><span class=\"section\"></span></p><h2>User information</h2>\n\n<p>Both users are using 64-bit systems\n\n</p><p><table border=\"1\" cellspacing=\"0\">\n<tbody><tr>\n<td>\nTicket      </td>\n<td>\n19542         </td>\n<td>\n19623</td>\n</tr>\n\n<tr>\n<td>\nGCB         </td>\n<td>\n7.0.5         </td>\n<td>\n7.2.1</td>\n</tr>\n\n<tr>\n<td>\nWorking     </td>\n<td>\n<pre>\n              </pre>\n</td>\n<td>\n7.2.0</td>\n</tr>\n\n<tr>\n<td>\nBad         </td>\n<td>\n7.2.1         </td>\n<td>\n7.2.3, 7.2.4</td>\n</tr>\n\n</tbody></table>\n</p><p><span class=\"section\"></span></p><h2>condor-admin #19542</h2>\n\n<p>Backtrace\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">#0  0x00000030c68c4360 in __read_nocancel () from /lib64/libc.so.6\n#1  0x000000000083f182 in GCB_read ()\n#2  0x0000000000831036 in __wrap_read ()\n#3  0x000000000059aad7 in DaemonCore::Driver ()\n#4  0x00000000005a46d1 in main ()\n</pre></div>\n\n\n<p>strace:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">read(4, 0x7fff80e4fe10, 8)              = -1 EAGAIN (Resource temporarily unavailable)\nread(4, 0x7fff80e4fe10, 8)              = -1 EAGAIN (Resource temporarily unavailable)\nread(4, 0x7fff80e4fe10, 8)              = -1 EAGAIN (Resource temporarily unavailable)\nread(4, 0x7fff80e4fe10, 8)              = -1 EAGAIN (Resource temporarily unavailable)\nread(4, 0x7fff80e4fe10, 8)              = -1 EAGAIN (Resource temporarily unavailable)\nread(4, 0x7fff80e4fe10, 8)              = -1 EAGAIN (Resource temporarily unavailable)\n</pre></div>\n\n\n<p><span class=\"section\"></span></p><h2>Investigation </h2>\n\n<p>Reproduced.  Requires an x86-64 machine.  In DaemonCore::Driver at daemon_core.cpp:2605 is code like this:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">#ifndef WIN32\n// Drain our async_pipe; we must do this before we unblock unix signals.\n// Just keep reading while something is there.  async_pipe is set to\n// non-blocking mode via fcntl, so the read below will not block.\nwhile( read(async_pipe[0],asyncpipe_buf,8) &gt; 0 );\n#endif\n</pre></div>\n\n\n<p>This loop loops forever.  Of course read() is being transformed into __wrap_read(), which itself is a thin wrapper for GCB_read().  GCB_read() correctly detects that this is not a GCB managed FD and hands the call off to the system read().  Why this constantly returns a positive value is not yet known.\n\n</p><p>With much assistance from psilord, the next layer of the problem has been cracked.  The generated assembly is testing the return code from __wrap_read() as a 64-bit value, but __wrap_read() is returning a 32-bit value. __wrap_read is returning a 32-bit -1 (0xffffffff) to indicate an error.  This is interpreted as 0x00000000ffffffff, which is 4294967295, which is positive.  Assuming that about 4 billion bytes have been successfully read(), the loop tries again.\n\n</p><p><strong>The problem: GCB assumes that read (and a _bunch_ of other functions) return int (32 bits on Linux 32 and Linux 64).  read returns ssize_t, and on 64-bit Linux that is a 64-bit quantity.</strong>\n\n</p><p>The relevant code:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">0x00000000004e3e0a &lt;_ZN10DaemonCore6DriverEv+2048&gt;:     callq  0x7265b0 &lt;__wrap_read&gt;\n0x00000000004e3e0f &lt;_ZN10DaemonCore6DriverEv+2053&gt;:     test   %rax,%rax\n0x00000000004e3e12 &lt;_ZN10DaemonCore6DriverEv+2056&gt;:     setg   %al  - Set if ZF=0 and SF=OF\n0x00000000004e3e15 &lt;_ZN10DaemonCore6DriverEv+2059&gt;:     test   %al,%al\n0x00000000004e3e17 &lt;_ZN10DaemonCore6DriverEv+2061&gt;:     jne    0x4e3df4 &lt;_ZN10DaemonCore6DriverEv+2026&gt;\n</pre></div>\n\n\n<p>Annotated:\n\n</p><p></p><ul>\n<li>callq  __wrap_read - Call __wrap_read. %rax is 0x00000000ffffffff.  The lower 32 bits are eax, and represent -1, but rax as a whole is 4294967295\n</li><li>test   %rax,%rax - Set eflags/rflags.  OF is 0. If rax&gt;0: SF=0, ZF=0. if rax&lt;0: SF=1, ZF=0. if rax==0: SF=0, ZF=1.  Because rax is 4294967295, SF=0, ZF=0\n</li><li>setg   %al  - if ZF=0 and SF=OF: al=1, otherwise al=0.  Given het above: al=1.\n</li><li>test   %al,%al - Set eflags/rflags.  OF is 0. If al==0: ZF=1, otherwise ZF=0.  Because al=1 is ZF=0\n</li><li>jne    &lt;_ZN10DaemonCore6DriverEv+2026&gt; - if ZF==0: jump backward (redo loop), otherwise continue.  Because ZF==0, the loop continues.\n</li></ul>\n\n<p><span class=\"section\"></span></p><h2>Useful Links</h2>\n\n<p></p><ul>\n<li><a class=\"external\" href=\"http://www.amd.com/us-en/Processors/DevelopWithAMD/0,,30_2252_869_875%5E7044,00.html\">AMD64 Architecture Tech Docs</a> - In particular, book 1 for registers and flags, book 3 for assembly.</li></ul>\n</blockquote>", "remarks": "<blockquote>\n<em>2009-Sep-01 18:14:45 by psilord:</em> <br/>\n\nOh yeah, make sure to check the return codepath of the wrapper and see if it is\nspecifically treating rax as eax for the return code of the wrapper. Looking at\nthe assembly might be helpful there too.\n\n<p>If the wrapper is manually using eax instead of rax, then that is what you need\nto figure out why it is doing that. Look for something forcing the return value to\nbe hard coded to 32 bits.\n\n</p><p></p><hr/>\n<em>2009-Sep-01 18:16:05 by psilord:</em> <br/>\n\nOh just now I noticed the bolded text. Ok, that's the error. read returns size_t,\nnot int. That be be the totality of the problem. Now you just have to fix gcb to\nchoose the right return types for the right platforms.\n\n<p></p><hr/>\n<em>2009-Sep-02 15:14:08 by adesmet:</em> <br/>\n\nGCB itself has been updated with a fix, but it hasn't been tested against Condor yet.\n\n<p></p><hr/>\n<em>2011-Nov-09 16:49:19 by adesmet:</em> <br/>\n\nGCB is dead.</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "defect", "last_change": "2011-Nov-21 15:56", "status": "abandoned", "created": "2009-Sep-01 11:02", "fixed_version": "2009-Sep-01 11:02", "broken_version": "", "priority": "2", "subsystem": "Daemons", "assigned_to": "", "derived_from": "", "creator": "adesmet", "rust": "", "customer_group": "other", "visibility": "public", "notify": "", "due_date": ""}