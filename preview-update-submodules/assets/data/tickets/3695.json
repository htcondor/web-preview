{"id": 3695, "title": "Ticket #3695: Accounting Group with accept_surplus = false can go above quota", "description": "<blockquote>\nWe are able to reproducibly configure HTCondor accounting groups to go above their configured quota.  The description at a high level:\n\n<p>We have two child groups, and want to limit the sum of their allocation to a fixed value, but are willing to let the usage for the individual groups float from zero to the sum.  To implement this, we set accept_surplus = true for the children, and false for their parent, and assign a fixed quota to the parent. If there is infinite demand for one child group and zero for the other in the first negotiation cycle, the first group will correctly be assigned the sum.  However, if demand then springs up in the next cycle for the other child group, the system, ignorant of usage, assigns the full static quota (with no surplus) to the group with no usage, and the sum allocated to the two groups exceeds the parent's quota.\n\n</p><p></p><hr/>\nTo reproduce\n\n<p></p><div class=\"code\">\n<pre class=\"code\">NUM_CPUS = 100\nMEMORY = 8192\nGROUP_NAMES = group_atlas_analysis, group_atlas_analysis.long,\ngroup_atlas_analysis.short\nGROUP_QUOTA_group_atlas_analysis = 80\nGROUP_QUOTA_group_atlas_analysis.short = 40\nGROUP_QUOTA_group_atlas_analysis.long = 40\nGROUP_ACCEPT_SURPLUS_group_atlas_analysis = false\nGROUP_ACCEPT_SURPLUS_group_atlas_analysis = false\nGROUP_ACCEPT_SURPLUS_group_atlas_analysis.long = true\nGROUP_ACCEPT_SURPLUS_group_atlas_analysis.short = true\nGROUP_AUTOREGROUP = false\nGROUP_ACCEPT_SURPLUS = false\nNEGOTIATOR_ALLOW_QUOTA_OVERSUBSCRIPTION = false\n\n\n# long.submit\nuniverse = vanilla\nexecutable = /bin/sleep\narguments = 3600\n\noutput = o\nerror  = e\n\nnotification = never\nlog = log\n+AccountingGroup = \"group_atlas_analysis.long.longUser\"\nqueue 100\n\n# short.submit\n$ cat short.submi3\nuniverse = vanilla\nexecutable = /bin/sleep\narguments = 3600\n\noutput = o\nerror  = e\n\nnotification = never\nlog = log\n#copy_to_spool = true\n+AccountingGroup = \"group_atlas_analysis.short.shortUser\"\nqueue 100\n\n$ condor_submit long.submit\nSubmitting\njob(s)....................................................................................................\n100 job(s) submitted to cluster 436.\n\n# note that after submitting 100 jobs in the first group, 80 are\nrunning, as expected,\n# using the quota of 40 for the group, and borrowing the surplus 40 from\nthe other group.\n# But, capped at the 80 of my parent group.\n$ condor_userprio\nLast Priority Update:  6/11 11:05\nGroup                                    Config     Use Effective\nPriority   Res   Total\n   User Name                               Quota   Surplus Priority\nFactor   In Use\n--------------------------------------- --------- ------- ------------\n--------- ------ ------------\ngroup_atlas_analysis.short                  40.00\nByQuota                   1.00      0\n   shortUser@chevre.cs.wisc.edu 3.77      1.00      0\ngroup_atlas_analysis.long                   40.00\nByQuota                   1.00     80\n   longUser@chevre.cs.wisc.edu 5.68      1.00     80\n\n$ condor_submit short.submit\nSubmitting\njob(s)....................................................................................................\n100 job(s) submitted to cluster 437.\n\n# However, here, although my parent group has a quota of 80, and\naccept_surplus\nis false for the parent, the sum of the two children is above the quota.\n$ condor_userprio\nLast Priority Update:  6/11 11:08\nGroup                                    Config     Use Effective\nPriority   Res   Total\n   User Name                               Quota   Surplus Priority\nFactor   In Use\n--------------------------------------- --------- ------- ------------\n--------- ------ ------------\ngroup_atlas_analysis.short                  40.00\nByQuota                   1.00     20\n   shortUser@chevre.cs.wisc.edu 3.76      1.00     20\ngroup_atlas_analysis.long                   40.00\nByQuota                   1.00     80\n   longUser@chevre.cs.wisc.edu 5.76      1.00     80\n</pre></div>\n</blockquote>", "remarks": "<blockquote>\n<em>2013-Jun-17 15:47:26 by eje:</em> <br/>\n\nFrom email discussion, for posterity:\n\n<p>OK, I see what's happening.   The surplus logic is working properly -- that is, no surplus is awarded to anybody on the 2nd cycle.  Here's the state of play coming into the 2nd cycle:\n\n</p><p></p><div class=\"verbatim\">\n<pre>06/12/13 10:54:53 group quotas: group= &lt;none&gt;  cquota= 0  static= 0  accept= 1  quota= 20  req= 0  usage= 0\n06/12/13 10:54:53 group quotas: group= group_atlas_analysis  cquota= 80  static= 1  accept= 0  quota= 0  req= 0  usage= 0\n06/12/13 10:54:53 group quotas: group= group_atlas_analysis.long  cquota= 40  static= 1  accept= 1  quota= 40  req= 180  usage= 80\n06/12/13 10:54:53 group quotas: group= group_atlas_analysis.short  cquota= 40  static= 1  accept= 1  quota= 40  req= 100  usage= 0\n</pre></div>\n\n\n<p>\"group_atlas_analysis.long\" is using the 80 it was given from last round, since at that point it was able to accept the surplus from \"group_atlas_analysis.short\".  Note, now both \".long\" and \".short\" are requesting more than their quota.\n\n</p><p>So, here we can see that the outcome was that both \".long\" and \".short\" were allocated up to their quota of 40:  (\"allocated= 40\").   Note, this logic is <strong>not</strong> designed to penalize any group if it currently has more than its quota.\n\n</p><p></p><div class=\"verbatim\">\n<pre>06/12/13 10:54:53 group quotas: group= &lt;none&gt;  quota= 20  requested= 0  allocated= 0  unallocated= 0\n06/12/13 10:54:53 group quotas: group= group_atlas_analysis  quota= 0  requested= 0  allocated= 0  unallocated= 0\n06/12/13 10:54:53 group quotas: group= group_atlas_analysis.long  quota= 40  requested= 180  allocated= 40  unallocated= 140\n06/12/13 10:54:53 group quotas: group= group_atlas_analysis.short  quota= 40  requested= 100  allocated= 40  unallocated= 60\n</pre></div>\n\n\n<p>Also note: \".long\" does not negotiate this round, because it <strong>does</strong> skip negotiation for groups whose current usage is &gt;= their allocation:\n\n</p><p></p><div class=\"verbatim\">\n<pre>06/12/13 10:54:55 Group group_atlas_analysis.long - sortkey= 2\n06/12/13 10:54:55 Group group_atlas_analysis.long - skipping, at or over quota (usage=80)\n</pre></div>\n\n\n<p>Now, the pertinent bit:   \".short\" was allocated its quota of 40.   There <strong>are</strong> 20 unused slots laying around, and so it negotiates and manages to get those 20.   If there had been <strong>other</strong> groups contending, recall that this is currently dealt with by the group-negotiation sorting order, which defaults to a starvation metric, so the most-starved groups always get first shot at negotiation.  In this case, that was only \".short\"\n\n</p><p></p><div class=\"verbatim\">\n<pre>&gt; Once this specific fire is put out, seems like we really need a list of\n&gt; common HGQ usage scenarios, and for each scenario a configuration\n&gt; example and a regression test....\n</pre></div>\n\n\n<p>So, I think this all touches on the semantics of (a) what factors \"should\" be taken into account during resource allocations, and (b) what does it mean to be a child group.   I recall Steve Timm once said that his intuition about group hierarchy was that if a parent group's quota was \"Q\", then it \"should\" mean that child groups are constrained to never use more than Q groups, total.  That is <strong>not</strong> the currently implemented semantic.  Implementing such a semantic would require a new kind of logic, where a group's current usage is also checked against rolled-up totals for its parents, on up to root, prior to being allowed to negotiate for a next resource.\n\n</p><p></p><hr/>\n<em>2013-Jun-18 11:07:26 by jrt:</em> <br/>\n\nThis is a regression. The children groups should not go outside of the parent's quota. Not sure where it was introduced, however condor-7.8.8-0.4.1.el6.x86_64 (which does have some additional patches in it) does not show the issue, but 7.9.1 does. Also, with 7.9.1 dynamic quotas seem to work as designed with the parent bounding the children. So this seems to be specific to handling of static quotas.\n\n<p></p><hr/>\n<em>2013-Jun-18 11:12:46 by gthain:</em> <br/>\n\nNote there's a race condition here -- if demand for both groups exist at one negotiation cycle, the parent's quota is honored.  If the new demand shows up in the second, then the quota is exceeded.\n\n<p></p><hr/>\n<em>2013-Jun-18 12:43:47 by jrt:</em> <br/>\n\n7.8.8 and 7.9.1 still test good as in my previous comment even separating submission across different cycles.\n\n<p></p><hr/>\n<em>2013-Jun-21 18:07:25 by eje:</em> <br/>\n\nREVIEW of patches:\n\n<p>I think Jon's patch does the right thing in terms of examining \"allocated\" values in a way that is compatible with both static and dynamic quotas (our customers will want this to work with dynamic quotas).\n\n</p><p>Greg's patch examines parents up the stack, which I think is the right thing for cases where a group's immediate parent doesn't have surplus disabled, but some other ancestor does.   Recomputing the usages each round seems good, although with large hierarchies it might have a measurable cost.\n\n</p><p></p><hr/>\n<em>2013-Jun-22 14:52:43 by eje:</em> <br/>\n\nAnother question about proposed semantics:  both patches seem to only enforce a maximum for groups where accept-surplus is disabled.  One possible interpretation is that <strong>all</strong> groups enforce maximums, and if a group happens to accept surplus, then that surplus correspondingly increases the maximum.   In the code, this would actually be simpler. It would amount to removing the check for accept_surplus in the logic.\n\n<p></p><hr/>\n<em>2013-Jun-24 09:40:30 by gthain:</em> <br/>\n\ns/enabled/disabled/ in the previous remark?\n\n<p></p><hr/>\n<em>2013-Jun-24 14:25:39 by jrt:</em> <br/>\n\nThe other way to do it is integrate it in the fairshare routines so there is no low level accept_surplus check in negotiationTime. <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=NegotiationTime\" title=\"Negotiation Time\">NegotiationTime</a></span> remains unchanged and sum of allocated values for children never exceeds parent quota - subtree usage. Any unused slots are handled out in RR fashion, so each starved group gets a shot at some of the remaining. Both patches simply limit. Conceivably, the first group could get the bulk of slots, a second group a limited number, and a third group none. This would be a more complicated patch and I think would probably require at least one additional recursive tree walk, maybe two.\n\n<p>For Greg's patch, I think calculate_subtree_usage can be eliminated and instead get usage in fairshare as I did in the patch I attached. Also, it looks like the check for static_quota should be removed because it does repro with dynamic quotas too.\n\n</p><p></p><hr/>\n<em>2013-Jun-24 16:07:53 by eje:</em> <br/>\n\nto elaborate on my comment above, suppose you have:\n\n<p></p><div class=\"code\">\n<pre class=\"code\"># hierarchy four deep\nGROUP_NAMES = a, a.b, a.b.c, a.b.c.d\n\n# only \"a.b\" has surplus disabled\nGROUP_ACCEPT_SURPLUS = true\nGROUP_ACCEPT_SURPLUS_a.b = false\n</pre></div>\n\n\n<p>In the current patch, the child(ren) of \"a.b.c\" would not be restricted to \"a.b.c\"'s quota, because it has surplus enabled.\n\n</p><p>However, whether or not surplus is enabled can be thought of as orthogonal to whether parent groups limit the sum of child (subtree) quotas.  Put another way, the config var NEGOTIATOR_STRICT_ENFORCE_QUOTA could apply to all parent groups, not just ones with surplus disabled.  With this semantic, \"a.b.c.d\" would be limited by its quota, but also \"a.b.c\", \"a.b\" and \"a\" -- the quotas of all parent groups would have to be respected.\n\n</p><p>Tangentially, maybe something like NEGOTIATOR_ENFORCE_PARENT_QUOTAS as an alternative to NEGOTIATOR_STRICT_ENFORCE_QUOTA.</p></blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body><blockquote>\n<ul>\n<li><a href=\"../files/754/NegotiatorLog\">NegotiatorLog</a>\n161973 bytes added by gthain on 2013-Jun-12 15:56:42 UTC.\n<br/>\nNegotiator log with D_FULLDEBUG<br/>\n</li><li><a href=\"../files/757/match.patch\">match.patch</a>\n4866 bytes added by jrt on 2013-Jun-19 14:37:46 UTC.\n<br/>\nPatch to fix hfs where accept_surplus is false.<br/>\n</li><li><a href=\"../files/762/0001-In-group-quota-constrain-allocation-when-accept_surp.patch\">0001-In-group-quota-constrain-allocation-when-accept_surp.patch</a>\n5087 bytes added by gthain on 2013-Jun-21 21:10:06 UTC.\n<br/>\nHere's the patch BNL is running<br/>\n</li></ul>\n</blockquote></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2013-Jul-01 14:52</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/eab20f6993bb1eab98ae47c47680bfaed3117d52\">[36739]</a></span>: minor version history item edit ===GT=== <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=3695\" onclick=\"get_ticket_and_populate_wrapper('3695'); return false;\" title=\"Accounting Group with accept_surplus = false can go above quota\">#3695</a></span>  (By Karen Miller )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2013-Jun-26 09:33</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/5a3d289444c3e8c6358f2284dfcdbd8edea965d4\">[36684]</a></span>: Support strict enforcement of dynamic quotas <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=3695\" onclick=\"get_ticket_and_populate_wrapper('3695'); return false;\" title=\"Accounting Group with accept_surplus = false can go above quota\">#3695</a></span>  (By Greg Thain )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2013-Jun-24 13:52</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/c1816dfe896ec292ee5d51b4b2c413a7072695ed\">[36660]</a></span>: Document <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=3695\" onclick=\"get_ticket_and_populate_wrapper('3695'); return false;\" title=\"Accounting Group with accept_surplus = false can go above quota\">#3695</a></span>  (By Greg Thain )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2013-Jun-24 11:10</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/ba84daf6fb0effbaf32b66bd5193a7c7df9b4b32\">[36655]</a></span>: In group quota, constrain allocation when accept_surplus=false <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=3695\" onclick=\"get_ticket_and_populate_wrapper('3695'); return false;\" title=\"Accounting Group with accept_surplus = false can go above quota\">#3695</a></span>  (By Greg Thain )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2013-Jun-24 11:09</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/469a7c71d30a3ae78908c9ceb407cc4ca42590af\">[36654]</a></span>: In group quota, constrain allocation when accept_surplus=false <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=3695\" onclick=\"get_ticket_and_populate_wrapper('3695'); return false;\" title=\"Accounting Group with accept_surplus = false can go above quota\">#3695</a></span>  (By Greg Thain )</td></tr>\n</tbody></table>", "type": "defect", "last_change": "2013-Jul-01 15:09", "status": "resolved", "created": "2013-Jun-12 10:16", "fixed_version": "2013-Jun-12 10:16", "broken_version": "v080000", "priority": "1", "subsystem": "DaemonsCM", "assigned_to": "gthain", "derived_from": "", "creator": "gthain", "rust": "", "customer_group": "atlas", "visibility": "public", "notify": "eje@cs.wisc.edu, matt@cs.wisc.edu, tstclair@redhat.com, gthain@cs.wisc.edu, tannenba@cs.wisc.edu", "due_date": "20130624"}