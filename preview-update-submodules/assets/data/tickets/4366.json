{"id": 4366, "title": "Ticket #4366: memoryleak on accepted socket", "description": "<blockquote>\nJaime: maybe this is the same as your memory leak, but this time, coming through the shared point endpoint?\n\n<p></p><div class=\"code\">\n<pre class=\"code\">==10286== 910 (784 direct, 126 indirect) bytes in 1 blocks are definitely lost in loss record 1,562 of 1,585\n==10286==    at 0x4A075BC: operator new(unsigned long) (vg_replace_malloc.c:298)\n==10286==    by 0x4F81ACE: SharedPortEndpoint::ReceiveSocket(ReliSock*, ReliSock*) (shared_port_endpoint.cpp:999)\n==10286==    by 0x4F817EC: SharedPortEndpoint::DoListenerAccept(ReliSock*) (shared_port_endpoint.cpp:913)\n==10286==    by 0x4F815DC: SharedPortEndpoint::HandleListenerAccept(Stream*) (shared_port_endpoint.cpp:833)\n==10286==    by 0x4FDE359: DaemonCore::CallSocketHandler_worker(int, bool, Stream*) (daemon_core.cpp:3849)\n==10286==    by 0x4FDE08B: DaemonCore::CallSocketHandler_worker_demarshall(void*) (daemon_core.cpp:3811)\n==10286==    by 0x4E4783C: CondorThreads::pool_add(void (*)(void*), void*, int*, char const*) (condor_threads.cpp:1106)\n==10286==    by 0x4FDE02E: DaemonCore::CallSocketHandler(int&amp;, bool) (daemon_core.cpp:3799)\n==10286==    by 0x4FDDA31: DaemonCore::Driver() (daemon_core.cpp:3672)\n==10286==    by 0x4FC63F2: dc_main(int, char**) (daemon_core_main.cpp:2772)\n==10286==    by 0x48F176: main (schedd_main.cpp:210)\n\n</pre></div>\n</blockquote>", "remarks": "<blockquote>\n<em>2014-May-20 14:35:36 by jfrey:</em> <br/>\n\nI don't see an obvious way for this <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ReliSock\" title=\"Reli Sock\">ReliSock</a></span> to leak once it gets to the HandleReqAsync() call. With the leak I fixed in <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=4370\" onclick=\"get_ticket_and_populate_wrapper('4370'); return false;\" title=\"Memory leak when reusing cached collector connection\">#4370</a></span>, the socket must already be registered in <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCore\" title=\"Daemon Core\">DaemonCore</a></span>. In SharedPortEndpoint::ReceiveSocket() itself, the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ReliSock\" title=\"Reli Sock\">ReliSock</a></span> will leak if sending the response to the shared port daemon fails.\n\n<p></p><hr/>\n<em>2014-May-20 14:38:57 by jfrey:</em> <br/>\n\nIn SharedPortEndpoint::ReceiveSocket(), I think we should just remove the early return when we fail to send a reply to the shared-port daemon. Why not handle the connection we just received?</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2014-May-20 14:49</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/f0cd89c5d15a6acbe1abccc4010766da417b341b\">[40190]</a></span>: Fix memory leak when a daemon can't respond to the shared port daemon. <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=4366\" onclick=\"get_ticket_and_populate_wrapper('4366'); return false;\" title=\"memoryleak on accepted socket\">#4366</a></span> In SharedPortEndpoint::ReceiveSocket(), don't return early if we fail to send a reply to the shared port daemon. This can leak a <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ReliSock\" title=\"Reli Sock\">ReliSock</a></span> and an fd, and I don't see a reason not to try servicing the connection we just received.\u00a0[...]\n (By Jaime Frey )</td></tr>\n</tbody></table>", "type": "defect", "last_change": "2014-May-30 14:38", "status": "resolved", "created": "2014-May-13 14:01", "fixed_version": "2014-May-13 14:01", "broken_version": "v070000", "priority": "4", "subsystem": "", "assigned_to": "jfrey", "derived_from": "#4362", "creator": "gthain", "rust": "", "customer_group": "other", "visibility": "public", "notify": "", "due_date": ""}