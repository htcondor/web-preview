{"id": 791, "title": "Ticket #791: Reduce shadow memory usage", "description": "<blockquote>\nOf all of the daemons, the memory size for the shadow is the most important.  A user might have hundreds or thousands running simultaneously.  Over the years we've gotten lax about what creeps in, and the shadow's non-sharable heap is pretty big.  We should find out where the memory is going and try to cut down on it, either eliminating it or only using the memory when we use the feature requiring the memory (eg <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=786\" onclick=\"get_ticket_and_populate_wrapper('786'); return false;\" title=\"VOMS static initializer allocates memory even when VOMS not used\">#786</a></span>).</blockquote>", "remarks": "<blockquote>\n<hr/>\n<em>2010-Oct-20 15:59:08 by jfrey:</em> <br/>\n\nBulk change of target version from v070504 to v070505 using ./ticket-target-mover.\n<hr/>\n<em>2011-Jan-27 14:46:04 by danb:</em> <br/>\n\nBulk change of target version from v070505 to v070506 using ./ticket-target-mover.\n<hr/>\n<em>2011-Feb-01 14:49:30 by tannenba:</em> <br/>\n\nBulk change of target version from v070506 to NULL using ./ticket-target-mover.\n\n<p></p><hr/>\n<em>2012-Jul-19 14:57:09 by adesmet:</em> <br/>\n\nOne of the potential paths that has been repeatedly considered is the \"multi-shadow,\" where we have a single shadow serving multiple starters, sharing the overhead.\n\n<p></p><hr/>\n<em>2012-Jul-19 15:05:06 by adesmet:</em> <br/>\n\nSee also Ticket <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=3137\" onclick=\"get_ticket_and_populate_wrapper('3137'); return false;\" title=\"Reduce memory usage of libcondor_utils\">#3137</a></span>: Reduce memory usage of libcondor_utils\n\n<p></p><hr/>\n<em>2012-Jul-19 15:12:36 by adesmet:</em> <br/>\n\nBrian Bockelman did an in depth investigation and posted his results on condor-devel <a class=\"external\" href=\"https://lists.cs.wisc.edu/archive/condor-devel/2012-July/msg00014.shtml\">https://lists.cs.wisc.edu/archive/condor-devel/2012-July/msg00014.shtml</a>  The key bits are here:\n\n<p>When I last talked to Miron about multi-shadow, he suggested first wringing every last byte out of the current one before even proposing the multi-shadow.  So, I spent about an hour with igprof and staring at smaps.\n\n</p><p>I measured a shadow as having 360KB of heap, about 550KB total unshared space, and 274KB of data live on the heap (so about 25% waste due to fragmentation).\n\n</p><p>Here's what I found that we could save.  List is in ascending order of difficulty to implement.\n</p><ul>\n<li>055 kB 0) Turn off classad caching: 55KB.\n</li><li>008 kB 1) Copy of job's classad inside the file transfer object: 8KB\n</li><li>005 kB 2) gethostbyaddr -&gt; gethostbyaddr_r (including all callsites, even in the logging code!  See ExecuteEvent::writeEvent): 5KB.\n</li><li>002 kB 3) getpwnam, getpwuid to reentrant versions: 2KB\n</li><li>007 kB 4) Remove stats object from <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCore\" title=\"Daemon Core\">DaemonCore</a></span> for shadow: 7KB\n</li><li>100 kB(?) 5) libcondor_utils has 156KB of dirty writable memory (non-const statics?) that can't be shared: 100KB?  This part was not included in my heap calculations, but is indeed non-shared.\n</li><li>005-015 kB 6) Cleanup of auth code to reduce heap fragmentation: 5-15KB\n</li><li>009 kB 7) Un-loading the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=IpVerify\" title=\"Ip Verify\">IpVerify</a></span> table after usage: 9KB.\n</li><li>070 kB 8) The configuration subsystem.  This would be one tough nugget to crack (note: would all be shared with the multi-shadow), but is very lightly used after the shadow fires up.  70KB.\n</li></ul>\n\n<p>Lessons learned:\n</p><ul>\n<li>Classad caching does more harm than good for a single shadow (20% of heap)\n</li><li>If we squeeze really hard at odds-n-ends in the heap, we can shrink the heap by 10%.  I don't think all the items listed above are plausible (especially 8).\n</li><li>Non-const globals in libcondor_utils consist of 25% of the total memory footprint.  There are 332 source files in libcondor_utils - whack-a-mole time?\n<ul>\n<li>Similarly, there are a few things sitting around in the other Condor libraries, but nothing as sizable.\n</li></ul>\n</li><li>Obviously sharable resources for the multi-shadow (parameter subsystem, auth hash maps and tables, daemon core object) make up 50% of the heap.\n</li><li>It's not immediately obvious how much the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span> cache will affect the multi-shadow, but I would expect a bit of sharing.  Let's estimate 50% of the current cache is sharable, or 10% of the total heap.\n</li></ul>\n\n<p>So, we can squeeze about 15% of the shadow size by continuing to shave things and turning off caching.\n\n</p><p>Assuming 10 jobs per 1 shadow, we could realize a 60% memory gain.\n\n</p><p>Both numbers become more dramatic if we can figure out who's hanging out in the data segment.  after 5 minutes with 'nm', it appears the data segment consists primarily of the parameter table.  From digging around, all of the param table and all the ATTR_* symbols are in the not-shared data segment, and hence become unique memory.\n\n</p><p>The simplest way forward seems to be:\n</p><ul>\n<li>Change ATTR_* to const char [] and inline the symbols.  Right now, we keep N+1 copies of the symbol name and one copy of the symbol contents in memory (the symbol name and contents are about the same size; N is the number of uses of the ATTR_*).  Inlining would reduce this to just N.\n</li><li>Change the param table to be based on macros (plain symbols can be in the read-only section; structs have to be initialized), and load it on the first use.\n</li></ul>\n\n<p>Having the attribute names and the param table non-shared are a rather embarrassing way to spend 25% of the shadow's memory budget!\n\n</p><p>Updated estimates after playing with the shadow for more than an hour:\n</p><ul>\n<li>All the linked libraries add up a bit more drastically than I originally thought (I had ignored all the small ones and just looked at the big ones in my first estimates).  Adding in all my optimizations, there are 888KB of Private_Dirty memory.  I squeezed things down to 96KB for libcondor_utils's data segment from 156KB.  The savings are more drastic on more recent versions of GCC (where LTO is available).  There's not much more left to squeeze out due to vtables, got, and plt.\n</li><li>There's probably 150KB of unique data per shadow, once you subtract out the things I mention above.  Hence, 738KB can be thought of as \"overhead\".  So, running 10 jobs per shadow would result in an 75% memory savings.\n</li></ul>\n\n<p>In all, it indicates that multi-shadow would be beneficial and \"shadow squeezing\" is going to continue to have diminishing returns.</p></blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "enhance", "last_change": "2012-Oct-17 06:07", "status": "new", "created": "2009-Sep-29 16:17", "fixed_version": "2009-Sep-29 16:17", "broken_version": "", "priority": "3", "subsystem": "Daemons", "assigned_to": "", "derived_from": "", "creator": "adesmet", "rust": "", "customer_group": "other", "visibility": "public", "notify": "", "due_date": ""}