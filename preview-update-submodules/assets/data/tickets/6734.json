{"id": 6734, "title": "Ticket #6734: Need a python binding for sending a credential like condor_submit does", "description": "<blockquote>\nIn order to submit jobs that use the <code>SEC_CREDENTIAL_PRODUCER</code> mechanism via the python bindings, we need a python binding that can send a ticket to the CREDD in the same that that condor_submit currently does.\n\n<p>What <code>condor_submit</code> currently does is 3 things\n\n</p><p></p><ol>\n<li>run the script specified by <code>SEC_CREDENTIAL_PRODUCER</code>, the output of this script is treated as a binary blob and called an <strong>uber-ticket</strong>.\n\n<p></p></li><li>send the <strong>uber-ticket</strong> to the <code>condor_credd</code> along with the full name of the current user.  This is essentially <code>condor_store_cred add &lt;user&gt; &lt;uber-ticket&gt;</code>,\nbut since the credd expects the ADD command as a string, the <strong>uber-ticket</strong> is first base64 encoded.\n\n<p></p></li><li>add the <code>SendCredential</code> attribute to the job being submitted.\n</li></ol>\n\n<p>Ultimately, we want it to be easy for users of the python-bindings to submit jobs in a way that gives all of the functionality of <code>condor_submit</code> without a lot of special code in the python script to deal with side issues like spooling of files and <code>SEC_CREDENTIAL_PRODUCER</code>.  But we also want python scripts not to be forced to use hacks to disable or defer these side issues - for instance, there is no need to call <code>SEC_CREDENTIAL_PRODUCER</code> <strong>each</strong> time we submit a job, a much lower cadence would be better and it should be possible for a sophisticated script writer to choose to do that.\n\n</p><p>So for ease of implementation and flexibility of use, we will start by writing the low-lever worker functions that give script writers access to the individual steps. This will NOT be part of the submit class, but rather a new CREDD class with at least three methods. A method that sends an <strong>uber-ticket</strong> to the CREDD and returns success or failure; A method that checks to see if the CREDD already has an <strong>uber-ticket</strong> for that user, and a method that invokes <code>SEC_CREDENTIAL_PRODUCER</code> and returns a object containing the <strong>uber-ticket</strong>.\n\n</p><p>===\n<span class=\"subsection\"></span></p><h3>CREDD binding API</h3>\n\n<p>There will be a new object, <strong>Credd</strong> that represents a connection to a specific <code>condor_credd</code> in much the same way the the Schedd and Collector objects do.\nThe Credd object can be constructed from an optional location_ad.\n\n</p><p>It will have methods to <strong>add</strong> , <strong>delete</strong> , and <strong>query</strong> various kinds of credentials.\nEach of these functions will take an optional username, if no username is supplied, the name of the current user will be used.\n\n</p><p><em>class</em> htcondor.Credd([ <em>location-ad</em> ])\n</p><ul>\nA command interface to a <code>condor_credd</code> daemon, if no <em>location-ad</em> is supplied then the default credd is used.\n</ul>\n\n<p><em>method</em> add_password( <em>password</em> [, user= <em>None</em> ]) -&gt; <em>None</em>\n</p><ul>\nadd a password for the given user.  If no user is supplied, the current user is used.  In most cases, only administrators can add passwords for users other than themselves.\n</ul>\n\n<p><em>method</em> delete_password([user= <em>None</em> ]) -&gt; <em>None</em>\n</p><ul>\ndelete the password for the given user.  If no user is supplied, the current user is used.  In most cases, only administrators can delete passwords for users other than themselves.\n</ul>\n\n<p><em>method</em> query_password([user= <em>None</em> ]) -&gt; <em>Bool</em>\n</p><ul>\nask if the given user has a stored password. returns True or False.\n</ul>\n\n<p><em>method</em> add_user_cred( <em>credtype</em>, [credential= <em>None</em> ] [, user= <em>None</em> ]) -&gt; <em>None</em>\n</p><ul>\nadd a credential of type <em>credtype</em> for the given user. If no user is supplied, the current user is used. If no credential is supplied, one for the given <em>credtype</em> will be generated if possible. credential is treated as a hunk of binary data and sent verbatim to the credd.  The expected contents of credential will depend on the <em>credtype</em>, so if the <em>credtype</em> is <strong>krb</strong> the credential should be a Kerberos ticket, or whatever the <code>condor_credmon</code> for <strong>krb</strong> expects to consume.  If the <em>credtype</em> is <strong>krb</strong> and no credential is provided, the output of the <code>SEC_CREDENTIAL_PRODUCER</code> script will be used.\n</ul>\n\n<p><em>method</em> delete_user_cred( <em>credtype</em> [, user= <em>None</em> ]) -&gt; <em>None</em>\n</p><ul>\ndelete the credential of the <em>credtype</em> for the given user.  If no user is supplied, the current user is used.\n</ul>\n\n<p><em>method</em> query_user_cred( <em>credtype</em> [, user= <em>None</em> ]) -&gt; <em>DateTime</em>\n</p><ul>\nask if the given user has a credential of the given <em>credtype</em>. If no user is supplied, the current user is used.  If a credential exists, the time the credential was stored is returned. (if the <em>credtype</em> is <strong>password</strong>, the current time will be returned, as the storage time may not be available)\n</ul>\n\n<p><em>method</em> add_user_service_cred( <em>credtype</em>, <em>credential</em>, <em>meta</em>, [, user= <em>None</em> ]) -&gt; <em>None</em>\n</p><ul>\nadd a service credential of type <em>credtype</em> for the given user. If no user is supplied, the current user is used.  Currently, the <em>credtype</em> must be <strong>OAuth</strong>.  The service name, handle, and other metadata must be specified as a <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span>, schema TBD.\n</ul>\n\n<p><em>method</em> delete_user_service_cred( <em>credtype</em> , <em>meta_,[, user= _None</em> ]) -&gt; <em>None</em>\n</p><ul>\ndelete a service credential of the <em>credtype</em> for the given user.  If no user is supplied, the current user is used. Currently, the <em>credtype</em> must be of type <strong>OAuth</strong>. The service name, handle, and other metadata must be specified as a <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span>, schema TBD.\n</ul>\n\n<p><em>method</em> query_user_service_cred( <em>credtype</em>, <em>meta</em> [, user= <em>None</em> ]) -&gt; <em>CredStatus</em>\n</p><ul>\nask if the given user has a service credential of the given <em>credtype</em>. If no user is supplied, the current user is used. Currently, <em>credtype</em> must be of type <strong>OAuth</strong>.  The service name and optional handle is specified in the <em>meta</em> argument, schema TBD.  Information about stored credentials for that service are returned as a <em>CredStatus</em> object.\n</ul>\n\n<p><em>method</em> check_user_service_creds( <em>credtype</em>, <em>ClassAdList</em>, [, user= <em>None</em> ]) -&gt; <em>CredCheck</em>\n</p><ul>\nask if the given user has all of the permissions indicated by the list of classads in <em>ClassAdList</em> for the given <em>credtype</em>.  This is intended for use with <strong>OAuth</strong>, and there will be a method on Submit that will return a <em>ClassAdList</em> of permissions that the job will be needing.\n</ul>\n\n<p><em>credtype</em> <em>enum</em> { password, krb, oauth }\n\n</p><p><em>class</em> htcondor.CredStatus\n</p><ul>\na class that holds the return value of Credd.query_user_service_creds().  it will contain information about what service credentials are stored, whether there are refresh or use tokens, and timestamps for the various tokens, schema TBD.\n</ul>\n\n<p><em>class</em> htcondor.CredCheck\n</p><ul>\na class that holds the return value of Credd.check_user_service_creds().  It may contain a URL that the user should visit in order to acquire the needed <strong>OAuth</strong> tokens.\n</ul>\n\n<p>where <em>password</em> should be a string, and <em>blob</em> is a binary hunk of data, usually the contents of a file.\n\n</p><p><span class=\"subsection\"></span></p><h3>condor_store_cred equivalency</h3>\n\n<p>New arguments will be added to <code>condor_store_cred</code> so that the underlying c++ credd communication can be accessible on the command line as well as python bindings.  In particular, the <strong>add</strong>, <strong>delete</strong>, and <strong>query</strong> commands will be extended to allow a - <em>credtype</em> modifier, and arguments will be added to allow the credential itself to be supplied by filename.  For example\n\n</p><p></p><div class=\"term\">\n<pre class=\"term\"># run the credential producer to make a ticket and then store it in the credd\n./sec_credential_producer &gt; tmpfile\ncondor_store_credd add-krb -i tmpfile\n\n# ask the credd if the user has OAuth tokens for box\ncondor_store_cred query-oauth -s box\n</pre></div>\n</blockquote>", "remarks": "<blockquote>\n<em>2019-Apr-04 04:10:23 by bbockelm:</em> <br/>\n\nPer a conversation with the CERN HTCondor group, we need to bump this ticket.\n\n<p></p><hr/>\n<em>2020-Apr-17 14:04:43 by johnkn:</em> <br/>\n\nNote, the <code>check_user_service_creds</code> method is just a stub in the 8.9.7 release, this work has been moved into a new ticket so that this one can be resolved.\n\n<p></p><hr/>\n<em>2020-Apr-29 12:45:16 by johnkn:</em> <br/>\n\n<div class=\"snip\">\n<pre class=\"sniplabel\">python code fragment for submitting with KRB/AFS credentials</pre>\n<pre class=\"snip\">#!/bin/env python\n\n# import HTCondor python bindings\nimport htcondor\n\n# find our local schedd\nschedd = htcondor.Schedd()\n\n# store a Krb/AFS credential for the current user\n# this will invoke SEC_CREDENTIAL_PRODUCER to make the cred\ncredd = htcondor.Credd()\ncredd.add_user_cred(htcondor.CredTypes.Kerberos, None)\n\n# use this instead to talk to a specific credd\n#col = htcondor.Collector()\n#credd = htcondor.Credd(col.locate(htcondor.DaemonTypes.Credd,\"machine.name\"))\n\n# create submit object as you normally would... here is a test to see if\n# your job has obtained its kerberos tickets.\nsub = htcondor.Submit(\"\"\"\n    executable = /usr/bin/klist\n    output = submit_krb.out\n    error = submit_krb.err\n    log = submit_krb.log\n    \"\"\")\n\n# let the starter/shadow know that a Krb/AFS credential needs to be sent with the job\nsub[\"MY.SendCredential\"] = \"true\"\n\n# submit normally\nwith schedd.transaction() as txn:\n    sub.queue(txn)\n</pre></div>\n\n\n<p></p><hr/>\n<em>2020-May-18 09:57:29 by tim:</em> <br/>\n\nDocumentation forthcoming in derived ticket.\n\n<p></p><hr/>\n<em>2020-Sep-22 12:13:33 by tannenba:</em> <br/>\n\nThis ticket was resolved with a remark saying \"Documentation forthcoming in derived ticket\", and yet there is no derived child ticket about documentation for this work.  Thus I am changing this ticket from Resolved to docpending.\n\n<p></p><hr/>\n<em>2020-Sep-22 13:48:57 by johnkn:</em> <br/>\n\nI believe <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/8e1bc4418263f7d0028b6adf4950d927f41354a6\">[59129]</a></span> is the documentation commit for this work</blockquote>", "derived_tickets": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">\n<span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=7606\" onclick=\"get_ticket_and_populate_wrapper('7606'); return false;\" title=\"Python binding for oauth creds is incomplete\">#7606</a></span></td>\n<td align=\"center\" valign=\"center\" width=\"30\">\n<span class=\"icon ptr1\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\">\nPython binding for oauth creds is incomplete</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">\n<span class=\"ticket\"><a class=\"new\" href=\"/wiki-archive/tickets/?ticket=7629\" onclick=\"get_ticket_and_populate_wrapper('7629'); return false;\" title=\"figure out how to conclusively determine which credd we should use\">#7629</a></span></td>\n<td align=\"center\" valign=\"center\" width=\"30\">\n<span class=\"icon ptr1\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\">\nfigure out how to conclusively determine which credd we should use</td></tr>\n</tbody></table>", "attachments": "<html><head></head><body></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2020-May-19 13:46</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/4b37ec308d00bb3049b50922ac21b471a315e7c3\">[59686]</a></span>: Version history for merge of Kerberos and OAuth modes. <span class=\"ticket\"><a class=\"docpending\" href=\"/wiki-archive/tickets/?ticket=6734\" onclick=\"get_ticket_and_populate_wrapper('6734'); return false;\" title=\"Need a python binding for sending a credential like condor_submit does\">#6734</a></span>  (By zmiller )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2020-Mar-11 15:56</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/8e1bc4418263f7d0028b6adf4950d927f41354a6\">[59129]</a></span>: (<span class=\"ticket\"><a class=\"docpending\" href=\"/wiki-archive/tickets/?ticket=6734\" onclick=\"get_ticket_and_populate_wrapper('6734'); return false;\" title=\"Need a python binding for sending a credential like condor_submit does\">#6734</a></span>) edits for credd binding docstrings, and include them in the manual  (By Josh Karpel )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2020-Mar-05 16:17</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/4615cc28a377298be21f484fbc136d31e1761cdc\">[59085]</a></span>: for <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=7462\" onclick=\"get_ticket_and_populate_wrapper('7462'); return false;\" title=\"Different token types should be distinguished in the cred dir\">#7462</a></span> and <span class=\"ticket\"><a class=\"docpending\" href=\"/wiki-archive/tickets/?ticket=6734\" onclick=\"get_ticket_and_populate_wrapper('6734'); return false;\" title=\"Need a python binding for sending a credential like condor_submit does\">#6734</a></span>. allow multiple credmons to be running at the same time The credd now puts kerberos credentials in SEC_CREDENTIAL_DIRECTORY_KRB and oauth credentials in SEC_CREDENTIAL_DIRECTORY_OAUTH This commit allows a single job to use both Kerberose and OAuth credentials and a single schedd/startd\u00a0[...]\n (By John (TJ) Knoeller )</td></tr>\n</tbody></table>", "type": "enhance", "last_change": "2020-Sep-22 13:48", "status": "docpending", "created": "2018-Aug-10 13:04", "fixed_version": "2018-Aug-10 13:04", "broken_version": "", "priority": "3", "subsystem": "PythonBinding", "assigned_to": "johnkn", "derived_from": "#6513", "creator": "johnkn", "rust": "", "customer_group": "cern", "visibility": "public", "notify": "bbockelman@morgridge.org, zmiller@cs.wisc.edu, johnkn@cs.wisc.edu, vincent.brillault@cern.ch", "due_date": ""}