{"id": 2804, "title": "Ticket #2804: condor checkpointing broken", "description": "<blockquote>\nI'm not quite sure I believe what I'm seeing (and would be delighted if you told me I was just being dumb), but it looks like checkpointing is badly, badly broken on multiple Linux OSs and Condor versions.\n\n<p>So far we've tested Condor 7.7.4, 7.6.4, and 7.4.4 on Centos 5 (i.e., RHEL5) and Condor 7.7.4 and 7.6.6 on Scientific Linux 6  (i.e., RHEL6) with identical results.\n\n</p><p>I've boiled it down to a trivial test case:\n\n</p><p>OS:\n</p><div class=\"code\">\n<pre class=\"code\">[pfcouvar@sugar-dev1 ~]$ cat /etc/issue\nCentOS release 5.3 (Final)\nKernel \\r on an \\m\n</pre></div>\n\nKernel:\n<div class=\"code\">\n<pre class=\"code\">[pfcouvar@sugar-dev1 ~]$ uname -a\nLinux sugar-dev1.phy.syr.edu 2.6.18-238.12.1.el5 #1 SMP Tue May 31 13:22:04 EDT 2011 x86_64 x86_64 x86_64 GNU/Linux\n</pre></div>\n\nCondor:\n<div class=\"code\">\n<pre class=\"code\">[pfcouvar@sugar-dev1 ~]$ condor_version\n$CondorVersion: 7.6.4 Oct 20 2011 BuildID: 379441 $\n$CondorPlatform: x86_64_rhap_5 $\n</pre></div>\n\nCode:\n<div class=\"code\">\n<pre class=\"code\">[pfcouvar@sugar-dev1 ~]$ cat hello.c\n#include &lt;stdio.h&gt;\n\nvoid ckpt_and_exit(void);\n\nmain() {\n\n printf(\"Hello world!\\n\");\n ckpt_and_exit();\n}\n</pre></div>\n\nCondor compile:\n<div class=\"code\">\n<pre class=\"code\">[pfcouvar@sugar-dev1 ~]$ condor_compile gcc hello.c -o hello\nLINKING FOR CONDOR : /usr/bin/ld -L/usr/lib64/condor -Bstatic --eh-frame-hdr -m elf_x86_64 --hash-style=gnu -o hello /usr/lib64/condor/condor_rt0.o /usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/4.1.2/crtbeginT.o -L/usr/lib64/condor -L/usr/lib/gcc/x86_64-redhat-linux/4.1.2 -L/usr/lib/gcc/x86_64-redhat-linux/4.1.2 -L/usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 /tmp/cca7E9Dg.o /usr/lib64/condor/libcondorsyscall.a /usr/lib64/condor/libcondor_z.a /usr/lib64/condor/libcomp_libstdc++.a /usr/lib64/condor/libcomp_libgcc.a /usr/lib64/condor/libcomp_libgcc_eh.a -lcondor_c -lcondor_nss_files -lcondor_nss_dns -lcondor_resolv -lcondor_c -lcondor_nss_files -lcondor_nss_dns -lcondor_resolv -lcondor_c /usr/lib64/condor/libcomp_libgcc.a /usr/lib64/condor/libcomp_libgcc_eh.a /usr/lib/gcc/x86_64-redhat-linux/4.1.2/crtend.o /usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../lib64/crtn.o\n/usr/lib64/condor/libcondorsyscall.a(condor_file_agent.cpp.o): In function `CondorFileAgent::open(char const*, int, int)':\n/home/condor/execute/dir_29800/userdir/src/condor_ckpt/condor_file_agent.cpp:106: warning: the use of `tmpnam' is dangerous, better use `mkstemp'\n/usr/lib64/condor/libcondorsyscall.a(special_stubs.cpp.o): In function `condor_gethostbyaddr':\n/home/condor/execute/dir_29800/userdir/src/condor_syscall_lib/special_stubs.cpp:170: warning: Using 'gethostbyaddr' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking\n/usr/lib64/condor/libcondorsyscall.a(special_stubs.cpp.o): In function `condor_gethostbyname':\n/home/condor/execute/dir_29800/userdir/src/condor_syscall_lib/special_stubs.cpp:163: warning: Using 'gethostbyname' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking\n</pre></div>\n\nRun:\n<div class=\"code\">\n<pre class=\"code\">[pfcouvar@sugar-dev1 ~]$ ./hello\nCondor: Notice: Will checkpoint to ./hello.ckpt\nCondor: Notice: Remote system calls disabled.\nHello world!\nKilled\n</pre></div>\n\nDebug:\n<div class=\"code\">\n<pre class=\"code\">[pfcouvar@sugar-dev1 ~]$ strace ./hello &gt; hello.strace.out 2&gt;&amp;1\n[pfcouvar@sugar-dev1 ~]$ tail -18 hello.strace.out\nopen(\"./hello.ckpt.tmp\", O_WRONLY|O_TRUNC) = 3\nrt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0\nrt_sigprocmask(SIG_BLOCK, ~[ILL TRAP ABRT BUS FPE SEGV RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0\nwrite(3, \"\\353\\257\\376\\0\\2\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"..., 960) = 960\nrt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0\nrt_sigprocmask(SIG_BLOCK, ~[ILL TRAP ABRT BUS FPE SEGV RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0\nwrite(3, \"DATA\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 \\4\\0\\0\\0\\0\\0\\0\\0\\300r\\0\\0\\0\\0\\0\"..., 96) = 96\nrt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0\nrt_sigprocmask(SIG_BLOCK, ~[ILL TRAP ABRT BUS FPE SEGV RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0\nwrite(3, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"..., 81960960) = 670688\nrt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0\nrt_sigprocmask(SIG_BLOCK, ~[ILL TRAP ABRT BUS FPE SEGV RTMIN RT_1], ~[KILL STOP RTMIN RT_1], 8) = 0\nwrite(3, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"..., 81290272) = -1 EFAULT (Bad address)\nrt_sigprocmask(SIG_SETMASK, ~[KILL STOP RTMIN RT_1], NULL, 8) = 0\ngetpid()                                = 23795\nselect(0, NULL, NULL, NULL, {1, 0})     = 0 (Timeout)\nkill(23795, SIGKILL &lt;unfinished ...&gt;\n+++ killed by SIGKILL +++\n</pre></div>\n\nAs you can see, the third write() is failing with EFAULT.  A partially-written (and thus unusable) checkpoint temp file remains behind.\n\n<p>I should add that the same fault occurs if I sent a SIGUSR2 or SIGTSTP to the running process.  So it's not specific to the use of ckpt_and_exit() in my example above.\n\n</p><p>This is obviously a critical bug for us.  Feel free to give me a call.  I'd be happy to grant Todd access to any of our systems to reproduce it himself.</p></blockquote>", "remarks": "<blockquote>\nThankfully, I am an old fart who hasn't kept up with the latest technology, and Condor is not to blame.\n\n<p>The solution to my problem is to disable address space randomization, as described here: <a class=\"external\" href=\"http://research.cs.wisc.edu/condor/manual/v7.6/6_1Linux.html\">http://research.cs.wisc.edu/condor/manual/v7.6/6_1Linux.html</a>.\n\n</p><p></p><hr/>\n<em>2012-Feb-06 10:04:16 by tannenba:</em> <br/>\n\nNote that address randomization is disabled automatically when the job is launched by Condor (the condor_starter does this as it is launching the job).  But when the job is launched by the end-user, as is the case of using standalone checkpointing, the user needs to do the deed.</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "incident", "last_change": "2012-May-03 10:23", "status": "defer", "created": "2012-Feb-02 14:44", "fixed_version": "2012-Feb-02 14:44", "broken_version": "v070606", "priority": "5", "subsystem": "Std", "assigned_to": "tannenba", "derived_from": "", "creator": "pfc", "rust": "s8128", "customer_group": "ligo", "visibility": "public", "notify": "dabrown@syr.edu,pcouvare@caltech.edu", "due_date": ""}