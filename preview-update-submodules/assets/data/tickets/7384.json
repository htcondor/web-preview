{"id": 7384, "title": "Ticket #7384: Support job-id's as element type in ranger class", "description": "<blockquote>\nTJ requested we make the element type a template parameter to the ranger class to allow ranges of job-ids to be used, in addition to the current behavior, which typedefs element_type to int.\n\n<p>This means adding a couple required methods to the JOB_ID_KEY class in proc.h, templatizing everything in the ranger class, and specializing the part of the load/persist functions that read/write each supported element type.</p></blockquote>", "remarks": "<blockquote>\n<em>2019-Nov-29 17:58:56 by edquist:</em> <br/>\n\nThis is all ready to go.  There are plenty of unit tests in <code>src/condor_unit_tests/OTEST_ranger.cpp</code>, and hopefully the interface in <code>ranger.h</code> explains itself alright, but I'll provide some discussion &amp; examples here for reference &amp; getting started.\n\n<p>---\n\n</p><p>The basic idea is a <code>ranger&lt;T&gt;</code> is a container of <code>T</code> elements, like a <code>std::set&lt;T&gt;</code>, but internally they are stored as ranges, and can be inserted/erased as such (as well as element-wise).  The container is searchable to test if it contains a particular element within any of its ranges.\n\n</p><p>Currently the supported element types are <code>int</code> and <code>JOB_ID_KEY</code>, though we can add any type that is comparable (&lt;, ==) and incrementable/decrementable (++, --, and +/- int) - details are in the commit message for <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/eaf1ad3151c0646f7472964fd43315ea291d1f96\">[58491]</a></span>.\n\n</p><p>The internal <code>ranger&lt;T&gt;::range</code> objects are a <code>[start,end)</code> pair of <code>T</code> elements, with the <code>end</code> element being one-past the last element in the range (as is the standard pattern for STL containers &amp; algorithms).  Sub-ranges can be inserted/erased either by specifying a <code>[start,end)</code> range, or by using the <code>*_slice</code> versions, which take a <code>start</code> and a <code>back</code> element, for specifying inclusive <code>[start,back]</code>.  (These are just wrappers that set the <code>end</code> of the range to <code>back+1</code>.)\n\n</p><p>A <code>ranger&lt;T&gt;</code> object is iterable over the ordered set of ranges it contains, and each range (that is, <code>ranger&lt;T&gt;::range</code>) is iterable over the elements in that range.  Iterable element-wise access to the entire container is also provided with <code>ranger&lt;T&gt;::get_elements()</code>.\n\n</p><p><code>front_element()</code> and <code>back_element()</code> members provide a reference to the first and final elements in the entire ranger set.  It is invalid to call either of these if the ranger container is <code>empty()</code>.\n\n</p><p><code>load()</code> and <code>persist()</code> member functions are provided for inserting a C-string representation of ranges, or storing that representation to a <code>std::string</code>, in a format per discussion with TJ.  (Semicolon-separated sub-ranges, where each sub-range is either <code>START-BACK</code> (with inclusive <code>BACK</code>), or just <code>START</code> for a single-element range.  Eg, <code>\"2\"</code>, <code>\"5-10\"</code>, <code>\"4;7;10-20;44;50-60\"</code>.  <code>JOB_ID_KEY</code> elements are stored as the obvious <code>CLUSTER.PROC</code>. More generally, any new type to be supported has to implement a <code>read_element()</code> and <code>write_element()</code> in <code>ranger.cpp</code>.\n\n</p><p><code>persist_range()</code> and <code>persist_slice()</code> are also provided for storing only a subset of the full container.  <code>load()</code> can be called multiple times against persisted subsets (ie, partitions) to reproduce the original full container.\n\n</p><p>The <code>ranger&lt;T&gt;</code> template class, along with <code>ranger&lt;T&gt;::range</code>, are basically agnostic to the details of the type <code>T</code>.  The only requirement is that each range have <code>start &lt; end</code> (that is, <code>start</code> &lt;= <code>back</code>).  Thus, for a <code>ranger&lt;JOB_ID_KEY&gt;</code>, a range like <code>[7.11, 8.4)</code> will contain <code>7.100</code> and <code>8.1</code>, but not <code>7.9</code> or <code>8.10</code>.\n\n</p><p>While <code>[7.11, 8.4)</code> is a valid range (since <code>7.11 &lt; 8.4</code>), it is not possible to iterate across all the elements in that range, since there is no way to reach the end (<code>8.4</code>) from the beginning (<code>7.9</code>) by incrementing the <code>.PROC</code> part.  Thus, if you want to be able to list / iterate over every element in your <code>ranger&lt;JOB_ID_KEY&gt;</code>, you should ensure that within each range inserted, the <code>CLUSTER</code> components match.  (Eg, <code>\"7.11-7.100;8.1-8.3\"</code>)\n\n</p><p>Likewise, there is no special treatment of a job-id element with a <code>PROC</code> of <code>-1</code>.  It just falls in line according to the job-id element class's own sorting, which puts <code>4.-1</code> after all <code>3.x</code> but before <code>4.0</code>.  So a range representing all <code>3.x</code> elements (for non-negative <code>x</code>) would be <code>[3.0, 4.0)</code>, or equivalently, for the slice versions, <code>[3.0, 4.-1]</code>.\n\n</p><p>---\n\n</p><p>Ok!  Some examples.\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">// initialize empty int ranger\nranger&lt;int&gt; r;\n\n// initialize with list of elements\nranger&lt;int&gt; r2 = {1, 2, 3, 5, 10};\n\n// initialize with list of ranges\nranger&lt;int&gt; r3 = {{20,30}, {40,50}, {60,80}};\n\n// insert elements\nr.insert(77);\nr.insert(88);\n\n// insert [start,end) ranges\nr.insert({100, 150});\n\nranger&lt;int&gt;::range rr(200, 300);\nr.insert(rr);\n\n// insert slice with [start,back] elements\nr.insert_slice(302, 310);\n\n// erase methods work the same as insert\nr.erase(120);\nr.erase({125, 130});\nr.erase_slice(133, 139);\n\n// test element membership\nif (r.contains(131)) /* true  */ { ... }\nif (r.contains(135)) /* false */ { ... }\n\n// get min and max elements\nif (!r.empty()) {\n    int min_elt = r.front_element();\n    int max_elt = r.back_element();\n    ...\n}\n\n// save string representation\nstd::string s;\nr.persist(s);\n\n// save string representation in [start,end) range partitions\nstd::string s0, s1, s2, s3;\nr.persist_range(s0, {  0, 100});\nr.persist_range(s1, {100, 200});\nr.persist_range(s2, {200, 300});\nr.persist_range(s3, {300, 400});\n\n// same thing, but save in [start,back] slice partitions\nr.persist_slice(s0,   0,  99);\nr.persist_slice(s1, 100, 199);\nr.persist_slice(s2, 200, 299);\nr.persist_slice(s3, 300, 399);\n\n// clear and reload from saved buffer\nr.clear();\nr.load(s.c_str());\n\n// clear and reload from partitions\nr.clear();\nr.load(s0.c_str());\nr.load(s1.c_str());\nr.load(s2.c_str());\n\n// iterate over each sub-range\nfor (auto &amp;subrange : r)\n    for (int i : subrange)\n        process_int(i);\n\n// same thing, but iterate over all elements directly\nfor (int i : r.get_elements())\n    process_int(i);\n\n</pre></div>\n\n\n<p>That's pretty much the tour.  Everything for <code>JOB_ID_KEY</code> elements follows the same pattern, which I'll enclude just to provide explicit examples.\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">// initialize empty job-id ranger\nranger&lt;JOB_ID_KEY&gt; r;\n\n// initialize with list of elements\nranger&lt;JOB_ID_KEY&gt; r2 = {{1,1}, {1,2}, {1,3}, {5,5}, {10,10}};\n\n// initialize with list of ranges\nranger&lt;JOB_ID_KEY&gt; r3 = {{{1,20},{1,30}}, {{2,40},{2,50}}, {{3,60},{3,80}}};\n\n// insert elements\nr.insert({1,77});\nr.insert({2,88});\n\n// insert [start,end) ranges\nr.insert({{1,100}, {1,150}});\n\nranger&lt;JOB_ID_KEY&gt;::range rr({1,200}, {1,300});\nr.insert(rr);\n\n// insert slice with [start,back] elements\nr.insert_slice({1,302}, {1,310});\n\n// erase methods work the same as insert\nr.erase({1,120});\nr.erase({{1,125}, {1,130}});\nr.erase_slice({1,133}, {1,139});\n\n// test element membership\nif (r.contains({1,131})) /* true  */ { ... }\nif (r.contains({1,135})) /* false */ { ... }\n\n// get min and max elements\nif (!r.empty()) {\n    JOB_ID_KEY min_elt = r.front_element();\n    JOB_ID_KEY max_elt = r.back_element();\n    ...\n}\n\n// save string representation\nstd::string s;\nr.persist(s);\n\n// save string representation in [start,end) range partitions\nstd::string s0, s1, s2, s3;\nr.persist_range(s0, {{0,0}, {3,0}});\nr.persist_range(s1, {{3,0}, {6,0}});\nr.persist_range(s2, {{6,0}, {9,0}});\nr.persist_range(s3, {{9,0}, {12,0}});\n\n// same thing, but save in [start,back] slice partitions\nr.persist_slice(s0, {0,0}, {3,-1});\nr.persist_slice(s1, {3,0}, {6,-1});\nr.persist_slice(s2, {6,0}, {9,-1});\nr.persist_slice(s3, {9,0}, {12,-1});\n\n// clear and reload from saved buffer\nr.clear();\nr.load(s.c_str());\n\n// clear and reload from partitions\nr.clear();\nr.load(s0.c_str());\nr.load(s1.c_str());\nr.load(s2.c_str());\n\n// iterate over each sub-range\nfor (auto &amp;subrange : r)\n    for (JOB_ID_KEY id : subrange)\n        process_jobid(id);\n\n// same thing, but iterate over all elements directly\nfor (JOB_ID_KEY id : r.get_elements())\n    process_jobid(id);\n</pre></div>\n\n\n<p></p><hr/>\n<em>2019-Dec-02 14:46:30 by tim:</em> <br/>\n\nInternal code. No user visible changes. No documentation.</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2019-Nov-23 11:00</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/e59dfa7a52dab742bc03c64e0b09c4e5f928e7a4\">[58542]</a></span>: fix persisting a slice with no elements add extra persist_slice tests for a slice that contains no elements, and add initializer list tests for jobid elements (<span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=7384\" onclick=\"get_ticket_and_populate_wrapper('7384'); return false;\" title=\"Support job-id's as element type in ranger class\">#7384</a></span>)  (By Carl Edquist )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2019-Nov-21 12:20</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/eb5fafa3c2f11b81a8cb122e994ab96371c8b3c6\">[58530]</a></span>: use suffix return type syntax This avoids the need to fully-qualify all the nested types -- which are worse in the case of templates, because then they need an extra 'typename' keyword for the things with '::' that depend on a template parameter.\u00a0[...]\n (By Carl Edquist )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2019-Nov-20 15:54</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/21ac5ee35decf79093d8017dd02f1823946e9488\">[58524]</a></span>: (<span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=7384\" onclick=\"get_ticket_and_populate_wrapper('7384'); return false;\" title=\"Support job-id's as element type in ranger class\">#7384</a></span>) fix partial specialization of lower_bound/upper_bound Before templatizing ranger, the lower/upper_bound functions were templated for generic container types, and specialized (overloaded) for std::set in particular, to use the optimized std::set::lower_bound instead of the generic std::lower_bound.\u00a0[...]\n (By Carl Edquist )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2019-Nov-15 22:56</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/de0d56774b3350d75ac9c9d1f66ebd2bebcd1fed\">[58492]</a></span>: (<span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=7384\" onclick=\"get_ticket_and_populate_wrapper('7384'); return false;\" title=\"Support job-id's as element type in ranger class\">#7384</a></span>) add a few more 'typename' keywords for windows compiler  (By Carl Edquist )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2019-Nov-15 22:20</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/eaf1ad3151c0646f7472964fd43315ea291d1f96\">[58491]</a></span>: (<span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=7384\" onclick=\"get_ticket_and_populate_wrapper('7384'); return false;\" title=\"Support job-id's as element type in ranger class\">#7384</a></span>) templatize ranger on element type to support job-ids The old ranger is now `ranger&lt;int&gt;`, and we now specifically support `ranger&lt;JOB_ID_KEY&gt;`.\u00a0[...]\n (By Carl Edquist )</td></tr>\n</tbody></table>", "type": "enhance", "last_change": "2019-Dec-02 14:46", "status": "resolved", "created": "2019-Nov-15 22:08", "fixed_version": "2019-Nov-15 22:08", "broken_version": "", "priority": "4", "subsystem": "Libs", "assigned_to": "edquist", "derived_from": "", "creator": "edquist", "rust": "", "customer_group": "other", "visibility": "public", "notify": "edquist@cs.wisc.edu, johnkn@cs.wisc.edu", "due_date": ""}