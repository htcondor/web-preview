{"id": 1168, "title": "Ticket #1168: RFE: /proc/<pid>/io data available to job ad policy and archive", "description": "<blockquote>\nCondor currently reports CPU usage information in Job ads during execution. The linux kernel provides other information, such as io statistics for processes. It would be useful to report the io statistics in the Job ad as well.\n\n<p><a class=\"external\" href=\"http://www.kernel.org/doc/Documentation/filesystems/proc.txt\">http://www.kernel.org/doc/Documentation/filesystems/proc.txt</a>\n\n</p><p></p><div class=\"verbatim\">\n<pre>3.3  /proc/&lt;pid&gt;/io - Display the IO accounting fields\n-------------------------------------------------------\n\nThis file contains IO statistics for each running process\n\nExample\n-------\n\ntest:/tmp # dd if=/dev/zero of=/tmp/test.dat &amp;\n[1] 3828\n\ntest:/tmp # cat /proc/3828/io\nrchar: 323934931\nwchar: 323929600\nsyscr: 632687\nsyscw: 632675\nread_bytes: 0\nwrite_bytes: 323932160\ncancelled_write_bytes: 0\n\n\nDescription\n-----------\n\nrchar\n-----\n\nI/O counter: chars read\nThe number of bytes which this task has caused to be read from storage. This\nis simply the sum of bytes which this process passed to read() and pread().\nIt includes things like tty IO and it is unaffected by whether or not actual\nphysical disk IO was required (the read might have been satisfied from\npagecache)\n\n\nwchar\n-----\n\nI/O counter: chars written\nThe number of bytes which this task has caused, or shall cause to be written\nto disk. Similar caveats apply here as with rchar.\n\n\nsyscr\n-----\n\nI/O counter: read syscalls\nAttempt to count the number of read I/O operations, i.e. syscalls like read()\nand pread().\n\n\nsyscw\n-----\n\nI/O counter: write syscalls\nAttempt to count the number of write I/O operations, i.e. syscalls like\nwrite() and pwrite().\n\n\nread_bytes\n----------\n\nI/O counter: bytes read\nAttempt to count the number of bytes which this process really did cause to\nbe fetched from the storage layer. Done at the submit_bio() level, so it is\naccurate for block-backed filesystems. &lt;please add status regarding NFS and\nCIFS at a later time&gt;\n\n\nwrite_bytes\n-----------\n\nI/O counter: bytes written\nAttempt to count the number of bytes which this process caused to be sent to\nthe storage layer. This is done at page-dirtying time.\n\n\ncancelled_write_bytes\n---------------------\n\nThe big inaccuracy here is truncate. If a process writes 1MB to a file and\nthen deletes the file, it will in fact perform no writeout. But it will have\nbeen accounted as having caused 1MB of write.\nIn other words: The number of bytes which this process caused to not happen,\nby truncating pagecache. A task can cause \"negative\" IO too. If this task\ntruncates some dirty pagecache, some IO which another task has been accounted\nfor (in it's write_bytes) will not be happening. We _could_ just subtract that\nfrom the truncating task's write_bytes, but there is information loss in doing\nthat.\n\n\nNote\n----\n\nAt its current implementation state, this is a bit racy on 32-bit machines: if\nprocess A reads process B's /proc/pid/io while process B is updating one of\nthose 64-bit counters, process A could see an intermediate result.\n\n\nMore information about this can be found within the taskstats documentation in\nDocumentation/accounting.\n</pre></div>\n</blockquote>", "remarks": "<blockquote>\n<hr/>\n<em>2010-Oct-20 16:03:30 by jfrey:</em> <br/>\n\nBulk change of target version from v070504 to v070505 using ./ticket-target-mover.\n<hr/>\n<em>2011-Jan-27 14:46:04 by danb:</em> <br/>\n\nBulk change of target version from v070505 to v070506 using ./ticket-target-mover.\n<hr/>\n<em>2011-Feb-01 14:49:30 by tannenba:</em> <br/>\n\nBulk change of target version from v070506 to NULL using ./ticket-target-mover.\n\n<p></p><hr/>\n<em>2011-Feb-01 17:38:52 by bbockelm:</em> <br/>\n\nThis can also be achieved cheaply via <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=1831\" onclick=\"get_ticket_and_populate_wrapper('1831'); return false;\" title=\"Take advantage of cgroups-based capabilities on new Linux platforms\">#1831</a></span> using cgroups; should even avoid race conditions.</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "enhance", "last_change": "2011-Feb-01 17:38", "status": "new", "created": "2010-Feb-01 14:06", "fixed_version": "2010-Feb-01 14:06", "broken_version": "", "priority": "3", "subsystem": "Daemons", "assigned_to": "", "derived_from": "", "creator": "matt", "rust": "", "customer_group": "other", "visibility": "public", "notify": "matt@cs.wisc.edu", "due_date": ""}