{"id": 3076, "title": "Ticket #3076: Startd slot stuck in Preempting/Vacating", "description": "<blockquote>\nObserved in the CHTC pool running 7.7.6: slots are sometimes hanging around in Preempting/Vacating indefinitely.   At the moment 150 slots out of about 2,000 are in Preempting/Vacating, and have been for at least 2 days, and in some cases as long as 45 days.  In all cases examined, the associated starter exited as expected, many, many days ago.  There don't appear to be any leak processes; we're using slot users so they're easy to detect.  Unfortunately our startd logs were too small, 50 MB with D_FULLDEBUG so about 12 hours, so we don't know if the startd even detected the starter exiting.  Ken increased the logs to 240 MB, but the problem hasn't happened since we started digging more deeply.\n\n<p>As a side effect, jobs are trying to match to preempting slots, only to be rejected.  The appearance to the user is that there jobs take a long time to match, when in fact they're matching but are immediately rejected.\n\n</p><p>Observed on a Windows XP machines in new batlab (exec-102) running 7.8.0.  Both slots were stuck.  This time the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=StartLog\" title=\"Start Log\">StartLog</a></span> was spammed with entries in this form: \"06/21/12 16:08:01 <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCore\" title=\"Daemon Core\">DaemonCore</a></span>: async_pipe is signalled, but async_pipe_signal is false.\"  The warning may be unrelated, <span class=\"ticket\"><a class=\"new\" href=\"/wiki-archive/tickets/?ticket=3079\" onclick=\"get_ticket_and_populate_wrapper('3079'); return false;\" title=\"condor_startd loops with async_pipe is signalled, but async_pipe_signa\">#3079</a></span> was created to track is separately if necessary.</p></blockquote>", "remarks": "<blockquote>\n<em>2012-Jun-27 15:53:10 by adesmet:</em> <br/>\n\nImmediate cause isolated to <a class=\"file\" href=\"rlog?f=src/condor_startd.V6/startd_main.cpp\">/src/condor_startd.V6/startd_main.cpp</a> around line 752 in the function reaper:\n\n<p></p><div class=\"code\">\n<pre class=\"code\">int\nreaper(Service *, int pid, int status)\n{\n/* [snip */\n\tfoo = resmgr-&gt;getClaimByPid(pid);\n\tif( foo ) {\n\t\tfoo-&gt;starterExited(status);\n\t}\n\treturn TRUE;\n}\n</pre></div>\n\n\n<p>resmgr-&gt;getClaimByPid(pid) is returning NULL, so we silently skip over foo-&gt;starterExited(status).\n\n</p><p>This appears to only happen with fetchwork jobs (but it may be that something about fetchwork jobs, or how we have CHTC configured makes fetchwork more likely to tickle the bug.  In particular, fetchwork jobs can be interrupted at any point while we don't normally interrupt other jobs until 24 hours has passed.  Also, fetchwork jobs can start very quickly, while other jobs have more overhead.\n\n</p><p>A representative <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=StartLog\" title=\"Start Log\">StartLog</a></span> is:\n</p><div class=\"code\">\n<pre class=\"code\">06/27/12 15:44:42 Starter pid 9991 exited with status 0\n06/27/12 15:44:42 Starter pid 9995 exited with status 0\n06/27/12 15:44:42 Starter pid 9998 exited with status 0\n06/27/12 15:44:42 slot7: State change: starter exited\n06/27/12 15:44:42 slot7: State change: No preempting claim, returning to owner\n06/27/12 15:44:42 slot7: Changing state and activity: Preempting/Vacating -&gt; Owner/Idle\n06/27/12 15:44:42 slot7: State change: IS_OWNER is false\n06/27/12 15:44:42 slot7: Changing state: Owner -&gt; Unclaimed\n06/27/12 15:44:42 Starter pid 9999 exited with status 0\n06/27/12 15:44:42 Starter pid 10001 exited with status 0\n06/27/12 15:44:42 slot2: State change: starter exited\n06/27/12 15:44:42 slot2: State change: No preempting claim, returning to owner\n06/27/12 15:44:42 slot2: Changing state and activity: Preempting/Vacating -&gt; Owner/Idle\n06/27/12 15:44:42 slot2: State change: IS_OWNER is false\n06/27/12 15:44:42 slot2: Changing state: Owner -&gt; Unclaimed\n</pre></div>\n\n\n<p>The jobs in slots 2 and 7 exited preempting successfully.  Slots 1, 6, and 8 (associated with PIDs 9991, 9995, and 9999, but in an unknown association) do not.\n\n</p><p>Current technique to reproduce in a few minutes:\n\n</p><p></p><ol>\n<li>Set up condor; ./condor_configure --make-personal-condor\n</li><li>Add to your configuration:\n<div class=\"code\">\n<pre class=\"code\">STARTD_JOB_HOOK_KEYWORD = ALAN\nALAN_HOOK_FETCH_WORK=/scratch/adesmet/V7_8-branch/release_dir/hooks/fetch-work-infinite\nFetchWorkDelay=1\nNUM_CPUS=8\n# FetchWorkDelay means the log will be full of garbage, make it big\nMAX_START_LOG=100000000\n</pre></div>\n\n</li><li>Create fetch-work-infinite\n<div class=\"code\">\n<pre class=\"code\">#! /usr/bin/perl -w\nuse strict;\nmy $exe = '/bin/sleep';\nmy $args = 3600;\nmy $owner = 'adesmet';\nprint &lt;&lt;END;\nCmd=\"$exe\"\nArgs=\"$args\"\nOwner=\"$owner\"\nJobUniverse=5\nRequirements=TRUE\nRequestCpus=1\nRequestMemory=8\nRequestDisk=1024\nEND\nexit 0;\n</pre></div>\n\n</li><li>Start up condor\n</li><li>Run spam-vacate, a Perl tool that follows:\n<div class=\"code\">\n<pre class=\"code\">#! /usr/bin/perl\n\nmy $MAX = 90;\nwhile(1) {\n        my $val = rand($MAX);\n        print \"Sleeping for $val\\n\";\n        sleep($val);\n        system('condor_vacate');\n\n        my(@wedged) = `condor_status -const 'State==\"Preempting\" &amp;&amp; ( CurrentTime-EnteredCurrentActivity ) &gt; 20' -format '%d\\n' CurrentTime-EnteredCurrentActivity`;\n        if(@wedged) {\n                die \"Wedged something, huzzah!\"\n        }\n\n}\n</pre></div>\n\n</li></ol>\n\n<p>New question: Why isn't resmgr-&gt;getClaimByPid(pid) finding the claim?  Presumably there is a window when the PID exists, but the claim isn't registered.\n\n</p><p></p><hr/>\n<em>2012-Jun-27 16:09:05 by adesmet:</em> <br/>\n\nTesting to see if I can reproduce with vanilla jobs.  Guessing no, but just in case.\n\n<p></p><hr/>\n<em>2012-Jun-28 18:03:51 by adesmet:</em> <br/>\n\nCannot reproduce with vanilla jobs.\n\n<p>Healthy code path:\n</p><ol>\n<li>Starter::kill (sometimes called twice?!)\n</li><li>reaper notices condor_starter exited\n</li><li>Claim::resetClaim deletes the Starter\n</li></ol>\n\n<p>Unhealthy code path\n</p><ol>\n<li>Starter::kill (sometimes called twice?!)\n</li><li>Claim::~Claim deletes the Starter\n</li><li>associated Starter is deleted\n</li><li>reaper notices condor_starter exited\n</li></ol>\n\n<p>It's not yet clear why the Starter is being deleted.\n\n</p><p></p><hr/>\n<em>2012-Jun-29 13:49:13 by adesmet:</em> <br/>\n\nStack during an unhealthy (\"early\") call to Claim::~Claim which destroys the associated Starter object.\n\n<p></p><ul>\n<li>Claim::~Claim()\n</li><li>Resource::createFetchClaim(compat_classad::ClassAd*, float)\n</li><li>Resource::createOrUpdateFetchClaim(compat_classad::ClassAd*, float)\n</li><li>StartdHookMgr::handleHookFetchWork(FetchClient*)\n</li><li>FetchClient::hookExited(int)\n</li><li>HookClientMgr::reaperOutput(int, int)\n</li><li>DaemonCore::CallReaper(int, char const*, int, int)\n</li><li>DaemonCore::HandleProcessExit(int, int)\n</li><li>DaemonCore::HandleDC_SERVICEWAITPIDS(int)\n</li><li>DaemonCore::Driver()\n</li><li>dc_main(int, char**)\n</li><li>main\n</li><li>__libc_start_main\n</li><li>CronJob::Reaper(int, int)\n</li></ul>\n\n<p></p><hr/>\n<em>2012-Jun-29 14:41:55 by adesmet:</em> <br/>\n\nCurrent hypothesis:\n\n<p></p><ol>\n<li>Current job (probably fetchwork <em>but not necessarily</em>) is preempting.  Startd is waiting for the starter to exit\n</li><li>Fetchwork hook for the slot returns, Startd decides to hand the slot over to the new fetch job; why not, it's already preempting.\n</li><li>Fetchwork hook deletes the old Claim (<a class=\"file\" href=\"rlog?f=src/condor_startd.V6/Resource.cpp\">/src/condor_startd.V6/Resource.cpp</a> line 2476 inside Resource::createFetchClaim).  As a side effect, the Starter object is destroyed, along with any connection of the PID to this slot.\n</li><li>The starter exits (ot at least the startd notices that the starter exited).  It ignores this, since it no longer know which slot its connected to.  As such, the code path that codes Preempting to Unclaimed never fires.\n</li></ol>\n\n<p>Open questions\n\n</p><p></p><ul>\n<li>Can this happen to a non-fetchwork job?  I suspect yes.\n</li><li>Can this happen when the new job is a non-fetchwork job.  Not sure.\n</li><li>What's the right behavior?\n<ul>\n<li>When the new fetchwork job decides to stomp on the old claim, should it force the slot into Idle? Seems dangerous in general to stomp on an unresolved job.\n</li><li>Refuse new fetchwork (any work?) until we're out of preempting?\n</li></ul>\n</li></ul>\n\n<p></p><hr/>\n<em>2012-Jun-29 17:02:19 by adesmet:</em> <br/>\n\nWhy complicate things? Just do what happens if the fetchwork job arrives and the machine is claimed: mark it as the next/preempting claim (r_pre) and carry on.\n\n<p>\"startd exiting because of fatal exception.\"? Oh, alright then.\n\n</p><p></p><hr/>\n<em>2012-Jul-03 15:23:44 by adesmet:</em> <br/>\n\nWent with the straightforward option: if a fetchwork job shows up and we're preempting, just refuse it.\n\n<p>Also, log if we see unexpected processes exit; don't just silently ignore them.\n\n</p><p>Work is on V7_8-preempting-fix-branch pending review and eventual merge to V7_8-branch.\n\n</p><p></p><hr/>\n<em>2012-Jul-10 16:04:57 by adesmet:</em> <br/>\n\nBounced by johnkn, who correctly points out that in this case we won't invoke the reply fetch hook, a violation of the API.  Fixing.\n\n<p></p><hr/>\n<em>2012-Jul-12 11:10:05 by adesmet:</em> <br/>\n\nBetter solution checked in to V7_8-preempting-fix-branch. Handing back to TJ for re-review.\n\n<p></p><hr/>\n<em>2012-Jul-18 11:08:49 by johnkn:</em> <br/>\n\nBetter fix looks good to me.</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2012-Jul-17 12:16</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/cf1ecb401813d36da560cc2c4bea247e0d570808\">[32816]</a></span>: minor edit to 7.8.2 version history item ===GT=== <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=3076\" onclick=\"get_ticket_and_populate_wrapper('3076'); return false;\" title=\"Startd slot stuck in Preempting/Vacating\">#3076</a></span>  (By Karen Miller )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2012-Jul-12 12:00</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/9adc9d0fa76525ce862aab7d1a228606188e135c\">[32746]</a></span>: Fix \"stuck in preempting\" bug, warn on starter exit with no claim <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=3076\" onclick=\"get_ticket_and_populate_wrapper('3076'); return false;\" title=\"Startd slot stuck in Preempting/Vacating\">#3076</a></span> Squashed commit of the following:\u00a0[...]\n (By Alan De Smet )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2012-Jul-12 11:57</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/8b7968d50d623084a4c1f2b4d2ae1e6c581fa406\">[32744]</a></span>: Fix \"stuck in preempting\" bug, warn on starter exit with no claim <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=3076\" onclick=\"get_ticket_and_populate_wrapper('3076'); return false;\" title=\"Startd slot stuck in Preempting/Vacating\">#3076</a></span> Squashed commit of the following:\u00a0[...]\n (By Alan De Smet )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2012-Jul-10 17:17</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/b2ab0e053868c5fb6dd7d05c0b5009dd76605473\">[32689]</a></span>: Ensure we call the reply fetch hook, even if we reject the job because we're mid-preempting. <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=3076\" onclick=\"get_ticket_and_populate_wrapper('3076'); return false;\" title=\"Startd slot stuck in Preempting/Vacating\">#3076</a></span>  (By Alan De Smet )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2012-Jul-03 15:20</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/206dc9a5bda7ace6f306dfd4196389a5d3ee1520\">[32580]</a></span>: Fix \"stuck in preempting\" bug. <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=3076\" onclick=\"get_ticket_and_populate_wrapper('3076'); return false;\" title=\"Startd slot stuck in Preempting/Vacating\">#3076</a></span> If a fetchwork job shows up, and we're in preempting, just ignore it. Also, if we do get an unexpected starter exiting, at least log it for future debugging.  (By Alan De Smet )</td></tr>\n</tbody></table>", "type": "defect", "last_change": "2012-Aug-23 11:33", "status": "resolved", "created": "2012-Jun-21 13:35", "fixed_version": "2012-Jun-21 13:35", "broken_version": "v070706", "priority": "4", "subsystem": "", "assigned_to": "adesmet", "derived_from": "", "creator": "adesmet", "rust": "", "customer_group": "other", "visibility": "public", "notify": "", "due_date": ""}