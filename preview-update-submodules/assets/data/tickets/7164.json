{"id": 7164, "title": "Ticket #7164: Busy Loop in CEDAR auth on windows on connection closure", "description": "<blockquote>\ncondor_read() is supposed to return -2 when attempting to read from a socket that's been closed by the peer. But it only does this if recv() returns 0 (normal connection shutdown). If the connection closes abnormally (e.g. recv() returns -1, errno=ECONNRESET), condor_read() doesn't return the special \"closed\" value. When this happens to a <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ReliSock\" title=\"Reli Sock\">ReliSock</a></span>, the underlying socket will be ready for read, but ReliSock::readReady() will return false. For readers attempting to do non-blocking operations, this can lead to a busy loop of checking but not reading from the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ReliSock\" title=\"Reli Sock\">ReliSock</a></span> until the timeout is hit. SecManStartCommand::receiveAuthInfo_inner() is one location where this can occur.\n\n<p>On unix, after recv() fails once with ECONNRESET, subsequent calls return 0. This limits us to one pass through the loop. On Windows, recv() will fail with WSAECONNABORTED on every call, resulting in looping bounded only by the ReliSock's timeout.\n\n</p><p>We should add a check in condor_read() for the common \"connection died\" errno values and return -2 when they occur.</p></blockquote>", "remarks": "<blockquote>\n<strong>CODE_REVIEW</strong> looks good.</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2019-Jul-25 10:47</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/ada82a932c5694b609d47b2e63a96d259a4fe627\">[57482]</a></span>: Docs for condor_read() busy loop fix. <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=7164\" onclick=\"get_ticket_and_populate_wrapper('7164'); return false;\" title=\"Busy Loop in CEDAR auth on windows on connection closure\">#7164</a></span>  (By Jaime Frey )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2019-Jul-25 10:38</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/1e79f24440be9af6b9337471b1450aef254e4532\">[57479]</a></span>: condor_read() should recognize abnormal socket closure. <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=7164\" onclick=\"get_ticket_and_populate_wrapper('7164'); return false;\" title=\"Busy Loop in CEDAR auth on windows on connection closure\">#7164</a></span> condor_read() now returns -2 on abnormal socket closure (recv() fails with ECONNRESET or similar). Before, it only did so on orderly socket closure (recv() returns 0). This allows ReliSock::readReady() to accurately indicate that the sock\u00a0[...]\n (By Jaime Frey )</td></tr>\n</tbody></table>", "type": "defect", "last_change": "2019-Aug-08 16:52", "status": "resolved", "created": "2019-Jul-24 16:28", "fixed_version": "2019-Jul-24 16:28", "broken_version": "", "priority": "3", "subsystem": "Libs", "assigned_to": "johnkn", "derived_from": "", "creator": "jfrey", "rust": "", "customer_group": "other", "visibility": "public", "notify": "jfrey@cs.wisc.edu,johnkn@cs.wisc.edu", "due_date": ""}