diff --git a/src/condor_c++_util/condor_attributes.cpp b/src/condor_c++_util/condor_attributes.cpp
index 95d53a8..d2a2c41 100644
--- a/src/condor_c++_util/condor_attributes.cpp
+++ b/src/condor_c++_util/condor_attributes.cpp
@@ -488,6 +488,7 @@ const char *ATTR_REMOVE_KILL_SIG          = "RemoveKillSig";
 const char *ATTR_REMOVE_REASON            = "RemoveReason";
 const char *ATTR_REQUEUE_REASON           = "RequeueReason";
 const char *ATTR_REQUIREMENTS             = "Requirements";
+const char *ATTR_RESOURCE_WEIGHT          = "ResourceWeight";
 const char *ATTR_RESULT                   = "Result";
 const char *ATTR_RSC_BYTES_SENT			 = "RSCBytesSent";
 const char *ATTR_RSC_BYTES_RECVD			 = "RSCBytesRecvd";
diff --git a/src/condor_includes/condor_accountant.h b/src/condor_includes/condor_accountant.h
index df5d399..dcfd9f0 100644
--- a/src/condor_includes/condor_accountant.h
+++ b/src/condor_includes/condor_accountant.h
@@ -49,6 +49,7 @@ public:
   void Initialize();  // Configuration
 
   int GetResourcesUsed(const MyString& CustomerName); // get # of used resources
+  float GetResourcesUsedFloat(const MyString& CustomerName); // same for float
   float GetPriority(const MyString& CustomerName); // get priority for a customer
   void SetPriority(const MyString& CustomerName, float Priority); // set priority for a customer
 
@@ -112,7 +113,8 @@ private:
   float HalfLifePeriod;     // The time in sec in which the priority is halved by aging
   MyString LogFileName;      // Name of Log file
   int	MaxAcctLogSize;		// Max size of log file
-  bool   DiscountSuspendedResources;
+  bool  DiscountSuspendedResources;
+  bool  UseResourceWeights; 
   StringList *GroupNamesList;
 
   //--------------------------------------------------------
@@ -135,6 +137,7 @@ private:
   static MyString PriorityAttr;
   static MyString UnchargedTimeAttr;
   static MyString ResourcesUsedAttr;
+  static MyString ResourcesUsedRWAttr;
   static MyString AccumulatedUsageAttr;
   static MyString BeginUsageTimeAttr;
   static MyString LastUsageTimeAttr;
@@ -146,6 +149,8 @@ private:
   static MyString StartTimeAttr;
   static MyString Cpus;
 
+  static MyString ResourceWeightAttr;
+
   //--------------------------------------------------------
   // Utility functions
   //--------------------------------------------------------
diff --git a/src/condor_includes/condor_attributes.h b/src/condor_includes/condor_attributes.h
index af9f8c9..703d4f9 100644
--- a/src/condor_includes/condor_attributes.h
+++ b/src/condor_includes/condor_attributes.h
@@ -427,6 +427,7 @@ extern const char * ATTR_REMOVE_KILL_SIG;
 extern const char * ATTR_REMOVE_REASON;
 extern const char * ATTR_REQUEUE_REASON;
 extern const char * ATTR_REQUIREMENTS;
+extern const char * ATTR_RESOURCE_WEIGHT;
 extern const char * ATTR_RESULT;
 extern const char * ATTR_RSC_BYTES_SENT;
 extern const char * ATTR_RSC_BYTES_RECVD;
diff --git a/src/condor_negotiator.V6/Accountant.cpp b/src/condor_negotiator.V6/Accountant.cpp
index cfc29ba..faab238 100644
--- a/src/condor_negotiator.V6/Accountant.cpp
+++ b/src/condor_negotiator.V6/Accountant.cpp
@@ -42,6 +42,7 @@ MyString Accountant::ResourceRecord="Resource.";
 
 MyString Accountant::PriorityAttr="Priority";
 MyString Accountant::ResourcesUsedAttr="ResourcesUsed";
+MyString Accountant::ResourcesUsedRWAttr="ResourcesUsedRW";
 MyString Accountant::UnchargedTimeAttr="UnchargedTime";
 MyString Accountant::AccumulatedUsageAttr="AccumulatedUsage";
 MyString Accountant::BeginUsageTimeAttr="BeginUsageTime";
@@ -54,7 +55,7 @@ MyString Accountant::RemoteUserAttr="RemoteUser";
 MyString Accountant::StartTimeAttr="StartTime";
 
 MyString Accountant::Cpus="Cpus";
-
+MyString Accountant::ResourceWeightAttr=ATTR_RESOURCE_WEIGHT;
 
 //------------------------------------------------------------------
 // Constructor - One time initialization
@@ -164,6 +165,8 @@ void Accountant::Initialize()
 
   DiscountSuspendedResources = param_boolean(
                              "NEGOTIATOR_DISCOUNT_SUSPENDED_RESOURCES",false);
+  UseResourceWeights = param_boolean("NEGOTIATOR_USE_RESOURCE_WEIGHTS",false);
+
 
   dprintf(D_ACCOUNTANT,"PRIORITY_HALFLIFE=%f\n",HalfLifePeriod);
   dprintf(D_ACCOUNTANT,"NICE_USER_PRIO_FACTOR=%f\n",NiceUserPriorityFactor);
@@ -272,6 +275,17 @@ int Accountant::GetResourcesUsed(const MyString& CustomerName)
 }
 
 //------------------------------------------------------------------
+// Return the number of resources used (floating point version)
+//------------------------------------------------------------------
+
+float Accountant::GetResourcesUsedFloat(const MyString& CustomerName) 
+{
+  float ResourcesUsedRW=0.0;
+  GetAttributeFloat(CustomerRecord+CustomerName,ResourcesUsedRWAttr,ResourcesUsedRW);
+  return ResourcesUsedRW;
+}
+
+//------------------------------------------------------------------
 // Return the priority of a customer
 //------------------------------------------------------------------
 
@@ -467,18 +481,22 @@ void Accountant::AddMatch(const MyString& CustomerName, ClassAd* ResourceAd)
   MyString ResourceName=GetResourceName(ResourceAd);
   time_t T=time(0);
 
-  // dprintf(D_ACCOUNTANT,"Accountant::AddMatch - CustomerName=%s, ResourceName=%s\n",CustomerName.Value(),ResourceName.Value());
+  dprintf(D_ACCOUNTANT,"Accountant::AddMatch - CustomerName=%s, ResourceName=%s\n",CustomerName.Value(),ResourceName.Value());
 
   // Check if the resource is used
   MyString RemoteUser;
   if (GetAttributeString(ResourceRecord+ResourceName,RemoteUserAttr,RemoteUser)) {
     if (CustomerName==RemoteUser) {
-      // dprintf(D_ACCOUNTANT,"Match already existed!\n");
+	  dprintf(D_ACCOUNTANT,"Match already existed!\n");
       return;
     }
     RemoveMatch(ResourceName,T);
   }
-  
+
+  float ResourceWeight=1.0;
+  if(ResourceAd->EvalFloat(ResourceWeightAttr.Value(),NULL,ResourceWeight) == 0) {
+	  ResourceWeight = 1.0;
+  }
 
   int ResourcesUsed=0;
   GetAttributeInt(CustomerRecord+CustomerName,ResourcesUsedAttr,ResourcesUsed);
@@ -489,6 +507,7 @@ void Accountant::AddMatch(const MyString& CustomerName, ClassAd* ResourceAd)
   bool update_group_info = false;
   MyString GroupName;
   int GroupResourcesUsed=0;
+  float GroupResourcesUsedRW = 0.0;
   int GroupUnchargedTime=0;
   if ( GroupNamesList ) {
 	  GroupName = CustomerName;
@@ -501,6 +520,7 @@ void Accountant::AddMatch(const MyString& CustomerName, ClassAd* ResourceAd)
 	  if ( pos != -1 && GroupNamesList->contains_anycase(GroupName.Value()) ) {
 			update_group_info = true;			
 			GetAttributeInt(CustomerRecord+GroupName,ResourcesUsedAttr,GroupResourcesUsed);
+			GetAttributeFloat(CustomerRecord+GroupName,ResourcesUsedRWAttr,GroupResourcesUsedRW);
 			GetAttributeInt(CustomerRecord+GroupName,UnchargedTimeAttr,GroupUnchargedTime);
 	  }
   }
@@ -521,14 +541,18 @@ void Accountant::AddMatch(const MyString& CustomerName, ClassAd* ResourceAd)
   // there is a group record to update
   if ( update_group_info ) {
 	  // Update customer's group resource usage count
+	  GroupResourcesUsedRW += ResourceWeight * cpusPerSlot;
 	  GroupResourcesUsed += cpusPerSlot;
+	  dprintf(D_ACCOUNTANT, "GroupResourcesUsedRW becomes: %.3f\n", GroupResourcesUsedRW);
+	  SetAttributeFloat(CustomerRecord+GroupName,ResourcesUsedRWAttr,GroupResourcesUsedRW);
 	  SetAttributeInt(CustomerRecord+GroupName,ResourcesUsedAttr,GroupResourcesUsed);
 	  // add negative "uncharged" time if match starts after last update 
 	  GroupUnchargedTime-=T-LastUpdateTime;
 	  SetAttributeInt(CustomerRecord+GroupName,UnchargedTimeAttr,GroupUnchargedTime);
+	  SetAttributeFloat(ResourceRecord+ResourceName,ResourceWeightAttr,ResourceWeight);
   }
 
-  // Set resource's info: user, and start-time
+  // Set reosurce's info: user, and start-time
   SetAttributeString(ResourceRecord+ResourceName,RemoteUserAttr,CustomerName);
   SetAttributeInt(ResourceRecord+ResourceName,Cpus,cpusPerSlot);
   SetAttributeInt(ResourceRecord+ResourceName,StartTimeAttr,T);
@@ -573,7 +597,9 @@ void Accountant::RemoveMatch(const MyString& ResourceName, time_t T)
 	bool update_group_info = false;
 	MyString GroupName;
 	int GroupResourcesUsed=0;
+	float GroupResourcesUsedRW=0.0;
 	int GroupUnchargedTime=0;
+	float ResourceWeight=1.0;
 	if ( GroupNamesList ) {
 	  GroupName = CustomerName;
 	  int pos = GroupName.FindChar('.');	// '.' is the group seperater
@@ -585,7 +611,12 @@ void Accountant::RemoveMatch(const MyString& ResourceName, time_t T)
 	  if ( pos != -1 && GroupNamesList->contains_anycase(GroupName.Value()) ) {
 			update_group_info = true;			
 			GetAttributeInt(CustomerRecord+GroupName,ResourcesUsedAttr,GroupResourcesUsed);
+			GetAttributeFloat(CustomerRecord+GroupName,ResourcesUsedRWAttr,GroupResourcesUsedRW);
 			GetAttributeInt(CustomerRecord+GroupName,UnchargedTimeAttr,GroupUnchargedTime);
+			GetAttributeFloat(ResourceRecord+ResourceName,ResourceWeightAttr,ResourceWeight);
+			if(ResourceWeight <= 0.0) {
+				ResourceWeight = 1.0;
+			}
 	  }
 	}
 
@@ -603,7 +634,16 @@ void Accountant::RemoveMatch(const MyString& ResourceName, time_t T)
 	if ( update_group_info ) {
 	  // Update customer's group resource usage count
       GroupResourcesUsed -= cpusPerSlot;
-	  if (GroupResourcesUsed < 0) GroupResourcesUsed = 0;
+      if (GroupResourcesUsed < 0) GroupResourcesUsed = 0;
+
+	  if (GroupResourcesUsedRW>0.0) { 
+	  	GroupResourcesUsedRW -= ResourceWeight;
+		if(GroupResourcesUsedRW < 0.0) {
+		  GroupResourcesUsedRW = 0.0;
+		}
+	  }
+	  SetAttributeFloat(CustomerRecord+GroupName,ResourcesUsedRWAttr,GroupResourcesUsedRW);
+
 	  SetAttributeInt(CustomerRecord+GroupName,ResourcesUsedAttr,GroupResourcesUsed);
 	  // update uncharged time
 	  GroupUnchargedTime+=T-StartTime;
@@ -691,6 +731,7 @@ void Accountant::UpdatePriorities()
   float AccumulatedUsage;
   float RecentUsage;
   int ResourcesUsed;
+  float ResourcesUsedRW;
   int BeginUsageTime;
 
   AcctLog->table.startIterations();
@@ -713,6 +754,7 @@ void Accountant::UpdatePriorities()
     if (ad->LookupFloat(AccumulatedUsageAttr.Value(),AccumulatedUsage)==0) AccumulatedUsage=0;
     if (ad->LookupInteger(BeginUsageTimeAttr.Value(),BeginUsageTime)==0) BeginUsageTime=0;
     if (ad->LookupInteger(ResourcesUsedAttr.Value(),ResourcesUsed)==0) ResourcesUsed=0;
+	if (ad->LookupFloat(ResourcesUsedRWAttr.Value(),ResourcesUsedRW)==0) ResourcesUsedRW=0.0;
 
     RecentUsage=float(ResourcesUsed)+float(UnchargedTime)/TimePassed;
     Priority=Priority*AgingFactor+RecentUsage*(1-AgingFactor);
@@ -732,7 +774,7 @@ void Accountant::UpdatePriorities()
 
 	AcctLog->CommitTransaction();
 	
-    dprintf(D_ACCOUNTANT,"CustomerName=%s , Old Priority=%5.3f , New Priority=%5.3f , ResourcesUsed=%d\n",key,OldPrio,Priority,ResourcesUsed);
+    dprintf(D_ACCOUNTANT,"CustomerName=%s , Old Priority=%5.3f , New Priority=%5.3f , ResourcesUsed=%d , ResourcesUsedRW=%f\n",key,OldPrio,Priority,ResourcesUsed,ResourcesUsedRW);
     dprintf(D_ACCOUNTANT,"RecentUsage=%8.3f, UnchargedTime=%d, AccumulatedUsage=%5.3f, BeginUsageTime=%d\n",RecentUsage,UnchargedTime,AccumulatedUsage,BeginUsageTime);
 
   }
diff --git a/src/condor_negotiator.V6/matchmaker.cpp b/src/condor_negotiator.V6/matchmaker.cpp
index f93a460..5f4cef3 100644
--- a/src/condor_negotiator.V6/matchmaker.cpp
+++ b/src/condor_negotiator.V6/matchmaker.cpp
@@ -61,6 +61,8 @@ typedef int (*lessThanFunc)(AttrList*, AttrList*, void*);
 
 static bool want_simple_matching = false;
 
+MyString ResourceWeightAttr = ATTR_RESOURCE_WEIGHT;
+
 //added by ameet - dirty hack - needs to be removed soon!!!
 //#include "../condor_c++_util/queuedbmanager.h"
 //QueueDBManager queueDBManager;
@@ -321,10 +323,10 @@ reinitialize ()
 			EXCEPT ("Error parsing PREEMPTION_RANK expression: %s", tmp);
 		}
 	}
-	dprintf (D_ALWAYS,"PREEMPTION_RANK = %s\n", (tmp?tmp:"None"));
-	if( tmp ) free( tmp );
 
+	dprintf (D_ALWAYS,"PREEMPTION_RANK = %s\n", (tmp?tmp:"None"));
 
+	if( tmp ) free( tmp );
 
 	if (NegotiatorPreJobRank) delete NegotiatorPreJobRank;
 	NegotiatorPreJobRank = NULL;
@@ -370,6 +372,8 @@ reinitialize ()
 		free( preferred_collector );
 	}
 
+	useResourceWeights = param_boolean("NEGOTIATOR_USE_RESOURCE_WEIGHTS", false);
+
 	want_simple_matching = param_boolean("NEGOTIATOR_SIMPLE_MATCHING",false);
 	want_matchlist_caching = param_boolean("NEGOTIATOR_MATCHLIST_CACHING",true);
 	ConsiderPreemption = param_boolean("NEGOTIATOR_CONSIDER_PREEMPTION",true);
@@ -803,8 +807,8 @@ compute_significant_attrs(ClassAdList & startdAds)
 	}
 		// Always get rid of the follow attrs:
 		//    CurrentTime - for obvious reasons
-		//    RemoteUserPrio and friends - not needed since we negotiate per user
-		//    SubmittorPrio and friends - not needed since we negotiate per user
+		//    RemoteUserPrio - not needed since we negotiate per user
+		//    SubmittorPrio - not needed since we negotiate per user
 	external_references.remove_anycase(ATTR_CURRENT_TIME);
 	external_references.remove_anycase(ATTR_REMOTE_USER_PRIO);
 	external_references.remove_anycase(ATTR_REMOTE_USER_RESOURCES_IN_USE);
@@ -822,7 +826,7 @@ compute_significant_attrs(ClassAdList & startdAds)
 
 
 bool Matchmaker::
-getGroupInfoFromUserId( const char *user, int & groupQuota, int & groupUsage )
+getGroupInfoFromUserId( const char *user, float & groupQuota, float & groupUsage )
 {
 	/*  Given a user id in the form group.user, strip off the group name
 		return any associated quota and usage for that group.  On failure,
@@ -833,8 +837,8 @@ getGroupInfoFromUserId( const char *user, int & groupQuota, int & groupUsage )
 	 */
 	ASSERT(groupQuotasHash);
 
-	groupQuota = 0;
-	groupUsage = 0;
+	groupQuota = 0.0;
+	groupUsage = 0.0;
 
 	if (!user) return false;
 
@@ -995,10 +999,10 @@ negotiationTime ()
 		while ((groups = groupList.next ()))
 		{
 			tmpstr.sprintf("GROUP_QUOTA_%s",groups);
-			int quota = param_integer(tmpstr.Value(), -1 );
-			if ( quota >= 0 ) {
+			float quota = param_double(tmpstr.Value(), -1.0 );
+			if ( quota >= 0.0 ) {
                 // Static groups quotas take priority over any dynamic quota
-                dprintf(D_FULLDEBUG, "group %s static quota = %d\n",
+                dprintf(D_FULLDEBUG, "group %s static quota = %.3f\n",
                         groups, quota);
             } else {
                 // Next look for a floating point dynamic quota.
@@ -1014,7 +1018,7 @@ negotiationTime ()
                     // use specified dynamic quota
                     quota = (int)(quota_fraction * numDynGroupSlots);
                     dprintf(D_FULLDEBUG,
-                        "group %s dynamic quota for %d slots = %d\n",
+                        "group %s dynamic quota for %d slots = %.3f\n",
                             groups, numDynGroupSlots, quota);
                 } else {
                     // neither a static nor dynamic quota was defined
@@ -1024,7 +1028,6 @@ negotiationTime ()
                     continue;
                 }
             }
-
             if ( quota <= 0 ) {
                 // Quota for group may have been set to zero by admin.
                 dprintf(D_ALWAYS,
@@ -1042,8 +1045,10 @@ negotiationTime ()
 			// fill in the info into the groupArray, so we can sort
 			// the groups into the order we want to negotiate them.
 			int usage  = accountant.GetResourcesUsed(groups);
+			float usageRW = accountant.GetResourcesUsedFloat(groups);
 			groupArray[i].groupName = groups;  // don't free this! (in groupList)
 			groupArray[i].maxAllowed = quota;
+			groupArray[i].usageRW = usageRW;
 			groupArray[i].usage = usage;
 				// the 'prio' field is used to sort the group array, i.e. to
 				// decide which groups get to negotiate first.  
@@ -1052,8 +1057,8 @@ negotiationTime ()
 				// percentage amount of their quota get to negotiate first.
 			groupArray[i].prio = ( 100 * usage ) / quota;
 			dprintf(D_FULLDEBUG,
-				"Group Table : group %s quota %d usage %d prio %2.2f\n",
-				groups,quota,usage,groupArray[i].prio);
+				"Group Table : group %s quota %.3f usage %d(%.3f) prio %2.2f\n",
+					groups,quota,usage,usageRW,groupArray[i].prio);
 			i++;
 		}
 		int groupArrayLen = i;
@@ -1094,13 +1099,24 @@ negotiationTime ()
 					groupArray[i].groupName);
 				continue;
 			}
-			if ( groupArray[i].usage >= groupArray[i].maxAllowed  &&
-				 !ConsiderPreemption ) 
-			{
-				dprintf(D_ALWAYS,
-					"Group %s - skipping, at or over quota (usage=%d)\n",
-					groupArray[i].groupName,groupArray[i].usage);
-				continue;
+			if(useResourceWeights) {
+				if ( groupArray[i].usageRW >= groupArray[i].maxAllowed  &&
+					 !ConsiderPreemption ) 
+					{
+						dprintf(D_ALWAYS,
+								"Group %s - skipping, at or over quota (usage=%.3f)\n",
+								groupArray[i].groupName,groupArray[i].usageRW);
+						continue;
+					}
+			} else {
+				if ( groupArray[i].usage >= groupArray[i].maxAllowed  &&
+					 !ConsiderPreemption ) 
+					{
+						dprintf(D_ALWAYS,
+								"Group %s - skipping, at or over quota (usage=%d)\n",
+								groupArray[i].groupName,groupArray[i].usage);
+						continue;
+					}
 			}
 			dprintf(D_ALWAYS,"Group %s - negotiating\n",
 				groupArray[i].groupName);
@@ -1170,13 +1186,14 @@ int Matchmaker::
 negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 					 ClaimIdHash& claimIds, 
 					 ClassAdList& scheddAds, 
-					 int groupQuota, const char* groupAccountingName)
+					 float groupQuota, const char* groupAccountingName)
 {
 	ClassAd		*schedd;
 	MyString    scheddName;
 	MyString    scheddAddr;
 	int			result;
 	int			numStartdAds;
+	double      resourceWeightTotal;
 	double		maxPrioValue;
 	double		maxAbsPrioValue;
 	double		normalFactor;
@@ -1190,6 +1207,7 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 	int			scheddUsage;
 	int			totalTime;
 	int			MaxscheddLimit;
+	double      MaxscheddLimitRW;
 	int			hit_schedd_prio_limit;
 	int			hit_network_prio_limit;
 	bool ignore_schedd_limit;
@@ -1229,6 +1247,15 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 		if ( numStartdAds > groupQuota ) {
 			numStartdAds = groupQuota;
 		}
+		if(useResourceWeights) {
+			resourceWeightTotal = sumResourceWeights(startdAds);
+			if ( resourceWeightTotal > groupQuota ) {
+				resourceWeightTotal = groupQuota;
+			}
+		} else {
+			resourceWeightTotal = numStartdAds;
+		}
+
 			// Calculate how many machines are left over after dishing out
 			// rounded share of machines to each submitter.
 			// What's left are the user-prio "pie crumbs".
@@ -1241,10 +1268,12 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 			maxAbsPrioValue,
 			normalFactor,
 			normalAbsFactor,
+			resourceWeightTotal,
 				/* result parameters: */
 			userprioCrumbs );
 
 		MaxscheddLimit = 0;
+		MaxscheddLimitRW = 0.0;
 		// ----- Negotiate with the schedds in the sorted list
 		dprintf( D_ALWAYS, "Phase 4.%d:  Negotiating with schedds ...\n",
 			spin_pie );
@@ -1293,6 +1322,12 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 			free(schedd_ver_string);
 			schedd_ver_string = NULL;
 
+			double scheddLimitRW = 0.0;
+			double scheddUsageRW = 0.0;
+
+			float resourceWeight = 1.0;
+			schedd->EvalFloat(ResourceWeightAttr.Value(), NULL, resourceWeight);
+
 			calculateScheddLimit(
 				scheddName.Value(),
 				groupAccountingName,
@@ -1302,9 +1337,13 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 				maxAbsPrioValue,
 				normalFactor,
 				normalAbsFactor,
+				resourceWeight,
+				resourceWeightTotal,
 					/* result parameters: */
 				scheddLimit,
+				scheddLimitRW,
 				scheddUsage,
+				scheddUsageRW,
 				scheddShare,
 				scheddAbsShare,
 				scheddPrio,
@@ -1324,6 +1363,9 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 			if( scheddLimit > MaxscheddLimit ) {
 				MaxscheddLimit = scheddLimit;
 			}
+			if( scheddLimitRW > MaxscheddLimitRW ) {
+				MaxscheddLimitRW = scheddLimitRW;
+			}
 
 			if ( num_idle_jobs > 0 ) {
 				dprintf (D_FULLDEBUG, "  Calculating schedd limit with the "
@@ -1344,6 +1386,12 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 					userprioCrumbs, scheddLimit - scheddLimitWithoutCrumbs);
 				dprintf (D_FULLDEBUG, "    MaxscheddLimit   = %d\n",
 					MaxscheddLimit);
+				dprintf (D_FULLDEBUG, "    scheddLimitRW    = %f\n",
+					scheddLimitRW);
+				dprintf (D_FULLDEBUG, "    scheddUsageRW    = %f\n",
+					scheddUsageRW);
+				dprintf (D_FULLDEBUG, "    MaxscheddLimitRW = %f\n",
+					MaxscheddLimitRW);
 			}
 
 			// initialize reasons for match failure; do this now
@@ -1354,6 +1402,7 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 			rejPreemptForPrio = 0;
 			rejPreemptForPolicy = 0;
 			rejPreemptForRank = 0;
+			rejForGroupQuota = 0;
 
 			// Optimizations: 
 			// If number of idle jobs = 0, don't waste time with negotiate.
@@ -1386,11 +1435,12 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 					}
 					int numMatched = 0;
 					startTime = time(NULL);
+					double limitRWUsed = 0.0;
 					result=negotiate( scheddName.Value(),schedd,scheddPrio,
-								  scheddAbsShare, scheddLimit,
+								  scheddAbsShare, scheddLimit, scheddLimitRW,
 								  startdAds, claimIds, 
 								  scheddVersion, ignore_schedd_limit,
-								  startTime, numMatched);
+								  startTime, numMatched, limitRWUsed);
 					updateNegCycleEndTime(startTime, schedd);
 
 					if( numMatched > scheddLimitWithoutCrumbs ) {
@@ -1449,8 +1499,10 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 			}
 		}
 		scheddAds.Close();
+		// does MaxScheddLimit[RW] ever get updated in this loop?
 	} while ( (hit_schedd_prio_limit == TRUE || hit_network_prio_limit == TRUE)
-			 && (MaxscheddLimit > 0) && (startdAds.MyLength() > 0) );
+			  && ( useResourceWeights ? (MaxscheddLimitRW > 0.0) : (MaxscheddLimit > 0) )
+			  && (startdAds.MyLength() > 0) );
 
 	return TRUE;
 }
@@ -1523,7 +1575,7 @@ trimStartdAds(ClassAdList &startdAds)
 
 		// If we are not considering preemption, we can save time
 		// (and also make the spinning pie algorithm more correct) by
-		// getting rid of ads that are in claimed or preempting state.
+		// getting rid of ads that are not in the Unclaimed state.
 	
 	if ( ConsiderPreemption ) {
 			// we need to keep all the ads.
@@ -1546,6 +1598,21 @@ trimStartdAds(ClassAdList &startdAds)
 	return removed;
 }
 
+double Matchmaker::
+sumResourceWeights(ClassAdList &startdAds)
+{
+	ClassAd *ad = NULL;
+	double sum = 0.0;
+
+	startdAds.Open();
+	while( (ad=startdAds.Next()) ) {
+		float resourceWeight = 1.0;
+		ad->EvalFloat(ResourceWeightAttr.Value(), NULL, resourceWeight);
+		sum+=resourceWeight;
+	}
+	return sum;
+}
+
 bool Matchmaker::
 obtainAdsFromCollector (
 						ClassAdList &allAds,
@@ -1829,10 +1896,11 @@ Matchmaker::MakeClaimIdHash(ClassAdList &startdPvtAdList, ClaimIdHash &claimIds)
 
 int Matchmaker::
 negotiate( char const *scheddName, const ClassAd *scheddAd, double priority, double share,
-		   int scheddLimit,
+		   int scheddLimit, double scheddLimitRW,
 		   ClassAdList &startdAds, ClaimIdHash &claimIds, 
 		   const CondorVersionInfo & scheddVersion,
-		   bool ignore_schedd_limit, time_t startTime, int &numMatched)
+		   bool ignore_schedd_limit, time_t startTime, 
+		   int &numMatched, double &limitRWUsed)
 {
 	ReliSock	*sock;
 	int			reply;
@@ -1959,22 +2027,42 @@ negotiate( char const *scheddName, const ClassAd *scheddAd, double priority, dou
 
 
 		// Handle the case if we are over the scheddLimit
-		if ( numMatched >= scheddLimit ) {
-			if ( ignore_schedd_limit ) {
-				only_consider_startd_rank = true;
-				if ( display_overlimit ) {  // print message only once
-					display_overlimit = false;
-					dprintf (D_FULLDEBUG, 	
-						"    Over submitter resource limit (%d) ... "
-					    "only consider startd ranks\n", scheddLimit);
+		if(useResourceWeights) {
+			if( limitRWUsed >= scheddLimitRW ) {
+				if( ignore_schedd_limit ) {
+					only_consider_startd_rank = true;
+					if( display_overlimit ) {
+						display_overlimit = false;
+						dprintf(D_FULLDEBUG,
+								"    Over submitter resource limit (%f) ... "
+								"only consider startd ranks\n", scheddLimitRW);
+					}
+				} else {
+					dprintf (D_ALWAYS, 	
+							 "    Reached submitter resource limit: %f ... stopping\n", limitRWUsed);
+					break;	// get out of the infinite for loop & stop negotiating
 				}
 			} else {
-				dprintf (D_ALWAYS, 	
-				"    Reached submitter resource limit: %d ... stopping\n", numMatched);
-				break;	// get out of the infinite for loop & stop negotiating
+				only_consider_startd_rank = false;
 			}
 		} else {
-			only_consider_startd_rank = false;
+			if ( numMatched >= scheddLimit ) {
+				if ( ignore_schedd_limit ) {
+					only_consider_startd_rank = true;
+					if ( display_overlimit ) {  // print message only once
+						display_overlimit = false;
+						dprintf (D_FULLDEBUG, 	
+								 "    Over submitter resource limit (%d) ... "
+								 "only consider startd ranks\n", scheddLimit);
+					}
+				} else {
+					dprintf (D_ALWAYS, 	
+							 "    Reached submitter resource limit: %d ... stopping\n", numMatched);
+					break;	// get out of the infinite for loop & stop negotiating
+				}
+			} else {
+				only_consider_startd_rank = false;
+			}
 		}
 
 
@@ -2009,10 +2097,18 @@ negotiate( char const *scheddName, const ClassAd *scheddAd, double priority, dou
 				// So in this case, return MM_RESUME since there still may be 
 				// jobs which the schedd wants scheduled but have not been considered
 				// as candidates for no preemption or user priority preemption.
-			if ( numMatched >= scheddLimit ) {
-				return MM_RESUME;
+			if ( useResourceWeights ) {
+				if( limitRWUsed >= scheddLimitRW ) {
+					return MM_RESUME;
+				} else {
+					return MM_DONE;
+				}
 			} else {
-				return MM_DONE;
+				if ( numMatched >= scheddLimit ) {
+					return MM_RESUME;
+				} else {
+					return MM_DONE;
+				}
 			}
 		}
 		else
@@ -2052,7 +2148,7 @@ negotiate( char const *scheddName, const ClassAd *scheddAd, double priority, dou
 		// next insert the submitter user usage attributes into the request
 		request.Assign(ATTR_SUBMITTER_USER_RESOURCES_IN_USE, 
 					   accountant.GetResourcesUsed ( scheddName ));
-		int temp_groupQuota, temp_groupUsage;
+		float temp_groupQuota, temp_groupUsage;
 		if (getGroupInfoFromUserId(scheddName,temp_groupQuota,temp_groupUsage))
 		{
 			// this is a group, so enter group usage info
@@ -2070,7 +2166,9 @@ negotiate( char const *scheddName, const ClassAd *scheddAd, double priority, dou
 			// 2e(i).  find a compatible offer
 			if (!(offer=matchmakingAlgorithm(scheddName, scheddAddr.Value(), request,
 											 startdAds, priority,
-											 share, only_consider_startd_rank)))
+											 share, 
+											 limitRWUsed, scheddLimitRW,
+											 only_consider_startd_rank)))
 			{
 				int want_match_diagnostics = 0;
 				request.LookupBool (ATTR_WANT_MATCH_DIAGNOSTICS,
@@ -2097,6 +2195,8 @@ negotiate( char const *scheddName, const ClassAd *scheddAd, double priority, dou
 							"PREEMPTION_REQUIREMENTS == False";
 					} else if (rejPreemptForPrio) {
 						diagnostic_message = "insufficient priority";
+					} else if (rejForGroupQuota) {
+						diagnostic_message = "group quota exceeded";
 					} else {
 						diagnostic_message = "no match found";
 					}
@@ -2187,6 +2287,9 @@ negotiate( char const *scheddName, const ClassAd *scheddAd, double priority, dou
 		} else  {
 			startdAds.Delete (offer);
 		}	
+
+		limitRWUsed += GetResourceWeight(offer);
+
 	}
 
 
@@ -2238,6 +2341,39 @@ EvalNegotiatorMatchRank(char const *expr_name,ExprTree *expr,
 	return rank;
 }
 
+float Matchmaker::
+GetResourceWeight(ClassAd *candidate) 
+{
+	float ResourceWeight = 1.0;
+	MyString candidateName;
+	candidate->LookupString(ATTR_NAME, candidateName);
+	
+	if(candidate->EvalFloat(ResourceWeightAttr.Value(), NULL, 
+							  ResourceWeight) == 0) {
+		dprintf(D_FULLDEBUG, "Can't get ResourceWeight for '%s'; using 1.0\n", 
+				candidateName.Value());
+		ResourceWeight = 1.0;
+	}
+	return ResourceWeight;
+}
+
+bool Matchmaker::
+GroupQuotaPermits(ClassAd *candidate, double &used, double total) 
+{
+	float ResourceWeight = GetResourceWeight(candidate);
+	if((used + ResourceWeight) <= total) {
+		dprintf(D_FULLDEBUG, 
+				"GroupQuota available.  ResourceWeight: %.3f "
+				"Available: was %.3f, becomes %.3f\n", 
+				ResourceWeight, total - used, total - (used+ResourceWeight));
+		used += ResourceWeight;
+		return true;
+	} 
+	dprintf(D_FULLDEBUG, "GroupQuota not available.  ResourceWeight: %.3f "
+			"Available: %.3f\n", ResourceWeight, total - used);
+	return false;
+}
+
 
 /*
 Warning: scheddAddr may not be the actual address we'll use to contact the
@@ -2248,6 +2384,7 @@ ClassAd *Matchmaker::
 matchmakingAlgorithm(const char *scheddName, const char *scheddAddr, ClassAd &request,
 					 ClassAdList &startdAds,
 					 double preemptPrio, double share,
+					 double limitRWUsed, double scheddLimitRW,
 					 bool only_for_startdrank)
 {
 		// to store values pertaining to a particular candidate offer
@@ -2273,6 +2410,7 @@ matchmakingAlgorithm(const char *scheddName, const char *scheddAddr, ClassAd &re
 		// request attributes
 	int				requestAutoCluster = -1;
 
+	dprintf(D_FULLDEBUG, "matchmakingAlgorithm: limit %f used %f\n", scheddLimitRW, limitRWUsed);
 
 		// Check resource constraints requested by request
 	rejForConcurrencyLimit = 0;
@@ -2351,7 +2489,8 @@ matchmakingAlgorithm(const char *scheddName, const char *scheddAddr, ClassAd &re
 				rejForConcurrencyLimit,
 				rejPreemptForPrio,
 				rejPreemptForPolicy,
-				rejPreemptForRank);
+				rejPreemptForRank,
+				rejForGroupQuota);
 		}
 			//  TODO  - compare results, reserve net bandwidth
 		return cached_bestSoFar;
@@ -2446,18 +2585,12 @@ matchmakingAlgorithm(const char *scheddName, const char *scheddAddr, ClassAd &re
 	rejPreemptForPrio = 0;
 	rejPreemptForPolicy = 0;
 	rejPreemptForRank = 0;
+	rejForGroupQuota = 0;
 
 	// scan the offer ads
 	startdAds.Open ();
 	while ((candidate = startdAds.Next ())) {
 
-			// this will insert remote user priority information into the 
-			// startd ad (if it is currently running a job), which can then
-			// be referenced via the various PREEMPTION_REQUIREMENTS expressions.
-			// we now need to do this inside the inner loop because we insert
-			// usage information 
-		addRemoteUserPrios(candidate);
-
 			// the candidate offer and request must match
 		if( !( *candidate == request ) ) {
 				// they don't match; continue
@@ -2563,6 +2696,12 @@ matchmakingAlgorithm(const char *scheddName, const char *scheddAddr, ClassAd &re
 		}
 #endif
 
+		if(useResourceWeights && 
+		   !GroupQuotaPermits(candidate, limitRWUsed, scheddLimitRW)) {
+			rejForGroupQuota++;
+			continue;
+		}
+
 		candidatePreJobRankValue = EvalNegotiatorMatchRank(
 		  "NEGOTIATOR_PRE_JOB_RANK",NegotiatorPreJobRank,
 		  request,candidate);
@@ -2649,7 +2788,8 @@ matchmakingAlgorithm(const char *scheddName, const char *scheddAddr, ClassAd &re
 	if ( MatchList ) {
 		MatchList->set_diagnostics(rejForNetwork, rejForNetworkShare, 
 		    rejForConcurrencyLimit,
-			rejPreemptForPrio, rejPreemptForPolicy, rejPreemptForRank);
+			rejPreemptForPrio, rejPreemptForPolicy, rejPreemptForRank,
+			rejForGroupQuota);
 			// only bother sorting if there is more than one entry
 		if ( MatchList->length() > 1 ) {
 			dprintf(D_FULLDEBUG,"Start of sorting MatchList (len=%d)\n",
@@ -2661,6 +2801,9 @@ matchmakingAlgorithm(const char *scheddName, const char *scheddAddr, ClassAd &re
 		ClassAd *bestCached = MatchList->pop_candidate();
 		// TODO - do bestCached and bestSoFar refer to the same
 		// machine preference? (sanity check)
+		if(bestCached != bestSoFar) {
+			dprintf(D_ALWAYS, "INSANE: bestCached != bestSoFar\n");
+		}
 		bestCached = NULL; // just to remove unused variable warning
 	}
 
@@ -2995,10 +3138,14 @@ Matchmaker::calculateScheddLimit(
 	double maxAbsPrioValue,
 	double normalFactor,
 	double normalAbsFactor,
+	float resourceWeight,
+	double resourceWeightTotal,
 		/* result parameters: */
 	int &scheddLimit,
+	double &scheddLimitRW,
 	int &scheddUsage,
-	double scheddShare,
+	double &scheddUsageRW,
+	double &scheddShare,
 	double &scheddAbsShare,
 	double &scheddPrio,
 	double &scheddPrioFactor,
@@ -3007,27 +3154,43 @@ Matchmaker::calculateScheddLimit(
 		// calculate the percentage of machines that this schedd can use
 	scheddPrio = accountant.GetPriority ( scheddName );
 	scheddUsage = accountant.GetResourcesUsed ( scheddName );
+	scheddUsageRW = accountant.GetResourcesUsedFloat( scheddName );
 	scheddShare = maxPrioValue/(scheddPrio*normalFactor);
 	double unroundedScheddLimit;
 	if ( param_boolean("NEGOTIATOR_IGNORE_USER_PRIORITIES",false) ) {
 			// why is this not assigned to numStartdAds?
 		unroundedScheddLimit = 500000;
+		scheddLimitRW = DBL_MAX;
 	} else {
 		unroundedScheddLimit = (scheddShare*numStartdAds)-scheddUsage;
+		scheddLimitRW = (scheddShare*resourceWeightTotal)-scheddUsageRW;
 	}
 	if( unroundedScheddLimit < 0 ) {
 		unroundedScheddLimit = 0;
 	}
+	if( scheddLimitRW < 0 ) {
+		scheddLimitRW = 0.0;
+	}
+
 	if ( groupAccountingName ) {
 		int maxAllowed = groupQuota - accountant.GetResourcesUsed(groupAccountingName);
+		float maxAllowedRW = resourceWeightTotal 
+			- accountant.GetResourcesUsedFloat(groupAccountingName);
 		if ( maxAllowed < 0 ) maxAllowed = 0;
+		if ( maxAllowedRW < 0 ) maxAllowedRW = 0.0;
 		if ( unroundedScheddLimit > maxAllowed ) {
 			unroundedScheddLimit = maxAllowed;
 		}
+		if ( scheddLimitRW > maxAllowedRW ) {
+			scheddLimitRW = maxAllowedRW;
+		}
 	}
 
 	scheddLimit  = (int) rint(unroundedScheddLimit);
 	scheddLimitRoundoff = unroundedScheddLimit - scheddLimit;
+	if(scheddLimitRoundoff < 0.0) {
+		dprintf(D_ALWAYS, "Negative scheddLimitRoundoff: %.3f", scheddLimitRoundoff);
+	}
 
 		// calculate this schedd's absolute fair-share for allocating
 		// resources other than CPUs (like network capacity and licenses)
@@ -3046,6 +3209,7 @@ Matchmaker::calculateUserPrioCrumbs(
 	double maxAbsPrioValue,
 	double normalFactor,
 	double normalAbsFactor,
+	double resourceWeightTotal,
 		/* result parameters: */
 	int &userprioCrumbs )
 {
@@ -3069,8 +3233,12 @@ Matchmaker::calculateUserPrioCrumbs(
 		double scheddPrioFactor = 0.0;
 		MyString scheddName;
 		double scheddLimitRoundoff = 0.0;
+		float resourceWeight = 1.0;
+		double scheddLimitRW = 0.0;
+		double scheddUsageRW = 0.0;
 
 		schedd->LookupString( ATTR_NAME, scheddName );
+		schedd->EvalFloat(ResourceWeightAttr.Value(), NULL, resourceWeight);
 
 		calculateScheddLimit(
 			scheddName.Value(),
@@ -3081,9 +3249,13 @@ Matchmaker::calculateUserPrioCrumbs(
 			maxAbsPrioValue,
 			normalFactor,
 			normalAbsFactor,
+			resourceWeight,
+			resourceWeightTotal,
 				/* result parameters: */
 			scheddLimit,
+			scheddLimitRW,
 			scheddUsage,
+			scheddUsageRW,
 			scheddShare,
 			scheddAbsShare,
 			scheddPrio,
@@ -3094,6 +3266,9 @@ Matchmaker::calculateUserPrioCrumbs(
 	scheddAds.Close();
 
 	userprioCrumbs = (int)rint( roundoff_sum );
+	if(userprioCrumbs < 0) {
+		dprintf(D_ALWAYS, "Negative userprioCrumbs: %d\n", userprioCrumbs);
+	}
 }
 
 void Matchmaker::
@@ -3184,7 +3359,7 @@ addRemoteUserPrios( ClassAd	*ad )
 	float	prio;
 	int     total_slots, i;
 	float     preemptingRank;
-	int temp_groupQuota, temp_groupUsage;
+	float temp_groupQuota, temp_groupUsage;
 
 	if ( !ConsiderPreemption ) {
 			// Hueristic - no need to take the time to populate ad with 
@@ -3318,6 +3493,7 @@ MatchListType(int maxlen)
 	m_rejPreemptForPrio = 0;
 	m_rejPreemptForPolicy = 0; 
 	m_rejPreemptForRank = 0;
+	m_rejForGroupQuota = 0;
 }
 
 Matchmaker::MatchListType::
@@ -3441,7 +3617,8 @@ get_diagnostics(int & rejForNetwork,
 					int & rejForConcurrencyLimit,
 					int & rejPreemptForPrio,
 					int & rejPreemptForPolicy,
-					int & rejPreemptForRank)
+				    int & rejPreemptForRank,
+				    int & rejForGroupQuota)
 {
 	rejForNetwork = m_rejForNetwork;
 	rejForNetworkShare = m_rejForNetworkShare;
@@ -3449,6 +3626,7 @@ get_diagnostics(int & rejForNetwork,
 	rejPreemptForPrio = m_rejPreemptForPrio;
 	rejPreemptForPolicy = m_rejPreemptForPolicy;
 	rejPreemptForRank = m_rejPreemptForRank;
+	rejForGroupQuota = m_rejForGroupQuota;
 }
 
 void Matchmaker::MatchListType::
@@ -3457,7 +3635,8 @@ set_diagnostics(int rejForNetwork,
 					int rejForConcurrencyLimit,
 					int rejPreemptForPrio,
 					int rejPreemptForPolicy,
-					int rejPreemptForRank)
+				    int rejPreemptForRank,
+				    int rejForGroupQuota)
 {
 	m_rejForNetwork = rejForNetwork;
 	m_rejForNetworkShare = rejForNetworkShare;
@@ -3465,6 +3644,7 @@ set_diagnostics(int rejForNetwork,
 	m_rejPreemptForPrio = rejPreemptForPrio;
 	m_rejPreemptForPolicy = rejPreemptForPolicy;
 	m_rejPreemptForRank = rejPreemptForRank;
+	m_rejForGroupQuota = rejForGroupQuota;
 }
 
 void Matchmaker::MatchListType::
diff --git a/src/condor_negotiator.V6/matchmaker.h b/src/condor_negotiator.V6/matchmaker.h
index 013d1a3..a03d9e6 100644
--- a/src/condor_negotiator.V6/matchmaker.h
+++ b/src/condor_negotiator.V6/matchmaker.h
@@ -90,6 +90,7 @@ class Matchmaker : public Service
     protected:
 		char * NegotiatorName;
 		int update_interval;
+		
 
 	private:
 		ClassAd * publicAd;
@@ -122,19 +123,20 @@ class Matchmaker : public Service
 		**/
 		int negotiate( char const *scheddName, const ClassAd *scheddAd, 
 		   double priority, double share,
-		   int scheddLimit,
+		   int scheddLimit, double scheddLimitRW,
 		   ClassAdList &startdAds, ClaimIdHash &claimIds, 
 		   const CondorVersionInfo & scheddVersion,
-		   bool ignore_schedd_limit, time_t startTime, int &numMatched);
+		   bool ignore_schedd_limit, time_t startTime, 
+		   int &numMatched, double &limitRWUsed);
 
 		int negotiateWithGroup ( int untrimmed_num_startds,
 			ClassAdList& startdAds, 
 			ClaimIdHash& claimIds, ClassAdList& scheddAds, 
-			int groupQuota=INT_MAX, const char* groupAccountingName=NULL);
+			float groupQuota=INT_MAX, const char* groupAccountingName=NULL);
 
 		
 		ClassAd *matchmakingAlgorithm(const char*,const char*,ClassAd&,ClassAdList&,
-									  double=-1.0, double=1.0, bool=false);
+									  double=-1.0, double=1.0, double=0.0, double=0.0, bool=false);
 		int matchmakingProtocol(ClassAd &request, ClassAd *offer, 
 						ClaimIdHash &claimIds, Sock *sock,
 						const char* scheddName, const char* scheddAddr);
@@ -169,10 +171,14 @@ class Matchmaker : public Service
 		                          double maxAbsPrioValue,
 		                          double normalFactor,
 		                          double normalAbsFactor,
+								  float resourceWeight,
+								  double resourceWeightTotal,
 		                            /* result parameters: */
 		                          int &scheddLimit,
+								  double &scheddLimitRW,
 		                          int &scheddUsage,
-		                          double scheddShare,
+								  double &scheddUsageRW,
+		                          double &scheddShare,
 		                          double &scheddAbsShare,
 		                          double &scheddPrio,
 		                          double &scheddPrioFactor,
@@ -200,6 +206,7 @@ class Matchmaker : public Service
 		                              double maxAbsPrioValue,
 		                              double normalFactor,
 		                              double normalAbsFactor,
+									  double resourceWeightTotal,
 		                                   /* result parameters: */
 		                              int &userprioCrumbs );
 
@@ -218,6 +225,10 @@ class Matchmaker : public Service
 			// trim out startd ads that are not in the Unclaimed state.
 		int trimStartdAds(ClassAdList &startdAds);
 
+		float GetResourceWeight(ClassAd *candidate);
+		bool GroupQuotaPermits(ClassAd *candidate, double &used, double total);
+		double sumResourceWeights(ClassAdList &startdAds);
+
 		/* ODBC insert functions */
 		void insert_into_rejects(char const *userName, ClassAd& job);
 		void insert_into_matches(char const *userName, ClassAd& request, ClassAd& offer);
@@ -234,6 +245,7 @@ class Matchmaker : public Service
 		bool preemption_rank_unstable;
 		ExprTree *NegotiatorPreJobRank;  // rank applied before job rank
 		ExprTree *NegotiatorPostJobRank; // rank applied after job rank
+		bool useResourceWeights; // Should resource weights be used or do all machines count 1.
 		bool want_matchlist_caching;	// should we cache matches per autocluster?
 		bool ConsiderPreemption; // if false, negotiation is faster (default=true)
 		/// Should the negotiator inform startds of matches?
@@ -252,11 +264,11 @@ class Matchmaker : public Service
 		typedef HashTable<MyString, MapEntry*> AdHash;
 		AdHash *stashedAds;			
 
-		typedef HashTable<MyString, int> groupQuotasHashType;
+		typedef HashTable<MyString, float> groupQuotasHashType;
 		groupQuotasHashType *groupQuotasHash;
 
-		bool getGroupInfoFromUserId( const char *user, int & groupQuota, 
-			 int & groupUsage );
+		bool getGroupInfoFromUserId( const char *user, float & groupQuota, 
+			 float & groupUsage );
 		
 #ifdef WANT_NETMAN
 		// allocate network capacity
@@ -294,6 +306,7 @@ class Matchmaker : public Service
 		int rejPreemptForPrio;	//   - insufficient prio to preempt?
 		int rejPreemptForPolicy; //   - PREEMPTION_REQUIREMENTS == False?
 		int rejPreemptForRank;	//   - startd RANKs new job lower?
+		int rejForGroupQuota;   //   - not enough group quota?
 
 
 		// Class used to store each individual entry in the
@@ -331,7 +344,7 @@ class Matchmaker : public Service
 		class MatchListType
 		{
 		public:
-			
+
 			ClassAd* pop_candidate();
 			bool cache_still_valid(ClassAd &request,ExprTree *preemption_req,
 				ExprTree *preemption_rank,bool preemption_req_unstable, bool preemption_rank_unstable);
@@ -340,13 +353,15 @@ class Matchmaker : public Service
 					int & rejForConcurrencyLimit,
 					int & rejPreemptForPrio,
 					int & rejPreemptForPolicy,
-					int & rejPreemptForRank);
+					int & rejPreemptForRank,
+					int & rejForGroupQuota);
 			void set_diagnostics(int rejForNetwork,
 					int rejForNetworkShare,
 					int rejForConcurrencyLimit,
 					int rejPreemptForPrio,
 					int rejPreemptForPolicy,
-					int rejPreemptForRank);
+					int rejPreemptForRank,
+					int rejForGroupQuota);
 			void add_candidate(ClassAd* candidate,
 					double candidateRankValue,
 					double candidatePreJobRankValue,
@@ -358,7 +373,7 @@ class Matchmaker : public Service
 
 			MatchListType(int maxlen);
 			~MatchListType();
-			
+
 		private:
 
 			// AdListEntry* peek_candidate();
@@ -374,7 +389,9 @@ class Matchmaker : public Service
 			int m_rejForConcurrencyLimit;	//   - limited concurrency?
 			int m_rejPreemptForPrio;	//   - insufficient prio to preempt?
 			int m_rejPreemptForPolicy; //   - PREEMPTION_REQUIREMENTS == False?
-			int m_rejPreemptForRank;	//   - startd RANKs new job lower?
+			int m_rejPreemptForRank;    //   - startd RANKs new job lower?
+			int m_rejForGroupQuota;     //   - not enough group quota?
+			
 			
 		};
 		MatchListType* MatchList;
@@ -392,8 +409,9 @@ class Matchmaker : public Service
 			~SimpleGroupEntry();
 			char *groupName;
 			float prio;
-			int maxAllowed;
+			float maxAllowed;
 			int usage;
+			float usageRW;
 			ClassAdList submitterAds;			
 		};
 		static int groupSortCompare(const void*, const void*);
diff --git a/src/condor_startd.V6/ResMgr.cpp b/src/condor_startd.V6/ResMgr.cpp
index dfd9c82..0a09027 100644
--- a/src/condor_startd.V6/ResMgr.cpp
+++ b/src/condor_startd.V6/ResMgr.cpp
@@ -167,6 +167,7 @@ ResMgr::init_config_classad( void )
 #if HAVE_HIBERNATION
 	configInsert( config_classad, "HIBERNATE", false );
 #endif /* HAVE_HIBERNATION */
+	configInsert( config_classad, ATTR_RESOURCE_WEIGHT, false );
 
 		// Next, try the IS_OWNER expression.  If it's not there, give
 		// them a resonable default, instead of leaving it undefined. 
@@ -437,7 +438,7 @@ ResMgr::reconfig_resources( void )
 
 #if HAVE_HIBERNATION
 	updateHibernateConfiguration();
-#endif /* HAVE_HIBERNATION */
+#endif /* HAVE_HIBERNATE */
 
 		// Tell each resource to reconfig itself.
 	walk(&Resource::reconfig);
@@ -1484,6 +1485,7 @@ ResMgr::send_update( int cmd, ClassAd* public_ad, ClassAd* private_ad,
 	return daemonCore->sendUpdates(cmd, public_ad, private_ad, nonblock);
 }
 
+
 void
 ResMgr::update_all( void )
 {
@@ -1598,24 +1600,24 @@ ResMgr::compute( amask_t how_much )
 	}
 
 		// Now that everything has actually been computed, we can
-		// refresh our interval classad with all the current values of
+		// refresh our internal classad with all the current values of
 		// everything so that when we evaluate our state or any other
 		// expressions, we've got accurate data to evaluate.
 	walk( &Resource::refresh_classad, how_much );
 
-		// Now that we have an updated interval classad for each
+		// Now that we have an updated internal classad for each
 		// resource, we can "compute" anything where we need to 
 		// evaluate classad expressions to get the answer.
 	walk( &Resource::compute, A_EVALUATED );
 
-		// Next, we can publish any results from that to our interval
+		// Next, we can publish any results from that to our internal
 		// classads to make sure those are still up-to-date
 	walk( &Resource::refresh_classad, A_EVALUATED );
 
-		// Finally, now that all the interval classads are up to date
+		// Finally, now that all the internal classads are up to date
 		// with all the attributes they could possibly have, we can
 		// publish the cross-slot attributes desired from
-		// STARTD_SLOT_ATTRS into each slots's interval ClassAd.
+		// STARTD_SLOT_ATTRS into each slots's internal ClassAd.
 	walk( &Resource::refresh_classad, A_SHARED_SLOT );
 
 		// Now that we're done, we can display all the values.
@@ -1826,7 +1828,7 @@ ResMgr::reset_timers( void )
 				 update_offset );
 	}
 	if( poll_tid != -1 ) {
-		daemonCore->Reset_Timer( poll_tid, polling_interval,
+		daemonCore->Reset_Timer( poll_tid, polling_interval, 
 								 polling_interval );
 	}
 	if( up_tid != -1 ) {
@@ -1836,7 +1838,7 @@ ResMgr::reset_timers( void )
 
 #if HAVE_HIBERNATION
 	resetHibernateTimer();
-#endif /* HAVE_HIBERNATION */
+#endif /* HAVE_HIBERNATE */
 
 }
 
@@ -2037,7 +2039,6 @@ ResMgr::allHibernating( MyString &target ) const
 		dprintf( D_FULLDEBUG, "allHibernating: doesn't want hibernate\n" );
 		return 0;
 	}
-
 		// The following may evaluate to true even if there
 		// is a claim on one or more of the resources, so we
 		// don't bother checking for claims first. 
diff --git a/src/condor_startd.V6/Resource.cpp b/src/condor_startd.V6/Resource.cpp
index a47edb2..aa28710 100644
--- a/src/condor_startd.V6/Resource.cpp
+++ b/src/condor_startd.V6/Resource.cpp
@@ -1636,6 +1636,8 @@ Resource::publish( ClassAd* cap, amask_t mask )
 					"should be added by ResMgr!", ATTR_CPU_BUSY );
 		}
 
+		caInsert(cap, r_classad, ATTR_RESOURCE_WEIGHT);
+
 			// Include everything from STARTD_EXPRS.
 			// And then include everything from SLOTx_STARTD_EXPRS
 		daemonCore->publish(cap);
