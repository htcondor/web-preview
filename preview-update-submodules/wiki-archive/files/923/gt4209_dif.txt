diff --git a/doc/user-man/dagman.tex b/doc/user-man/dagman.tex
index b3b6f12..0e9751f 100644
--- a/doc/user-man/dagman.tex
+++ b/doc/user-man/dagman.tex
@@ -2348,7 +2348,9 @@ the FINAL node will be run.
 
 One of the most important considerations with a FINAL node is that the
 success or failure of the FINAL node overrides all previous status
-in determining the success or failure of the DAG.
+in determining the success or failure of the DAG
+(this includes status specified by any ABORT-DAG-ON specification
+that has taken effect).
 For example, if some nodes of a DAG fail,
 but the FINAL node succeeds, the DAG will be considered successful.
 Therefore, it is important
@@ -2787,6 +2789,9 @@ The node status file can be updated at most once
 per \Macro{DAGMAN\_USER\_LOG\_SCAN\_INTERVAL},
 as defined at section~\ref{param:DAGManUserLogScanInterval},
 no matter how small the \Arg{minimumUpdateTime} value.
+Also, the node status file will be updated when the DAG finishes
+(whether successfully or not), even if \Arg{minimumUpdateTime} seconds
+have not elapsed since the last update.
 
 As an example, if the DAG input file contains the line
 \begin{verbatim}
@@ -2809,7 +2814,7 @@ Here is an example of a node status file:
   JOB A STATUS_DONE      ()
   JOB B STATUS_SUBMITTED (not_idle)
   JOB C STATUS_SUBMITTED (idle)
-  JOB D STATUS_UNREADY   ()
+  JOB D STATUS_NOT_READY ()
 
   Nodes total: 4
   Nodes done: 1
@@ -2828,7 +2833,8 @@ Here is an example of a node status file:
 Possible node status values are:
 
 \begin{itemize}
-\item \verb@STATUS_UNREADY@ At least one parent has not yet finished.
+\item \verb@STATUS_NOT_READY@ At least one parent has not yet finished
+(or the node is a final node).
 \item \verb@STATUS_READY@ All parents have finished, but not yet running.
 \item \verb@STATUS_PRERUN@ The PRE script is running.
 \item \verb@STATUS_SUBMITTED@ The node's HTCondor or Stork job(s) are in 
diff --git a/doc/version-history/8-0.history.tex b/doc/version-history/8-0.history.tex
index e5de3cf..97cfc79 100644
--- a/doc/version-history/8-0.history.tex
+++ b/doc/version-history/8-0.history.tex
@@ -45,6 +45,17 @@ The details of each version are described below.
 as the manual and useage indicates instead of just \Opt{-stream}.
 \Ticket{4205}
 
+\item Fixed a bug in which \Condor{dagman} did not correctly update
+the node status file at the end of the run for DAGs containing
+final nodes.
+\Ticket{4209}
+
+\item Fixed a bug in which \Condor{dagman} sometimes printed incorrect
+node status counts to the node status file.  Note that this fix also
+included changing the "STATUS\_UNREADY" strings in the node status
+file to "STATUS\_NOT\_READY" to be more consistent.
+\Ticket{4248}
+
 \end{itemize}
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
diff --git a/src/condor_dagman/dag.cpp b/src/condor_dagman/dag.cpp
index 28a9818..d55c732 100644
--- a/src/condor_dagman/dag.cpp
+++ b/src/condor_dagman/dag.cpp
@@ -17,7 +17,6 @@
  *
  ***************************************************************/
 
-
 //
 // Terminology note:
 // We are calling a *node* the combination of pre-script, job, and
@@ -186,7 +185,7 @@ Dag::Dag( /* const */ StringList &dagFiles,
 	_recovery = false;
 	_abortOnScarySubmit = true;
 	_configFile = NULL;
-	_runningFinalNode = false;
+	_finalNodeRun = false;
 		
 		// Don't print any waiting node reports until we're done with
 		// recovery mode.
@@ -195,6 +194,7 @@ Dag::Dag( /* const */ StringList &dagFiles,
 	_lastEventTime = 0;
 
 	_dagIsHalted = false;
+	_dagIsAborted = false;
 	_dagFiles.rewind();
 	_haltFile = HaltFileName( _dagFiles.next() );
 	_dagStatus = DAG_STATUS_OK;
@@ -807,6 +807,8 @@ Dag::ProcessTerminatedEvent(const ULogEvent *event, Job *job,
 							termEvent->subproc );
 		}
 
+		ProcessJobProcEnd( job, recovery, failed );
+
 		if( job->_scriptPost == NULL ) {
 			bool abort = CheckForDagAbort(job, "job");
 			// if dag abort happened, we never return here!
@@ -815,8 +817,6 @@ Dag::ProcessTerminatedEvent(const ULogEvent *event, Job *job,
 			}
 		}
 
-		ProcessJobProcEnd( job, recovery, failed );
-
 		PrintReadyQ( DEBUG_DEBUG_2 );
 
 		return;
@@ -867,6 +867,8 @@ Dag::RemoveBatchJob(Job *node) {
 }
 
 //---------------------------------------------------------------------------
+// Note:  if job is the final node of the DAG, should we set _dagStatus
+// in here according to whether job succeeded or failed?  wenger 2014-03-18
 void
 Dag::ProcessJobProcEnd(Job *job, bool recovery, bool failed) {
 
@@ -1432,6 +1434,9 @@ Dag::StartFinalNode()
 			// Clear out the ready queue so "regular" jobs don't run
 			// when we run the final node (this is really just needed
 			// for the DAG abort and DAG halt cases).
+			// Note:  maybe we should change nodes in the prerun state
+			// to not ready here, to be more consistent.  But I'm not
+			// dealing with that for now.  wenger 2014-03-17
 		Job* job;
 		_readyQ->Rewind();
 		while ( _readyQ->Next( job ) ) {
@@ -1440,13 +1445,14 @@ Dag::StartFinalNode()
 							"Removing node %s from ready queue\n",
 							job->GetJobName() );
 				_readyQ->DeleteCurrent();
+				job->SetStatus( Job::STATUS_NOT_READY );
 			}
 		}
 
 			// Now start up the final node.
 		_final_job->SetStatus( Job::STATUS_READY );
 		if ( StartNode( _final_job, false ) ) {
-			_runningFinalNode = true;
+			_finalNodeRun = true;
 			return true;
 		}
 	}
@@ -1482,7 +1488,7 @@ Dag::SubmitReadyJobs(const Dagman &dm)
 		debug_printf( DEBUG_QUIET,
 					"DAG is halted because halt file %s exists\n",
 					_haltFile.Value() );
-		if ( _runningFinalNode ) {
+		if ( _finalNodeRun ) {
 			debug_printf( DEBUG_QUIET,
 						"Continuing to allow final node to run\n" );
 		} else {
@@ -1925,10 +1931,18 @@ Dag::PrintReadyQ( debug_level_t level ) const {
 bool
 Dag::FinishedRunning( bool includeFinalNode ) const
 {
-	if ( includeFinalNode && _final_job && !_runningFinalNode ) {
+	if ( includeFinalNode && _final_job && !_finalNodeRun ) {
 			// Make sure we don't incorrectly return true if we get called
-			// just before a final node is started...
+			// just before a final node is started...  (There is a race
+			// condition here otherwise, because all of the "regular"
+			// nodes can be done, and the final node not changed to
+			// ready yet.)
 		return false;
+	} else if ( IsHalted() ) {
+			// Note that we're checking for scripts actually running here,
+			// not the number of nodes in the PRERUN or POSTRUN state --
+			// if we're halted, we don't start any new PRE scripts.
+		return NumJobsSubmitted() == 0 && NumScriptsRunning() == 0;
 	}
 
 	return NumJobsSubmitted() == 0 && NumNodesReady() == 0 &&
@@ -1939,12 +1953,20 @@ Dag::FinishedRunning( bool includeFinalNode ) const
 bool
 Dag::DoneSuccess( bool includeFinalNode ) const
 {
-	if ( NumNodesDone( includeFinalNode ) == NumNodes( includeFinalNode ) ) {
+	if ( !FinishedRunning( includeFinalNode ) ) {
+			// Note: if final node is running we should get to here...
+		return false;
+	} else if ( NumNodesDone( includeFinalNode ) ==
+				NumNodes( includeFinalNode ) ) {
+			// This is the normal case.
 		return true;
 	} else if ( includeFinalNode && _final_job &&
 				_final_job->GetStatus() == Job::STATUS_DONE ) {
 			// Final node can override the overall DAG status.
 		return true;
+	} else if ( _dagIsAborted && _dagStatus == DAG_STATUS_OK ) {
+			// Abort-dag-on can override the overall DAG status.
+		return true;
 	}
 
 	return false;
@@ -1961,12 +1983,27 @@ Dag::DoneFailed( bool includeFinalNode ) const
 				_final_job->GetStatus() == Job::STATUS_DONE ) {
 			// Success of final node overrides failure of any other node.
 		return false;
+	} else if ( _dagIsAborted && _dagStatus == DAG_STATUS_OK ) {
+			// Abort-dag-on can override the overall DAG status.
+		return false;
+	} else if ( IsHalted() ) {
+		return true;
 	}
 
 	return NumNodesFailed() > 0;
 }
 
 //---------------------------------------------------------------------------
+bool
+Dag::DoneCycle( bool includeFinalNode) const
+{
+	return FinishedRunning( includeFinalNode ) &&
+				!DoneSuccess( includeFinalNode ) &&
+				NumNodesFailed() == 0 &&
+				!IsHalted() && !_dagIsAborted;
+}
+
+//---------------------------------------------------------------------------
 int
 Dag::NumNodes( bool includeFinal ) const
 {
@@ -2400,10 +2437,6 @@ Dag::TerminateJob( Job* job, bool recovery, bool bootstrap )
 	ASSERT( !(recovery && bootstrap) );
     ASSERT( job != NULL );
 
-	if ( job == _final_job ) {
-		_runningFinalNode = false;
-	}
-
 	job->TerminateSuccess(); // marks job as STATUS_DONE
 	if ( job->GetStatus() != Job::STATUS_DONE ) {
 		EXCEPT( "Node %s is not in DONE state", job->GetJobName() );
@@ -2614,6 +2647,7 @@ Dag::CheckForDagAbort(Job *job, const char *type)
 				job->retval == job->abort_dag_val ) {
 		debug_printf( DEBUG_QUIET, "Aborting DAG because we got "
 				"the ABORT exit value from a %s\n", type);
+		_dagIsAborted = true;
 		if ( job->have_abort_dag_return_val ) {
 			main_shutdown_rescue( job->abort_dag_return_val,
 						job->abort_dag_return_val != 0 ? DAG_STATUS_ABORT :
@@ -2868,9 +2902,12 @@ Dag::DumpNodeStatus( bool held, bool removed )
 		const char *statusStr = Job::status_t_names[node->GetStatus()];
 		const char *nodeNote = "";
 		if ( node->GetStatus() == Job::STATUS_READY ) {
+				// Note:  Job::STATUS_READY only means that the job is
+				// ready to submit if it doesn't have any unfinished
+				// parents.
 			if ( !node->CanSubmit() ) {
 				// See Job::_job_type_names for other strings.
-				statusStr = "STATUS_UNREADY  ";
+				statusStr = Job::status_t_names[Job::STATUS_NOT_READY];
 			}
 		} else if ( node->GetStatus() == Job::STATUS_SUBMITTED ) {
 			nodeNote = node->GetIsIdle() ? "idle" : "not_idle";
@@ -2909,7 +2946,11 @@ Dag::DumpNodeStatus( bool held, bool removed )
 		statusNote = "success";
 	} else if ( DoneFailed( true ) ) {
 		dagStatus = Job::STATUS_ERROR;
-		statusNote = "failed";
+		if ( _dagStatus == DAG_STATUS_ABORT ) {
+			statusNote = "aborted";
+		} else {
+			statusNote = "failed";
+		}
 	} else if ( DoneCycle( true ) ) {
 		dagStatus = Job::STATUS_ERROR;
 		statusNote = "cycle";
diff --git a/src/condor_dagman/dag.h b/src/condor_dagman/dag.h
index 501274d..4a86a51 100644
--- a/src/condor_dagman/dag.h
+++ b/src/condor_dagman/dag.h
@@ -399,7 +399,8 @@ class Dag {
 	bool DoneSuccess( bool includeFinalNode ) const;
 
 		/** Determine whether the DAG is finished, but failed (because
-			of a node job failure, etc.).
+			of a node job failure, etc.).  Note that this returns false
+			if there's a cycle in the DAG but no nodes failed.
     		@param whether to consider the final node, if any
 			@return true iff the DAG is finished but failed
 		*/
@@ -410,10 +411,7 @@ class Dag {
     		@param whether to consider the final node, if any
 			@return true iff the DAG is finished but there is a cycle
 		*/
-	inline bool DoneCycle( bool includeFinalNode) {
-				return FinishedRunning( includeFinalNode ) &&
-				!DoneSuccess( includeFinalNode ) &&
-				NumNodesFailed() == 0; }
+	inline bool DoneCycle( bool includeFinalNode) const;
 
 		/** Submit all ready jobs, provided they are not waiting on a
 			parent job or being throttled.
@@ -702,7 +700,7 @@ class Dag {
 		existing jobs to finish but not submitting any new ones).
 		@return true iff the DAG is halted.
 	*/
-	bool IsHalted() { return _dagIsHalted; }
+	bool IsHalted() const { return _dagIsHalted; }
 
 	enum dag_status {
 		DAG_STATUS_OK = 0,
@@ -725,7 +723,7 @@ class Dag {
 		running (or has been run).
 		@return true iff the final node is running or has been run
 	*/
-	inline bool RunningFinalNode() { return _runningFinalNode; }
+	inline bool FinalNodeRun() { return _finalNodeRun; }
 
 	/** Determine whether the DAG is in recovery mode.
 		@return true iff the DAG is in recovery mode
@@ -855,7 +853,7 @@ class Dag {
 			@return True iff aborting the DAG (it really should not
 			    return in that case)
 		*/
-	static bool CheckForDagAbort(Job *job, const char *type);
+	bool CheckForDagAbort(Job *job, const char *type);
 
 		// takes a userlog event and returns the corresponding node
 	Job* LogEventNodeLookup( int logsource, const ULogEvent* event,
@@ -923,9 +921,9 @@ class Dag {
 	void WriteNodeToRescue( FILE *fp, Job *node,
 				bool reset_retries_upon_rescue, bool isPartial );
 
-		// True iff the final node is ready to be run, or is running
-		// (including PRE and POST scripts, if any.
-	bool _runningFinalNode;
+		// True iff the final node is ready to be run, is running,
+		// or has been run (including PRE and POST scripts, if any).
+	bool _finalNodeRun;
 
     /// List of Job objects
     List<Job>     _jobs;
@@ -1165,6 +1163,12 @@ class Dag {
 		// Whether the DAG is currently halted.
 	bool _dagIsHalted;
 
+		// Whether the DAG has been aborted.
+		// Note:  we need this in addition to _dagStatus, because if you
+		// have a abort-dag-on return value of 0, _dagStatus will be
+		// DAG_STATUS_OK even on the abort...
+	bool _dagIsAborted;
+
 		// The name of the halt file (we halt the DAG if that file exists).
 	MyString _haltFile;
 	
diff --git a/src/condor_dagman/dagman_main.cpp b/src/condor_dagman/dagman_main.cpp
index 5970e17..4f6eb45 100644
--- a/src/condor_dagman/dagman_main.cpp
+++ b/src/condor_dagman/dagman_main.cpp
@@ -1456,7 +1456,9 @@ void condor_event_timer () {
 		// DAG is run anyhow).
 	if ( dagman.dag->IsHalted() && dagman.dag->NumJobsSubmitted() == 0 &&
 				dagman.dag->PostRunNodeCount() == 0 &&
-				!dagman.dag->RunningFinalNode() ) {
+				!dagman.dag->FinalNodeRun() ) {
+			// Note:  main_shutdown_rescue() will run the final node
+			// if there is one.
 		debug_printf ( DEBUG_QUIET, "Exiting because DAG is halted "
 					"and no jobs or scripts are running\n" );
 		main_shutdown_rescue( EXIT_ERROR, Dag::DAG_STATUS_HALTED );
diff --git a/src/condor_dagman/scriptQ.h b/src/condor_dagman/scriptQ.h
index ae633d8..fd36cf9 100644
--- a/src/condor_dagman/scriptQ.h
+++ b/src/condor_dagman/scriptQ.h
@@ -57,6 +57,9 @@ class ScriptQ : public Service {
 	*/
 	int RunAllWaitingScripts();
 
+	/** Return the number of scripts actually running (does not include
+	    scripts that are queued to run but have been deferred).
+	*/
     int NumScriptsRunning();
 
     // reaper function for PRE & POST script completion
diff --git a/src/condor_tests/CMakeLists.txt b/src/condor_tests/CMakeLists.txt
index ad56ead..55f25a4 100644
--- a/src/condor_tests/CMakeLists.txt
+++ b/src/condor_tests/CMakeLists.txt
@@ -554,6 +554,10 @@ if (BUILD_TESTING)
 	condor_pl_test(job_dagman_classad "Test the DAGMan classad status update capability" "dagman;quick;full;quicknolink")
 	condor_pl_test(job_dagman_repeat_holds "Test the suppression of repeat hold events" "dagman;quick;full;quicknolink")
 	condor_pl_test(job_dagman_submit_parse "Test parsing of submit output" "dagman;quick;full;quicknolink")
+	#condor_pl_test(job_dagman_abort-B "Test DAG abort with failure" "dagman;quick;full;quicknolink")
+	#condor_pl_test(job_dagman_abort-final-A "Test DAG abort with final node" "dagman;quick;full;quicknolink")
+	#condor_pl_test(job_dagman_abort-final-B "Test DAG abort with final node" "dagman;quick;full;quicknolink")
+	#condor_pl_test(job_dagman_cycle-A "Test DAG status file with cycle" "dagman;quick;full;quicknolink")
 	#condor_pl_test(perf_jobs_sue_10_10_30_van "Generated jobs performance test" "performance;long")
 	#condor_pl_test(perf_xfer_deb_10_10_30_van "Generated transfer performance test" "performance;long")
 	condor_pl_test(job_filexfer_sandbox-empty_van "Are job sandboxes with bad permissions cleaned up?" "framework;quick;full;quicknolink")
diff --git a/src/condor_tests/job_dagman_abort-A.dag b/src/condor_tests/job_dagman_abort-A.dag
index 27018b7..7713f6d 100644
--- a/src/condor_tests/job_dagman_abort-A.dag
+++ b/src/condor_tests/job_dagman_abort-A.dag
@@ -1,3 +1,5 @@
+NODE_STATUS_FILE job_dagman_abort-A.status 600
+
 Job A job_dagman_abort-A-node-succeed.cmd
 Vars A nodename = "$(JOB)"
 Job B job_dagman_abort-A-node-succeed.cmd
@@ -9,5 +11,6 @@ Vars D nodename = "$(JOB)"
 
 Abort-dag-on C 5 return 0
 
-PARENT A CHILD B C
-PARENT B C CHILD D
+PARENT A CHILD B
+PARENT B CHILD C
+PARENT C CHILD D
diff --git a/src/condor_tests/job_dagman_abort-A.run b/src/condor_tests/job_dagman_abort-A.run
index 704a312..113e7e3 100755
--- a/src/condor_tests/job_dagman_abort-A.run
+++ b/src/condor_tests/job_dagman_abort-A.run
@@ -18,6 +18,8 @@
 ##
 ##**************************************************************
 
+# Note: we should check the node status file that the DAG now creates.
+
 use CondorTest;
 use CondorUtils;
 
@@ -27,6 +29,20 @@ $testname = "job_dagman_abort-A";
 $dagman_args = "-verbose";
 
 @outfiles = ("job_dagman_abort-A-node.A", "job_dagman_abort-A-node.B");
+$statusfile = "job_dagman_abort-A.status";
+@statuslines = ("JOB A STATUS_DONE",
+	"JOB B STATUS_DONE",
+	"JOB C STATUS_ERROR",
+	"JOB D STATUS_NOT_READY",
+	"Nodes total: 4",
+	"Nodes done: 2",
+	"Nodes pre: 0",
+	"Nodes queued: 0",
+	"Nodes post: 0",
+	"Nodes ready: 0",
+	"Nodes un-ready: 1",
+	"Nodes failed: 1",
+	"DAG status: STATUS_DONE      \\(success\\)");
 
 my $killedchosen = 0;
 
@@ -35,6 +51,12 @@ sub IDLE{1};
 sub HELD{5};
 sub RUNNING{2};
 
+# clean out old output files
+foreach $name (@outfiles) {
+	runcmd("rm -f $name.out $name.err");
+}
+runcmd("rm -f $statusfile");
+
 $abnormal = sub 
 {
 	die "Want to see only submit, execute and successful completion\n";
@@ -91,10 +113,38 @@ $success = sub
 			$diditpass = 0;
 		}
 	}
-	# clean out old output files
-	foreach $name (@outfiles) {
-		runcmd("rm -f $name.out $name.err");
+
+	# Check the node status file.
+	$line = "";
+	$passed = 0;
+	$canopen = open(STATUS,"<$statusfile");
+	if( ! (defined $canopen)) {
+		CondorTest::debug("Can not open statusfile<$statusfile>:$!\n",1);
+		$diditpass = 0;
+	}
+	while(<STATUS>) {
+		chomp();
+		$line = $_;
+		for ( $ind = 0; $ind <= $#statuslines; $ind++ ) {
+			$target = $statuslines[$ind];
+			if( $line =~ /$target/ ) {
+				CondorTest::debug("$name: $line\n",1);
+				# Remove the target we just found from the array.
+				splice(@statuslines, $ind, 1);
+				last;
+			}
+		}
+	}
+	close(STATUS);
+
+	if ($#statuslines >= 0) {
+		CondorTest::debug("failed missing node status lines:\n");
+		foreach $missing (@statuslines) {
+			print "  $missing\n";
+		}
+		$diditpass = 0;
 	}
+
 	if($diditpass == 0) {
 		die "All expected files and correct output failed\n";
 	}
diff --git a/src/condor_tests/job_dagman_abort-B-node-fail.cmd b/src/condor_tests/job_dagman_abort-B-node-fail.cmd
new file mode 100644
index 0000000..2b66f31
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-B-node-fail.cmd
@@ -0,0 +1,9 @@
+executable           	= ./x_dagman_retry-monitor.pl
+arguments		= 5
+universe             	= scheduler
+notification         	= NEVER
+getenv               	= true
+output			= job_dagman_abort-B-node.$(nodename).out
+error			= job_dagman_abort-B-node.err
+queue
+
diff --git a/src/condor_tests/job_dagman_abort-B-node-succeed.cmd b/src/condor_tests/job_dagman_abort-B-node-succeed.cmd
new file mode 100644
index 0000000..80e4282
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-B-node-succeed.cmd
@@ -0,0 +1,9 @@
+executable           	= /bin/echo
+arguments		= job_dagman_abort-B-node.cmd $(nodename) OK
+universe             	= scheduler
+notification         	= NEVER
+getenv               	= true
+output			= job_dagman_abort-B-node.$(nodename).out
+error			= job_dagman_abort-B-node.err
+queue
+
diff --git a/src/condor_tests/job_dagman_abort-B-script.pl b/src/condor_tests/job_dagman_abort-B-script.pl
new file mode 100755
index 0000000..55569b0
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-B-script.pl
@@ -0,0 +1,3 @@
+#! /usr/bin/env perl
+
+exit(5);
diff --git a/src/condor_tests/job_dagman_abort-B.cfg b/src/condor_tests/job_dagman_abort-B.cfg
new file mode 100644
index 0000000..45faec2
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-B.cfg
@@ -0,0 +1 @@
+DAGMAN_MAX_JOBS_SUBMITTED = 1
diff --git a/src/condor_tests/job_dagman_abort-B.dag b/src/condor_tests/job_dagman_abort-B.dag
new file mode 100644
index 0000000..8204ca8
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-B.dag
@@ -0,0 +1,23 @@
+# This is like abort-A, except that this DAG fails on abort instead
+# of succeeding.
+Config job_dagman_abort-B.cfg
+
+NODE_STATUS_FILE job_dagman_abort-B.status 600
+
+Job A job_dagman_abort-B-node-succeed.cmd
+Vars A nodename = "$(JOB)"
+
+Job B job_dagman_abort-B-node-succeed.cmd
+Vars B nodename = "$(JOB)"
+
+Job C job_dagman_abort-B-node-fail.cmd
+Vars C nodename = "$(JOB)"
+Script Post C job_dagman_abort-B-script.pl
+
+Job D job_dagman_abort-B-node-fail.cmd
+Vars D nodename = "$(JOB)"
+
+Abort-dag-on C 5 return 1
+
+PARENT A CHILD B
+PARENT B CHILD C D
diff --git a/src/condor_tests/job_dagman_abort-B.run b/src/condor_tests/job_dagman_abort-B.run
new file mode 100755
index 0000000..bfa4e4f
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-B.run
@@ -0,0 +1,170 @@
+#! /usr/bin/env perl
+##**************************************************************
+##
+## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+## University of Wisconsin-Madison, WI.
+## 
+## Licensed under the Apache License, Version 2.0 (the "License"); you
+## may not use this file except in compliance with the License.  You may
+## obtain a copy of the License at
+## 
+##    http://www.apache.org/licenses/LICENSE-2.0
+## 
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an "AS IS" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+##
+##**************************************************************
+
+use CondorTest;
+use CondorUtils;
+
+$cmd = 'job_dagman_abort-B.dag';
+$testdesc =  'Condor submit dag - basic abort-dag-on test - scheduler U';
+$testname = "job_dagman_abort-B";
+$dagman_args = "-verbose";
+
+@outfiles = ("job_dagman_abort-B-node.A", "job_dagman_abort-B-node.B");
+$statusfile = "job_dagman_abort-B.status";
+@statuslines = ("JOB A STATUS_DONE",
+	"JOB B STATUS_DONE",
+	"JOB C STATUS_ERROR",
+	"JOB D STATUS_ERROR     \\(removed\\)",
+	"Nodes total: 4",
+	"Nodes done: 2",
+	"Nodes pre: 0",
+	"Nodes queued: 0",
+	"Nodes post: 0",
+	"Nodes ready: 0",
+	"Nodes un-ready: 0",
+	"Nodes failed: 2",
+	"DAG status: STATUS_ERROR     \\(aborted\\)");
+
+my $killedchosen = 0;
+
+# truly const variables in perl
+sub IDLE{1};
+sub HELD{5};
+sub RUNNING{2};
+
+# clean out old output files
+foreach $name (@outfiles) {
+	runcmd("rm -f $name.out $name.err");
+}
+runcmd("rm -f $statusfile");
+
+$abnormal = sub 
+{
+	die "Want to see only submit, execute and successful completion\n";
+};
+
+$aborted = sub 
+{
+	die "Abort event NOT expected\n";
+};
+
+$held = sub 
+{
+	die "Held event NOT expected\n";
+};
+
+$executed = sub
+{
+	my %info = @_;
+
+	CondorTest::debug("Good. We need the dag to run<$info{cluster}>\n",1);
+};
+
+$submitted = sub
+{
+	CondorTest::debug("submitted: This test will see submit, executing and successful completion\n",1);
+};
+
+$success = sub
+{
+	die("DAG is expected to fail.\n");
+};
+
+$failure = sub
+{
+	CondorTest::debug("executed successfully\n",1);
+	CondorTest::debug("Verifying output\n",1);
+	$diditpass = 1;
+	foreach $name (@outfiles) {
+		$line = "";
+		$passed = 0;
+		$canopen = open(OUT,"<$name.out");
+		if( ! (defined $canopen)) {
+			CondorTest::debug("Can not open outfile<$name.out>:$!\n",1);
+			$diditpass = 0;
+		}
+		while(<OUT>) {
+			chomp();
+			$line = $_;
+			if( $line =~ /^.*OK$/ ) {
+				$passed = 1;
+				CondorTest::debug("$name.out: $line\n",1);
+			}
+		}
+		close(OUT);
+		if($passed == 1 ) {
+			;
+		} else {
+			CondorTest::debug("failed $name.out: $line\n",1);
+			$diditpass = 0;
+		}
+	}
+
+	# Check the node status file.
+	$line = "";
+	$passed = 0;
+	$canopen = open(STATUS,"<$statusfile");
+	if( ! (defined $canopen)) {
+		CondorTest::debug("Can not open statusfile<$statusfile>:$!\n",1);
+		$diditpass = 0;
+	}
+	while(<STATUS>) {
+		chomp();
+		$line = $_;
+		for ( $ind = 0; $ind <= $#statuslines; $ind++ ) {
+			$target = $statuslines[$ind];
+			if( $line =~ /$target/ ) {
+				CondorTest::debug("$name: $line\n",1);
+				# Remove the target we just found from the array.
+				splice(@statuslines, $ind, 1);
+				last;
+			}
+		}
+	}
+	close(STATUS);
+
+	if ($#statuslines >= 0) {
+		CondorTest::debug("failed missing node status lines:\n");
+		foreach $missing (@statuslines) {
+			print "  $missing\n";
+		}
+		$diditpass = 0;
+	}
+
+	if($diditpass == 0) {
+		die "All expected files and correct output failed\n";
+	}
+};
+
+CondorTest::RegisterExitedSuccess( $testname, $success);
+CondorTest::RegisterExitedFailure( $testname, $failure);
+CondorTest::RegisterExecute($testname, $executed);
+CondorTest::RegisterExitedAbnormal( $testname, $abnormal );
+CondorTest::RegisterAbort( $testname, $aborted );
+CondorTest::RegisterHold( $testname, $held );
+CondorTest::RegisterSubmit( $testname, $submitted );
+
+if( CondorTest::RunDagTest($testname, $cmd, 0, $dagman_args) ) {
+	CondorTest::debug("$testname: SUCCESS\n",1);
+	exit(0);
+} else {
+	die "$testname: CondorTest::RunTest() failed\n";
+}
+
diff --git a/src/condor_tests/job_dagman_abort-final-A-node-fail.cmd b/src/condor_tests/job_dagman_abort-final-A-node-fail.cmd
new file mode 100644
index 0000000..d639e2a
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-final-A-node-fail.cmd
@@ -0,0 +1,9 @@
+executable           	= ./x_dagman_retry-monitor.pl
+arguments		= 5
+universe             	= scheduler
+notification         	= NEVER
+getenv               	= true
+output			= job_dagman_abort-final-A-node.$(nodename).out
+error			= job_dagman_abort-final-A-node.err
+queue
+
diff --git a/src/condor_tests/job_dagman_abort-final-A-node-succeed.cmd b/src/condor_tests/job_dagman_abort-final-A-node-succeed.cmd
new file mode 100644
index 0000000..8f83971
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-final-A-node-succeed.cmd
@@ -0,0 +1,9 @@
+executable           	= /bin/echo
+arguments		= job_dagman_abort-final-A-node.cmd $(nodename) OK
+universe             	= scheduler
+notification         	= NEVER
+getenv               	= true
+output			= job_dagman_abort-final-A-node.$(nodename).out
+error			= job_dagman_abort-final-A-node.err
+queue
+
diff --git a/src/condor_tests/job_dagman_abort-final-A-nodeE.cmd b/src/condor_tests/job_dagman_abort-final-A-nodeE.cmd
new file mode 100644
index 0000000..855a62d
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-final-A-nodeE.cmd
@@ -0,0 +1,7 @@
+executable = ./job_dagman_abort-final-A-nodeE.pl
+output = job_dagman_abort-final-A-nodeE.out
+error = job_dagman_abort-final-A-nodeE.err
+arguments = "E 1 $(DAG_STATUS) $(FAILED_COUNT)"
+universe = scheduler
+notification = NEVER
+queue
diff --git a/src/condor_tests/job_dagman_abort-final-A-nodeE.pl b/src/condor_tests/job_dagman_abort-final-A-nodeE.pl
new file mode 100755
index 0000000..2de2ca6
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-final-A-nodeE.pl
@@ -0,0 +1,8 @@
+#! /usr/bin/env perl
+
+system("echo '  DAG_STATUS=$ARGV[2]'");
+system("echo '  FAILED_COUNT=$ARGV[3]'");
+
+system("echo '$ARGV[0]'");
+
+exit($ARGV[1]);
diff --git a/src/condor_tests/job_dagman_abort-final-A.dag b/src/condor_tests/job_dagman_abort-final-A.dag
new file mode 100644
index 0000000..7db0f32
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-final-A.dag
@@ -0,0 +1,19 @@
+NODE_STATUS_FILE job_dagman_abort-final-A.status 600
+
+Job A job_dagman_abort-final-A-node-succeed.cmd
+Vars A nodename = "$(JOB)"
+Job B job_dagman_abort-final-A-node-succeed.cmd
+Vars B nodename = "$(JOB)"
+Job C job_dagman_abort-final-A-node-fail.cmd
+Vars C nodename = "$(JOB)"
+Job D job_dagman_abort-final-A-node-fail.cmd
+Vars D nodename = "$(JOB)"
+
+# Final node will invert the overall DAG status (success->failure).
+Final E job_dagman_abort-final-A-nodeE.cmd
+
+Abort-dag-on C 5 return 0
+
+PARENT A CHILD B
+PARENT B CHILD C
+PARENT C CHILD D
diff --git a/src/condor_tests/job_dagman_abort-final-A.run b/src/condor_tests/job_dagman_abort-final-A.run
new file mode 100755
index 0000000..bd3b75e
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-final-A.run
@@ -0,0 +1,207 @@
+#! /usr/bin/env perl
+##**************************************************************
+##
+## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+## University of Wisconsin-Madison, WI.
+## 
+## Licensed under the Apache License, Version 2.0 (the "License"); you
+## may not use this file except in compliance with the License.  You may
+## obtain a copy of the License at
+## 
+##    http://www.apache.org/licenses/LICENSE-2.0
+## 
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an "AS IS" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+##
+##**************************************************************
+
+use CondorTest;
+use CondorUtils;
+
+$cmd = 'job_dagman_abort-final-A.dag';
+$testdesc =  'Condor submit dag - basic abort-final-dag-on test - scheduler U';
+$testname = "job_dagman_abort-final-A";
+$dagman_args = "-verbose";
+
+@outfiles = ("job_dagman_abort-final-A-node.A", "job_dagman_abort-final-A-node.B");
+$statusfile = "job_dagman_abort-final-A.status";
+@statuslines = ("JOB A STATUS_DONE",
+	"JOB B STATUS_DONE",
+	"JOB C STATUS_ERROR",
+	"JOB D STATUS_NOT_READY",
+	"JOB E STATUS_ERROR",
+	"Nodes total: 5",
+	"Nodes done: 2",
+	"Nodes pre: 0",
+	"Nodes queued: 0",
+	"Nodes post: 0",
+	"Nodes ready: 0",
+	"Nodes un-ready: 1",
+	"Nodes failed: 2",
+	"DAG status: STATUS_ERROR     \\(failed\\)");
+$finalfile = "job_dagman_abort-final-A-nodeE.out";
+@finallines = ("DAG_STATUS=0",
+	"FAILED_COUNT=1",
+	"E");
+
+my $killedchosen = 0;
+
+# truly const variables in perl
+sub IDLE{1};
+sub HELD{5};
+sub RUNNING{2};
+
+# clean out old output and status files
+foreach $name (@outfiles) {
+	runcmd("rm -f $name.out $name.err");
+}
+runcmd("rm -f $statusfile");
+runcmd("rm -f $finalfile");
+
+$abnormal = sub 
+{
+	die "Want to see only submit, execute and successful completion\n";
+};
+
+$aborted = sub 
+{
+	die "Abort event NOT expected\n";
+};
+
+$held = sub 
+{
+	die "Held event NOT expected\n";
+};
+
+$executed = sub
+{
+	my %info = @_;
+
+	CondorTest::debug("Good. We need the dag to run<$info{cluster}>\n",1);
+};
+
+$submitted = sub
+{
+	CondorTest::debug("submitted: This test will see submit, executing and successful completion\n",1);
+};
+
+$success = sub
+{
+	die("DAG is expected to fail.\n");
+};
+
+$failure = sub
+{
+	CondorTest::debug("executed successfully\n",1);
+	CondorTest::debug("Verifying output\n",1);
+	$diditpass = 1;
+	foreach $name (@outfiles) {
+		$line = "";
+		$passed = 0;
+		$canopen = open(OUT,"<$name.out");
+		if( ! (defined $canopen)) {
+			CondorTest::debug("Can not open outfile<$name.out>:$!\n",1);
+			$diditpass = 0;
+		}
+		while(<OUT>) {
+			chomp();
+			$line = $_;
+			if( $line =~ /^.*OK$/ ) {
+				$passed = 1;
+				CondorTest::debug("$name.out: $line\n",1);
+			}
+		}
+		close(OUT);
+		if($passed == 1 ) {
+			;
+		} else {
+			CondorTest::debug("failed $name.out: $line\n",1);
+			$diditpass = 0;
+		}
+	}
+
+	# Check the final node output file.
+	$line = "";
+	$passed = 0;
+	$canopen = open(FINAL,"<$finalfile");
+	if( ! (defined $canopen)) {
+		CondorTest::debug("Can not open finalfile<$finalfile>:$!\n",1);
+		$diditpass = 0;
+	}
+	while(<FINAL>) {
+		chomp();
+		$line = $_;
+		for ( $ind = 0; $ind <= $#finallines; $ind++ ) {
+			$target = $finallines[$ind];
+			if( $line =~ /$target/ ) {
+				CondorTest::debug("$name: $line\n",1);
+				# Remove the target we just found from the array.
+				splice(@finallines, $ind, 1);
+				last;
+			}
+		}
+	}
+	close(FINAL);
+
+	if ($#finallines >= 0) {
+		CondorTest::debug("failed missing final node output lines:\n");
+		foreach $missing (@finallines) {
+			print "  $missing\n";
+		}
+		$diditpass = 0;
+	}
+
+	# Check the node status file.
+	$line = "";
+	$passed = 0;
+	$canopen = open(STATUS,"<$statusfile");
+	if( ! (defined $canopen)) {
+		CondorTest::debug("Can not open statusfile<$statusfile>:$!\n",1);
+		$diditpass = 0;
+	}
+	while(<STATUS>) {
+		chomp();
+		$line = $_;
+		for ( $ind = 0; $ind <= $#statuslines; $ind++ ) {
+			$target = $statuslines[$ind];
+			if( $line =~ /$target/ ) {
+				CondorTest::debug("$name: $line\n",1);
+				# Remove the target we just found from the array.
+				splice(@statuslines, $ind, 1);
+				last;
+			}
+		}
+	}
+	close(STATUS);
+
+	if ($#statuslines >= 0) {
+		CondorTest::debug("failed missing node status lines:\n");
+		foreach $missing (@statuslines) {
+			print "  $missing\n";
+		}
+		$diditpass = 0;
+	}
+
+	if($diditpass == 0) {
+		die "All expected files and correct output failed\n";
+	}
+};
+
+CondorTest::RegisterExitedSuccess( $testname, $success);
+CondorTest::RegisterExitedFailure( $testname, $failure);
+CondorTest::RegisterExecute($testname, $executed);
+CondorTest::RegisterExitedAbnormal( $testname, $abnormal );
+CondorTest::RegisterAbort( $testname, $aborted );
+CondorTest::RegisterHold( $testname, $held );
+CondorTest::RegisterSubmit( $testname, $submitted );
+
+if( CondorTest::RunDagTest($testname, $cmd, 0, $dagman_args) ) {
+	CondorTest::debug("$testname: SUCCESS\n",1);
+	exit(0);
+} else {
+	die "$testname: CondorTest::RunTest() failed\n";
+}
+
diff --git a/src/condor_tests/job_dagman_abort-final-B-node-fail.cmd b/src/condor_tests/job_dagman_abort-final-B-node-fail.cmd
new file mode 100644
index 0000000..7a8c01a
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-final-B-node-fail.cmd
@@ -0,0 +1,9 @@
+executable           	= ./x_dagman_retry-monitor.pl
+arguments		= 5
+universe             	= scheduler
+notification         	= NEVER
+getenv               	= true
+output			= job_dagman_abort-final-B-node.$(nodename).out
+error			= job_dagman_abort-final-B-node.err
+queue
+
diff --git a/src/condor_tests/job_dagman_abort-final-B-node-succeed.cmd b/src/condor_tests/job_dagman_abort-final-B-node-succeed.cmd
new file mode 100644
index 0000000..a864829
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-final-B-node-succeed.cmd
@@ -0,0 +1,9 @@
+executable           	= /bin/echo
+arguments		= job_dagman_abort-final-B-node.cmd $(nodename) OK
+universe             	= scheduler
+notification         	= NEVER
+getenv               	= true
+output			= job_dagman_abort-final-B-node.$(nodename).out
+error			= job_dagman_abort-final-B-node.err
+queue
+
diff --git a/src/condor_tests/job_dagman_abort-final-B-nodeE.cmd b/src/condor_tests/job_dagman_abort-final-B-nodeE.cmd
new file mode 100644
index 0000000..ff282ba
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-final-B-nodeE.cmd
@@ -0,0 +1,7 @@
+executable = ./job_dagman_abort-final-B-nodeE.pl
+output = job_dagman_abort-final-B-nodeE.out
+error = job_dagman_abort-final-B-nodeE.err
+arguments = "E 0 $(DAG_STATUS) $(FAILED_COUNT)"
+universe = scheduler
+notification = NEVER
+queue
diff --git a/src/condor_tests/job_dagman_abort-final-B-nodeE.pl b/src/condor_tests/job_dagman_abort-final-B-nodeE.pl
new file mode 100755
index 0000000..2de2ca6
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-final-B-nodeE.pl
@@ -0,0 +1,8 @@
+#! /usr/bin/env perl
+
+system("echo '  DAG_STATUS=$ARGV[2]'");
+system("echo '  FAILED_COUNT=$ARGV[3]'");
+
+system("echo '$ARGV[0]'");
+
+exit($ARGV[1]);
diff --git a/src/condor_tests/job_dagman_abort-final-B-script.pl b/src/condor_tests/job_dagman_abort-final-B-script.pl
new file mode 100755
index 0000000..55569b0
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-final-B-script.pl
@@ -0,0 +1,3 @@
+#! /usr/bin/env perl
+
+exit(5);
diff --git a/src/condor_tests/job_dagman_abort-final-B.dag b/src/condor_tests/job_dagman_abort-final-B.dag
new file mode 100644
index 0000000..76daa52
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-final-B.dag
@@ -0,0 +1,20 @@
+NODE_STATUS_FILE job_dagman_abort-final-B.status 600
+
+Job A job_dagman_abort-final-B-node-succeed.cmd
+Vars A nodename = "$(JOB)"
+Job B job_dagman_abort-final-B-node-succeed.cmd
+Vars B nodename = "$(JOB)"
+Job C job_dagman_abort-final-B-node-fail.cmd
+Vars C nodename = "$(JOB)"
+Script Pre C job_dagman_abort-final-B-script.pl
+Job D job_dagman_abort-final-B-node-fail.cmd
+Vars D nodename = "$(JOB)"
+
+# Final node will invert the overall DAG status (failure->success).
+Final E job_dagman_abort-final-B-nodeE.cmd
+
+Abort-dag-on C 5 return 1
+
+PARENT A CHILD B
+PARENT B CHILD C
+PARENT C CHILD D
diff --git a/src/condor_tests/job_dagman_abort-final-B.run b/src/condor_tests/job_dagman_abort-final-B.run
new file mode 100755
index 0000000..ef04128
--- /dev/null
+++ b/src/condor_tests/job_dagman_abort-final-B.run
@@ -0,0 +1,201 @@
+#! /usr/bin/env perl
+##**************************************************************
+##
+## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+## University of Wisconsin-Madison, WI.
+## 
+## Licensed under the Apache License, Version 2.0 (the "License"); you
+## may not use this file except in compliance with the License.  You may
+## obtain a copy of the License at
+## 
+##    http://www.apache.org/licenses/LICENSE-2.0
+## 
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an "AS IS" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+##
+##**************************************************************
+
+use CondorTest;
+use CondorUtils;
+
+$cmd = 'job_dagman_abort-final-B.dag';
+$testdesc =  'Condor submit dag - basic abort-final-dag-on test - scheduler U';
+$testname = "job_dagman_abort-final-B";
+$dagman_args = "-verbose";
+
+@outfiles = ("job_dagman_abort-final-B-node.A", "job_dagman_abort-final-B-node.B");
+$statusfile = "job_dagman_abort-final-B.status";
+@statuslines = ("JOB A STATUS_DONE",
+	"JOB B STATUS_DONE",
+	"JOB C STATUS_ERROR",
+	"JOB D STATUS_NOT_READY",
+	"JOB E STATUS_DONE",
+	"Nodes total: 5",
+	"Nodes done: 3",
+	"Nodes pre: 0",
+	"Nodes queued: 0",
+	"Nodes post: 0",
+	"Nodes ready: 0",
+	"Nodes un-ready: 1",
+	"Nodes failed: 1",
+	"DAG status: STATUS_DONE      \\(success\\)");
+$finalfile = "job_dagman_abort-final-B-nodeE.out";
+@finallines = ("DAG_STATUS=3",
+	"FAILED_COUNT=1",
+	"E");
+
+my $killedchosen = 0;
+
+# truly const variables in perl
+sub IDLE{1};
+sub HELD{5};
+sub RUNNING{2};
+
+# clean out old output and status files
+foreach $name (@outfiles) {
+	runcmd("rm -f $name.out $name.err");
+}
+runcmd("rm -f $statusfile");
+runcmd("rm -f $finalfile");
+
+$abnormal = sub 
+{
+	die "Want to see only submit, execute and successful completion\n";
+};
+
+$aborted = sub 
+{
+	die "Abort event NOT expected\n";
+};
+
+$held = sub 
+{
+	die "Held event NOT expected\n";
+};
+
+$executed = sub
+{
+	my %info = @_;
+
+	CondorTest::debug("Good. We need the dag to run<$info{cluster}>\n",1);
+};
+
+$submitted = sub
+{
+	CondorTest::debug("submitted: This test will see submit, executing and successful completion\n",1);
+};
+
+$success = sub
+{
+	CondorTest::debug("executed successfully\n",1);
+	CondorTest::debug("Verifying output\n",1);
+	$diditpass = 1;
+	foreach $name (@outfiles) {
+		$line = "";
+		$passed = 0;
+		$canopen = open(OUT,"<$name.out");
+		if( ! (defined $canopen)) {
+			CondorTest::debug("Can not open outfile<$name.out>:$!\n",1);
+			$diditpass = 0;
+		}
+		while(<OUT>) {
+			chomp();
+			$line = $_;
+			if( $line =~ /^.*OK$/ ) {
+				$passed = 1;
+				CondorTest::debug("$name.out: $line\n",1);
+			}
+		}
+		close(OUT);
+		if($passed == 1 ) {
+			;
+		} else {
+			CondorTest::debug("failed $name.out: $line\n",1);
+			$diditpass = 0;
+		}
+	}
+
+	# Check the final node output file.
+	$line = "";
+	$passed = 0;
+	$canopen = open(FINAL,"<$finalfile");
+	if( ! (defined $canopen)) {
+		CondorTest::debug("Can not open finalfile<$finalfile>:$!\n",1);
+		$diditpass = 0;
+	}
+	while(<FINAL>) {
+		chomp();
+		$line = $_;
+		for ( $ind = 0; $ind <= $#finallines; $ind++ ) {
+			$target = $finallines[$ind];
+			if( $line =~ /$target/ ) {
+				CondorTest::debug("$name: $line\n",1);
+				# Remove the target we just found from the array.
+				splice(@finallines, $ind, 1);
+				last;
+			}
+		}
+	}
+	close(FINAL);
+
+	if ($#finallines >= 0) {
+		CondorTest::debug("failed missing final node output lines:\n");
+		foreach $missing (@finallines) {
+			print "  $missing\n";
+		}
+		$diditpass = 0;
+	}
+
+	# Check the node status file.
+	$line = "";
+	$passed = 0;
+	$canopen = open(STATUS,"<$statusfile");
+	if( ! (defined $canopen)) {
+		CondorTest::debug("Can not open statusfile<$statusfile>:$!\n",1);
+		$diditpass = 0;
+	}
+	while(<STATUS>) {
+		chomp();
+		$line = $_;
+		for ( $ind = 0; $ind <= $#statuslines; $ind++ ) {
+			$target = $statuslines[$ind];
+			if( $line =~ /$target/ ) {
+				CondorTest::debug("$name: $line\n",1);
+				# Remove the target we just found from the array.
+				splice(@statuslines, $ind, 1);
+				last;
+			}
+		}
+	}
+	close(STATUS);
+
+	if ($#statuslines >= 0) {
+		CondorTest::debug("failed missing node status lines:\n");
+		foreach $missing (@statuslines) {
+			print "  $missing\n";
+		}
+		$diditpass = 0;
+	}
+
+	if($diditpass == 0) {
+		die "All expected files and correct output failed\n";
+	}
+};
+
+CondorTest::RegisterExitedSuccess( $testname, $success);
+CondorTest::RegisterExecute($testname, $executed);
+CondorTest::RegisterExitedAbnormal( $testname, $abnormal );
+CondorTest::RegisterAbort( $testname, $aborted );
+CondorTest::RegisterHold( $testname, $held );
+CondorTest::RegisterSubmit( $testname, $submitted );
+
+if( CondorTest::RunDagTest($testname, $cmd, 0, $dagman_args) ) {
+	CondorTest::debug("$testname: SUCCESS\n",1);
+	exit(0);
+} else {
+	die "$testname: CondorTest::RunTest() failed\n";
+}
+
diff --git a/src/condor_tests/job_dagman_cycle-A-node.cmd b/src/condor_tests/job_dagman_cycle-A-node.cmd
new file mode 100644
index 0000000..39446f2
--- /dev/null
+++ b/src/condor_tests/job_dagman_cycle-A-node.cmd
@@ -0,0 +1,5 @@
+universe     = scheduler
+executable   = ./x_sleep.pl
+arguments    = 1
+Notification = NEVER
+queue
diff --git a/src/condor_tests/job_dagman_cycle-A.dag b/src/condor_tests/job_dagman_cycle-A.dag
new file mode 100644
index 0000000..22b2775
--- /dev/null
+++ b/src/condor_tests/job_dagman_cycle-A.dag
@@ -0,0 +1,9 @@
+Node_status_file job_dagman_cycle-A.status
+
+Job A job_dagman_cycle-A-node.cmd
+Job B job_dagman_cycle-A-node.cmd
+Job C job_dagman_cycle-A-node.cmd
+
+Parent A Child B
+Parent B Child C
+Parent C Child B
diff --git a/src/condor_tests/job_dagman_cycle-A.run b/src/condor_tests/job_dagman_cycle-A.run
new file mode 100755
index 0000000..bd975ef
--- /dev/null
+++ b/src/condor_tests/job_dagman_cycle-A.run
@@ -0,0 +1,141 @@
+#! /usr/bin/env perl
+##**************************************************************
+##
+## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+## University of Wisconsin-Madison, WI.
+## 
+## Licensed under the Apache License, Version 2.0 (the "License"); you
+## may not use this file except in compliance with the License.  You may
+## obtain a copy of the License at
+## 
+##    http://www.apache.org/licenses/LICENSE-2.0
+## 
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an "AS IS" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+##
+##**************************************************************
+
+use CondorTest;
+use CondorUtils;
+
+$cmd = 'job_dagman_cycle-A.dag';
+$testdesc =  'Condor submit dag - basic cycle test - scheduler U';
+$testname = "job_dagman_cycle-A";
+$dagman_args = "-verbose";
+
+$statusfile = "job_dagman_cycle-A.status";
+@statuslines = ("JOB A STATUS_DONE",
+	"JOB B STATUS_NOT_READY",
+	"JOB C STATUS_NOT_READY",
+	"Nodes total: 3",
+	"Nodes done: 1",
+	"Nodes pre: 0",
+	"Nodes queued: 0",
+	"Nodes post: 0",
+	"Nodes ready: 0",
+	"Nodes un-ready: 2",
+	"Nodes failed: 0",
+	"DAG status: STATUS_ERROR     \\(cycle\\)");
+
+my $killedchosen = 0;
+
+# truly const variables in perl
+sub IDLE{1};
+sub HELD{5};
+sub RUNNING{2};
+
+# clean out old output files
+runcmd("rm -f $statusfile");
+
+$abnormal = sub 
+{
+	die "Want to see only submit, execute and successful completion\n";
+};
+
+$aborted = sub 
+{
+	die "Abort event NOT expected\n";
+};
+
+$held = sub 
+{
+	die "Held event NOT expected\n";
+};
+
+$executed = sub
+{
+	my %info = @_;
+
+	CondorTest::debug("Good. We need the dag to run<$info{cluster}>\n",1);
+};
+
+$submitted = sub
+{
+	CondorTest::debug("submitted: This test will see submit, executing and successful completion\n",1);
+};
+
+$success = sub
+{
+	die("DAG is expected to fail.\n");
+};
+
+$failure = sub
+{
+	CondorTest::debug("executed successfully\n",1);
+	CondorTest::debug("Verifying output\n",1);
+	$diditpass = 1;
+
+	# Check the node status file.
+	$line = "";
+	$passed = 0;
+	$canopen = open(STATUS,"<$statusfile");
+	if( ! (defined $canopen)) {
+		CondorTest::debug("Can not open statusfile<$statusfile>:$!\n",1);
+		$diditpass = 0;
+	}
+	while(<STATUS>) {
+		chomp();
+		$line = $_;
+		for ( $ind = 0; $ind <= $#statuslines; $ind++ ) {
+			$target = $statuslines[$ind];
+			if( $line =~ /$target/ ) {
+				CondorTest::debug("$name: $line\n",1);
+				# Remove the target we just found from the array.
+				splice(@statuslines, $ind, 1);
+				last;
+			}
+		}
+	}
+	close(STATUS);
+
+	if ($#statuslines >= 0) {
+		CondorTest::debug("failed missing node status lines:\n");
+		foreach $missing (@statuslines) {
+			print "  $missing\n";
+		}
+		$diditpass = 0;
+	}
+
+	if($diditpass == 0) {
+		die "All expected files and correct output failed\n";
+	}
+};
+
+CondorTest::RegisterExitedSuccess( $testname, $success);
+CondorTest::RegisterExitedFailure( $testname, $failure);
+CondorTest::RegisterExecute($testname, $executed);
+CondorTest::RegisterExitedAbnormal( $testname, $abnormal );
+CondorTest::RegisterAbort( $testname, $aborted );
+CondorTest::RegisterHold( $testname, $held );
+CondorTest::RegisterSubmit( $testname, $submitted );
+
+if( CondorTest::RunDagTest($testname, $cmd, 0, $dagman_args) ) {
+	CondorTest::debug("$testname: SUCCESS\n",1);
+	exit(0);
+} else {
+	die "$testname: CondorTest::RunTest() failed\n";
+}
+
diff --git a/src/condor_tests/job_dagman_final-A.dag b/src/condor_tests/job_dagman_final-A.dag
index fc97524..94001a3 100644
--- a/src/condor_tests/job_dagman_final-A.dag
+++ b/src/condor_tests/job_dagman_final-A.dag
@@ -1,5 +1,5 @@
 JOBSTATE_LOG job_dagman_final-A.dag.jobstate.log
-NODE_STATUS_FILE job_dagman_final-A.status 300
+NODE_STATUS_FILE job_dagman_final-A.status 600
 
 JOB A_A job_dagman_final-A-nodeA.cmd
 JOB A_B job_dagman_final-A-nodeB.cmd
diff --git a/src/condor_tests/job_dagman_final-A.run b/src/condor_tests/job_dagman_final-A.run
index d7f39d6..b6bed19 100755
--- a/src/condor_tests/job_dagman_final-A.run
+++ b/src/condor_tests/job_dagman_final-A.run
@@ -53,6 +53,12 @@ $scriptfile = "job_dagman_final-A.scripts.out";
 			"  FAILED_COUNT=0",
 			"Node A_C Post");
 
+$statusfile = "job_dagman_final-A.status";
+@status_lines = ("JOB A_A STATUS_DONE",
+	"JOB A_B STATUS_DONE",
+	"JOB A_C STATUS_DONE",
+	"DAG status: STATUS_DONE");
+
 my $killedchosen = 0;
 
 # truly const variables in perl
@@ -67,6 +73,9 @@ if (-e $outfile) {
 if (-e $scriptfile) {
 	runcmd("rm -f $scriptfile");
 }
+if (-e $statusfile) {
+	runcmd("rm -f $statusfile");
+}
 
 $abnormal = sub 
 {
@@ -139,6 +148,37 @@ $success = sub
 		}
 	}
 
+	# Check the node status file (for gittrac #4209).
+	CondorTest::debug("Checking $statusfile\n",1);
+	$line = "";
+	$passed = 0;
+	$canopen = open(OUT,"<$statusfile");
+	if (! (defined $canopen)) {
+		CondorTest::debug("Can not open node status file<$statusfile>:$!\n",1);
+		$diditpass = 0;
+	}
+	while(<OUT>) {
+		chomp();
+		$line = $_;
+		if ($#status_lines >= 0) {
+			$target = $status_lines[0];
+			if( $line =~ /$target/ ) {
+				CondorTest::debug("$name: $line\n",1);
+				# Remove the target we just found from the array.
+				shift @status_lines;
+			}
+		}
+	}
+	close(OUT);
+
+	if ($#status_lines >= 0) {
+		CondorTest::debug("failed missing node status lines:\n");
+		foreach $missing (@status_lines) {
+			print "  $missing\n";
+		}
+		$diditpass = 0;
+	}
+
 	if($diditpass == 0) {
 		die "All expected files and correct output failed\n";
 	}
diff --git a/src/condor_tests/job_dagman_final-B.dag b/src/condor_tests/job_dagman_final-B.dag
index 982eeca..20233cd 100644
--- a/src/condor_tests/job_dagman_final-B.dag
+++ b/src/condor_tests/job_dagman_final-B.dag
@@ -1,4 +1,4 @@
-NODE_STATUS_FILE job_dagman_final-B.status
+NODE_STATUS_FILE job_dagman_final-B.status 600
 
 JOB B_A job_dagman_final-B-nodeA.cmd
 # Node B_B will fail.
diff --git a/src/condor_tests/job_dagman_final-C.dag b/src/condor_tests/job_dagman_final-C.dag
index 2c7339e..89e9d8f 100644
--- a/src/condor_tests/job_dagman_final-C.dag
+++ b/src/condor_tests/job_dagman_final-C.dag
@@ -1,4 +1,4 @@
-NODE_STATUS_FILE job_dagman_final-C.status
+NODE_STATUS_FILE job_dagman_final-C.status 600
 
 # This node fails the first time around, then succeeds.  This is to make
 # sure DAG_STATUS is correct on node retries.
diff --git a/src/condor_tests/job_dagman_final-E.dag b/src/condor_tests/job_dagman_final-E.dag
index aa70220..d83d8a0 100644
--- a/src/condor_tests/job_dagman_final-E.dag
+++ b/src/condor_tests/job_dagman_final-E.dag
@@ -1,5 +1,7 @@
 CONFIG job_dagman_final-E.config
 
+NODE_STATUS_FILE job_dagman_final-E.status 600
+
 # This node now uses the 'always run post' feature.
 JOB E_A job_dagman_final-E-nodeA.cmd
 SCRIPT PRE E_A job_dagman_final-E-script.pl E_A Pre $DAG_STATUS $FAILED_COUNT 1
diff --git a/src/condor_tests/job_dagman_final-F.run b/src/condor_tests/job_dagman_final-F.run
index dc4a37c..fb991c6 100755
--- a/src/condor_tests/job_dagman_final-F.run
+++ b/src/condor_tests/job_dagman_final-F.run
@@ -44,7 +44,7 @@ $rescuefile = "job_dagman_final-F.dag.rescue001";
 			"  FAILED done with F_B2",
 			"Job for node F_C",
 			"  DAG_STATUS=3",
-			"  FAILED_COUNT=0",
+			"  FAILED_COUNT=1",
 			"  OK done with F_C");
 
 # Note: we must find these lines *in the specified order*.
@@ -54,11 +54,11 @@ $rescuefile = "job_dagman_final-F.dag.rescue001";
 			"  RETURN=-1",
 			"Node F_C Pre",
 			"  DAG_STATUS=3",
-			"  FAILED_COUNT=0",
+			"  FAILED_COUNT=1",
 			"  RETURN=-1",
 			"Node F_C Post",
 			"  DAG_STATUS=3",
-			"  FAILED_COUNT=0",
+			"  FAILED_COUNT=1",
 			"  RETURN=0");
 
 my $killedchosen = 0;
diff --git a/src/condor_tests/job_dagman_final-I-nodeB.cmd b/src/condor_tests/job_dagman_final-I-nodeB.cmd
index 53075f5..2d8b789 100644
--- a/src/condor_tests/job_dagman_final-I-nodeB.cmd
+++ b/src/condor_tests/job_dagman_final-I-nodeB.cmd
@@ -1,6 +1,6 @@
 executable = ./job_dagman_final-I-node.pl
-output = job_dagman_final-I-nodeA.out
-error = job_dagman_final-I-nodeA.err
+output = job_dagman_final-I-nodeB.out
+error = job_dagman_final-I-nodeB.err
 arguments = "I_B 0 $(DAG_STATUS) $(FAILED_COUNT)"
 universe = scheduler
 notification = NEVER
diff --git a/src/condor_tests/job_dagman_final-I-nodeC.cmd b/src/condor_tests/job_dagman_final-I-nodeC.cmd
index a925033..ae2227c 100644
--- a/src/condor_tests/job_dagman_final-I-nodeC.cmd
+++ b/src/condor_tests/job_dagman_final-I-nodeC.cmd
@@ -1,6 +1,6 @@
 executable = ./job_dagman_final-I-node.pl
-output = job_dagman_final-I-nodeA.out
-error = job_dagman_final-I-nodeA.err
+output = job_dagman_final-I-nodeC.out
+error = job_dagman_final-I-nodeC.err
 arguments = "I_C 0 $(DAG_STATUS) $(FAILED_COUNT)"
 universe = scheduler
 notification = NEVER
diff --git a/src/condor_tests/job_dagman_final-I-nodeD.cmd b/src/condor_tests/job_dagman_final-I-nodeD.cmd
index 94f92f8..7359c98 100644
--- a/src/condor_tests/job_dagman_final-I-nodeD.cmd
+++ b/src/condor_tests/job_dagman_final-I-nodeD.cmd
@@ -1,6 +1,6 @@
 executable = ./job_dagman_final-I-node.pl
-output = job_dagman_final-I-nodeA.out
-error = job_dagman_final-I-nodeA.err
+output = job_dagman_final-I-nodeD.out
+error = job_dagman_final-I-nodeD.err
 arguments = "I_D 0 $(DAG_STATUS) $(FAILED_COUNT)"
 universe = scheduler
 notification = NEVER
diff --git a/src/condor_tests/job_dagman_final-I.dag b/src/condor_tests/job_dagman_final-I.dag
index b368e9f..fc02757 100644
--- a/src/condor_tests/job_dagman_final-I.dag
+++ b/src/condor_tests/job_dagman_final-I.dag
@@ -1,6 +1,8 @@
 # Test DAG halt in combination with final node -- node B will halt the
 # DAG.
 
+NODE_STATUS_FILE job_dagman_final-I.status 600
+
 JOB I_A job_dagman_final-I-nodeA.cmd
 JOB I_B job_dagman_final-I-nodeB.cmd
 JOB I_C1 job_dagman_final-I-nodeC.cmd
diff --git a/src/condor_tests/job_dagman_final-I.run b/src/condor_tests/job_dagman_final-I.run
index 328a359..9469f5d 100755
--- a/src/condor_tests/job_dagman_final-I.run
+++ b/src/condor_tests/job_dagman_final-I.run
@@ -32,6 +32,7 @@ $outfile = "job_dagman_final-I.nodes.out";
 $scriptfile = "job_dagman_final-I.scripts.out";
 $rescuefile = "job_dagman_final-I.dag.rescue001";
 $haltfile = "job_dagman_final-I.dag.halt";
+$statusfile = "job_dagman_final-I.status";
 
 # Note: we must find these lines *in the specified order*.
 @node_output_lines = ("Job for node I_A",
@@ -58,6 +59,21 @@ $haltfile = "job_dagman_final-I.dag.halt";
 			"  FAILED_COUNT=0",
 			"  RETURN=0");
 
+@statuslines = ("JOB I_A STATUS_DONE",
+	"JOB I_B STATUS_DONE",
+	"JOB I_C1 STATUS_NOT_READY",
+	"JOB I_C2 STATUS_PRERUN",
+	"JOB I_D STATUS_DONE",
+	"Nodes total: 5",
+	"Nodes done: 3",
+	"Nodes pre: 1",
+	"Nodes queued: 0",
+	"Nodes post: 0",
+	"Nodes ready: 0",
+	"Nodes un-ready: 1",
+	"Nodes failed: 0",
+	"DAG status: STATUS_DONE      \\(success\\)");
+
 my $killedchosen = 0;
 
 # truly const variables in perl
@@ -72,6 +88,9 @@ if (-e $outfile) {
 if (-e $scriptfile) {
 	runcmd("rm -f $scriptfile");
 }
+if (-e $statusfile) {
+	runcmd("rm -f $statusfile");
+}
 runcmd("rm -f job_dagman_final-I.dag.rescue*");
 
 # Get rid of halt file if it exists.
@@ -150,6 +169,37 @@ $success = sub
 		}
 	}
 
+	# Check the node status file.
+	$line = "";
+	$passed = 0;
+	$canopen = open(STATUS,"<$statusfile");
+	if( ! (defined $canopen)) {
+		CondorTest::debug("Can not open statusfile<$statusfile>:$!\n",1);
+		$diditpass = 0;
+	}
+	while(<STATUS>) {
+		chomp();
+		$line = $_;
+		for ( $ind = 0; $ind <= $#statuslines; $ind++ ) {
+			$target = $statuslines[$ind];
+			if( $line =~ /$target/ ) {
+				CondorTest::debug("$name: $line\n",1);
+				# Remove the target we just found from the array.
+				splice(@statuslines, $ind, 1);
+				last;
+			}
+		}
+	}
+	close(STATUS);
+
+	if ($#statuslines >= 0) {
+		CondorTest::debug("failed missing node status lines:\n");
+		foreach $missing (@statuslines) {
+			print "  $missing\n";
+		}
+		$diditpass = 0;
+	}
+
 	if (! -e $rescuefile) {
 		CondorTest::debug("Expected rescue DAG $rescuefile does not exist\n");
 		$diditpass = 0;
diff --git a/src/condor_tests/job_dagman_halt-A-node.pl b/src/condor_tests/job_dagman_halt-A-node.pl
index 4dfca27..aadb407 100755
--- a/src/condor_tests/job_dagman_halt-A-node.pl
+++ b/src/condor_tests/job_dagman_halt-A-node.pl
@@ -19,6 +19,7 @@ if ($ARGV[1] eq "-sleep") {
 	sleep(5);
 
 } elsif ($ARGV[1] eq "-halt") {
+	#TEMP -- check for sibling node start?
 	sleep(15); # Allow time for sibling node to start.
 	print OUT "  $ARGV[0] halting DAG\n";
 	system("touch $halt_file");
diff --git a/src/condor_tests/job_dagman_halt-A.dag b/src/condor_tests/job_dagman_halt-A.dag
index a195fe6..5f8807c 100644
--- a/src/condor_tests/job_dagman_halt-A.dag
+++ b/src/condor_tests/job_dagman_halt-A.dag
@@ -1,3 +1,5 @@
+NODE_STATUS_FILE job_dagman_halt-A.status 600
+
 # This waits until the DAG is halted, sleeps, and then un-halts the DAG.
 Job NodeW1 job_dagman_halt-A-node.cmd
 Vars NodeW1 nodename="$(JOB)"
