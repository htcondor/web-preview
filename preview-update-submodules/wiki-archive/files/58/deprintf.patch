diff --git a/src/condor_birdwatcher/SystrayManager.cpp b/src/condor_birdwatcher/SystrayManager.cpp
index e89e77d..e3b029c 100755
--- a/src/condor_birdwatcher/SystrayManager.cpp
+++ b/src/condor_birdwatcher/SystrayManager.cpp
@@ -1,22 +1,22 @@
-/***************************************************************
- *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
- * University of Wisconsin-Madison, WI.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you
- * may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ***************************************************************/
-
+/***************************************************************
+ *
+ * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
 #include <stdafx.h>
 #include "SystrayManager.h"
 #include "resource.h"
diff --git a/src/condor_c++_util/condor_config.cpp b/src/condor_c++_util/condor_config.cpp
index 060a07e..20a2653 100644
--- a/src/condor_c++_util/condor_config.cpp
+++ b/src/condor_c++_util/condor_config.cpp
@@ -1,2292 +1,2292 @@
-/***************************************************************
- *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
- * University of Wisconsin-Madison, WI.
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you
- * may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ***************************************************************/
-
-
-/*
-
-  This file implements config(), the function all daemons call to
-  configure themselves.  It takes an optional argument which
-  determines if config should be quiet or verbose on errors.  It
-  defaults to verbose error reporting.
-
-  There's also an entry point, config_host() where you pass in a
-  string that should be filled in for HOSTNAME.  This is only used by
-  special arguments to condor_config_val used by condor_init to
-  bootstrap the installation process.
-
-  When looking for the global config source, config() checks the
-  "CONDOR_CONFIG" environment variable to find its location.  If that
-  doesn't exist, we look in the following locations:
-
-      1) /etc/condor/
-      2) /usr/local/etc/
-      3) ~condor/
-      4) ${GLOBUS_LOCATION}/etc/
-
-  If none of the above locations contain a config source, config()
-  prints an error message and exits.
-
-  In each "global" config source, a list of "local" config files, or a single
-  cmd whose output is to be piped in as the configuration settings can be
-  specified.  If a cmd is specified, it is processed and its output used
-  as the configuration data.  If a file or list of files is specified, each
-  file given in the list is read and processed in order.  These lists can
-  be used to specify both platform-specific config files and machine-specific
-  config files, in addition to a single, pool-wide, platform-independent
-  config file.
-
-*/
-
-#include "condor_common.h"
-#include "condor_debug.h"
-#include "condor_syscall_mode.h"
-#include "condor_config.h"
-#include "condor_string.h"
-#include "string_list.h"
-#include "condor_attributes.h"
-#include "my_hostname.h"
-#include "condor_version.h"
-#include "util_lib_proto.h"
-#include "my_username.h"
-#ifdef WIN32
-#	include "ntsysinfo.h"		// for WinNT getppid
-#	include <locale.h>
-#endif
-#include "directory.h"			// for StatInfo
-#include "condor_scanner.h"		// for MAXVARNAME, etc
-#include "condor_distribution.h"
-#include "condor_environ.h"
-#include "setenv.h"
-#include "HashTable.h"
-#include "extra_param_info.h"
-#include "condor_uid.h"
-#include "condor_mkstemp.h"
-#include "basename.h"
-#include "condor_random_num.h"
-#include "extArray.h"
-#include "subsystem_info.h"
-
-#if HAVE_EXT_GCB
-#include "GCB.h"
-#endif
-
-extern "C" {
-	
-// Function prototypes
-void real_config(char* host, int wantsQuiet, bool wantExtraInfo);
-int Read_config(const char*, BUCKET**, int, int, bool,
-				ExtraParamTable* = NULL);
-bool is_piped_command(const char* filename);
-bool is_valid_command(const char* cmdToExecute);
-int SetSyscalls(int);
-char* find_global();
-char* find_file(const char*, const char*);
-void init_tilde();
-void fill_attributes();
-void check_domain_attributes();
-void clear_config();
-void reinsert_specials(char*);
-void process_config_source(char*, char*, char*, int);
-void process_locals( char*, char*);
-void process_directory( char*, char*);
-static int  process_dynamic_configs();
-void check_params();
-
-// External variables
-extern int	ConfigLineNo;
-}  /* End extern "C" */
-
-// Global variables
-BUCKET	*ConfigTab[TABLESIZE];
-static ExtraParamTable *extra_info = NULL;
-static char* tilde = NULL;
-extern DLL_IMPORT_MAGIC char **environ;
-static bool have_config_source = true;
-
-MyString global_config_source;
-StringList local_config_sources;
-
-static int ParamValueNameAscendingSort(const void *l, const void *r);
-
-
-// Function implementations
-
-void
-config_fill_ad( ClassAd* ad, const char *prefix )
-{
-	char 		*tmp;
-	char		*expr;
-	StringList	reqdExprs;
-	MyString 	buffer;
-
-	if( !ad ) return;
-
-	if ( ( NULL == prefix ) && get_mySubSystem()->hasLocalName() ) {
-		prefix = get_mySubSystem()->getLocalName();
-	}
-
-	buffer.sprintf( "%s_EXPRS", get_mySubSystem()->getName() );
-	tmp = param( buffer.Value() );
-	if( tmp ) {
-		reqdExprs.initializeFromString (tmp);	
-		free (tmp);
-	}
-
-	buffer.sprintf( "%s_ATTRS", get_mySubSystem()->getName() );
-	tmp = param( buffer.Value() );
-	if( tmp ) {
-		reqdExprs.initializeFromString (tmp);	
-		free (tmp);
-	}
-
-	if(prefix) {
-		buffer.sprintf( "%s_%s_EXPRS", prefix, get_mySubSystem()->getName() );
-		tmp = param( buffer.Value() );
-		if( tmp ) {
-			reqdExprs.initializeFromString (tmp);	
-			free (tmp);
-		}
-
-		buffer.sprintf( "%s_%s_ATTRS", prefix, get_mySubSystem()->getName() );
-		tmp = param( buffer.Value() );
-		if( tmp ) {
-			reqdExprs.initializeFromString (tmp);	
-			free (tmp);
-		}
-
-	}
-
-	if( !reqdExprs.isEmpty() ) {
-		reqdExprs.rewind();
-		while ((tmp = reqdExprs.next())) {
-			expr = NULL;
-			if(prefix) {
-				buffer.sprintf("%s_%s", prefix, tmp);	
-				expr = param(buffer.Value());
-			}
-			if(!expr) {
-				expr = param(tmp);
-			}
-			if(expr == NULL) continue;
-			buffer.sprintf( "%s = %s", tmp, expr );
-
-			if( !ad->Insert( buffer.Value() ) ) {
-				dprintf(D_ALWAYS,
-						"CONFIGURATION PROBLEM: Failed to insert ClassAd attribute %s.  The most common reason for this is that you forgot to quote a string value in the list of attributes being added to the %s ad.\n",
-						buffer.Value(), get_mySubSystem()->getName() );
-			}
-
-			free( expr );
-		}	
-	}
-	
-	/* Insert the version into the ClassAd */
-	buffer.sprintf( "%s=\"%s\"", ATTR_VERSION, CondorVersion() );
-	ad->Insert( buffer.Value() );
-
-	buffer.sprintf( "%s=\"%s\"", ATTR_PLATFORM, CondorPlatform() );
-	ad->Insert( buffer.Value() );
-}
-
-
-/*
-Walks all found configuration entries looking for the
-"forbidden string".  If said string is found, EXCEPT.
-
-Output is via a giant EXCEPT string because the dprintf
-system probably isn't working yet.
-*/
-const char * FORBIDDEN_CONFIG_VAL = "YOU_MUST_CHANGE_THIS_INVALID_CONDOR_CONFIGURATION_VALUE";
-static void
-validate_entries( bool ignore_invalid_entry ) {
-	HASHITER it = hash_iter_begin( ConfigTab, TABLESIZE );
-	unsigned int invalid_entries = 0;
-	MyString tmp;
-	MyString output = "The following configuration macros appear to contain default values that must be changed before Condor will run.  These macros are:\n";
-	while( ! hash_iter_done(it) ) {
-		char * val = hash_iter_value(it);
-		if( strstr(val, FORBIDDEN_CONFIG_VAL) ) {
-			char * name = hash_iter_key(it);
-			MyString filename;
-			int line_number;
-			param_get_location(name, filename, line_number);
-			tmp.sprintf("   %s (found on line %d of %s)\n", name, line_number, filename.Value());
-			output += tmp;
-			invalid_entries++;
-		}
-		hash_iter_next(it);
-	}
-	hash_iter_delete(&it);
-	if(invalid_entries > 0) {
-		if(ignore_invalid_entry) {
-			dprintf(D_ALWAYS, "%s", output.Value());
-		} else {
-			EXCEPT(output.Value());
-		}
-	}
-}
-
-// return a list sorted by macro name of all of the macro values found in the
-// locally defined files.
-ExtArray<ParamValue>*
-param_all(void)
-{
-	ExtArray<ParamValue> *pvs = NULL;
-	MyString filename;
-	int line_number;
-	MyString str;
-	HASHITER it = hash_iter_begin( ConfigTab, TABLESIZE );
-	char *name = NULL;
-	char *value = NULL;
-	int i;
-	ParamValue *sort_array = NULL;
-
-	pvs = new ExtArray<ParamValue>;
-	ASSERT(pvs);
-
-	// walk the config table and insert everything I found into the list.
-	i = 0;
-	while( ! hash_iter_done(it) ) {
-		name = hash_iter_key(it);
-		value = hash_iter_value(it);
-		param_get_location(name, filename, line_number);
-
-		(*pvs)[i].name = name;
-		(*pvs)[i].value = value;
-		(*pvs)[i].filename = filename;
-		(*pvs)[i].lnum = line_number;
-		(*pvs)[i].source = "Local Config File";
-
-		i++;
-
-		hash_iter_next(it);
-	}
-	hash_iter_delete(&it);
-
-	// Sort the list based upon name
-	// qsort and extArray don't play nice together...
-
-	// copy the data to a new POD array
-
-	sort_array = new ParamValue[pvs->getlast() + 1];
-	ASSERT(sort_array);
-
-	for (i = 0; i < pvs->getlast() + 1; i++) {
-		sort_array[i] = (*pvs)[i];
-	}
-
-	// sort it
-	qsort(sort_array, pvs->getlast() + 1, sizeof(ParamValue),
-		ParamValueNameAscendingSort);
-
-	// copy it back into the ExtArray
-	for (i = 0; i < pvs->getlast() + 1; i++) {
-		(*pvs)[i] = sort_array[i];
-	}
-	
-	delete [] sort_array;
-
-	return pvs;
-}
-
-static int ParamValueNameAscendingSort(const void *l, const void *r)
-{
-	const ParamValue *left = (const ParamValue*)l;
-	const ParamValue *right = (const ParamValue*)r;
-
-	if (left->name < right->name) {
-		return -1;
-	}
-
-	if (left->name > right->name) {
-		return 1;
-	}
-
-	return 0;
-}
-
-
-void
-config( int wantsQuiet, bool ignore_invalid_entry, bool wantsExtraInfo )
-{
-#ifdef WIN32
+/***************************************************************
+ *
+ * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+
+/*
+
+  This file implements config(), the function all daemons call to
+  configure themselves.  It takes an optional argument which
+  determines if config should be quiet or verbose on errors.  It
+  defaults to verbose error reporting.
+
+  There's also an entry point, config_host() where you pass in a
+  string that should be filled in for HOSTNAME.  This is only used by
+  special arguments to condor_config_val used by condor_init to
+  bootstrap the installation process.
+
+  When looking for the global config source, config() checks the
+  "CONDOR_CONFIG" environment variable to find its location.  If that
+  doesn't exist, we look in the following locations:
+
+      1) /etc/condor/
+      2) /usr/local/etc/
+      3) ~condor/
+      4) ${GLOBUS_LOCATION}/etc/
+
+  If none of the above locations contain a config source, config()
+  prints an error message and exits.
+
+  In each "global" config source, a list of "local" config files, or a single
+  cmd whose output is to be piped in as the configuration settings can be
+  specified.  If a cmd is specified, it is processed and its output used
+  as the configuration data.  If a file or list of files is specified, each
+  file given in the list is read and processed in order.  These lists can
+  be used to specify both platform-specific config files and machine-specific
+  config files, in addition to a single, pool-wide, platform-independent
+  config file.
+
+*/
+
+#include "condor_common.h"
+#include "condor_debug.h"
+#include "condor_syscall_mode.h"
+#include "condor_config.h"
+#include "condor_string.h"
+#include "string_list.h"
+#include "condor_attributes.h"
+#include "my_hostname.h"
+#include "condor_version.h"
+#include "util_lib_proto.h"
+#include "my_username.h"
+#ifdef WIN32
+#	include "ntsysinfo.h"		// for WinNT getppid
+#	include <locale.h>
+#endif
+#include "directory.h"			// for StatInfo
+#include "condor_scanner.h"		// for MAXVARNAME, etc
+#include "condor_distribution.h"
+#include "condor_environ.h"
+#include "setenv.h"
+#include "HashTable.h"
+#include "extra_param_info.h"
+#include "condor_uid.h"
+#include "condor_mkstemp.h"
+#include "basename.h"
+#include "condor_random_num.h"
+#include "extArray.h"
+#include "subsystem_info.h"
+
+#if HAVE_EXT_GCB
+#include "GCB.h"
+#endif
+
+extern "C" {
+	
+// Function prototypes
+void real_config(char* host, int wantsQuiet, bool wantExtraInfo);
+int Read_config(const char*, BUCKET**, int, int, bool,
+				ExtraParamTable* = NULL);
+bool is_piped_command(const char* filename);
+bool is_valid_command(const char* cmdToExecute);
+int SetSyscalls(int);
+char* find_global();
+char* find_file(const char*, const char*);
+void init_tilde();
+void fill_attributes();
+void check_domain_attributes();
+void clear_config();
+void reinsert_specials(char*);
+void process_config_source(char*, char*, char*, int);
+void process_locals( char*, char*);
+void process_directory( char*, char*);
+static int  process_dynamic_configs();
+void check_params();
+
+// External variables
+extern int	ConfigLineNo;
+}  /* End extern "C" */
+
+// Global variables
+BUCKET	*ConfigTab[TABLESIZE];
+static ExtraParamTable *extra_info = NULL;
+static char* tilde = NULL;
+extern DLL_IMPORT_MAGIC char **environ;
+static bool have_config_source = true;
+
+MyString global_config_source;
+StringList local_config_sources;
+
+static int ParamValueNameAscendingSort(const void *l, const void *r);
+
+
+// Function implementations
+
+void
+config_fill_ad( ClassAd* ad, const char *prefix )
+{
+	char 		*tmp;
+	char		*expr;
+	StringList	reqdExprs;
+	MyString 	buffer;
+
+	if( !ad ) return;
+
+	if ( ( NULL == prefix ) && get_mySubSystem()->hasLocalName() ) {
+		prefix = get_mySubSystem()->getLocalName();
+	}
+
+	buffer.sprintf( "%s_EXPRS", get_mySubSystem()->getName() );
+	tmp = param( buffer.Value() );
+	if( tmp ) {
+		reqdExprs.initializeFromString (tmp);	
+		free (tmp);
+	}
+
+	buffer.sprintf( "%s_ATTRS", get_mySubSystem()->getName() );
+	tmp = param( buffer.Value() );
+	if( tmp ) {
+		reqdExprs.initializeFromString (tmp);	
+		free (tmp);
+	}
+
+	if(prefix) {
+		buffer.sprintf( "%s_%s_EXPRS", prefix, get_mySubSystem()->getName() );
+		tmp = param( buffer.Value() );
+		if( tmp ) {
+			reqdExprs.initializeFromString (tmp);	
+			free (tmp);
+		}
+
+		buffer.sprintf( "%s_%s_ATTRS", prefix, get_mySubSystem()->getName() );
+		tmp = param( buffer.Value() );
+		if( tmp ) {
+			reqdExprs.initializeFromString (tmp);	
+			free (tmp);
+		}
+
+	}
+
+	if( !reqdExprs.isEmpty() ) {
+		reqdExprs.rewind();
+		while ((tmp = reqdExprs.next())) {
+			expr = NULL;
+			if(prefix) {
+				buffer.sprintf("%s_%s", prefix, tmp);	
+				expr = param(buffer.Value());
+			}
+			if(!expr) {
+				expr = param(tmp);
+			}
+			if(expr == NULL) continue;
+			buffer.sprintf( "%s = %s", tmp, expr );
+
+			if( !ad->Insert( buffer.Value() ) ) {
+				dprintf(D_ALWAYS,
+						"CONFIGURATION PROBLEM: Failed to insert ClassAd attribute %s.  The most common reason for this is that you forgot to quote a string value in the list of attributes being added to the %s ad.\n",
+						buffer.Value(), get_mySubSystem()->getName() );
+			}
+
+			free( expr );
+		}	
+	}
+	
+	/* Insert the version into the ClassAd */
+	buffer.sprintf( "%s=\"%s\"", ATTR_VERSION, CondorVersion() );
+	ad->Insert( buffer.Value() );
+
+	buffer.sprintf( "%s=\"%s\"", ATTR_PLATFORM, CondorPlatform() );
+	ad->Insert( buffer.Value() );
+}
+
+
+/*
+Walks all found configuration entries looking for the
+"forbidden string".  If said string is found, EXCEPT.
+
+Output is via a giant EXCEPT string because the dprintf
+system probably isn't working yet.
+*/
+const char * FORBIDDEN_CONFIG_VAL = "YOU_MUST_CHANGE_THIS_INVALID_CONDOR_CONFIGURATION_VALUE";
+static void
+validate_entries( bool ignore_invalid_entry ) {
+	HASHITER it = hash_iter_begin( ConfigTab, TABLESIZE );
+	unsigned int invalid_entries = 0;
+	MyString tmp;
+	MyString output = "The following configuration macros appear to contain default values that must be changed before Condor will run.  These macros are:\n";
+	while( ! hash_iter_done(it) ) {
+		char * val = hash_iter_value(it);
+		if( strstr(val, FORBIDDEN_CONFIG_VAL) ) {
+			char * name = hash_iter_key(it);
+			MyString filename;
+			int line_number;
+			param_get_location(name, filename, line_number);
+			tmp.sprintf("   %s (found on line %d of %s)\n", name, line_number, filename.Value());
+			output += tmp;
+			invalid_entries++;
+		}
+		hash_iter_next(it);
+	}
+	hash_iter_delete(&it);
+	if(invalid_entries > 0) {
+		if(ignore_invalid_entry) {
+			dprintf(D_ALWAYS, "%s", output.Value());
+		} else {
+			EXCEPT(output.Value());
+		}
+	}
+}
+
+// return a list sorted by macro name of all of the macro values found in the
+// locally defined files.
+ExtArray<ParamValue>*
+param_all(void)
+{
+	ExtArray<ParamValue> *pvs = NULL;
+	MyString filename;
+	int line_number;
+	MyString str;
+	HASHITER it = hash_iter_begin( ConfigTab, TABLESIZE );
+	char *name = NULL;
+	char *value = NULL;
+	int i;
+	ParamValue *sort_array = NULL;
+
+	pvs = new ExtArray<ParamValue>;
+	ASSERT(pvs);
+
+	// walk the config table and insert everything I found into the list.
+	i = 0;
+	while( ! hash_iter_done(it) ) {
+		name = hash_iter_key(it);
+		value = hash_iter_value(it);
+		param_get_location(name, filename, line_number);
+
+		(*pvs)[i].name = name;
+		(*pvs)[i].value = value;
+		(*pvs)[i].filename = filename;
+		(*pvs)[i].lnum = line_number;
+		(*pvs)[i].source = "Local Config File";
+
+		i++;
+
+		hash_iter_next(it);
+	}
+	hash_iter_delete(&it);
+
+	// Sort the list based upon name
+	// qsort and extArray don't play nice together...
+
+	// copy the data to a new POD array
+
+	sort_array = new ParamValue[pvs->getlast() + 1];
+	ASSERT(sort_array);
+
+	for (i = 0; i < pvs->getlast() + 1; i++) {
+		sort_array[i] = (*pvs)[i];
+	}
+
+	// sort it
+	qsort(sort_array, pvs->getlast() + 1, sizeof(ParamValue),
+		ParamValueNameAscendingSort);
+
+	// copy it back into the ExtArray
+	for (i = 0; i < pvs->getlast() + 1; i++) {
+		(*pvs)[i] = sort_array[i];
+	}
+	
+	delete [] sort_array;
+
+	return pvs;
+}
+
+static int ParamValueNameAscendingSort(const void *l, const void *r)
+{
+	const ParamValue *left = (const ParamValue*)l;
+	const ParamValue *right = (const ParamValue*)r;
+
+	if (left->name < right->name) {
+		return -1;
+	}
+
+	if (left->name > right->name) {
+		return 1;
+	}
+
+	return 0;
+}
+
+
+void
+config( int wantsQuiet, bool ignore_invalid_entry, bool wantsExtraInfo )
+{
+#ifdef WIN32
 	char *locale = setlocale( LC_ALL, "English" );
-	dprintf ( D_ALWAYS, "Locale: %s\n", locale );
-#endif
-	real_config( NULL, wantsQuiet, wantsExtraInfo );
-	validate_entries( ignore_invalid_entry );
-}
-
-
-void
-config_host( char* host )
-{
-	real_config( host, 0, true );
-}
-
-/* This function initialize GSI (maybe other) authentication related
-   stuff Daemons that should use the condor daemon credentials should
-   set the argument is_daemon=true.  This function is automatically
-   called at config init time with is_daemon=false, so that all
-   processes get the basic auth config.  The order of calls to this
-   function do not matter, as the results are only additive.
-   Therefore, calling with is_daemon=false and then with
-   is_daemon=true or vice versa are equivalent.
-*/
-void
-condor_auth_config(int is_daemon)
-{
-#if !defined(SKIP_AUTHENTICATION) && defined(HAVE_EXT_GLOBUS)
-
-		// First, if there is X509_USER_PROXY, we clear it
-		// (if we're a daemon).
-	if ( is_daemon ) {
-		UnsetEnv( "X509_USER_PROXY" );
-	}
-
-		// Next, we param the configuration file for GSI related stuff and
-		// set the corresponding environment variables for it
-
-	char *pbuf = 0;
-	char *proxy_buf = 0;
-	char *cert_buf = 0;
-	char *key_buf = 0;
-	char *trustedca_buf = 0;
-	char *mapfile_buf = 0;
-
-	MyString buffer;
-
-
-		// Here's how it works. If you define any of
-		// GSI_DAEMON_CERT, GSI_DAEMON_KEY, GSI_DAEMON_PROXY, or
-		// GSI_DAEMON_TRUSTED_CA_DIR, those will get stuffed into the
-		// environment.
-		//
-		// Everything else depends on GSI_DAEMON_DIRECTORY. If
-		// GSI_DAEMON_DIRECTORY is not defined, then only settings that are
-		// defined above will be placed in the environment, so if you
-		// want the cert and host in a non-standard location, but want to use
-		// /etc/grid-security/certifcates as the trusted ca dir, only
-		// define GSI_DAEMON_CERT and GSI_DAEMON_KEY, and not
-		// GSI_DAEMON_DIRECTORY and GSI_DAEMON_TRUSTED_CA_DIR
-		//
-		// If GSI_DAEMON_DIRECTORY is defined, condor builds a "reasonable"
-		// default out of what's already been defined and what it can
-		// construct from GSI_DAEMON_DIRECTORY  - ie  the trusted CA dir ends
-		// up as in $(GSI_DAEMON_DIRECTORY)/certificates, and so on
-		// The proxy is not included in the "reasonable defaults" section
-
-		// First, let's get everything we might want
-	pbuf = param( STR_GSI_DAEMON_DIRECTORY );
-	trustedca_buf = param( STR_GSI_DAEMON_TRUSTED_CA_DIR );
-	mapfile_buf = param( STR_GSI_MAPFILE );
-	if( is_daemon ) {
-		proxy_buf = param( STR_GSI_DAEMON_PROXY );
-		cert_buf = param( STR_GSI_DAEMON_CERT );
-		key_buf = param( STR_GSI_DAEMON_KEY );
-	}
-
-	if (pbuf) {
-
-		if( !trustedca_buf) {
-			buffer.sprintf( "%s%ccertificates", pbuf, DIR_DELIM_CHAR);
-			SetEnv( STR_GSI_CERT_DIR, buffer.Value() );
-		}
-
-		if (!mapfile_buf ) {
-			buffer.sprintf( "%s%cgrid-mapfile", pbuf, DIR_DELIM_CHAR);
-			SetEnv( STR_GSI_MAPFILE, buffer.Value() );
-		}
-
-		if( is_daemon ) {
-			if( !cert_buf ) {
-				buffer.sprintf( "%s%chostcert.pem", pbuf, DIR_DELIM_CHAR);
-				SetEnv( STR_GSI_USER_CERT, buffer.Value() );
-			}
-	
-			if (!key_buf ) {
-				buffer.sprintf( "%s%chostkey.pem", pbuf, DIR_DELIM_CHAR);
-				SetEnv( STR_GSI_USER_KEY, buffer.Value() );
-			}
-		}
-
-		free( pbuf );
-	}
-
-	if(trustedca_buf) {
-		SetEnv( STR_GSI_CERT_DIR, trustedca_buf );
-		free(trustedca_buf);
-	}
-
-	if (mapfile_buf) {
-		SetEnv( STR_GSI_MAPFILE, mapfile_buf );
-		free(mapfile_buf);
-	}
-
-	if( is_daemon ) {
-		if(proxy_buf) {
-			SetEnv( STR_GSI_USER_PROXY, proxy_buf );
-			free(proxy_buf);
-		}
-
-		if(cert_buf) {
-			SetEnv( STR_GSI_USER_CERT, cert_buf );
-			free(cert_buf);
-		}
-
-		if(key_buf) {
-			SetEnv( STR_GSI_USER_KEY, key_buf );
-			free(key_buf);
-		}
-	}
-
-#endif
-}
-
-void
-condor_net_remap_config( bool force_param )
-{
-    char *str = NULL;
-	if( ! force_param && getenv("NET_REMAP_ENABLE") ) {
-			/*
-			  this stuff is already set.  unless the caller is forcing
-			  us to call param() again (e.g. the master is trying to
-			  re-bind() if the GCB broker is down and it's got a list
-			  to try) we should return immediately and leave our
-			  environment alone.  this way, the master can choose what
-			  GCB broker to use for itself and all its children, even
-			  if there's a list and we're using $RANDOM_CHOICE().
-			*/
-		return;
-	}
-		
-		/*
-		  this method is only called if we're enabling a network remap
-		  service.  if we do, we always need to force condor to bind()
-		  to all interfaces (INADDR_ANY).  since we don't want to rely
-		  on users to set this themselves to get GCB working, we'll
-		  set it automatically.  the only harm of setting this is that
-		  we need Condor to automatically handle hostallow stuff for
-		  "localhost", or users need to add localhost to their
-		  hostallow settings as appropriate.  we can't rely on the
-		  later, and the former only works on some platforms.
-		  luckily, the automatic localhost stuff works on all
-		  platforms where GCB works (linux, and we hope, solaris), so
-		  it's safe to turn this on whenever we're using GCB
-		*/
-	insert( "BIND_ALL_INTERFACES", "TRUE", ConfigTab, TABLESIZE );
-	extra_info->AddInternalParam("BIND_ALL_INTERFACES");
-
-    // Env: the type of service
-    SetEnv( "NET_REMAP_ENABLE", "true");
-    str = param("NET_REMAP_SERVICE");
-    if (str) {
-        if (!strcasecmp(str, "GCB")) {
-            SetEnv( "GCB_ENABLE", "true" );
-            free(str);
-            str = NULL;
-            // Env: InAgent
-            if( (str = param("NET_REMAP_INAGENT")) ) {
-					// NET_REMAP_INAGENT is a list of GCB brokers.
-				const char *next_broker;
-				StringList all_brokers( str );
-				StringList working_brokers;
-
-					// Pick a random working GCB broker.
-				all_brokers.rewind();
-				while ( (next_broker = all_brokers.next()) ) {
-					int rc = 0;
-					int num_slots = 0;
-
-#if HAVE_EXT_GCB
-					rc = GCB_broker_query( next_broker,
-										   GCB_DATA_QUERY_FREE_SOCKS,
-										   &num_slots );
-#endif
-					if ( rc == 0 ) {
-						working_brokers.append( next_broker );
-					}
-				}
-
-				if ( working_brokers.number() > 0 ) {
-					int rand_entry = (get_random_int() % working_brokers.number()) + 1;
-					int i = 0;
-					working_brokers.rewind();
-					while ( (i < rand_entry) &&
-							(next_broker=working_brokers.next()) ) {
-						i++;
-					}
-
-					dprintf( D_FULLDEBUG,"Using GCB broker %s\n",next_broker );
-					SetEnv( "GCB_INAGENT", next_broker );
-				} else {
-						// TODO How should we indicate that we tried and
-						//   failed to find a working broker? For now, we
-						//   set GCB_INAGENT to a valid, but non-existent
-						//   IP address. That should cause a failure when
-						//   we try to make a socket. The address we use
-						//   is defined in our header file, so callers
-						//   can check GCB_INAGENT to see if we failed to
-						//   find a broker.
-					dprintf( D_ALWAYS,"No usable GCB brokers were found. "
-							 "Setting GCB_INAGENT=%s\n",
-							 CONDOR_GCB_INVALID_BROKER );
-					SetEnv( "GCB_INAGENT", CONDOR_GCB_INVALID_BROKER );
-				}
-				free( str );
-                str = NULL;
-            }
-            // Env: Routing table
-            if( (str = param("NET_REMAP_ROUTE")) ) {
-                SetEnv( "GCB_ROUTE", str );
-				free( str );
-                str = NULL;
-            }
-        } else if (!strcasecmp(str, "DPF")) {
-            SetEnv( "DPF_ENABLE", "true" );
-            free(str);
-            str = NULL;
-            // Env: InAgent
-            if( (str = param("NET_REMAP_INAGENT")) ) {
-                SetEnv( "DPF_INAGENT", str );
-				free(str);
-				str = NULL;
-            }
-            // Env: Routing table
-            if( (str = param("NET_REMAP_ROUTE")) ) {
-                SetEnv( "DPF_ROUTE", str );
-				free(str);
-				str = NULL;
-            }
-        }
-    }
-}
-
-
-void
-real_config(char* host, int wantsQuiet, bool wantExtraInfo)
-{
-	char* config_source = NULL;
-	char* tmp = NULL;
-	int scm;
-
-	static bool first_time = true;
-	if( first_time ) {
-		first_time = false;
-		init_config(wantExtraInfo);
-	} else {
-			// Clear out everything in our config hash table so we can
-			// rebuild it from scratch.
-		clear_config();
-		if (wantExtraInfo) {
-			extra_info = new ExtraParamTable();
-		} else {
-			extra_info = new DummyExtraParamTable();
-		}
-	}
-
-	dprintf( D_CONFIG, "config: using subsystem '%s', local '%s'\n",
-			 get_mySubSystem()->getName(), get_mySubSystem()->getLocalName("") );
-
-		/*
-		  N.B. if we are using the yellow pages, system calls which are
-		  not supported by either remote system calls or file descriptor
- 		  mapping will occur.  Thus we must be in LOCAL/UNRECORDED mode here.
-		*/
-	scm = SetSyscalls( SYS_LOCAL | SYS_UNRECORDED );
-
-		// Try to find user "condor" in the passwd file.
-	init_tilde();
-
-		// Insert an entry for "tilde", (~condor)
-	if( tilde ) {
-		insert( "tilde", tilde, ConfigTab, TABLESIZE );
-		extra_info->AddInternalParam("tilde");
-
-	} else {
-			// What about tilde if there's no ~condor?
-	}
-
-		// Insert some default values for attributes we want even if
-		// they're not defined in the config sources: ARCH and OPSYS.
-		// We also want to insert the special "SUBSYSTEM" macro here.
-		// We do this now since if they are defined in the config
-		// files, these values will get overridden.  However, we want
-		// them defined to begin with so that people can use them in
-		// the global config source to specify the location of
-		// platform-specific config sources, etc.  -Derek Wright 6/8/98
-		// Moved all the domain-specific stuff to a separate function
-		// since we might not know our full hostname yet. -Derek 10/20/98
-	fill_attributes();
-
-		// Try to find the global config source
-
-	char* env = getenv( EnvGetName(ENV_CONFIG) );
-	if( env && stricmp(env, "ONLY_ENV") == MATCH ) {
-			// special case, no config source desired
-		have_config_source = false;
-	}
-
-	if( have_config_source && ! (config_source = find_global()) ) {
-		if( wantsQuiet ) {
-			fprintf( stderr, "%s error: can't find config source.\n",
-					 myDistro->GetCap() );
-			exit( 1 );
-		}
-		fprintf(stderr,"\nNeither the environment variable %s_CONFIG,\n",
-				myDistro->GetUc() );
-#	  if defined UNIX
-		fprintf(stderr,"/etc/%s/, nor ~%s/ contain a %s_config source.\n",
-				myDistro->Get(), myDistro->Get(), myDistro->Get() );
-#	  elif defined WIN32
-		fprintf(stderr,"nor the registry contains a %s_config source.\n", myDistro->Get() );
-#	  else
-#		error "Unknown O/S"
-#	  endif
-		fprintf( stderr,"Either set %s_CONFIG to point to a valid config "
-				"source,\n", myDistro->GetUc() );
-#	  if defined UNIX
-		fprintf( stderr,"or put a \"%s_config\" file in /etc/%s or ~%s/\n",
-				 myDistro->Get(), myDistro->Get(), myDistro->Get() );
-#	  elif defined WIN32
-		fprintf( stderr,"or put a \"%s_config\" source in the registry at:\n"
-				 " HKEY_LOCAL_MACHINE\\Software\\%s\\%s_CONFIG",
-				 myDistro->Get(), myDistro->Get(), myDistro->GetUc() );
-#	  else
-#		error "Unknown O/S"
-#	  endif
-		fprintf( stderr, "Exiting.\n\n" );
-		exit( 1 );
-	}
-
-		// Read in the global file
-	if( have_config_source ) {
-		process_config_source( config_source, "global config source", NULL, true );
-		global_config_source = config_source;
-		free( config_source );
-		config_source = NULL;
-	}
-
-		// Insert entries for "hostname" and "full_hostname".  We do
-		// this here b/c we need these macros defined so that we can
-		// find the local config source if that's defined in terms of
-		// hostname or something.  However, we do this after reading
-		// the global config source so people can put the
-		// DEFAULT_DOMAIN_NAME parameter somewhere if they need it.
-		// -Derek Wright <wright@cs.wisc.edu> 5/11/98
-	if( host ) {
-		insert( "hostname", host, ConfigTab, TABLESIZE );
-		extra_info->AddInternalParam("hostname");
-	} else {
-		insert( "hostname", my_hostname(), ConfigTab, TABLESIZE );
-		extra_info->AddInternalParam("hostname");
-	}
-	insert( "full_hostname", my_full_hostname(), ConfigTab, TABLESIZE );
-	extra_info->AddInternalParam("full_hostname");
-
-		// Also insert tilde since we don't want that over-written.
-	if( tilde ) {
-		insert( "tilde", tilde, ConfigTab, TABLESIZE );
-		extra_info->AddInternalParam("tilde");
-	}
-
-		// Read in the LOCAL_CONFIG_FILE as a string list and process
-		// all the files in the order they are listed.
-	char *dirlist = param("LOCAL_CONFIG_DIR");
-	if(dirlist) {
-		process_directory(dirlist, host);
-	}
-	process_locals( "LOCAL_CONFIG_FILE", host );
-
-	char* newdirlist = param("LOCAL_CONFIG_DIR");
-	if(newdirlist && dirlist) {
-		if(strcmp(dirlist, newdirlist) ) {
-			process_directory(newdirlist, host);
-		}
-	}
-
-	if(dirlist) { free(dirlist); dirlist = NULL; }
-	if(newdirlist) { free(newdirlist); newdirlist = NULL; }
-
-		// Daemons should additionally call condor_auth_config()
-		// explicitly with the argument is_daemon=true.  Here, we just
-		// call with is_daemon=false, since that is fine for both daemons
-		// and non-daemons to do.
-	condor_auth_config( false );
-
-	// The following lines should be placed very carefully. Must be after
-	// global and local config sources being processed but before any
-	// call that may be interposed by GCB
-    if ( param_boolean("NET_REMAP_ENABLE", false) ) {
-        condor_net_remap_config();
-    }
-			
-		// Now, insert any macros defined in the environment.
-	for( int i = 0; environ[i]; i++ ) {
-		char magic_prefix[MAX_DISTRIBUTION_NAME + 3];	// case-insensitive
-		strcpy( magic_prefix, "_" );
-		strcat( magic_prefix, myDistro->Get() );
-		strcat( magic_prefix, "_" );
-		int prefix_len = strlen( magic_prefix );
-
-		// proceed only if we see the magic prefix
-		if( strncasecmp( environ[i], magic_prefix, prefix_len ) != 0 ) {
-			continue;
-		}
-
-		char *varname = strdup( environ[i] );
-		if( !varname ) {
-			EXCEPT( "Out of memory in %s:%d\n", __FILE__, __LINE__ );
-		}
-
-		// isolate variable name by finding & nulling the '='
-		int equals_offset = strchr( varname, '=' ) - varname;
-		varname[equals_offset] = '\0';
-		// isolate value by pointing to everything after the '='
-		char *varvalue = varname + equals_offset + 1;
-//		assert( !strcmp( varvalue, getenv( varname ) ) );
-		// isolate Condor macro_name by skipping magic prefix
-		char *macro_name = varname + prefix_len;
-
-		// special macro START_owner needs to be expanded (for the
-		// glide-in code) [which should probably be fixed to use
-		// the general mechanism and set START itself --pfc]
-		if( !strcmp( macro_name, "START_owner" ) ) {
-			MyString ownerstr;
-			ownerstr.sprintf( "Owner == \"%s\"", varvalue );
-			insert( "START", ownerstr.Value(), ConfigTab, TABLESIZE );
-			extra_info->AddEnvironmentParam("START");
-		}
-		// ignore "_CONDOR_" without any macro name attached
-		else if( macro_name[0] != '\0' ) {
-			insert( macro_name, varvalue, ConfigTab, TABLESIZE );
-			extra_info->AddEnvironmentParam(macro_name);
-		}
-
-		free( varname );
-	}
-
-		// Insert the special macros.  We don't want the user to
-		// override them, since it's not going to work.
-		// We also do this last because some things (like USERNAME)
-		// may depend on earlier configuration (USERID_MAP).
-	reinsert_specials( host );
-
-	process_dynamic_configs();
-
-	if (config_source) {
-		free( config_source );
-	}
-
-		// Now that we're done reading files, if DEFAULT_DOMAIN_NAME
-		// is set, we need to re-initialize my_full_hostname().
-	if( (tmp = param("DEFAULT_DOMAIN_NAME")) ) {
-		free( tmp );
-		init_full_hostname();
-	}
-
-		// Also, we should be safe to process the NETWORK_INTERFACE
-		// parameter at this point, if it's set.
-	init_ipaddr( TRUE );
-
-		// Re-insert the special macros.  We don't want the user to
-		// override them, since it's not going to work.
-	reinsert_specials( host );
-
-		// Make sure our FILESYSTEM_DOMAIN and UID_DOMAIN settings are
-		// correct.
-	check_domain_attributes();
-
-		// We have to do some platform-specific checking to make sure
-		// all the parameters we think are defined really are.
-	check_params();
-
-	condor_except_should_dump_core( param_boolean("ABORT_ON_EXCEPTION", false) );
-
-	(void)SetSyscalls( scm );
-}
-
-
-void
-process_config_source( char* file, char* name, char* host, int required )
-{
-	int rval;
-	if( access( file, R_OK ) != 0 && !is_piped_command(file)) {
-		if( !required) { return; }
-
-		if( !host ) {
-			fprintf( stderr, "ERROR: Can't read %s %s\n",
-					 name, file );
-			exit( 1 );
-		}
-	} else {
-		rval = Read_config( file, ConfigTab, TABLESIZE, EXPAND_LAZY,
-							false, extra_info );
-		if( rval < 0 ) {
-			fprintf( stderr,
-					 "Configuration Error Line %d while reading %s %s\n",
-					 ConfigLineNo, name, file );
-			exit( 1 );
-		}
-	}
-}
-
-
-// Param for given name, read it in as a string list, and process each
-// config source listed there.  If the value is actually a cmd whose
-// output should be piped, then do *not* treat it as a file list.
-void
-process_locals( char* param_name, char* host )
-{
-	StringList sources_to_process, sources_done;
-	char *source, *sources_value;
-	char *tmp;
-	int local_required;
-	
-	local_required = true;	
-    tmp = param( "REQUIRE_LOCAL_CONFIG_FILE" );
-    if( tmp ) {
-		if( tmp[0] == 'f' || tmp[0] == 'F' ) {
-			local_required = false;
-		}
-		free( tmp );
-    }
-
-	sources_value = param( param_name );
-	if( sources_value ) {
-		if ( is_piped_command( sources_value ) ) {
-			sources_to_process.insert( sources_value );
-		} else {
-			sources_to_process.initializeFromString( sources_value );
-		}
-		sources_to_process.rewind();
-		while( (source = sources_to_process.next()) ) {
-			process_config_source( source, "config source", host,
-								   local_required );
-			local_config_sources.append( source );
-
-			sources_done.append(source);
-
-			char* new_sources_value = param(param_name);
-			if(new_sources_value) {
-				if(strcmp(sources_value, new_sources_value) ) {
-				// the file we just processed altered the list of sources to
-				// process
-					sources_to_process.clearAll();
-					if ( is_piped_command( new_sources_value ) ) {
-						sources_to_process.insert( new_sources_value );
-					} else {
-						sources_to_process.initializeFromString(new_sources_value);
-					}
-
-					// remove all the ones we've finished from the old list
-                	sources_done.rewind();
-                	while( (source = sources_done.next()) ) {
-						sources_to_process.remove(source);
-					}
-					sources_to_process.rewind();
-					free(sources_value);
-					sources_value = new_sources_value;
-				} else {
-					free(new_sources_value);
-				}
-			}
-		}
-		free(sources_value);
-	}
-}
-
-int compareFiles(const void *a, const void *b) {
-	 return strcmp(*(char *const*)a, *(char *const*)b);
-}
-
-// examine each file in a directory and treat it as a config file
-void
-process_directory( char* dirlist, char* host )
-{
-	StringList locals;
-	Directory *files;
-	const char *file, *dirpath;
-	char **paths;
-	char *tmp;
-	int local_required;
-	
-	local_required = true;	
-	tmp = param( "REQUIRE_LOCAL_CONFIG_FILE" );
-	if( tmp ) {
-		if( tmp[0] == 'f' || tmp[0] == 'F' ) {
-			local_required = false;
-		}
-		free( tmp );
-	}
-
-	if(!dirlist) { return; }
-	locals.initializeFromString( dirlist );
-	locals.rewind();
-	while( (dirpath = locals.next()) ) {
-
-		paths = (char **)calloc(65536, sizeof(char *));
-		files = new Directory(dirpath);
-		int i = 0;
-		if(files == NULL) {
-			fprintf(stderr, "Cannot open %s\n", dirpath);
-		} else {
-			while( (file = files->Next()) && i < 65536) {
-				// don't consider directories
-				// maybe we should squash symlinks here...
-				if(! files->IsDirectory() ) {
-					paths[i] = strdup(files->GetFullPath());
-					i++;
-				}
-			}
-			delete files;
-		}
-		qsort(paths, i, sizeof(char *), compareFiles);
-		char **pathCopy = paths;
-		while(*pathCopy) {
-			process_config_source( *pathCopy, "config source", host,
-								   local_required );
-
-			local_config_sources.append(*pathCopy);
-
-			free(*pathCopy);
-			pathCopy++;
-		}
-		free(paths);
-	}
-}
-
-// Try to find the "condor" user's home directory
-void
-init_tilde()
-{
-	if( tilde ) {
-		free( tilde );
-		tilde = NULL;
-	}
-# if defined UNIX
-	struct passwd *pw;
-	if( (pw=getpwnam( myDistro->Get() )) ) {
-		tilde = strdup( pw->pw_dir );
-	}
-# else
-	// On Windows, we'll just look in the registry for TILDE.
-	HKEY	handle;
-	char regKey[1024];
-
-	snprintf( regKey, 1024, "Software\\%s", myDistro->GetCap() );
-
-	if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, regKey,
-		0, KEY_READ, &handle) == ERROR_SUCCESS ) {
-
-		// got the reg key open; now we just need to see if
-		// we can open the TILDE string value.
-
-		char the_path[MAX_PATH];
-		DWORD valType;
-		DWORD valSize = MAX_PATH - 2;
-
-		the_path[0] = '\0';
-
-		if ( RegQueryValueEx(handle, "TILDE", 0,
-			&valType, (unsigned char *)the_path, &valSize) == ERROR_SUCCESS ) {
-
-			if ( valType == REG_SZ && the_path[0] ) {
-				// got it!
-				tilde = strdup(the_path);
-			}
-		}
-		RegCloseKey(handle);
-	}
-	
-# endif
-}
-
-
-char*
-get_tilde()
-{
-	init_tilde();
-	return tilde;
-}
-
-
-char*
-find_global()
-{
-	MyString	file;
-	file.sprintf( "%s_config", myDistro->Get() );
-	return find_file( EnvGetName( ENV_CONFIG), file.Value() );
-}
-
-
-// Find location of specified file
-char*
-find_file(const char *env_name, const char *file_name)
-{
-	char* config_source = NULL;
-	char* env = NULL;
-	int fd = 0;
-
-		// If we were given an environment variable name, try that first.
-	if( env_name && (env = getenv( env_name )) ) {
-		config_source = strdup( env );
-		StatInfo si( config_source );
-		switch( si.Error() ) {
-		case SIGood:
-			if( si.IsDirectory() ) {
-				fprintf( stderr, "File specified in %s environment "
-						 "variable:\n\"%s\" is a directory.  "
-						 "Please specify a file.\n", env_name,
-						 config_source );
-				free( config_source );
-				config_source = NULL;
-				exit( 1 );
-			}
-				// Otherwise, we're happy
-			return config_source;
-			break;
-		case SINoFile:
-			// Check to see if it is a pipe command, in which case we're fine.
-			if (!is_piped_command(config_source) ||
-				!is_valid_command(config_source)) {
-
-				fprintf( stderr, "File specified in %s environment "
-						 "variable:\n\"%s\" does not exist.\n",
-						 env_name, config_source );
-				free( config_source );
-				exit( 1 );
-				break;
-			}
-			// Otherwise, we're happy
-			return config_source;
-
-		case SIFailure:
-			fprintf( stderr, "Cannot stat file specified in %s "
-					 "environment variable:\n\"%s\", errno: %d\n",
-					 env_name, config_source, si.Errno() );
-			free( config_source );
-			exit( 1 );
-			break;
-		}
-	}
-
-# ifdef UNIX
-
-	if (!config_source) {
-			// List of condor_config file locations we'll try to open.
-			// As soon as we find one, we'll stop looking.
-		int locations_length = 4;
-		MyString locations[locations_length];
-			// 1) /etc/condor/condor_config
-		locations[0].sprintf( "/etc/%s/%s", myDistro->Get(), file_name );
-			// 2) /usr/local/etc/condor_config (FreeBSD)
-		locations[1].sprintf( "/usr/local/etc/%s", file_name );
-		if (tilde) {
-				// 3) ~condor/condor_config
-			locations[2].sprintf( "%s/%s", tilde, file_name );
-		}
-			// 4) ${GLOBUS_LOCATION}/etc/condor_config
-		char *globus_location;
-		if ((globus_location = getenv("GLOBUS_LOCATION"))) {
-			locations[3].sprintf( "%s/etc/%s", globus_location, file_name );
-		}
-
-		int ctr;	
-		for (ctr = 0 ; ctr < locations_length; ctr++) {
-				// Only use this file if the path isn't empty and
-				// if we can read it properly.
-			if (!locations[ctr].IsEmpty()) {
-				config_source = strdup(locations[ctr].Value());
-				if ((fd = safe_open_wrapper(config_source, O_RDONLY)) < 0) {
-					free(config_source);
-					config_source = NULL;
-				} else {
-					close(fd);
-					dprintf(D_FULLDEBUG, "Reading condor configuration "
-							"from '%s'\n", config_source);
-					break;
-				}
-			}
-		} // FOR
-	} // IF
-
-# elif defined WIN32	// ifdef UNIX
-	// Only look in the registry on WinNT.
-	HKEY	handle;
-	char	regKey[256];
-
-	snprintf( regKey, 256, "Software\\%s", myDistro->GetCap() );
-	if ( !config_source && RegOpenKeyEx(HKEY_LOCAL_MACHINE, regKey,
-		0, KEY_READ, &handle) == ERROR_SUCCESS ) {
-		// We have found a registry key for Condor, which
-		// means this user has a pulse and has actually run the
-		// installation program before trying to run Condor.
-		// This user deserves a tax credit.
-
-		// So now that we found the key, read it.
-		char the_path[MAX_PATH];
-		DWORD valType;
-		DWORD valSize = MAX_PATH - 2;
-
-		the_path[0] = '\0';
-		if ( RegQueryValueEx(handle, env_name, 0,
-			&valType, (unsigned char *)the_path, &valSize) == ERROR_SUCCESS ) {
-
-			// confirm it is a string value with something there
-			if ( valType == REG_SZ && the_path[0] ) {
-				// got it!  whoohooo!
-				config_source = strdup(the_path);
-
-				if ( strncmp(config_source, "\\\\", 2 ) == 0 ) {
-					// UNC Path, so run a 'net use' on it first.
-					NETRESOURCE nr;
-					nr.dwType = RESOURCETYPE_DISK;
-					nr.lpLocalName = NULL;
-					nr.lpRemoteName = condor_dirname(config_source);
-					nr.lpProvider = NULL;
-					
-					if ( NO_ERROR != WNetAddConnection2(
-										&nr,   /* NetResource */
-										NULL,  /* password (default) */
-										NULL,  /* username (default) */
-										0      /* flags (none) */
-						) ) {
-
-						if ( GetLastError() == ERROR_INVALID_PASSWORD ) {
-							// try again with an empty password
-							WNetAddConnection2(
-										&nr,   /* NetResource */
-										"",    /* password (none) */
-										NULL,  /* username (default) */
-										0      /* flags (none) */
-							);
-						}
-
-						// whether it worked or not, we're gonna
-						// continue.  The goal of running the
-						// WNetAddConnection2() is to make a mapping
-						// to the UNC path. For reasons I don't fully
-						// understand, some sites need the mapping,
-						// and some don't. If it works, great; if not,
-						// try the safe_open_wrapper() anyways, and at
-						// worst we'll fail fast and the user can fix
-						// their file server.
-					}
-
-					if (nr.lpRemoteName) {
-						free(nr.lpRemoteName);
-					}
-				}
-
-				if( !(is_piped_command(config_source) &&
-					  is_valid_command(config_source)) &&
-					(fd = safe_open_wrapper( config_source, O_RDONLY)) < 0 ) {
-
-					free( config_source );
-					config_source = NULL;
-				} else {
-					if (fd != 0) {
-						close( fd );
-					}
-				}
-			}
-		}
-
-		RegCloseKey(handle);
-	}
-# else
-#	error "Unknown O/S"
-# endif		/* ifdef UNIX / Win32 */
-
-	return config_source;
-}
-
-
-void
-fill_attributes()
-{
-		/* There are a few attributes that specify what platform we're
-		   on that we want to insert values for even if they're not
-		   defined in the config sources.  These are ARCH and OPSYS,
-		   which we compute with the sysapi_condor_arch() and sysapi_opsys()
-		   functions.  We also insert the subsystem here.  Moved all
-		   the domain stuff to check_domain_attributes() on
-		   10/20.  Also, since this is called before we read in any
-		   config sources, there's no reason to check to see if any of
-		   these are already defined.  -Derek Wright
-		   Amended -Pete Keller 06/01/99 */
-
-	const char *tmp;
-
-	if( (tmp = sysapi_condor_arch()) != NULL ) {
-		insert( "ARCH", tmp, ConfigTab, TABLESIZE );
-		extra_info->AddInternalParam("ARCH");
-	}
-
-	if( (tmp = sysapi_uname_arch()) != NULL ) {
-		insert( "UNAME_ARCH", tmp, ConfigTab, TABLESIZE );
-		extra_info->AddInternalParam("UNAME_ARCH");
-	}
-
-	if( (tmp = sysapi_opsys()) != NULL ) {
-		insert( "OPSYS", tmp, ConfigTab, TABLESIZE );
-		extra_info->AddInternalParam("OPSYS");
-	}
-
-	if( (tmp = sysapi_uname_opsys()) != NULL ) {
-		insert( "UNAME_OPSYS", tmp, ConfigTab, TABLESIZE );
-		extra_info->AddInternalParam("UNAME_OPSYS");
-	}
-
-	insert( "subsystem", get_mySubSystem()->getName(), ConfigTab, TABLESIZE );
-	extra_info->AddInternalParam("subsystem");
-}
-
-
-void
-check_domain_attributes()
-{
-		/* Make sure the FILESYSTEM_DOMAIN and UID_DOMAIN attributes
-		   are set to something reasonable.  If they're not already
-		   defined, we default to our own full hostname.  Moved this
-		   to its own function so we're sure we have our full hostname
-		   by the time we call this. -Derek Wright 10/20/98 */
-
-	char *uid_domain, *filesys_domain;
-
-	filesys_domain = param("FILESYSTEM_DOMAIN");
-	if( !filesys_domain ) {
-		filesys_domain = my_full_hostname();
-		insert( "FILESYSTEM_DOMAIN", filesys_domain, ConfigTab, TABLESIZE );
-		extra_info->AddInternalParam("FILESYSTEM_DOMAIN");
-	} else {
-		free( filesys_domain );
-	}
-
-	uid_domain = param("UID_DOMAIN");
-	if( !uid_domain ) {
-		uid_domain = my_full_hostname();
-		insert( "UID_DOMAIN", uid_domain, ConfigTab, TABLESIZE );
-		extra_info->AddInternalParam("UID_DOMAIN");
-	} else {
-		free( uid_domain );
-	}
-}
-
-void
-init_config(bool wantExtraInfo  /* = true */)
-{
-	memset( (char *)ConfigTab, 0, (TABLESIZE * sizeof(BUCKET*)) );
-	if (wantExtraInfo) {
-		extra_info = new ExtraParamTable();
-	} else {
-		extra_info = new DummyExtraParamTable();
-	}
-
-	return;
-}
-
-void
-clear_config()
-{
-	register 	int 	i;
-	register 	BUCKET	*ptr = NULL;
-	register 	BUCKET	*tmp = NULL;
-
-	for( i=0; i<TABLESIZE; i++ ) {
-		ptr = ConfigTab[i];
-		while( ptr ) {
-			tmp = ptr->next;
-			FREE( ptr->value );
-			ptr->value = NULL;
-			FREE( ptr->name );
-			ptr->name = NULL;
-			FREE( ptr );
-			ptr = tmp;
-		}
-		ConfigTab[i] = NULL;
-	}
-	if (extra_info != NULL) {
-		delete extra_info;
-		extra_info = NULL;
-	}
-	global_config_source       = "";
-	local_config_sources.clearAll();
-	return;
-}
-
-
-/*
-** Return the value associated with the named parameter.  Return NULL
-** if the given parameter is not defined.
-*/
-char *
-param( const char *name )
-{
-	char		*val = NULL;
-	char param_name[MAX_PARAM_LEN];
-
-	// Try in order to find the parameter
-	// As we walk through, any value (including empty string) will
-	// cause a 'match' since presumably it was set to empty
-	// specifically to clear this parameter for this specific
-	// subsystem / local.
-
-	// 1. "subsys.local.name"
-	const char	*local = get_mySubSystem()->getLocalName();
-	if (  (NULL == val) && local ) {
-		snprintf(param_name,MAX_PARAM_LEN,"%s.%s.%s",
-				 get_mySubSystem()->getName(),
-				 local,
-				 name);
-		param_name[MAX_PARAM_LEN-1]='\0';
-		strlwr(param_name);
-		val = lookup_macro_lower( param_name, ConfigTab, TABLESIZE );
-	}
-	// 2. "local.name"
-	if (  (NULL == val) && local ) {
-		snprintf(param_name,MAX_PARAM_LEN,"%s.%s",
-				 local,
-				 name);
-		param_name[MAX_PARAM_LEN-1]='\0';
-		strlwr(param_name);
-		val = lookup_macro_lower( param_name, ConfigTab, TABLESIZE );
-	}
-	// 3. "subsys.name"
-	if ( NULL == val ) {
-		snprintf(param_name,MAX_PARAM_LEN,"%s.%s",
-				 get_mySubSystem()->getName(),
-				 name);
-		param_name[MAX_PARAM_LEN-1]='\0';
-		strlwr(param_name);
-		val = lookup_macro_lower( param_name, ConfigTab, TABLESIZE );
-	}
-	// 4. "name"
-	if ( NULL == val ) {
-		snprintf(param_name,MAX_PARAM_LEN,"%s",name);
-		param_name[MAX_PARAM_LEN-1]='\0';
-		strlwr(param_name);
-		val = lookup_macro_lower( param_name, ConfigTab, TABLESIZE );
-	}
-
-	// Still nothing (or empty)?  Give up.
-	if ( (NULL == val) || (*val=='\0') ) {
-		return NULL;
-	}
-
-	if( DebugFlags & D_CONFIG ) {
-		if( strlen(name) < strlen(param_name) ) {
-			param_name[strlen(param_name)-strlen(name)] = '\0';
-			dprintf( D_CONFIG, "Config '%s': using prefix '%s' ==> '%s'\n",
-					 name, param_name, val );
-		}
-		else {
-			dprintf( D_CONFIG, "Config '%s': no prefix ==> '%s'\n", name, val );
-		}
-	}
-
-	// Ok, now expand it out...
-	val = expand_macro( val, ConfigTab, TABLESIZE );
-
-	// If it returned an empty string, free it before returning NULL
-	if( val == NULL ) {
-		return NULL;
-	} else if ( val[0] == '\0' ) {
-		free( val );
-		return( NULL );
-	} else {
-		return val;
-	}
-}
-
-/*
-** Return the integer value associated with the named paramter.
-** This version returns true if a the parameter was found, or false
-** otherwise.
-** If the value is not defined or not a valid integer, then
-** return the default_value argument .  The min_value and max_value
-** arguments are optional and default to MININT and MAXINT.
-** These range checks are disabled if check_ranges is false.
-*/
-
-bool
-param_integer( const char *name, int &value,
-			   bool use_default, int default_value,
-			   bool check_ranges, int min_value, int max_value )
-{
-	int result;
-	long long_result;
-	char *string;
-	char *endptr = NULL;
-
-	ASSERT( name );
-	string = param( name );
-	if( ! string ) {
-		dprintf( D_CONFIG, "%s is undefined, using default value of %d\n",
-				 name, default_value );
-		if ( use_default ) {
-			value = default_value;
-		}
-		return false;
-	}
-
-	long_result = strtol(string,&endptr,10);
-	result = long_result;
-
-	ASSERT(endptr);
-	if( endptr != string ) {
-		while( isspace(*endptr) ) {
-			endptr++;
-		}
-	}
-	bool valid = (endptr != string && *endptr == '\0');
-
-	if( !valid ) {
-		EXCEPT( "%s in the condor configuration is not an integer (%s)."
-		        "  Please set it to an integer in the range %d to %d"
-		        " (default %d).",
-		        name, string, min_value, max_value, default_value );
-	}
-	else if( (long)result != long_result ) {
-		EXCEPT( "%s in the condor configuration is out of bounds for"
-				" an integer (%s)."
-				"  Please set it to an integer in the range %d to %d"
-				" (default %d).",
-				name, string, min_value, max_value, default_value );
-	}
-	else if ( check_ranges  &&  ( result < min_value )  ) {
-		EXCEPT( "%s in the condor configuration is too low (%s)."
-				"  Please set it to an integer in the range %d to %d"
-				" (default %d).",
-				name, string, min_value, max_value, default_value );
-	}
-	else if ( check_ranges  && ( result > max_value )  ) {
-		EXCEPT( "%s in the condor configuration is too high (%s)."
-				"  Please set it to an integer in the range %d to %d"
-				" (default %d).",
-				name, string, min_value, max_value, default_value );
-	}
-	free( string );
-
-	value = result;
-	return true;
-}
-
-
-/*
-** Return the integer value associated with the named paramter.
-** If the value is not defined or not a valid integer, then
-** return the default_value argument.  The min_value and max_value
-** arguments are optional and default to MININT and MAXINT.
-*/
-
-int
-param_integer( const char *name, int default_value,
-			   int min_value, int max_value )
-{
-	int result;
-
-	param_integer( name, result, true, default_value,
-				   true, min_value, max_value );
-	return result;
-}
-
-int param_integer_c( const char *name, int default_value,
-					   int min_value, int max_value)
-{
-	return param_integer( name, default_value, min_value, max_value );
-}
-
-// require that the attribute I'm looking for is defined in the config file.
-char* param_or_except(const char *attr)
-{
-	char *tmp = NULL;
-
-	tmp = param(attr);
-	if (tmp == NULL || strlen(tmp) <= 0) {
-		EXCEPT("Please define config file entry to non-null value: %s", attr);
-	}
-
-	return tmp;
-}
-
-
-/*
- * Return the [single precision] floating point value associated with the named
- * parameter.  If the value is not defined or not a valid float, then return
- * the default_value argument.  The min_value and max_value arguments are
- * optional and default to DBL_MIN and DBL_MAX.
- */
-
-double
-param_double( const char *name, double default_value,
-			   double min_value, double max_value )
-{
-	double result;
-	char *string;
-	char *endptr = NULL;
-
-	ASSERT( name );
-	string = param( name );
-	if( ! string ) {
-		dprintf( D_CONFIG, "%s is undefined, using default value of %f\n",
-				 name, default_value );
-		return default_value;
-	}
-
-	result = strtod(string,&endptr);
-
-	ASSERT(endptr);
-	if( endptr != string ) {
-		while( isspace(*endptr) ) {
-			endptr++;
-		}
-	}
-	bool valid = (endptr != string && *endptr == '\0');
-
-	if( !valid ) {
-		EXCEPT( "%s in the condor configuration is not a valid floating point number (%s)."
-		        "  Please set it to a number in the range %lg to %lg"
-		        " (default %lg).",
-		        name, string, min_value, max_value, default_value );
-	}
-	else if( result < min_value ) {
-		EXCEPT( "%s in the condor configuration is too low (%s)."
-		        "  Please set it to a number in the range %lg to %lg"
-		        " (default %lg).",
-		        name, string, min_value, max_value, default_value );
-	}
-	else if( result > max_value ) {
-		EXCEPT( "%s in the condor configuration is too high (%s)."
-		        "  Please set it to a number in the range %lg to %lg"
-		        " (default %lg).",
-		        name, string, min_value, max_value, default_value );
-	}
-	free( string );
-	return result;
-}
-
-/*
-** Return the boolean value associated with the named paramter.
-** The parameter value is expected to be set to the string
-** "TRUE" or "FALSE" (no quotes, case insensitive).
-** If the value is not defined or not a valid, then
-** return the default_value argument.
-*/
-
-bool
-param_boolean( const char *name, const bool default_value, bool do_log )
-{
-	bool result;
-	char *string;
-	char *endptr;
-	bool valid = true;
-
-	ASSERT( name );
-	string = param( name );
-	if (!string) {
-		if (do_log) {
-			dprintf( D_CONFIG, "%s is undefined, using default value of %s\n",
-					 name, default_value ? "True" : "False" );
-		}
-		return default_value;
-	}
-
-	endptr = string;
-	if( strncasecmp(endptr,"true",4) == 0 ) {
-		endptr+=4;
-		result = true;
-	}
-	else if( strncasecmp(endptr,"1",1) == 0 ) {
-		endptr+=1;
-		result = true;
-	}
-	else if( strncasecmp(endptr,"false",5) == 0 ) {
-		endptr+=5;
-		result = false;
-	}
-	else if( strncasecmp(endptr,"0",1) == 0 ) {
-		endptr+=1;
-		result = false;
-	}
-	else {
-		valid = false;
-	}
-
-	while( isspace(*endptr) ) {
-		endptr++;
-	}
-	if( *endptr != '\0' ) {
-		valid = false;
-	}
-
-	if( !valid ) {
-		EXCEPT( "%s in the condor configuration  is not a valid boolean (\"%s\")."
-		        "  Please set it to True or False (default is %s)",
-		        name, string, default_value ? "True" : "False" );
-	}
-
-	free( string );
-	
-	return result;
-}
-
-bool
-param_boolean_expr( const char *name, bool default_value, ClassAd const *me, ClassAd const *target )
-{
-	char *expr;
-	bool value = default_value;
-
-	ASSERT( name );
-	expr = param( name );
-	if( ! expr ) {
-		dprintf( D_CONFIG, "%s is undefined, using default value of %s\n",
-				 name, default_value ? "True" : "False" );
-		return default_value;
-	}
-
-	if( *expr ) {
-		ClassAd rhs;
-		if( me ) {
-			rhs = *me;
-		}
-
-		if( !rhs.AssignExpr( name, expr ) ) {
-			EXCEPT("Invalid expression for %s (%s) in config file.",
-			       name, expr);
-		}
-
-		int int_value = value;
-		if( !rhs.EvalBool(name,target,int_value) ) {
-			EXCEPT("Invalid result (not a boolean) for %s (%s) "
-			       "in condor configuration.",
-			       name, expr );
-		}
-		value = (int_value != 0);
-	}
-	free( expr );
-
-	return value;
-}
-
-char *
-macro_expand( const char *str )
-{
-	return( expand_macro(str, ConfigTab, TABLESIZE) );
-}
-
-/*
-** Same as param_boolean but for C -- returns 0 or 1
-** The parameter value is expected to be set to the string
-** "TRUE" or "FALSE" (no quotes, case insensitive).
-** If the value is not defined or not a valid, then
-** return the default_value argument.
-*/
-extern "C" int
-param_boolean_int( const char *name, int default_value )
-{
-    bool default_bool;
-
-    default_bool = default_value == 0 ? false : true;
-    return param_boolean(name, default_bool) ? 1 : 0;
-}
-
-// Note that the line_number can be -1 if the filename isn't a real
-// filename, but something like <Internal> or <Environment>
-bool param_get_location(
-	const char *parameter,
-	MyString  &filename,
-	int       &line_number)
-{
-	bool found_it;
-
-	if (parameter != NULL && extra_info != NULL) {
-		found_it = extra_info->GetParam(parameter, filename, line_number);
-	} else {
-		found_it = false;
-	}
-	return found_it;
-}
-
-void
-reinsert_specials( char* host )
-{
-	static unsigned int reinsert_pid = 0;
-	static unsigned int reinsert_ppid = 0;
-	static bool warned_no_user = false;
-	char buf[40];
-
-	if( tilde ) {
-		insert( "tilde", tilde, ConfigTab, TABLESIZE );
-		extra_info->AddInternalParam("tilde");
-	}
-	if( host ) {
-		insert( "hostname", host, ConfigTab, TABLESIZE );
-	} else {
-		insert( "hostname", my_hostname(), ConfigTab, TABLESIZE );
-	}
-	insert( "full_hostname", my_full_hostname(), ConfigTab, TABLESIZE );
-	insert( "subsystem", get_mySubSystem()->getName(), ConfigTab, TABLESIZE );
-	extra_info->AddInternalParam("hostname");
-	extra_info->AddInternalParam("full_hostname");
-	extra_info->AddInternalParam("subsystem");
-
-	// Insert login-name for our real uid as "username".  At the time
-	// we're reading in the config source, the priv state code is not
-	// initialized, so our euid will always be the same as our ruid.
-	char *myusernm = my_username();
-	if( myusernm ) {
-		insert( "username", myusernm, ConfigTab, TABLESIZE );
-		free(myusernm);
-		myusernm = NULL;
-		extra_info->AddInternalParam("username");
-	} else {
-		if( ! warned_no_user ) {
-			dprintf( D_ALWAYS, "ERROR: can't find username of current user! "
-					 "BEWARE: $(USERNAME) will be undefined\n" );
-			warned_no_user = true;
-		}
-	}
-
-	// Insert real-uid and real-gid as "real_uid" and "real_gid".
-	// Now these values are meaningless on Win32, but leaving
-	// them undefined can be undesireable, and setting them
-	// to "0" could be dangerous (that is root uid on unix),
-	// so we set them to something....
-	{
-		uid_t myruid;
-		gid_t myrgid;
-#ifdef WIN32
-			// Hmmm...
-		myruid = 666;
-		myrgid = 666;
-#else
-		myruid = getuid();
-		myrgid = getgid();
-#endif
-		snprintf(buf,40,"%u",myruid);
-		insert( "real_uid", buf, ConfigTab, TABLESIZE );
-		extra_info->AddInternalParam("real_uid");
-		snprintf(buf,40,"%u",myrgid);
-		insert( "real_gid", buf, ConfigTab, TABLESIZE );
-		extra_info->AddInternalParam("real_gid");
-	}
-		
-	// Insert values for "pid" and "ppid".  Use static values since
-	// this is expensive to re-compute on Windows.
-	// Note: we have to resort to ifdef WIN32 junk even though
-	// DaemonCore can nicely give us this information.  We do this
-	// because the config code is used by the tools as well as daemons.
-	if (!reinsert_pid) {
-#ifdef WIN32
-		reinsert_pid = ::GetCurrentProcessId();
-#else
-		reinsert_pid = getpid();
-#endif
-	}
-	snprintf(buf,40,"%u",reinsert_pid);
-	insert( "pid", buf, ConfigTab, TABLESIZE );
-	extra_info->AddInternalParam("pid");
-	if ( !reinsert_ppid ) {
-#ifdef WIN32
-		CSysinfo system_hackery;
-		reinsert_ppid = system_hackery.GetParentPID(reinsert_pid);
-#else
-		reinsert_ppid = getppid();
-#endif
-	}
-	snprintf(buf,40,"%u",reinsert_ppid);
-	insert( "ppid", buf, ConfigTab, TABLESIZE );
-	insert( "ip_address", my_ip_string(), ConfigTab, TABLESIZE );
-	extra_info->AddInternalParam("ppid");
-	extra_info->AddInternalParam("ip_address");
-}
-
-
-void
-config_insert( const char* attrName, const char* attrValue )
-{
-	if( ! (attrName && attrValue) ) {
-		return;
-	}
-	insert( attrName, attrValue, ConfigTab, TABLESIZE );
-}
-
-
-void
-check_params()
-{
-#if defined( HPUX )
-		// Only on HPUX does this check matter...
-	char* tmp;
-	if( !(tmp = param("ARCH")) ) {
-			// Arch isn't defined.  That means the user didn't define
-			// it _and_ the special file we use that maps workstation
-			// models to CPU types doesn't exist either.  Print a
-			// verbose message and exit.  -Derek Wright 8/14/98
-		fprintf( stderr, "ERROR: %s must know if you are running "
-				 "on an HPPA1 or an HPPA2 CPU.\n",
-				 myDistro->Get() );
-		fprintf( stderr, "Normally, we look in %s for your model.\n",
-				 "/opt/langtools/lib/sched.models" );
-		fprintf( stderr, "This file lists all HP models and the "
-				 "corresponding CPU type.  However,\n" );
-		fprintf( stderr, "this file does not exist on your machine "
-				 "or your model (%s)\n", sysapi_uname_arch() );
-		fprintf( stderr, "was not listed.  You should either explicitly "
-				 "set the ARCH parameter\n" );
-		fprintf( stderr, "in your config source, or install the "
-				 "sched.models file.\n" );
-		exit( 1 );
-	} else {
-		free( tmp );
-	}
-#endif
-}
-
-/* Begin code for runtime support for modifying a daemon's config source.
-   See condor_daemon_core.V6/README.config for more details. */
-
-static StringList PersistAdminList;
-
-class RuntimeConfigItem {
-public:
-	RuntimeConfigItem() : admin(NULL), config(NULL) { }
-	~RuntimeConfigItem() { if (admin) free(admin); if (config) free(config); }
-	void initialize() { admin = config = NULL; }
-	char *admin;
-	char *config;
-};
-
-#include "extArray.h"
-
-static ExtArray<RuntimeConfigItem> rArray;
-
-static MyString toplevel_persistent_config;
-
-/*
-  we want these two bools to be global, and only initialized on
-  startup, so that folks can't play tricks and change these
-  dynamically.  for example, if a site enables runtime but not
-  persistent configs, we can't allow someone to set
-  "ENABLE_PERSISTENT_CONFIG" with a condor_config_val -rset.
-  therefore, we only read these once, before we look at any of the
-  dynamic config source, to make sure we're happy.  this means it
-  requires a restart to change any of these, but i think that's a
-  reasonable burden on admins, considering the potential security
-  implications.  -derek 2006-03-17
-*/
-static bool enable_runtime;
-static bool enable_persistent;
-
-static void
-init_dynamic_config()
-{
-	static bool initialized = false;
-
-	if( initialized ) {
-			// already have a value, we're done
-		return;
-	}
-
-	enable_runtime = param_boolean( "ENABLE_RUNTIME_CONFIG", false );
-	enable_persistent = param_boolean( "ENABLE_PERSISTENT_CONFIG", false );
-	initialized = true;
-
-	if( !enable_persistent ) {
-			// we don't want persistent configs, leave the toplevel blank
-		return;
-	}
-
-	char* tmp;
-
-		// if we're using runtime config, try a subsys-specific config
-		// knob for the root location
-	MyString filename_parameter;
-	filename_parameter.sprintf( "%s_CONFIG", get_mySubSystem()->getName() );
-	tmp = param( filename_parameter.Value() );
-	if( tmp ) {
-		toplevel_persistent_config = tmp;
-		free( tmp );
-		return;
-	}
-
-	tmp = param( "PERSISTENT_CONFIG_DIR" );
-
-	if( !tmp ) {
-		if ( get_mySubSystem()->isClient( ) || !have_config_source ) {
-				/*
-				   we are just a tool, not a daemon.
-				   or, we were explicitly told we don't have
-				   the usual config sources.
-				   thus it is not imperative that we find what we
-				   were looking for...
-				*/
-			return;
-		} else {
-				// we are a daemon.  if we fail, we must exit.
-			fprintf( stderr, "%s error: ENABLE_PERSISTENT_CONFIG is TRUE, "
-					 "but neither %s nor PERSISTENT_CONFIG_DIR is "
-					 "specified in the configuration file\n",
-					 myDistro->GetCap(), filename_parameter.Value() );
-			exit( 1 );
-		}
-	}
-	toplevel_persistent_config.sprintf( "%s%c.config.%s", tmp,
-										DIR_DELIM_CHAR,
-										get_mySubSystem()->getName() );
-	free(tmp);
-}
-
-
-/*
-** Caller is responsible for allocating admin and config with malloc.
-** Caller should not free admin and config after the call.
-*/
-
-#define ABORT \
-	if(admin) { free(admin); } \
-	if(config) { free(config); } \
-	set_priv(priv); \
-	return -1
-
-int
-set_persistent_config(char *admin, char *config)
-{
-	int fd, rval;
-	char *tmp;
-	MyString filename;
-	MyString tmp_filename;
-	priv_state priv;
-
-	if (!admin || !admin[0] || !enable_persistent) {
-		if (admin)  { free(admin);  }
-		if (config) { free(config); }
-		return -1;
-	}
-
-	// make sure top level config source is set
-	init_dynamic_config();
-	if( ! toplevel_persistent_config.Length() ) {
-		EXCEPT( "Impossible: programmer error: toplevel_persistent_config "
-				"is 0-length, but we already initialized, enable_persistent "
-				"is TRUE, and set_persistent_config() has been called" );
-	}
-
-	priv = set_root_priv();
-	if (config && config[0]) {	// (re-)set config
-			// write new config to temporary file
-		filename.sprintf( "%s.%s", toplevel_persistent_config.Value(), admin );
-		tmp_filename.sprintf( "%s.tmp", filename.Value() );
-		do {
-			unlink( tmp_filename.Value() );
-			fd = safe_open_wrapper( tmp_filename.Value(), O_WRONLY|O_CREAT|O_EXCL, 0644 );
-		} while (fd == -1 && errno == EEXIST);
-		if( fd < 0 ) {
-			dprintf( D_ALWAYS, "safe_open_wrapper(%s) returned %d '%s' (errno %d) in "
-					 "set_persistent_config()\n", tmp_filename.Value(),
-					 fd, strerror(errno), errno );
-			ABORT;
-		}
-		if (write(fd, config, strlen(config)) != (ssize_t)strlen(config)) {
-			dprintf( D_ALWAYS, "write() failed with '%s' (errno %d) in "
-					 "set_persistent_config()\n", strerror(errno), errno );
-			ABORT;
-		}
-		if (close(fd) < 0) {
-			dprintf( D_ALWAYS, "close() failed with '%s' (errno %d) in "
-					 "set_persistent_config()\n", strerror(errno), errno );
-			ABORT;
-		}
-		
-			// commit config changes
-		if (rotate_file(tmp_filename.Value(), filename.Value()) < 0) {
-			dprintf( D_ALWAYS, "rotate_file(%s,%s) failed with '%s' "
-					 "(errno %d) in set_persistent_config()\n",
-					 tmp_filename.Value(), filename.Value(),
-					 strerror(errno), errno );
-			ABORT;
-		}
-	
-		// update admin list in memory
-		if (!PersistAdminList.contains(admin)) {
-			PersistAdminList.append(admin);
-		} else {
-			free(admin);
-			free(config);
-			set_priv(priv);
-			return 0;		// if no update is required, then we are done
-		}
-
-	} else {					// clear config
-
-		// update admin list in memory
-		PersistAdminList.remove(admin);
-		if (config) {
-			free(config);
-			config = NULL;
-		}
-	}		
-
-	// update admin list on disk
-	tmp_filename.sprintf( "%s.tmp", toplevel_persistent_config.Value() );
-	do {
-		unlink( tmp_filename.Value() );
-		fd = safe_open_wrapper( tmp_filename.Value(), O_WRONLY|O_CREAT|O_EXCL, 0644 );
-	} while (fd == -1 && errno == EEXIST);
-	if( fd < 0 ) {
-		dprintf( D_ALWAYS, "safe_open_wrapper(%s) returned %d '%s' (errno %d) in "
-				 "set_persistent_config()\n", tmp_filename.Value(),
-				 fd, strerror(errno), errno );
-		ABORT;
-	}
-	const char param[] = "RUNTIME_CONFIG_ADMIN = ";
-	if (write(fd, param, strlen(param)) != (ssize_t)strlen(param)) {
-		dprintf( D_ALWAYS, "write() failed with '%s' (errno %d) in "
-				 "set_persistent_config()\n", strerror(errno), errno );
-		ABORT;
-	}
-	PersistAdminList.rewind();
-	bool first_time = true;
-	while( (tmp = PersistAdminList.next()) ) {
-		if (!first_time) {
-			if (write(fd, ", ", 2) != 2) {
-				dprintf( D_ALWAYS, "write() failed with '%s' (errno %d) in "
-						 "set_persistent_config()\n", strerror(errno), errno );
-				ABORT;
-			}
-		} else {
-			first_time = false;
-		}
-		if (write(fd, tmp, strlen(tmp)) != (ssize_t)strlen(tmp)) {
-			dprintf( D_ALWAYS, "write() failed with '%s' (errno %d) in "
-					 "set_persistent_config()\n", strerror(errno), errno );
-			ABORT;
-		}
-	}
-	if (write(fd, "\n", 1) != 1) {
-		dprintf( D_ALWAYS, "write() failed with '%s' (errno %d) in "
-				 "set_persistent_config()\n", strerror(errno), errno );
-		ABORT;
-	}
-	if (close(fd) < 0) {
-		dprintf( D_ALWAYS, "close() failed with '%s' (errno %d) in "
-				 "set_persistent_config()\n", strerror(errno), errno );
-		ABORT;
-	}
-	
-	rval = rotate_file( tmp_filename.Value(),
-						toplevel_persistent_config.Value() );
-	if (rval < 0) {
-		dprintf( D_ALWAYS, "rotate_file(%s,%s) failed with '%s' (errno %d) "
-				 "in set_persistent_config()\n", tmp_filename.Value(),
-				 filename.Value(), strerror(errno), errno );
-		ABORT;
-	}
-
-	// if we removed a config, then we should clean up by removing the file(s)
-	if (!config || !config[0]) {
-		filename.sprintf( "%s.%s", toplevel_persistent_config.Value(), admin );
-		unlink( filename.Value() );
-		if (PersistAdminList.number() == 0) {
-			unlink( toplevel_persistent_config.Value() );
-		}
-	}
-
-	set_priv( priv );
-	free( admin );
-	if (config) { free( config ); }
-	return 0;
-}
-
-
-int
-set_runtime_config(char *admin, char *config)
-{
-	int i;
-
-	if (!admin || !admin[0] || !enable_runtime) {
-		if (admin)  { free(admin);  }
-		if (config) { free(config); }
-		return -1;
-	}
-
-	if (config && config[0]) {
-		for (i=0; i <= rArray.getlast(); i++) {
-			if (strcmp(rArray[i].admin, admin) == MATCH) {
-				free(admin);
-				free(rArray[i].config);
-				rArray[i].config = config;
-				return 0;
-			}
-		}
-		rArray[i].admin = admin;
-		rArray[i].config = config;
-	} else {
-		for (i=0; i <= rArray.getlast(); i++) {
-			if (strcmp(rArray[i].admin, admin) == MATCH) {
-				free(admin);
-				if (config) free(config);
-				free(rArray[i].admin);
-				free(rArray[i].config);
-				rArray[i] = rArray[rArray.getlast()];
-				rArray[rArray.getlast()].initialize();
-				rArray.truncate(rArray.getlast()-1);
-				return 0;
-			}
-		}
-	}
-
-	return 0;
-}
-
-
-extern "C" {
-
-static int
-process_persistent_configs()
-{
-	char *tmp = NULL;
-	int rval;
-	bool processed = false;
-
-	if( access( toplevel_persistent_config.Value(), R_OK ) == 0 &&
-		PersistAdminList.number() == 0 )
-	{
-		processed = true;
-
-		rval = Read_config( toplevel_persistent_config.Value(), ConfigTab,
-							TABLESIZE, EXPAND_LAZY, true, extra_info );
-		if (rval < 0) {
-			dprintf( D_ALWAYS, "Configuration Error Line %d while reading "
-					 "top-level persistent config source: %s\n",
-					 ConfigLineNo, toplevel_persistent_config.Value() );
-			exit(1);
-		}
-
-		tmp = param ("RUNTIME_CONFIG_ADMIN");
-		if (tmp) {
-			PersistAdminList.initializeFromString(tmp);
-			free(tmp);
-		}
-	}
-
-	PersistAdminList.rewind();
-	while ((tmp = PersistAdminList.next())) {
-		processed = true;
-		MyString config_source;
-		config_source.sprintf( "%s.%s", toplevel_persistent_config.Value(),
-							   tmp );
-		rval = Read_config( config_source.Value(), ConfigTab, TABLESIZE,
-							 EXPAND_LAZY, true, extra_info );
-		if (rval < 0) {
-			dprintf( D_ALWAYS, "Configuration Error Line %d "
-					 "while reading persistent config source: %s\n",
-					 ConfigLineNo, config_source.Value() );
-			exit(1);
-		}
-	}
-	return (int)processed;
-}
-
-
-static int
-process_runtime_configs()
-{
-	int i, rval, fd;
-	bool processed = false;
-
-	for (i=0; i <= rArray.getlast(); i++) {
-		processed = true;
-
-		char* tmp_dir = temp_dir_path();
-		ASSERT(tmp_dir);
-		MyString tmp_file_tmpl = tmp_dir;
-		free(tmp_dir);
-		tmp_file_tmpl += "/cndrtmpXXXXXX";
-
-		char* tmp_file = strdup(tmp_file_tmpl.Value());
-		fd = condor_mkstemp( tmp_file );
-		if (fd < 0) {
-			dprintf( D_ALWAYS, "condor_mkstemp(%s) returned %d, '%s' (errno %d) in "
-				 "process_dynamic_configs()\n", tmp_file, fd,
-				 strerror(errno), errno );
-			exit(1);
-		}
-
-		if (write(fd, rArray[i].config, strlen(rArray[i].config))
-			!= (ssize_t)strlen(rArray[i].config)) {
-			dprintf( D_ALWAYS, "write failed with errno %d in "
-					 "process_dynamic_configs\n", errno );
-			exit(1);
-		}
-		if (close(fd) < 0) {
-			dprintf( D_ALWAYS, "close failed with errno %d in "
-					 "process_dynamic_configs\n", errno );
-			exit(1);
-		}
-		rval = Read_config( tmp_file, ConfigTab, TABLESIZE,
-							EXPAND_LAZY, false, extra_info );
-		if (rval < 0) {
-			dprintf( D_ALWAYS, "Configuration Error Line %d "
-					 "while reading %s, runtime config: %s\n",
-					 ConfigLineNo, tmp_file, rArray[i].admin );
-			exit(1);
-		}
-		unlink(tmp_file);
-		free(tmp_file);
-	}
-
-	return (int)processed;
-}
-
-
-/*
-** returns 1 if dynamic (runtime or persistent) configs were
-** processed; 0 if no dynamic configs were defined, and -1 on error.
-*/
-static int
-process_dynamic_configs()
-{
-	int per_rval = 0;
-	int run_rval = 0;
-
-	init_dynamic_config();
-
-	if( enable_persistent ) {
-		per_rval = process_persistent_configs();
-	}
-
-	if( enable_runtime ) {
-		run_rval = process_runtime_configs();
-	}
-
-	if( per_rval < 0 || run_rval < 0 ) {
-		return -1;
-	}
-	if( per_rval || run_rval ) {
-		return 1;
-	}
-	return 0;
-}
-
-} // end of extern "C"
-
-/* End code for runtime support for modifying a daemon's config source. */
+	dprintf ( D_ALWAYS, "Locale: %s\n", locale );
+#endif
+	real_config( NULL, wantsQuiet, wantsExtraInfo );
+	validate_entries( ignore_invalid_entry );
+}
+
+
+void
+config_host( char* host )
+{
+	real_config( host, 0, true );
+}
+
+/* This function initialize GSI (maybe other) authentication related
+   stuff Daemons that should use the condor daemon credentials should
+   set the argument is_daemon=true.  This function is automatically
+   called at config init time with is_daemon=false, so that all
+   processes get the basic auth config.  The order of calls to this
+   function do not matter, as the results are only additive.
+   Therefore, calling with is_daemon=false and then with
+   is_daemon=true or vice versa are equivalent.
+*/
+void
+condor_auth_config(int is_daemon)
+{
+#if !defined(SKIP_AUTHENTICATION) && defined(HAVE_EXT_GLOBUS)
+
+		// First, if there is X509_USER_PROXY, we clear it
+		// (if we're a daemon).
+	if ( is_daemon ) {
+		UnsetEnv( "X509_USER_PROXY" );
+	}
+
+		// Next, we param the configuration file for GSI related stuff and
+		// set the corresponding environment variables for it
+
+	char *pbuf = 0;
+	char *proxy_buf = 0;
+	char *cert_buf = 0;
+	char *key_buf = 0;
+	char *trustedca_buf = 0;
+	char *mapfile_buf = 0;
+
+	MyString buffer;
+
+
+		// Here's how it works. If you define any of
+		// GSI_DAEMON_CERT, GSI_DAEMON_KEY, GSI_DAEMON_PROXY, or
+		// GSI_DAEMON_TRUSTED_CA_DIR, those will get stuffed into the
+		// environment.
+		//
+		// Everything else depends on GSI_DAEMON_DIRECTORY. If
+		// GSI_DAEMON_DIRECTORY is not defined, then only settings that are
+		// defined above will be placed in the environment, so if you
+		// want the cert and host in a non-standard location, but want to use
+		// /etc/grid-security/certifcates as the trusted ca dir, only
+		// define GSI_DAEMON_CERT and GSI_DAEMON_KEY, and not
+		// GSI_DAEMON_DIRECTORY and GSI_DAEMON_TRUSTED_CA_DIR
+		//
+		// If GSI_DAEMON_DIRECTORY is defined, condor builds a "reasonable"
+		// default out of what's already been defined and what it can
+		// construct from GSI_DAEMON_DIRECTORY  - ie  the trusted CA dir ends
+		// up as in $(GSI_DAEMON_DIRECTORY)/certificates, and so on
+		// The proxy is not included in the "reasonable defaults" section
+
+		// First, let's get everything we might want
+	pbuf = param( STR_GSI_DAEMON_DIRECTORY );
+	trustedca_buf = param( STR_GSI_DAEMON_TRUSTED_CA_DIR );
+	mapfile_buf = param( STR_GSI_MAPFILE );
+	if( is_daemon ) {
+		proxy_buf = param( STR_GSI_DAEMON_PROXY );
+		cert_buf = param( STR_GSI_DAEMON_CERT );
+		key_buf = param( STR_GSI_DAEMON_KEY );
+	}
+
+	if (pbuf) {
+
+		if( !trustedca_buf) {
+			buffer.sprintf( "%s%ccertificates", pbuf, DIR_DELIM_CHAR);
+			SetEnv( STR_GSI_CERT_DIR, buffer.Value() );
+		}
+
+		if (!mapfile_buf ) {
+			buffer.sprintf( "%s%cgrid-mapfile", pbuf, DIR_DELIM_CHAR);
+			SetEnv( STR_GSI_MAPFILE, buffer.Value() );
+		}
+
+		if( is_daemon ) {
+			if( !cert_buf ) {
+				buffer.sprintf( "%s%chostcert.pem", pbuf, DIR_DELIM_CHAR);
+				SetEnv( STR_GSI_USER_CERT, buffer.Value() );
+			}
+	
+			if (!key_buf ) {
+				buffer.sprintf( "%s%chostkey.pem", pbuf, DIR_DELIM_CHAR);
+				SetEnv( STR_GSI_USER_KEY, buffer.Value() );
+			}
+		}
+
+		free( pbuf );
+	}
+
+	if(trustedca_buf) {
+		SetEnv( STR_GSI_CERT_DIR, trustedca_buf );
+		free(trustedca_buf);
+	}
+
+	if (mapfile_buf) {
+		SetEnv( STR_GSI_MAPFILE, mapfile_buf );
+		free(mapfile_buf);
+	}
+
+	if( is_daemon ) {
+		if(proxy_buf) {
+			SetEnv( STR_GSI_USER_PROXY, proxy_buf );
+			free(proxy_buf);
+		}
+
+		if(cert_buf) {
+			SetEnv( STR_GSI_USER_CERT, cert_buf );
+			free(cert_buf);
+		}
+
+		if(key_buf) {
+			SetEnv( STR_GSI_USER_KEY, key_buf );
+			free(key_buf);
+		}
+	}
+
+#endif
+}
+
+void
+condor_net_remap_config( bool force_param )
+{
+    char *str = NULL;
+	if( ! force_param && getenv("NET_REMAP_ENABLE") ) {
+			/*
+			  this stuff is already set.  unless the caller is forcing
+			  us to call param() again (e.g. the master is trying to
+			  re-bind() if the GCB broker is down and it's got a list
+			  to try) we should return immediately and leave our
+			  environment alone.  this way, the master can choose what
+			  GCB broker to use for itself and all its children, even
+			  if there's a list and we're using $RANDOM_CHOICE().
+			*/
+		return;
+	}
+		
+		/*
+		  this method is only called if we're enabling a network remap
+		  service.  if we do, we always need to force condor to bind()
+		  to all interfaces (INADDR_ANY).  since we don't want to rely
+		  on users to set this themselves to get GCB working, we'll
+		  set it automatically.  the only harm of setting this is that
+		  we need Condor to automatically handle hostallow stuff for
+		  "localhost", or users need to add localhost to their
+		  hostallow settings as appropriate.  we can't rely on the
+		  later, and the former only works on some platforms.
+		  luckily, the automatic localhost stuff works on all
+		  platforms where GCB works (linux, and we hope, solaris), so
+		  it's safe to turn this on whenever we're using GCB
+		*/
+	insert( "BIND_ALL_INTERFACES", "TRUE", ConfigTab, TABLESIZE );
+	extra_info->AddInternalParam("BIND_ALL_INTERFACES");
+
+    // Env: the type of service
+    SetEnv( "NET_REMAP_ENABLE", "true");
+    str = param("NET_REMAP_SERVICE");
+    if (str) {
+        if (!strcasecmp(str, "GCB")) {
+            SetEnv( "GCB_ENABLE", "true" );
+            free(str);
+            str = NULL;
+            // Env: InAgent
+            if( (str = param("NET_REMAP_INAGENT")) ) {
+					// NET_REMAP_INAGENT is a list of GCB brokers.
+				const char *next_broker;
+				StringList all_brokers( str );
+				StringList working_brokers;
+
+					// Pick a random working GCB broker.
+				all_brokers.rewind();
+				while ( (next_broker = all_brokers.next()) ) {
+					int rc = 0;
+					int num_slots = 0;
+
+#if HAVE_EXT_GCB
+					rc = GCB_broker_query( next_broker,
+										   GCB_DATA_QUERY_FREE_SOCKS,
+										   &num_slots );
+#endif
+					if ( rc == 0 ) {
+						working_brokers.append( next_broker );
+					}
+				}
+
+				if ( working_brokers.number() > 0 ) {
+					int rand_entry = (get_random_int() % working_brokers.number()) + 1;
+					int i = 0;
+					working_brokers.rewind();
+					while ( (i < rand_entry) &&
+							(next_broker=working_brokers.next()) ) {
+						i++;
+					}
+
+					dprintf( D_FULLDEBUG,"Using GCB broker %s\n",next_broker );
+					SetEnv( "GCB_INAGENT", next_broker );
+				} else {
+						// TODO How should we indicate that we tried and
+						//   failed to find a working broker? For now, we
+						//   set GCB_INAGENT to a valid, but non-existent
+						//   IP address. That should cause a failure when
+						//   we try to make a socket. The address we use
+						//   is defined in our header file, so callers
+						//   can check GCB_INAGENT to see if we failed to
+						//   find a broker.
+					dprintf( D_ALWAYS,"No usable GCB brokers were found. "
+							 "Setting GCB_INAGENT=%s\n",
+							 CONDOR_GCB_INVALID_BROKER );
+					SetEnv( "GCB_INAGENT", CONDOR_GCB_INVALID_BROKER );
+				}
+				free( str );
+                str = NULL;
+            }
+            // Env: Routing table
+            if( (str = param("NET_REMAP_ROUTE")) ) {
+                SetEnv( "GCB_ROUTE", str );
+				free( str );
+                str = NULL;
+            }
+        } else if (!strcasecmp(str, "DPF")) {
+            SetEnv( "DPF_ENABLE", "true" );
+            free(str);
+            str = NULL;
+            // Env: InAgent
+            if( (str = param("NET_REMAP_INAGENT")) ) {
+                SetEnv( "DPF_INAGENT", str );
+				free(str);
+				str = NULL;
+            }
+            // Env: Routing table
+            if( (str = param("NET_REMAP_ROUTE")) ) {
+                SetEnv( "DPF_ROUTE", str );
+				free(str);
+				str = NULL;
+            }
+        }
+    }
+}
+
+
+void
+real_config(char* host, int wantsQuiet, bool wantExtraInfo)
+{
+	char* config_source = NULL;
+	char* tmp = NULL;
+	int scm;
+
+	static bool first_time = true;
+	if( first_time ) {
+		first_time = false;
+		init_config(wantExtraInfo);
+	} else {
+			// Clear out everything in our config hash table so we can
+			// rebuild it from scratch.
+		clear_config();
+		if (wantExtraInfo) {
+			extra_info = new ExtraParamTable();
+		} else {
+			extra_info = new DummyExtraParamTable();
+		}
+	}
+
+	dprintf( D_CONFIG, "config: using subsystem '%s', local '%s'\n",
+			 get_mySubSystem()->getName(), get_mySubSystem()->getLocalName("") );
+
+		/*
+		  N.B. if we are using the yellow pages, system calls which are
+		  not supported by either remote system calls or file descriptor
+ 		  mapping will occur.  Thus we must be in LOCAL/UNRECORDED mode here.
+		*/
+	scm = SetSyscalls( SYS_LOCAL | SYS_UNRECORDED );
+
+		// Try to find user "condor" in the passwd file.
+	init_tilde();
+
+		// Insert an entry for "tilde", (~condor)
+	if( tilde ) {
+		insert( "tilde", tilde, ConfigTab, TABLESIZE );
+		extra_info->AddInternalParam("tilde");
+
+	} else {
+			// What about tilde if there's no ~condor?
+	}
+
+		// Insert some default values for attributes we want even if
+		// they're not defined in the config sources: ARCH and OPSYS.
+		// We also want to insert the special "SUBSYSTEM" macro here.
+		// We do this now since if they are defined in the config
+		// files, these values will get overridden.  However, we want
+		// them defined to begin with so that people can use them in
+		// the global config source to specify the location of
+		// platform-specific config sources, etc.  -Derek Wright 6/8/98
+		// Moved all the domain-specific stuff to a separate function
+		// since we might not know our full hostname yet. -Derek 10/20/98
+	fill_attributes();
+
+		// Try to find the global config source
+
+	char* env = getenv( EnvGetName(ENV_CONFIG) );
+	if( env && stricmp(env, "ONLY_ENV") == MATCH ) {
+			// special case, no config source desired
+		have_config_source = false;
+	}
+
+	if( have_config_source && ! (config_source = find_global()) ) {
+		if( wantsQuiet ) {
+			fprintf( stderr, "%s error: can't find config source.\n",
+					 myDistro->GetCap() );
+			exit( 1 );
+		}
+		fprintf(stderr,"\nNeither the environment variable %s_CONFIG,\n",
+				myDistro->GetUc() );
+#	  if defined UNIX
+		fprintf(stderr,"/etc/%s/, nor ~%s/ contain a %s_config source.\n",
+				myDistro->Get(), myDistro->Get(), myDistro->Get() );
+#	  elif defined WIN32
+		fprintf(stderr,"nor the registry contains a %s_config source.\n", myDistro->Get() );
+#	  else
+#		error "Unknown O/S"
+#	  endif
+		fprintf( stderr,"Either set %s_CONFIG to point to a valid config "
+				"source,\n", myDistro->GetUc() );
+#	  if defined UNIX
+		fprintf( stderr,"or put a \"%s_config\" file in /etc/%s or ~%s/\n",
+				 myDistro->Get(), myDistro->Get(), myDistro->Get() );
+#	  elif defined WIN32
+		fprintf( stderr,"or put a \"%s_config\" source in the registry at:\n"
+				 " HKEY_LOCAL_MACHINE\\Software\\%s\\%s_CONFIG",
+				 myDistro->Get(), myDistro->Get(), myDistro->GetUc() );
+#	  else
+#		error "Unknown O/S"
+#	  endif
+		fprintf( stderr, "Exiting.\n\n" );
+		exit( 1 );
+	}
+
+		// Read in the global file
+	if( have_config_source ) {
+		process_config_source( config_source, "global config source", NULL, true );
+		global_config_source = config_source;
+		free( config_source );
+		config_source = NULL;
+	}
+
+		// Insert entries for "hostname" and "full_hostname".  We do
+		// this here b/c we need these macros defined so that we can
+		// find the local config source if that's defined in terms of
+		// hostname or something.  However, we do this after reading
+		// the global config source so people can put the
+		// DEFAULT_DOMAIN_NAME parameter somewhere if they need it.
+		// -Derek Wright <wright@cs.wisc.edu> 5/11/98
+	if( host ) {
+		insert( "hostname", host, ConfigTab, TABLESIZE );
+		extra_info->AddInternalParam("hostname");
+	} else {
+		insert( "hostname", my_hostname(), ConfigTab, TABLESIZE );
+		extra_info->AddInternalParam("hostname");
+	}
+	insert( "full_hostname", my_full_hostname(), ConfigTab, TABLESIZE );
+	extra_info->AddInternalParam("full_hostname");
+
+		// Also insert tilde since we don't want that over-written.
+	if( tilde ) {
+		insert( "tilde", tilde, ConfigTab, TABLESIZE );
+		extra_info->AddInternalParam("tilde");
+	}
+
+		// Read in the LOCAL_CONFIG_FILE as a string list and process
+		// all the files in the order they are listed.
+	char *dirlist = param("LOCAL_CONFIG_DIR");
+	if(dirlist) {
+		process_directory(dirlist, host);
+	}
+	process_locals( "LOCAL_CONFIG_FILE", host );
+
+	char* newdirlist = param("LOCAL_CONFIG_DIR");
+	if(newdirlist && dirlist) {
+		if(strcmp(dirlist, newdirlist) ) {
+			process_directory(newdirlist, host);
+		}
+	}
+
+	if(dirlist) { free(dirlist); dirlist = NULL; }
+	if(newdirlist) { free(newdirlist); newdirlist = NULL; }
+
+		// Daemons should additionally call condor_auth_config()
+		// explicitly with the argument is_daemon=true.  Here, we just
+		// call with is_daemon=false, since that is fine for both daemons
+		// and non-daemons to do.
+	condor_auth_config( false );
+
+	// The following lines should be placed very carefully. Must be after
+	// global and local config sources being processed but before any
+	// call that may be interposed by GCB
+    if ( param_boolean("NET_REMAP_ENABLE", false) ) {
+        condor_net_remap_config();
+    }
+			
+		// Now, insert any macros defined in the environment.
+	for( int i = 0; environ[i]; i++ ) {
+		char magic_prefix[MAX_DISTRIBUTION_NAME + 3];	// case-insensitive
+		strcpy( magic_prefix, "_" );
+		strcat( magic_prefix, myDistro->Get() );
+		strcat( magic_prefix, "_" );
+		int prefix_len = strlen( magic_prefix );
+
+		// proceed only if we see the magic prefix
+		if( strncasecmp( environ[i], magic_prefix, prefix_len ) != 0 ) {
+			continue;
+		}
+
+		char *varname = strdup( environ[i] );
+		if( !varname ) {
+			EXCEPT( "Out of memory in %s:%d\n", __FILE__, __LINE__ );
+		}
+
+		// isolate variable name by finding & nulling the '='
+		int equals_offset = strchr( varname, '=' ) - varname;
+		varname[equals_offset] = '\0';
+		// isolate value by pointing to everything after the '='
+		char *varvalue = varname + equals_offset + 1;
+//		assert( !strcmp( varvalue, getenv( varname ) ) );
+		// isolate Condor macro_name by skipping magic prefix
+		char *macro_name = varname + prefix_len;
+
+		// special macro START_owner needs to be expanded (for the
+		// glide-in code) [which should probably be fixed to use
+		// the general mechanism and set START itself --pfc]
+		if( !strcmp( macro_name, "START_owner" ) ) {
+			MyString ownerstr;
+			ownerstr.sprintf( "Owner == \"%s\"", varvalue );
+			insert( "START", ownerstr.Value(), ConfigTab, TABLESIZE );
+			extra_info->AddEnvironmentParam("START");
+		}
+		// ignore "_CONDOR_" without any macro name attached
+		else if( macro_name[0] != '\0' ) {
+			insert( macro_name, varvalue, ConfigTab, TABLESIZE );
+			extra_info->AddEnvironmentParam(macro_name);
+		}
+
+		free( varname );
+	}
+
+		// Insert the special macros.  We don't want the user to
+		// override them, since it's not going to work.
+		// We also do this last because some things (like USERNAME)
+		// may depend on earlier configuration (USERID_MAP).
+	reinsert_specials( host );
+
+	process_dynamic_configs();
+
+	if (config_source) {
+		free( config_source );
+	}
+
+		// Now that we're done reading files, if DEFAULT_DOMAIN_NAME
+		// is set, we need to re-initialize my_full_hostname().
+	if( (tmp = param("DEFAULT_DOMAIN_NAME")) ) {
+		free( tmp );
+		init_full_hostname();
+	}
+
+		// Also, we should be safe to process the NETWORK_INTERFACE
+		// parameter at this point, if it's set.
+	init_ipaddr( TRUE );
+
+		// Re-insert the special macros.  We don't want the user to
+		// override them, since it's not going to work.
+	reinsert_specials( host );
+
+		// Make sure our FILESYSTEM_DOMAIN and UID_DOMAIN settings are
+		// correct.
+	check_domain_attributes();
+
+		// We have to do some platform-specific checking to make sure
+		// all the parameters we think are defined really are.
+	check_params();
+
+	condor_except_should_dump_core( param_boolean("ABORT_ON_EXCEPTION", false) );
+
+	(void)SetSyscalls( scm );
+}
+
+
+void
+process_config_source( char* file, char* name, char* host, int required )
+{
+	int rval;
+	if( access( file, R_OK ) != 0 && !is_piped_command(file)) {
+		if( !required) { return; }
+
+		if( !host ) {
+			fprintf( stderr, "ERROR: Can't read %s %s\n",
+					 name, file );
+			exit( 1 );
+		}
+	} else {
+		rval = Read_config( file, ConfigTab, TABLESIZE, EXPAND_LAZY,
+							false, extra_info );
+		if( rval < 0 ) {
+			fprintf( stderr,
+					 "Configuration Error Line %d while reading %s %s\n",
+					 ConfigLineNo, name, file );
+			exit( 1 );
+		}
+	}
+}
+
+
+// Param for given name, read it in as a string list, and process each
+// config source listed there.  If the value is actually a cmd whose
+// output should be piped, then do *not* treat it as a file list.
+void
+process_locals( char* param_name, char* host )
+{
+	StringList sources_to_process, sources_done;
+	char *source, *sources_value;
+	char *tmp;
+	int local_required;
+	
+	local_required = true;	
+    tmp = param( "REQUIRE_LOCAL_CONFIG_FILE" );
+    if( tmp ) {
+		if( tmp[0] == 'f' || tmp[0] == 'F' ) {
+			local_required = false;
+		}
+		free( tmp );
+    }
+
+	sources_value = param( param_name );
+	if( sources_value ) {
+		if ( is_piped_command( sources_value ) ) {
+			sources_to_process.insert( sources_value );
+		} else {
+			sources_to_process.initializeFromString( sources_value );
+		}
+		sources_to_process.rewind();
+		while( (source = sources_to_process.next()) ) {
+			process_config_source( source, "config source", host,
+								   local_required );
+			local_config_sources.append( source );
+
+			sources_done.append(source);
+
+			char* new_sources_value = param(param_name);
+			if(new_sources_value) {
+				if(strcmp(sources_value, new_sources_value) ) {
+				// the file we just processed altered the list of sources to
+				// process
+					sources_to_process.clearAll();
+					if ( is_piped_command( new_sources_value ) ) {
+						sources_to_process.insert( new_sources_value );
+					} else {
+						sources_to_process.initializeFromString(new_sources_value);
+					}
+
+					// remove all the ones we've finished from the old list
+                	sources_done.rewind();
+                	while( (source = sources_done.next()) ) {
+						sources_to_process.remove(source);
+					}
+					sources_to_process.rewind();
+					free(sources_value);
+					sources_value = new_sources_value;
+				} else {
+					free(new_sources_value);
+				}
+			}
+		}
+		free(sources_value);
+	}
+}
+
+int compareFiles(const void *a, const void *b) {
+	 return strcmp(*(char *const*)a, *(char *const*)b);
+}
+
+// examine each file in a directory and treat it as a config file
+void
+process_directory( char* dirlist, char* host )
+{
+	StringList locals;
+	Directory *files;
+	const char *file, *dirpath;
+	char **paths;
+	char *tmp;
+	int local_required;
+	
+	local_required = true;	
+	tmp = param( "REQUIRE_LOCAL_CONFIG_FILE" );
+	if( tmp ) {
+		if( tmp[0] == 'f' || tmp[0] == 'F' ) {
+			local_required = false;
+		}
+		free( tmp );
+	}
+
+	if(!dirlist) { return; }
+	locals.initializeFromString( dirlist );
+	locals.rewind();
+	while( (dirpath = locals.next()) ) {
+
+		paths = (char **)calloc(65536, sizeof(char *));
+		files = new Directory(dirpath);
+		int i = 0;
+		if(files == NULL) {
+			fprintf(stderr, "Cannot open %s\n", dirpath);
+		} else {
+			while( (file = files->Next()) && i < 65536) {
+				// don't consider directories
+				// maybe we should squash symlinks here...
+				if(! files->IsDirectory() ) {
+					paths[i] = strdup(files->GetFullPath());
+					i++;
+				}
+			}
+			delete files;
+		}
+		qsort(paths, i, sizeof(char *), compareFiles);
+		char **pathCopy = paths;
+		while(*pathCopy) {
+			process_config_source( *pathCopy, "config source", host,
+								   local_required );
+
+			local_config_sources.append(*pathCopy);
+
+			free(*pathCopy);
+			pathCopy++;
+		}
+		free(paths);
+	}
+}
+
+// Try to find the "condor" user's home directory
+void
+init_tilde()
+{
+	if( tilde ) {
+		free( tilde );
+		tilde = NULL;
+	}
+# if defined UNIX
+	struct passwd *pw;
+	if( (pw=getpwnam( myDistro->Get() )) ) {
+		tilde = strdup( pw->pw_dir );
+	}
+# else
+	// On Windows, we'll just look in the registry for TILDE.
+	HKEY	handle;
+	char regKey[1024];
+
+	snprintf( regKey, 1024, "Software\\%s", myDistro->GetCap() );
+
+	if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, regKey,
+		0, KEY_READ, &handle) == ERROR_SUCCESS ) {
+
+		// got the reg key open; now we just need to see if
+		// we can open the TILDE string value.
+
+		char the_path[MAX_PATH];
+		DWORD valType;
+		DWORD valSize = MAX_PATH - 2;
+
+		the_path[0] = '\0';
+
+		if ( RegQueryValueEx(handle, "TILDE", 0,
+			&valType, (unsigned char *)the_path, &valSize) == ERROR_SUCCESS ) {
+
+			if ( valType == REG_SZ && the_path[0] ) {
+				// got it!
+				tilde = strdup(the_path);
+			}
+		}
+		RegCloseKey(handle);
+	}
+	
+# endif
+}
+
+
+char*
+get_tilde()
+{
+	init_tilde();
+	return tilde;
+}
+
+
+char*
+find_global()
+{
+	MyString	file;
+	file.sprintf( "%s_config", myDistro->Get() );
+	return find_file( EnvGetName( ENV_CONFIG), file.Value() );
+}
+
+
+// Find location of specified file
+char*
+find_file(const char *env_name, const char *file_name)
+{
+	char* config_source = NULL;
+	char* env = NULL;
+	int fd = 0;
+
+		// If we were given an environment variable name, try that first.
+	if( env_name && (env = getenv( env_name )) ) {
+		config_source = strdup( env );
+		StatInfo si( config_source );
+		switch( si.Error() ) {
+		case SIGood:
+			if( si.IsDirectory() ) {
+				fprintf( stderr, "File specified in %s environment "
+						 "variable:\n\"%s\" is a directory.  "
+						 "Please specify a file.\n", env_name,
+						 config_source );
+				free( config_source );
+				config_source = NULL;
+				exit( 1 );
+			}
+				// Otherwise, we're happy
+			return config_source;
+			break;
+		case SINoFile:
+			// Check to see if it is a pipe command, in which case we're fine.
+			if (!is_piped_command(config_source) ||
+				!is_valid_command(config_source)) {
+
+				fprintf( stderr, "File specified in %s environment "
+						 "variable:\n\"%s\" does not exist.\n",
+						 env_name, config_source );
+				free( config_source );
+				exit( 1 );
+				break;
+			}
+			// Otherwise, we're happy
+			return config_source;
+
+		case SIFailure:
+			fprintf( stderr, "Cannot stat file specified in %s "
+					 "environment variable:\n\"%s\", errno: %d\n",
+					 env_name, config_source, si.Errno() );
+			free( config_source );
+			exit( 1 );
+			break;
+		}
+	}
+
+# ifdef UNIX
+
+	if (!config_source) {
+			// List of condor_config file locations we'll try to open.
+			// As soon as we find one, we'll stop looking.
+		int locations_length = 4;
+		MyString locations[locations_length];
+			// 1) /etc/condor/condor_config
+		locations[0].sprintf( "/etc/%s/%s", myDistro->Get(), file_name );
+			// 2) /usr/local/etc/condor_config (FreeBSD)
+		locations[1].sprintf( "/usr/local/etc/%s", file_name );
+		if (tilde) {
+				// 3) ~condor/condor_config
+			locations[2].sprintf( "%s/%s", tilde, file_name );
+		}
+			// 4) ${GLOBUS_LOCATION}/etc/condor_config
+		char *globus_location;
+		if ((globus_location = getenv("GLOBUS_LOCATION"))) {
+			locations[3].sprintf( "%s/etc/%s", globus_location, file_name );
+		}
+
+		int ctr;	
+		for (ctr = 0 ; ctr < locations_length; ctr++) {
+				// Only use this file if the path isn't empty and
+				// if we can read it properly.
+			if (!locations[ctr].IsEmpty()) {
+				config_source = strdup(locations[ctr].Value());
+				if ((fd = safe_open_wrapper(config_source, O_RDONLY)) < 0) {
+					free(config_source);
+					config_source = NULL;
+				} else {
+					close(fd);
+					dprintf(D_FULLDEBUG, "Reading condor configuration "
+							"from '%s'\n", config_source);
+					break;
+				}
+			}
+		} // FOR
+	} // IF
+
+# elif defined WIN32	// ifdef UNIX
+	// Only look in the registry on WinNT.
+	HKEY	handle;
+	char	regKey[256];
+
+	snprintf( regKey, 256, "Software\\%s", myDistro->GetCap() );
+	if ( !config_source && RegOpenKeyEx(HKEY_LOCAL_MACHINE, regKey,
+		0, KEY_READ, &handle) == ERROR_SUCCESS ) {
+		// We have found a registry key for Condor, which
+		// means this user has a pulse and has actually run the
+		// installation program before trying to run Condor.
+		// This user deserves a tax credit.
+
+		// So now that we found the key, read it.
+		char the_path[MAX_PATH];
+		DWORD valType;
+		DWORD valSize = MAX_PATH - 2;
+
+		the_path[0] = '\0';
+		if ( RegQueryValueEx(handle, env_name, 0,
+			&valType, (unsigned char *)the_path, &valSize) == ERROR_SUCCESS ) {
+
+			// confirm it is a string value with something there
+			if ( valType == REG_SZ && the_path[0] ) {
+				// got it!  whoohooo!
+				config_source = strdup(the_path);
+
+				if ( strncmp(config_source, "\\\\", 2 ) == 0 ) {
+					// UNC Path, so run a 'net use' on it first.
+					NETRESOURCE nr;
+					nr.dwType = RESOURCETYPE_DISK;
+					nr.lpLocalName = NULL;
+					nr.lpRemoteName = condor_dirname(config_source);
+					nr.lpProvider = NULL;
+					
+					if ( NO_ERROR != WNetAddConnection2(
+										&nr,   /* NetResource */
+										NULL,  /* password (default) */
+										NULL,  /* username (default) */
+										0      /* flags (none) */
+						) ) {
+
+						if ( GetLastError() == ERROR_INVALID_PASSWORD ) {
+							// try again with an empty password
+							WNetAddConnection2(
+										&nr,   /* NetResource */
+										"",    /* password (none) */
+										NULL,  /* username (default) */
+										0      /* flags (none) */
+							);
+						}
+
+						// whether it worked or not, we're gonna
+						// continue.  The goal of running the
+						// WNetAddConnection2() is to make a mapping
+						// to the UNC path. For reasons I don't fully
+						// understand, some sites need the mapping,
+						// and some don't. If it works, great; if not,
+						// try the safe_open_wrapper() anyways, and at
+						// worst we'll fail fast and the user can fix
+						// their file server.
+					}
+
+					if (nr.lpRemoteName) {
+						free(nr.lpRemoteName);
+					}
+				}
+
+				if( !(is_piped_command(config_source) &&
+					  is_valid_command(config_source)) &&
+					(fd = safe_open_wrapper( config_source, O_RDONLY)) < 0 ) {
+
+					free( config_source );
+					config_source = NULL;
+				} else {
+					if (fd != 0) {
+						close( fd );
+					}
+				}
+			}
+		}
+
+		RegCloseKey(handle);
+	}
+# else
+#	error "Unknown O/S"
+# endif		/* ifdef UNIX / Win32 */
+
+	return config_source;
+}
+
+
+void
+fill_attributes()
+{
+		/* There are a few attributes that specify what platform we're
+		   on that we want to insert values for even if they're not
+		   defined in the config sources.  These are ARCH and OPSYS,
+		   which we compute with the sysapi_condor_arch() and sysapi_opsys()
+		   functions.  We also insert the subsystem here.  Moved all
+		   the domain stuff to check_domain_attributes() on
+		   10/20.  Also, since this is called before we read in any
+		   config sources, there's no reason to check to see if any of
+		   these are already defined.  -Derek Wright
+		   Amended -Pete Keller 06/01/99 */
+
+	const char *tmp;
+
+	if( (tmp = sysapi_condor_arch()) != NULL ) {
+		insert( "ARCH", tmp, ConfigTab, TABLESIZE );
+		extra_info->AddInternalParam("ARCH");
+	}
+
+	if( (tmp = sysapi_uname_arch()) != NULL ) {
+		insert( "UNAME_ARCH", tmp, ConfigTab, TABLESIZE );
+		extra_info->AddInternalParam("UNAME_ARCH");
+	}
+
+	if( (tmp = sysapi_opsys()) != NULL ) {
+		insert( "OPSYS", tmp, ConfigTab, TABLESIZE );
+		extra_info->AddInternalParam("OPSYS");
+	}
+
+	if( (tmp = sysapi_uname_opsys()) != NULL ) {
+		insert( "UNAME_OPSYS", tmp, ConfigTab, TABLESIZE );
+		extra_info->AddInternalParam("UNAME_OPSYS");
+	}
+
+	insert( "subsystem", get_mySubSystem()->getName(), ConfigTab, TABLESIZE );
+	extra_info->AddInternalParam("subsystem");
+}
+
+
+void
+check_domain_attributes()
+{
+		/* Make sure the FILESYSTEM_DOMAIN and UID_DOMAIN attributes
+		   are set to something reasonable.  If they're not already
+		   defined, we default to our own full hostname.  Moved this
+		   to its own function so we're sure we have our full hostname
+		   by the time we call this. -Derek Wright 10/20/98 */
+
+	char *uid_domain, *filesys_domain;
+
+	filesys_domain = param("FILESYSTEM_DOMAIN");
+	if( !filesys_domain ) {
+		filesys_domain = my_full_hostname();
+		insert( "FILESYSTEM_DOMAIN", filesys_domain, ConfigTab, TABLESIZE );
+		extra_info->AddInternalParam("FILESYSTEM_DOMAIN");
+	} else {
+		free( filesys_domain );
+	}
+
+	uid_domain = param("UID_DOMAIN");
+	if( !uid_domain ) {
+		uid_domain = my_full_hostname();
+		insert( "UID_DOMAIN", uid_domain, ConfigTab, TABLESIZE );
+		extra_info->AddInternalParam("UID_DOMAIN");
+	} else {
+		free( uid_domain );
+	}
+}
+
+void
+init_config(bool wantExtraInfo  /* = true */)
+{
+	memset( (char *)ConfigTab, 0, (TABLESIZE * sizeof(BUCKET*)) );
+	if (wantExtraInfo) {
+		extra_info = new ExtraParamTable();
+	} else {
+		extra_info = new DummyExtraParamTable();
+	}
+
+	return;
+}
+
+void
+clear_config()
+{
+	register 	int 	i;
+	register 	BUCKET	*ptr = NULL;
+	register 	BUCKET	*tmp = NULL;
+
+	for( i=0; i<TABLESIZE; i++ ) {
+		ptr = ConfigTab[i];
+		while( ptr ) {
+			tmp = ptr->next;
+			FREE( ptr->value );
+			ptr->value = NULL;
+			FREE( ptr->name );
+			ptr->name = NULL;
+			FREE( ptr );
+			ptr = tmp;
+		}
+		ConfigTab[i] = NULL;
+	}
+	if (extra_info != NULL) {
+		delete extra_info;
+		extra_info = NULL;
+	}
+	global_config_source       = "";
+	local_config_sources.clearAll();
+	return;
+}
+
+
+/*
+** Return the value associated with the named parameter.  Return NULL
+** if the given parameter is not defined.
+*/
+char *
+param( const char *name )
+{
+	char		*val = NULL;
+	char param_name[MAX_PARAM_LEN];
+
+	// Try in order to find the parameter
+	// As we walk through, any value (including empty string) will
+	// cause a 'match' since presumably it was set to empty
+	// specifically to clear this parameter for this specific
+	// subsystem / local.
+
+	// 1. "subsys.local.name"
+	const char	*local = get_mySubSystem()->getLocalName();
+	if (  (NULL == val) && local ) {
+		snprintf(param_name,MAX_PARAM_LEN,"%s.%s.%s",
+				 get_mySubSystem()->getName(),
+				 local,
+				 name);
+		param_name[MAX_PARAM_LEN-1]='\0';
+		strlwr(param_name);
+		val = lookup_macro_lower( param_name, ConfigTab, TABLESIZE );
+	}
+	// 2. "local.name"
+	if (  (NULL == val) && local ) {
+		snprintf(param_name,MAX_PARAM_LEN,"%s.%s",
+				 local,
+				 name);
+		param_name[MAX_PARAM_LEN-1]='\0';
+		strlwr(param_name);
+		val = lookup_macro_lower( param_name, ConfigTab, TABLESIZE );
+	}
+	// 3. "subsys.name"
+	if ( NULL == val ) {
+		snprintf(param_name,MAX_PARAM_LEN,"%s.%s",
+				 get_mySubSystem()->getName(),
+				 name);
+		param_name[MAX_PARAM_LEN-1]='\0';
+		strlwr(param_name);
+		val = lookup_macro_lower( param_name, ConfigTab, TABLESIZE );
+	}
+	// 4. "name"
+	if ( NULL == val ) {
+		snprintf(param_name,MAX_PARAM_LEN,"%s",name);
+		param_name[MAX_PARAM_LEN-1]='\0';
+		strlwr(param_name);
+		val = lookup_macro_lower( param_name, ConfigTab, TABLESIZE );
+	}
+
+	// Still nothing (or empty)?  Give up.
+	if ( (NULL == val) || (*val=='\0') ) {
+		return NULL;
+	}
+
+	if( DebugFlags & D_CONFIG ) {
+		if( strlen(name) < strlen(param_name) ) {
+			param_name[strlen(param_name)-strlen(name)] = '\0';
+			dprintf( D_CONFIG, "Config '%s': using prefix '%s' ==> '%s'\n",
+					 name, param_name, val );
+		}
+		else {
+			dprintf( D_CONFIG, "Config '%s': no prefix ==> '%s'\n", name, val );
+		}
+	}
+
+	// Ok, now expand it out...
+	val = expand_macro( val, ConfigTab, TABLESIZE );
+
+	// If it returned an empty string, free it before returning NULL
+	if( val == NULL ) {
+		return NULL;
+	} else if ( val[0] == '\0' ) {
+		free( val );
+		return( NULL );
+	} else {
+		return val;
+	}
+}
+
+/*
+** Return the integer value associated with the named paramter.
+** This version returns true if a the parameter was found, or false
+** otherwise.
+** If the value is not defined or not a valid integer, then
+** return the default_value argument .  The min_value and max_value
+** arguments are optional and default to MININT and MAXINT.
+** These range checks are disabled if check_ranges is false.
+*/
+
+bool
+param_integer( const char *name, int &value,
+			   bool use_default, int default_value,
+			   bool check_ranges, int min_value, int max_value )
+{
+	int result;
+	long long_result;
+	char *string;
+	char *endptr = NULL;
+
+	ASSERT( name );
+	string = param( name );
+	if( ! string ) {
+		dprintf( D_CONFIG, "%s is undefined, using default value of %d\n",
+				 name, default_value );
+		if ( use_default ) {
+			value = default_value;
+		}
+		return false;
+	}
+
+	long_result = strtol(string,&endptr,10);
+	result = long_result;
+
+	ASSERT(endptr);
+	if( endptr != string ) {
+		while( isspace(*endptr) ) {
+			endptr++;
+		}
+	}
+	bool valid = (endptr != string && *endptr == '\0');
+
+	if( !valid ) {
+		EXCEPT( "%s in the condor configuration is not an integer (%s)."
+		        "  Please set it to an integer in the range %d to %d"
+		        " (default %d).",
+		        name, string, min_value, max_value, default_value );
+	}
+	else if( (long)result != long_result ) {
+		EXCEPT( "%s in the condor configuration is out of bounds for"
+				" an integer (%s)."
+				"  Please set it to an integer in the range %d to %d"
+				" (default %d).",
+				name, string, min_value, max_value, default_value );
+	}
+	else if ( check_ranges  &&  ( result < min_value )  ) {
+		EXCEPT( "%s in the condor configuration is too low (%s)."
+				"  Please set it to an integer in the range %d to %d"
+				" (default %d).",
+				name, string, min_value, max_value, default_value );
+	}
+	else if ( check_ranges  && ( result > max_value )  ) {
+		EXCEPT( "%s in the condor configuration is too high (%s)."
+				"  Please set it to an integer in the range %d to %d"
+				" (default %d).",
+				name, string, min_value, max_value, default_value );
+	}
+	free( string );
+
+	value = result;
+	return true;
+}
+
+
+/*
+** Return the integer value associated with the named paramter.
+** If the value is not defined or not a valid integer, then
+** return the default_value argument.  The min_value and max_value
+** arguments are optional and default to MININT and MAXINT.
+*/
+
+int
+param_integer( const char *name, int default_value,
+			   int min_value, int max_value )
+{
+	int result;
+
+	param_integer( name, result, true, default_value,
+				   true, min_value, max_value );
+	return result;
+}
+
+int param_integer_c( const char *name, int default_value,
+					   int min_value, int max_value)
+{
+	return param_integer( name, default_value, min_value, max_value );
+}
+
+// require that the attribute I'm looking for is defined in the config file.
+char* param_or_except(const char *attr)
+{
+	char *tmp = NULL;
+
+	tmp = param(attr);
+	if (tmp == NULL || strlen(tmp) <= 0) {
+		EXCEPT("Please define config file entry to non-null value: %s", attr);
+	}
+
+	return tmp;
+}
+
+
+/*
+ * Return the [single precision] floating point value associated with the named
+ * parameter.  If the value is not defined or not a valid float, then return
+ * the default_value argument.  The min_value and max_value arguments are
+ * optional and default to DBL_MIN and DBL_MAX.
+ */
+
+double
+param_double( const char *name, double default_value,
+			   double min_value, double max_value )
+{
+	double result;
+	char *string;
+	char *endptr = NULL;
+
+	ASSERT( name );
+	string = param( name );
+	if( ! string ) {
+		dprintf( D_CONFIG, "%s is undefined, using default value of %f\n",
+				 name, default_value );
+		return default_value;
+	}
+
+	result = strtod(string,&endptr);
+
+	ASSERT(endptr);
+	if( endptr != string ) {
+		while( isspace(*endptr) ) {
+			endptr++;
+		}
+	}
+	bool valid = (endptr != string && *endptr == '\0');
+
+	if( !valid ) {
+		EXCEPT( "%s in the condor configuration is not a valid floating point number (%s)."
+		        "  Please set it to a number in the range %lg to %lg"
+		        " (default %lg).",
+		        name, string, min_value, max_value, default_value );
+	}
+	else if( result < min_value ) {
+		EXCEPT( "%s in the condor configuration is too low (%s)."
+		        "  Please set it to a number in the range %lg to %lg"
+		        " (default %lg).",
+		        name, string, min_value, max_value, default_value );
+	}
+	else if( result > max_value ) {
+		EXCEPT( "%s in the condor configuration is too high (%s)."
+		        "  Please set it to a number in the range %lg to %lg"
+		        " (default %lg).",
+		        name, string, min_value, max_value, default_value );
+	}
+	free( string );
+	return result;
+}
+
+/*
+** Return the boolean value associated with the named paramter.
+** The parameter value is expected to be set to the string
+** "TRUE" or "FALSE" (no quotes, case insensitive).
+** If the value is not defined or not a valid, then
+** return the default_value argument.
+*/
+
+bool
+param_boolean( const char *name, const bool default_value, bool do_log )
+{
+	bool result;
+	char *string;
+	char *endptr;
+	bool valid = true;
+
+	ASSERT( name );
+	string = param( name );
+	if (!string) {
+		if (do_log) {
+			dprintf( D_CONFIG, "%s is undefined, using default value of %s\n",
+					 name, default_value ? "True" : "False" );
+		}
+		return default_value;
+	}
+
+	endptr = string;
+	if( strncasecmp(endptr,"true",4) == 0 ) {
+		endptr+=4;
+		result = true;
+	}
+	else if( strncasecmp(endptr,"1",1) == 0 ) {
+		endptr+=1;
+		result = true;
+	}
+	else if( strncasecmp(endptr,"false",5) == 0 ) {
+		endptr+=5;
+		result = false;
+	}
+	else if( strncasecmp(endptr,"0",1) == 0 ) {
+		endptr+=1;
+		result = false;
+	}
+	else {
+		valid = false;
+	}
+
+	while( isspace(*endptr) ) {
+		endptr++;
+	}
+	if( *endptr != '\0' ) {
+		valid = false;
+	}
+
+	if( !valid ) {
+		EXCEPT( "%s in the condor configuration  is not a valid boolean (\"%s\")."
+		        "  Please set it to True or False (default is %s)",
+		        name, string, default_value ? "True" : "False" );
+	}
+
+	free( string );
+	
+	return result;
+}
+
+bool
+param_boolean_expr( const char *name, bool default_value, ClassAd const *me, ClassAd const *target )
+{
+	char *expr;
+	bool value = default_value;
+
+	ASSERT( name );
+	expr = param( name );
+	if( ! expr ) {
+		dprintf( D_CONFIG, "%s is undefined, using default value of %s\n",
+				 name, default_value ? "True" : "False" );
+		return default_value;
+	}
+
+	if( *expr ) {
+		ClassAd rhs;
+		if( me ) {
+			rhs = *me;
+		}
+
+		if( !rhs.AssignExpr( name, expr ) ) {
+			EXCEPT("Invalid expression for %s (%s) in config file.",
+			       name, expr);
+		}
+
+		int int_value = value;
+		if( !rhs.EvalBool(name,target,int_value) ) {
+			EXCEPT("Invalid result (not a boolean) for %s (%s) "
+			       "in condor configuration.",
+			       name, expr );
+		}
+		value = (int_value != 0);
+	}
+	free( expr );
+
+	return value;
+}
+
+char *
+macro_expand( const char *str )
+{
+	return( expand_macro(str, ConfigTab, TABLESIZE) );
+}
+
+/*
+** Same as param_boolean but for C -- returns 0 or 1
+** The parameter value is expected to be set to the string
+** "TRUE" or "FALSE" (no quotes, case insensitive).
+** If the value is not defined or not a valid, then
+** return the default_value argument.
+*/
+extern "C" int
+param_boolean_int( const char *name, int default_value )
+{
+    bool default_bool;
+
+    default_bool = default_value == 0 ? false : true;
+    return param_boolean(name, default_bool) ? 1 : 0;
+}
+
+// Note that the line_number can be -1 if the filename isn't a real
+// filename, but something like <Internal> or <Environment>
+bool param_get_location(
+	const char *parameter,
+	MyString  &filename,
+	int       &line_number)
+{
+	bool found_it;
+
+	if (parameter != NULL && extra_info != NULL) {
+		found_it = extra_info->GetParam(parameter, filename, line_number);
+	} else {
+		found_it = false;
+	}
+	return found_it;
+}
+
+void
+reinsert_specials( char* host )
+{
+	static unsigned int reinsert_pid = 0;
+	static unsigned int reinsert_ppid = 0;
+	static bool warned_no_user = false;
+	char buf[40];
+
+	if( tilde ) {
+		insert( "tilde", tilde, ConfigTab, TABLESIZE );
+		extra_info->AddInternalParam("tilde");
+	}
+	if( host ) {
+		insert( "hostname", host, ConfigTab, TABLESIZE );
+	} else {
+		insert( "hostname", my_hostname(), ConfigTab, TABLESIZE );
+	}
+	insert( "full_hostname", my_full_hostname(), ConfigTab, TABLESIZE );
+	insert( "subsystem", get_mySubSystem()->getName(), ConfigTab, TABLESIZE );
+	extra_info->AddInternalParam("hostname");
+	extra_info->AddInternalParam("full_hostname");
+	extra_info->AddInternalParam("subsystem");
+
+	// Insert login-name for our real uid as "username".  At the time
+	// we're reading in the config source, the priv state code is not
+	// initialized, so our euid will always be the same as our ruid.
+	char *myusernm = my_username();
+	if( myusernm ) {
+		insert( "username", myusernm, ConfigTab, TABLESIZE );
+		free(myusernm);
+		myusernm = NULL;
+		extra_info->AddInternalParam("username");
+	} else {
+		if( ! warned_no_user ) {
+			dprintf( D_ALWAYS, "ERROR: can't find username of current user! "
+					 "BEWARE: $(USERNAME) will be undefined\n" );
+			warned_no_user = true;
+		}
+	}
+
+	// Insert real-uid and real-gid as "real_uid" and "real_gid".
+	// Now these values are meaningless on Win32, but leaving
+	// them undefined can be undesireable, and setting them
+	// to "0" could be dangerous (that is root uid on unix),
+	// so we set them to something....
+	{
+		uid_t myruid;
+		gid_t myrgid;
+#ifdef WIN32
+			// Hmmm...
+		myruid = 666;
+		myrgid = 666;
+#else
+		myruid = getuid();
+		myrgid = getgid();
+#endif
+		snprintf(buf,40,"%u",myruid);
+		insert( "real_uid", buf, ConfigTab, TABLESIZE );
+		extra_info->AddInternalParam("real_uid");
+		snprintf(buf,40,"%u",myrgid);
+		insert( "real_gid", buf, ConfigTab, TABLESIZE );
+		extra_info->AddInternalParam("real_gid");
+	}
+		
+	// Insert values for "pid" and "ppid".  Use static values since
+	// this is expensive to re-compute on Windows.
+	// Note: we have to resort to ifdef WIN32 junk even though
+	// DaemonCore can nicely give us this information.  We do this
+	// because the config code is used by the tools as well as daemons.
+	if (!reinsert_pid) {
+#ifdef WIN32
+		reinsert_pid = ::GetCurrentProcessId();
+#else
+		reinsert_pid = getpid();
+#endif
+	}
+	snprintf(buf,40,"%u",reinsert_pid);
+	insert( "pid", buf, ConfigTab, TABLESIZE );
+	extra_info->AddInternalParam("pid");
+	if ( !reinsert_ppid ) {
+#ifdef WIN32
+		CSysinfo system_hackery;
+		reinsert_ppid = system_hackery.GetParentPID(reinsert_pid);
+#else
+		reinsert_ppid = getppid();
+#endif
+	}
+	snprintf(buf,40,"%u",reinsert_ppid);
+	insert( "ppid", buf, ConfigTab, TABLESIZE );
+	insert( "ip_address", my_ip_string(), ConfigTab, TABLESIZE );
+	extra_info->AddInternalParam("ppid");
+	extra_info->AddInternalParam("ip_address");
+}
+
+
+void
+config_insert( const char* attrName, const char* attrValue )
+{
+	if( ! (attrName && attrValue) ) {
+		return;
+	}
+	insert( attrName, attrValue, ConfigTab, TABLESIZE );
+}
+
+
+void
+check_params()
+{
+#if defined( HPUX )
+		// Only on HPUX does this check matter...
+	char* tmp;
+	if( !(tmp = param("ARCH")) ) {
+			// Arch isn't defined.  That means the user didn't define
+			// it _and_ the special file we use that maps workstation
+			// models to CPU types doesn't exist either.  Print a
+			// verbose message and exit.  -Derek Wright 8/14/98
+		fprintf( stderr, "ERROR: %s must know if you are running "
+				 "on an HPPA1 or an HPPA2 CPU.\n",
+				 myDistro->Get() );
+		fprintf( stderr, "Normally, we look in %s for your model.\n",
+				 "/opt/langtools/lib/sched.models" );
+		fprintf( stderr, "This file lists all HP models and the "
+				 "corresponding CPU type.  However,\n" );
+		fprintf( stderr, "this file does not exist on your machine "
+				 "or your model (%s)\n", sysapi_uname_arch() );
+		fprintf( stderr, "was not listed.  You should either explicitly "
+				 "set the ARCH parameter\n" );
+		fprintf( stderr, "in your config source, or install the "
+				 "sched.models file.\n" );
+		exit( 1 );
+	} else {
+		free( tmp );
+	}
+#endif
+}
+
+/* Begin code for runtime support for modifying a daemon's config source.
+   See condor_daemon_core.V6/README.config for more details. */
+
+static StringList PersistAdminList;
+
+class RuntimeConfigItem {
+public:
+	RuntimeConfigItem() : admin(NULL), config(NULL) { }
+	~RuntimeConfigItem() { if (admin) free(admin); if (config) free(config); }
+	void initialize() { admin = config = NULL; }
+	char *admin;
+	char *config;
+};
+
+#include "extArray.h"
+
+static ExtArray<RuntimeConfigItem> rArray;
+
+static MyString toplevel_persistent_config;
+
+/*
+  we want these two bools to be global, and only initialized on
+  startup, so that folks can't play tricks and change these
+  dynamically.  for example, if a site enables runtime but not
+  persistent configs, we can't allow someone to set
+  "ENABLE_PERSISTENT_CONFIG" with a condor_config_val -rset.
+  therefore, we only read these once, before we look at any of the
+  dynamic config source, to make sure we're happy.  this means it
+  requires a restart to change any of these, but i think that's a
+  reasonable burden on admins, considering the potential security
+  implications.  -derek 2006-03-17
+*/
+static bool enable_runtime;
+static bool enable_persistent;
+
+static void
+init_dynamic_config()
+{
+	static bool initialized = false;
+
+	if( initialized ) {
+			// already have a value, we're done
+		return;
+	}
+
+	enable_runtime = param_boolean( "ENABLE_RUNTIME_CONFIG", false );
+	enable_persistent = param_boolean( "ENABLE_PERSISTENT_CONFIG", false );
+	initialized = true;
+
+	if( !enable_persistent ) {
+			// we don't want persistent configs, leave the toplevel blank
+		return;
+	}
+
+	char* tmp;
+
+		// if we're using runtime config, try a subsys-specific config
+		// knob for the root location
+	MyString filename_parameter;
+	filename_parameter.sprintf( "%s_CONFIG", get_mySubSystem()->getName() );
+	tmp = param( filename_parameter.Value() );
+	if( tmp ) {
+		toplevel_persistent_config = tmp;
+		free( tmp );
+		return;
+	}
+
+	tmp = param( "PERSISTENT_CONFIG_DIR" );
+
+	if( !tmp ) {
+		if ( get_mySubSystem()->isClient( ) || !have_config_source ) {
+				/*
+				   we are just a tool, not a daemon.
+				   or, we were explicitly told we don't have
+				   the usual config sources.
+				   thus it is not imperative that we find what we
+				   were looking for...
+				*/
+			return;
+		} else {
+				// we are a daemon.  if we fail, we must exit.
+			fprintf( stderr, "%s error: ENABLE_PERSISTENT_CONFIG is TRUE, "
+					 "but neither %s nor PERSISTENT_CONFIG_DIR is "
+					 "specified in the configuration file\n",
+					 myDistro->GetCap(), filename_parameter.Value() );
+			exit( 1 );
+		}
+	}
+	toplevel_persistent_config.sprintf( "%s%c.config.%s", tmp,
+										DIR_DELIM_CHAR,
+										get_mySubSystem()->getName() );
+	free(tmp);
+}
+
+
+/*
+** Caller is responsible for allocating admin and config with malloc.
+** Caller should not free admin and config after the call.
+*/
+
+#define ABORT \
+	if(admin) { free(admin); } \
+	if(config) { free(config); } \
+	set_priv(priv); \
+	return -1
+
+int
+set_persistent_config(char *admin, char *config)
+{
+	int fd, rval;
+	char *tmp;
+	MyString filename;
+	MyString tmp_filename;
+	priv_state priv;
+
+	if (!admin || !admin[0] || !enable_persistent) {
+		if (admin)  { free(admin);  }
+		if (config) { free(config); }
+		return -1;
+	}
+
+	// make sure top level config source is set
+	init_dynamic_config();
+	if( ! toplevel_persistent_config.Length() ) {
+		EXCEPT( "Impossible: programmer error: toplevel_persistent_config "
+				"is 0-length, but we already initialized, enable_persistent "
+				"is TRUE, and set_persistent_config() has been called" );
+	}
+
+	priv = set_root_priv();
+	if (config && config[0]) {	// (re-)set config
+			// write new config to temporary file
+		filename.sprintf( "%s.%s", toplevel_persistent_config.Value(), admin );
+		tmp_filename.sprintf( "%s.tmp", filename.Value() );
+		do {
+			unlink( tmp_filename.Value() );
+			fd = safe_open_wrapper( tmp_filename.Value(), O_WRONLY|O_CREAT|O_EXCL, 0644 );
+		} while (fd == -1 && errno == EEXIST);
+		if( fd < 0 ) {
+			dprintf( D_ALWAYS, "safe_open_wrapper(%s) returned %d '%s' (errno %d) in "
+					 "set_persistent_config()\n", tmp_filename.Value(),
+					 fd, strerror(errno), errno );
+			ABORT;
+		}
+		if (write(fd, config, strlen(config)) != (ssize_t)strlen(config)) {
+			dprintf( D_ALWAYS, "write() failed with '%s' (errno %d) in "
+					 "set_persistent_config()\n", strerror(errno), errno );
+			ABORT;
+		}
+		if (close(fd) < 0) {
+			dprintf( D_ALWAYS, "close() failed with '%s' (errno %d) in "
+					 "set_persistent_config()\n", strerror(errno), errno );
+			ABORT;
+		}
+		
+			// commit config changes
+		if (rotate_file(tmp_filename.Value(), filename.Value()) < 0) {
+			dprintf( D_ALWAYS, "rotate_file(%s,%s) failed with '%s' "
+					 "(errno %d) in set_persistent_config()\n",
+					 tmp_filename.Value(), filename.Value(),
+					 strerror(errno), errno );
+			ABORT;
+		}
+	
+		// update admin list in memory
+		if (!PersistAdminList.contains(admin)) {
+			PersistAdminList.append(admin);
+		} else {
+			free(admin);
+			free(config);
+			set_priv(priv);
+			return 0;		// if no update is required, then we are done
+		}
+
+	} else {					// clear config
+
+		// update admin list in memory
+		PersistAdminList.remove(admin);
+		if (config) {
+			free(config);
+			config = NULL;
+		}
+	}		
+
+	// update admin list on disk
+	tmp_filename.sprintf( "%s.tmp", toplevel_persistent_config.Value() );
+	do {
+		unlink( tmp_filename.Value() );
+		fd = safe_open_wrapper( tmp_filename.Value(), O_WRONLY|O_CREAT|O_EXCL, 0644 );
+	} while (fd == -1 && errno == EEXIST);
+	if( fd < 0 ) {
+		dprintf( D_ALWAYS, "safe_open_wrapper(%s) returned %d '%s' (errno %d) in "
+				 "set_persistent_config()\n", tmp_filename.Value(),
+				 fd, strerror(errno), errno );
+		ABORT;
+	}
+	const char param[] = "RUNTIME_CONFIG_ADMIN = ";
+	if (write(fd, param, strlen(param)) != (ssize_t)strlen(param)) {
+		dprintf( D_ALWAYS, "write() failed with '%s' (errno %d) in "
+				 "set_persistent_config()\n", strerror(errno), errno );
+		ABORT;
+	}
+	PersistAdminList.rewind();
+	bool first_time = true;
+	while( (tmp = PersistAdminList.next()) ) {
+		if (!first_time) {
+			if (write(fd, ", ", 2) != 2) {
+				dprintf( D_ALWAYS, "write() failed with '%s' (errno %d) in "
+						 "set_persistent_config()\n", strerror(errno), errno );
+				ABORT;
+			}
+		} else {
+			first_time = false;
+		}
+		if (write(fd, tmp, strlen(tmp)) != (ssize_t)strlen(tmp)) {
+			dprintf( D_ALWAYS, "write() failed with '%s' (errno %d) in "
+					 "set_persistent_config()\n", strerror(errno), errno );
+			ABORT;
+		}
+	}
+	if (write(fd, "\n", 1) != 1) {
+		dprintf( D_ALWAYS, "write() failed with '%s' (errno %d) in "
+				 "set_persistent_config()\n", strerror(errno), errno );
+		ABORT;
+	}
+	if (close(fd) < 0) {
+		dprintf( D_ALWAYS, "close() failed with '%s' (errno %d) in "
+				 "set_persistent_config()\n", strerror(errno), errno );
+		ABORT;
+	}
+	
+	rval = rotate_file( tmp_filename.Value(),
+						toplevel_persistent_config.Value() );
+	if (rval < 0) {
+		dprintf( D_ALWAYS, "rotate_file(%s,%s) failed with '%s' (errno %d) "
+				 "in set_persistent_config()\n", tmp_filename.Value(),
+				 filename.Value(), strerror(errno), errno );
+		ABORT;
+	}
+
+	// if we removed a config, then we should clean up by removing the file(s)
+	if (!config || !config[0]) {
+		filename.sprintf( "%s.%s", toplevel_persistent_config.Value(), admin );
+		unlink( filename.Value() );
+		if (PersistAdminList.number() == 0) {
+			unlink( toplevel_persistent_config.Value() );
+		}
+	}
+
+	set_priv( priv );
+	free( admin );
+	if (config) { free( config ); }
+	return 0;
+}
+
+
+int
+set_runtime_config(char *admin, char *config)
+{
+	int i;
+
+	if (!admin || !admin[0] || !enable_runtime) {
+		if (admin)  { free(admin);  }
+		if (config) { free(config); }
+		return -1;
+	}
+
+	if (config && config[0]) {
+		for (i=0; i <= rArray.getlast(); i++) {
+			if (strcmp(rArray[i].admin, admin) == MATCH) {
+				free(admin);
+				free(rArray[i].config);
+				rArray[i].config = config;
+				return 0;
+			}
+		}
+		rArray[i].admin = admin;
+		rArray[i].config = config;
+	} else {
+		for (i=0; i <= rArray.getlast(); i++) {
+			if (strcmp(rArray[i].admin, admin) == MATCH) {
+				free(admin);
+				if (config) free(config);
+				free(rArray[i].admin);
+				free(rArray[i].config);
+				rArray[i] = rArray[rArray.getlast()];
+				rArray[rArray.getlast()].initialize();
+				rArray.truncate(rArray.getlast()-1);
+				return 0;
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+extern "C" {
+
+static int
+process_persistent_configs()
+{
+	char *tmp = NULL;
+	int rval;
+	bool processed = false;
+
+	if( access( toplevel_persistent_config.Value(), R_OK ) == 0 &&
+		PersistAdminList.number() == 0 )
+	{
+		processed = true;
+
+		rval = Read_config( toplevel_persistent_config.Value(), ConfigTab,
+							TABLESIZE, EXPAND_LAZY, true, extra_info );
+		if (rval < 0) {
+			dprintf( D_ALWAYS, "Configuration Error Line %d while reading "
+					 "top-level persistent config source: %s\n",
+					 ConfigLineNo, toplevel_persistent_config.Value() );
+			exit(1);
+		}
+
+		tmp = param ("RUNTIME_CONFIG_ADMIN");
+		if (tmp) {
+			PersistAdminList.initializeFromString(tmp);
+			free(tmp);
+		}
+	}
+
+	PersistAdminList.rewind();
+	while ((tmp = PersistAdminList.next())) {
+		processed = true;
+		MyString config_source;
+		config_source.sprintf( "%s.%s", toplevel_persistent_config.Value(),
+							   tmp );
+		rval = Read_config( config_source.Value(), ConfigTab, TABLESIZE,
+							 EXPAND_LAZY, true, extra_info );
+		if (rval < 0) {
+			dprintf( D_ALWAYS, "Configuration Error Line %d "
+					 "while reading persistent config source: %s\n",
+					 ConfigLineNo, config_source.Value() );
+			exit(1);
+		}
+	}
+	return (int)processed;
+}
+
+
+static int
+process_runtime_configs()
+{
+	int i, rval, fd;
+	bool processed = false;
+
+	for (i=0; i <= rArray.getlast(); i++) {
+		processed = true;
+
+		char* tmp_dir = temp_dir_path();
+		ASSERT(tmp_dir);
+		MyString tmp_file_tmpl = tmp_dir;
+		free(tmp_dir);
+		tmp_file_tmpl += "/cndrtmpXXXXXX";
+
+		char* tmp_file = strdup(tmp_file_tmpl.Value());
+		fd = condor_mkstemp( tmp_file );
+		if (fd < 0) {
+			dprintf( D_ALWAYS, "condor_mkstemp(%s) returned %d, '%s' (errno %d) in "
+				 "process_dynamic_configs()\n", tmp_file, fd,
+				 strerror(errno), errno );
+			exit(1);
+		}
+
+		if (write(fd, rArray[i].config, strlen(rArray[i].config))
+			!= (ssize_t)strlen(rArray[i].config)) {
+			dprintf( D_ALWAYS, "write failed with errno %d in "
+					 "process_dynamic_configs\n", errno );
+			exit(1);
+		}
+		if (close(fd) < 0) {
+			dprintf( D_ALWAYS, "close failed with errno %d in "
+					 "process_dynamic_configs\n", errno );
+			exit(1);
+		}
+		rval = Read_config( tmp_file, ConfigTab, TABLESIZE,
+							EXPAND_LAZY, false, extra_info );
+		if (rval < 0) {
+			dprintf( D_ALWAYS, "Configuration Error Line %d "
+					 "while reading %s, runtime config: %s\n",
+					 ConfigLineNo, tmp_file, rArray[i].admin );
+			exit(1);
+		}
+		unlink(tmp_file);
+		free(tmp_file);
+	}
+
+	return (int)processed;
+}
+
+
+/*
+** returns 1 if dynamic (runtime or persistent) configs were
+** processed; 0 if no dynamic configs were defined, and -1 on error.
+*/
+static int
+process_dynamic_configs()
+{
+	int per_rval = 0;
+	int run_rval = 0;
+
+	init_dynamic_config();
+
+	if( enable_persistent ) {
+		per_rval = process_persistent_configs();
+	}
+
+	if( enable_runtime ) {
+		run_rval = process_runtime_configs();
+	}
+
+	if( per_rval < 0 || run_rval < 0 ) {
+		return -1;
+	}
+	if( per_rval || run_rval ) {
+		return 1;
+	}
+	return 0;
+}
+
+} // end of extern "C"
+
+/* End code for runtime support for modifying a daemon's config source. */
diff --git a/src/condor_c++_util/directory.WINDOWS.cpp b/src/condor_c++_util/directory.WINDOWS.cpp
index f146e97..801d584 100644
--- a/src/condor_c++_util/directory.WINDOWS.cpp
+++ b/src/condor_c++_util/directory.WINDOWS.cpp
@@ -28,6 +28,7 @@
 #include "remote_close.WINDOWS.h"
 #include "string_conversion.WINDOWS.h"
 #include "security.WINDOWS.h"
+#include "deprintf.h"
 
 #include <winioctl.h>
 
@@ -92,13 +93,9 @@ PrintFormatedErrorMessage ( DWORD last_error, DWORD flags = 0 ) {
         if ( 0 == length ) {
 
             last_error = GetLastError ();
-
-            dprintf (
-                D_FULLDEBUG,
-                "PrintFormatedErrorMessage: failed to retrieve error "
-                "message. (last-error = %u)\n", 
-                last_error );
-
+			deprintf(D_FULLDEBUG,last_error,
+				"PrintFormatedErrorMessage: failed to retrieve error "
+				"message.\n");
             __leave;
 
         }
@@ -772,14 +769,8 @@ CondorTryCopyReparsePoint (
         if ( INVALID_HANDLE_VALUE == source ) {
 
             last_error = GetLastError ();
-
-            dprintf ( 
-                D_FULLDEBUG, 
-                "CondorTryCopyReparsePoint: Unable to open source "
-                "'%S'. (last-error = %u)\n", 
-                w_source, 
-                last_error );
-
+			deprintf(D_FULLDEBUG,last_error,"CondorTryCopyReparsePoint: Unable to open source "
+				"'%S'.\n", w_source);
             __leave;
 
         }
@@ -799,13 +790,16 @@ CondorTryCopyReparsePoint (
 
             last_error = GetLastError ();
 
-            dprintf ( 
+            /*dprintf ( 
                 D_FULLDEBUG,
                 "CondorTryCopyReparsePoint: Unable to get "
                 "reparse point information."
                 "(last-error = %u)\n",
-                last_error );
-
+                last_error );*/
+			deprintf(D_FULLDEBUG,last_error,
+				"CondorTryCopyReparsePoint: Unable to get "
+                "reparse point information.\n"
+				);
             __leave;
 
         }
@@ -820,12 +814,9 @@ CondorTryCopyReparsePoint (
             
             last_error = GetLastError ();
 
-            dprintf ( 
-                D_FULLDEBUG, 
-                "CondorTryCopyReparsePoint: Unable to create "
-                "destination directory '%S'. (last-error = %u)\n", 
-                w_destination, 
-                last_error );
+			deprintf(D_FULLDEBUG,last_error,
+				"CondorTryCopyReparsePoint: Unable to create "
+				"destination directory '%S'.\n", w_destination);
 
             __leave;
 
@@ -847,13 +838,9 @@ CondorTryCopyReparsePoint (
         if ( INVALID_HANDLE_VALUE == destination ) {
 
             last_error = GetLastError ();
-
-            dprintf ( 
-                D_FULLDEBUG, 
-                "CondorTryCopyReparsePoint: Unable to open "
-                "destination directory '%S'. (last-error = %u)\n", 
-                w_destination, 
-                last_error );
+			deprintf(D_FULLDEBUG,last_error,
+				"CondorTryCopyReparsePoint: Unable to open "
+				"destination directory '%S'.\n", w_destination);
 
             __leave;
 
@@ -873,15 +860,9 @@ CondorTryCopyReparsePoint (
         if ( !io_success ) {
 
             last_error = GetLastError ();
-
-            dprintf ( 
-                D_FULLDEBUG, 
-                "CondorTryCopyReparsePoint: Unable to set "
-                "destination information for '%S'. "
-                "(last-error = %u)\n", 
-                w_destination, 
-                last_error );
-
+			deprintf(D_FULLDEBUG,last_error,
+				"CondorTryCopyReparsePoint: Unable to set "
+                "destination information for '%S'.\n", w_destination);
             __leave;
 
         }        
@@ -959,13 +940,10 @@ CondorCopyDirectoryImpl (
 
             } 
 
-            dprintf ( 
-                D_FULLDEBUG, 
-                "CondorCopyDirectoryImpl: Unable to search in "
-                "'%S'. (last-error = %u)\n", 
-                w_source, 
-                last_error );
-
+			deprintf(D_FULLDEBUG,last_error,
+				"CondorCopyDirectoryImpl: Unable to search in "
+				"'%S'.\n", 
+                w_source);
             dprintf ( 
                 D_FULLDEBUG, 
                 "Trace:\n" );
@@ -1025,13 +1003,10 @@ CondorCopyDirectoryImpl (
 
                         last_error = GetLastError ();
 
-                        dprintf ( 
-                            D_FULLDEBUG, 
-                            "CondorCopyDirectoryImpl: "
-                            "Unable to copy the directory '%S'. "
-                            "(last-error = %u)\n", 
-                            find_data.cFileName, 
-                            last_error );
+						deprintf(D_FULLDEBUG,last_error,
+							"CondorCopyDirectoryImpl: "
+							"Unable to copy the directory '%S'.\n",
+							find_data.cFileName);
 
                         __leave;
 
@@ -1052,14 +1027,11 @@ CondorCopyDirectoryImpl (
                 }
 
                 last_error = GetLastError ();
-                
-                dprintf ( 
-                    D_FULLDEBUG, 
-                    "CondorCopyDirectoryImpl: "
-                    "Copying '%S' %s. (last-error = %u)\n", 
+                deprintf(D_FULLDEBUG,last_error,
+					"CondorCopyDirectoryImpl: "
+					"Copying '%S' %s.\n", 
                     find_data.cFileName, 
-                    entry_created ? "succeeded" : "failed", 
-                    last_error );
+                    entry_created ? "succeeded" : "failed");
 
 				/* re-apply the file attributes that we removed */
 				SetFileAttributesW ( 
@@ -1204,15 +1176,20 @@ CondorCopyDirectory (
 
                 last_error = GetLastError ();
 
-                dprintf ( 
+				if(removed)
+				{
+					dprintf ( 
                     D_FULLDEBUG, 
                     "CondorCopyDirectory: Removing locked directory "
-                    "'%s' %s. (last-error = %u)\n", 
-                    destination,
-                    removed ? "succeeded" : "failed", 
-                    removed ? 0 : last_error );
-
+                    "'%s' succeeded.\n", 
+                    destination);
+				}
                 if ( !removed ) {
+					deprintf(D_FULLDEBUG,last_error,
+					"CondorCopyDirectory: Removing locked directory "
+					"'%s' failed.\n", 
+                    destination);
+
                     __leave;
                 }
 
@@ -1242,14 +1219,11 @@ CondorCopyDirectory (
         if ( !copied ) {
 
             last_error = GetLastError ();
-            
-            dprintf ( 
-                D_FULLDEBUG, 
-                "CondorCopyDirectory: Unable to copy from '%S' to "
-                "'%S' (last-error = %u)\n", 
+            deprintf(D_FULLDEBUG,last_error,
+				"CondorCopyDirectory: Unable to copy from '%S' to "
+				"'%S'.\n", 
                 w_source, 
-                w_destination, 
-                last_error );
+                w_destination);
 
             __leave;
 
@@ -1269,13 +1243,9 @@ CondorCopyDirectory (
                 FALSE );
             
             if ( !removed ) {
-                
-                dprintf ( 
-                    D_FULLDEBUG, 
-                    "CondorCopyDirectory: Failed to remove "
-                    "'%s' privilege. (last-error = %d)\n",
-                    privelages[i],
-                    GetLastError () ); 
+                deprintf(D_FULLDEBUG,GetLastError(),
+					"CondorCopyDirectory: Failed to remove "
+					"'%s' privilege.\n",privelages[i]);
                 
             }
             
@@ -1654,12 +1624,10 @@ CondorRemoveDirectoryImpl (
             
             } 
             
-            dprintf ( 
-                D_FULLDEBUG, 
-                "CondorRemoveDirectoryImpl: Unable to search in "
-                "'%S'. (last-error = %u)\n", 
-                w_directory, 
-                last_error );
+			deprintf(D_FULLDEBUG,last_error,
+				"CondorRemoveDirectoryImpl: Unable to search in "
+				"'%S'.\n",
+				w_directory);
 
             dprintf ( 
                 D_FULLDEBUG, 
@@ -1706,13 +1674,11 @@ CondorRemoveDirectoryImpl (
 
                         last_error = GetLastError ();
 
-                        dprintf ( 
-                            D_FULLDEBUG, 
-                            "CondorRemoveDirectoryImpl: "
+						deprintf(D_FULLDEBUG,last_error,
+							"CondorRemoveDirectoryImpl: "
                             "Unable to delete the contents of "
-                            "directory '%S'. (last-error = %u)\n", 
-                            find_data.cFileName, 
-                            last_error );
+							"directory '%S'.\n", 
+                            find_data.cFileName);
 
                         __leave;
 
@@ -1733,17 +1699,23 @@ CondorRemoveDirectoryImpl (
 
                 last_error = GetLastError ();
 
-                dprintf ( 
-                    D_FULLDEBUG, 
-                    "CondorRemoveDirectoryImpl: "
-                    "Removing '%S' %s. (last-error = %u)\n", 
-                    find_data.cFileName, 
-                    entry_removed ? "succeeded" : "failed", 
-                    last_error );
+				if(entry_removed)
+				{
+					dprintf ( 
+						D_FULLDEBUG, 
+						"CondorRemoveDirectoryImpl: "
+						"Removing '%S' succeeded.\n", 
+						find_data.cFileName);
+				}
+				else
+				{
+					deprintf(D_FULLDEBUG,last_error,
+						"CondorRemoveDirectoryImpl: "
+						"Removing '%S' failed.\n", 
+						find_data.cFileName);
+					__leave;
+				}
 
-                if ( !entry_removed ) {
-                    __leave;
-                }
                 
                 delete [] w_current;    
                 w_current = NULL;
@@ -1849,18 +1821,23 @@ CondorRemoveDirectory ( PCSTR directory ) {
 
         last_error = GetLastError ();
         
-        dprintf ( 
-            D_FULLDEBUG, 
-            "CondorRemoveDirectory: Deleting the "
-            "contents of '%s' %s. (last-error = %u)\n", 
-            directory, 
-            removed ? "succeeded" : "failed",
-            last_error );
-
-        if ( !removed ) {
-            __leave;
-        }
-
+		if(removed)
+		{
+			dprintf ( 
+				D_FULLDEBUG, 
+				"CondorRemoveDirectory: Deleting the "
+				"contents of '%s' succeeded.\n", 
+				directory);
+		}
+		else
+		{
+			deprintf(D_FULLDEBUG,last_error,
+				"CondorRemoveDirectory: Deleting the "
+				"contents of '%s' failed.\n", 
+				directory);
+
+			__leave;
+		}
         /* finally, now that we are done with deleting the contents of 
         the given directory, delete it too */
         removed = CondorTryRemoveDirectory ( 
@@ -1868,16 +1845,25 @@ CondorRemoveDirectory ( PCSTR directory ) {
 
         last_error = GetLastError ();
 
-        dprintf ( 
-            D_FULLDEBUG, 
-            "CondorRemoveDirectory: Deleting the "
-            "directory '%s' %s. (last-error = %u)\n",
-            directory, 
-            removed ? ERROR_SUCCESS : last_error );
-
-        if ( !removed ) {
-            __leave;
-        }
+		if(removed)
+		{
+			dprintf ( 
+				D_FULLDEBUG, 
+				"CondorRemoveDirectory: Deleting the "
+				"contents of '%s' succeeded.\n", 
+				directory);
+		}
+		else
+		{
+			dprintf ( 
+				D_FULLDEBUG, 
+				"CondorRemoveDirectory: Deleting the "
+				"contents of '%s' failed. (last-error: %ls)\n", 
+				directory,
+				last_error );
+
+			__leave;
+		}
         
         /* we made it, it's all ok */
         ok = TRUE;
@@ -1893,14 +1879,10 @@ CondorRemoveDirectory ( PCSTR directory ) {
                 FALSE );
             
             if ( !removed ) {
-                
-                dprintf ( 
-                    D_FULLDEBUG, 
-                    "CondorRemoveDirectory: Failed to remove "
-                    "'%s' privilege. (last-error = %d)\n",
-                    privelages[i],
-                    GetLastError () );
-                
+                deprintf(D_FULLDEBUG,GetLastError(),
+					"CondorRemoveDirectory: Failed to remove "
+					"'%s' privilege.\n",
+					privelages[i]);             
             }
             
         }
@@ -1998,13 +1980,8 @@ CreateSubDirectory ( PCSTR path, LPSECURITY_ATTRIBUTES sa ) {
                     last_error = GetLastError ();
 
                     if ( ERROR_ALREADY_EXISTS != last_error ) {
-                        
-                        dprintf (
-                            D_FULLDEBUG,
-                            "CreateSubDirectory: failed. "
-                            "(last-error = %d)\n",
-                            last_error );
-
+                        deprintf(D_FULLDEBUG,last_error,
+							"CreateSubDirectory: failed.\n");
                         __leave;
 
                     }
@@ -2083,11 +2060,8 @@ CreateUserDirectory ( HANDLE user_token, PCSTR directory ) {
 
             last_error = GetLastError ();
 
-            dprintf (
-                D_FULLDEBUG,
-                "CreateUserDirectory: Failed to get user SID. "
-                "(last-error = %d)\n",
-                last_error  );
+			deprintf(D_FULLDEBUG,last_error,
+				"CreateUserDirectory: Failed to get user SID.\n");
 
             __leave;
 
@@ -2103,12 +2077,8 @@ CreateUserDirectory ( HANDLE user_token, PCSTR directory ) {
         if ( !got_sid ) {
             
             last_error = GetLastError ();            
-            
-            dprintf (
-                D_FULLDEBUG,
-                "CreateUserDirectory: Failed to get system SID. "
-                "(last-error = %d)\n",
-                last_error  );
+			deprintf(D_FULLDEBUG,last_error,
+				"CreateUserDirectory: Failed to get system SID.\n");
             
             __leave;
             
@@ -2125,12 +2095,7 @@ CreateUserDirectory ( HANDLE user_token, PCSTR directory ) {
         if ( !got_sid ) {
             
             last_error = GetLastError ();            
-            
-            dprintf (
-                D_FULLDEBUG,
-                "CreateUserDirectory: Failed to get admin SID. "
-                "(last-error = %d)\n",
-                last_error  );
+            deprintf(D_FULLDEBUG,last_error,"CreateUserDirectory: Failed to get admin SID.\n");
             
             __leave;
             
@@ -2153,13 +2118,7 @@ CreateUserDirectory ( HANDLE user_token, PCSTR directory ) {
         if ( !initialized ) {
 
             last_error = GetLastError ();            
-            
-            dprintf (
-                D_FULLDEBUG,
-                "CreateUserDirectory: Failed to Initialize ACL. "
-                "(last-error = %d)\n",
-                last_error );
-            
+            deprintf(D_FULLDEBUG,last_error,"CreateUserDirectory: Failed to Initialize ACL.\n");
             __leave;
 
         }
@@ -2177,14 +2136,10 @@ CreateUserDirectory ( HANDLE user_token, PCSTR directory ) {
             if ( !added ) {
                 
                 last_error = GetLastError ();            
-                
-                dprintf (
-                    D_FULLDEBUG,
-                    "CreateUserDirectory: Failed to initialize "
-                    "non-inheritable access-control list. "
-                    "(last-error = %d)\n",
-                    last_error );
-                
+                deprintf(D_FULLDEBUG,last_error,
+					"CreateUserDirectory: Failed to initialize "
+                    "non-inheritable access-control list. ");
+
                 __leave;
                 
             }
@@ -2206,14 +2161,9 @@ CreateUserDirectory ( HANDLE user_token, PCSTR directory ) {
             if ( !added ) {
                 
                 last_error = GetLastError ();            
-                
-                dprintf (
-                    D_FULLDEBUG,
-                    "CreateUserDirectory: Failed to initialize "
-                    "inheritable access-control list. "
-                    "(last-error = %d)\n",
-                    last_error );
-                
+                deprintf(D_FULLDEBUG,last_error,
+					"CreateUserDirectory: Failed to initialize "
+                    "inheritable access-control list.\n");
                 __leave;
                 
             }
@@ -2228,13 +2178,9 @@ CreateUserDirectory ( HANDLE user_token, PCSTR directory ) {
         if ( !sd_initialized ) {
             
             last_error = GetLastError ();            
-            
-            dprintf (
-                D_FULLDEBUG,
-                "CreateUserDirectory: Failed to initialize security "
-                "descriptor. (last-error = %d)\n",
-                last_error );
-            
+            deprintf(D_FULLDEBUG,last_error,
+				"CreateUserDirectory: Failed to initialize security "
+				"descriptor.\n");
             __leave;
             
         }
@@ -2248,13 +2194,9 @@ CreateUserDirectory ( HANDLE user_token, PCSTR directory ) {
         if ( !sd_set ) {
             
             last_error = GetLastError ();            
-            
-            dprintf (
-                D_FULLDEBUG,
-                "CreateUserDirectory: Failed to initialize security "
-                "descriptor DACL. (last-error = %d)\n",
-                last_error );
-            
+            deprintf(D_FULLDEBUG,last_error,
+				"CreateUserDirectory: Failed to initialize security "
+				"descriptor DACL.\n");
             __leave;
             
         }  
@@ -2272,13 +2214,9 @@ CreateUserDirectory ( HANDLE user_token, PCSTR directory ) {
         if ( !created ) {
             
             last_error = GetLastError ();            
-            
-            dprintf (
-                D_FULLDEBUG,
-                "CreateUserDirectory: Failed to create user's "
-                "directory. (last-error = %d)\n",
-                last_error );
-            
+            deprintf(D_FULLDEBUG,last_error,
+				"CreateUserDirectory: Failed to create user's "
+				"directory.\n");
             __leave;
             
         }            
diff --git a/src/condor_c++_util/dynuser.cpp b/src/condor_c++_util/dynuser.cpp
index f1f0bd5..984c6a5 100644
--- a/src/condor_c++_util/dynuser.cpp
+++ b/src/condor_c++_util/dynuser.cpp
@@ -28,6 +28,7 @@
 #include <lmwksta.h>
 #include <lmapibuf.h>
 
+#include "deprintf.h"
 
 // language-independant way to get at the name of the Local System account
 // delete[] the result!
@@ -85,7 +86,8 @@ getWellKnownName( DWORD subAuth1, DWORD subAuth2, bool domainname ) {
 		subAuth2,
 		0,0, 0, 0, 0, 0,
 		&pSystemSID) ) {
-		printf( "AllocateAndInitializeSid Error %u\n", GetLastError() );
+		//printf( "AllocateAndInitializeSid Error %u\n", GetLastError() );
+		deprintf(D_ALWAYS,GetLastError(),"AllocateAndInitializeSid Error.\n");
 		return NULL;
 	}
 	
@@ -103,7 +105,8 @@ getWellKnownName( DWORD subAuth1, DWORD subAuth2, bool domainname ) {
 	FreeSid(pSystemSID);
 	
 	if ( ! result ) {
-		printf( "LookupAccountSid Error %u\n", GetLastError() );
+		//printf( "LookupAccountSid Error %u\n", GetLastError() );
+		deprintf(D_ALWAYS,GetLastError(),"LookupAccountSid Error.\n");
 		return NULL;
 	} else if ( domainname ) {
 		delete[] systemName;
@@ -308,8 +311,9 @@ bool dynuser::logon_user(){
 		LOGON32_PROVIDER_DEFAULT,	// Logon provider
 		&logon_token)				// And the token to stuff it in.
 		) {
-			dprintf(D_ALWAYS,"LogonUser(%s, ... ) failed with status %d\n",
-				accountname,GetLastError());
+			/*dprintf(D_ALWAYS,"LogonUser(%s, ... ) failed with status %d\n",
+				accountname,GetLastError());*/
+			deprintf(D_ALWAYS,GetLastError(),"LogonUser(%s, ...) failed.\n", accountname);
 			return false;
 	}
 	
@@ -456,8 +460,9 @@ void dynuser::update_t() {
 	if ( accountname && accountname_t ) {
 		if (!MultiByteToWideChar( CP_ACP, MB_ERR_INVALID_CHARS, 
 					accountname, -1, accountname_t, 100)) {
-			dprintf(D_ALWAYS, "DynUser: MultiByteToWideChar() failed "
-					"error=%li\n", GetLastError());
+			/*dprintf(D_ALWAYS, "DynUser: MultiByteToWideChar() failed "
+					"error=%li\n", GetLastError());*/
+			deprintf(D_ALWAYS,GetLastError(),"DynUser: MultiByteToWideChar() failed.\n");
 			EXCEPT("Unexpected failure in dynuser:update_t\n");
 		}
 	}
@@ -482,8 +487,9 @@ void dynuser::update_t() {
 				return;
 		} 
 
-		dprintf(D_ALWAYS, "DynUser: MultiByteToWideChar() failed "
-				"error=%li\n", GetLastError());
+		/*dprintf(D_ALWAYS, "DynUser: MultiByteToWideChar() failed "
+				"error=%li\n", GetLastError());*/
+		deprintf(D_ALWAYS,GetLastError(),"DynUser: MultiByteToWideChar() failed.\n");
 		EXCEPT("Unexpected failure in dynuser:update_t\n");
 	}
 }
@@ -576,9 +582,9 @@ bool dynuser::hide_user() {
 			&subkey );
 
 		if ( ERROR_SUCCESS != ok || NULL == subkey ) {
-			dprintf ( D_FULLDEBUG,"dynuser::hide_user() "
-				"RegCreateKey(HKEY_LOCAL_MACHINE, %s) failed "
-				"(error=%d)\n", subkey_name, GetLastError () );
+			deprintf(D_FULLDEBUG, GetLastError(), 
+				"dynuser::hide_user() "
+				"RegCreateKey(HKEY_LOCAL_MACHINE, %s) failed.\n", subkey_name);
 			__leave;
 		}
 		
@@ -592,9 +598,9 @@ bool dynuser::hide_user() {
 			sizeof ( DWORD ) );
 
 		if ( ERROR_SUCCESS != ok ) {
-			dprintf ( D_FULLDEBUG,"dynuser::hide_user() "
-				"RegSetValueEx(%s, hide_user=0)) failed "
-				"(error=%d)\n", accountname, GetLastError () );
+			deprintf(D_FULLDEBUG, GetLastError(),
+				"dynuser::hide_user() "
+				"RegSetValueEx(%s, hide_user=0)) failed.\n", accountname);
 			__leave;
 		}
 
@@ -611,9 +617,10 @@ bool dynuser::hide_user() {
 	}
 
 	if ( ERROR_SUCCESS != ok ) {
-		dprintf ( D_FULLDEBUG,"dynuser::hide_user() failed "
-			"to hide user \"%s\" from the Windows Welcom Screen "
-			"(error=%d)\n", accountname, GetLastError () );
+		deprintf(D_FULLDEBUG,GetLastError(), 
+			"dynuser::hide_user() failed "
+			"to hide user \"%s\" from the Windows Welcome Screen ",
+			accountname);
 		return false;
 	}
 
diff --git a/src/condor_c++_util/executable_scripts.WINDOWS.cpp b/src/condor_c++_util/executable_scripts.WINDOWS.cpp
index cac88d7..c8fece8 100644
--- a/src/condor_c++_util/executable_scripts.WINDOWS.cpp
+++ b/src/condor_c++_util/executable_scripts.WINDOWS.cpp
@@ -24,6 +24,7 @@
 #include "condor_common.h"				/* pre-compiled header */
 #include "condor_config.h"				/* for param */
 #include "executable_scripts.WINDOWS.h" /* our header file */
+#include "deprintf.h"
 
 /***************************************************************
 * Macros
@@ -211,16 +212,13 @@ GetExecutableAndArgumentTemplateByExtention (
 		if ( INVALID_HANDLE_VALUE == found ) {
 
 			last_error = GetLastError ();
-
-			dprintf (
-                D_ALWAYS,
+			deprintf(D_ALWAYS,last_error,
 				"GetExecutableAndArgumentsByExtention: failed to "
                 "locate the executable, %s, to handle files "
-                "with extension '*%s'. (last-error = %d)\n",
+				"with extension '*%s'.\n",
 				start, 
-				extension, 
-				last_error );
-
+				extension
+				);
 			__leave;
 
 		}
diff --git a/src/condor_c++_util/hibernator.WINDOWS.cpp b/src/condor_c++_util/hibernator.WINDOWS.cpp
index eb6d388..c7f19dc 100644
--- a/src/condor_c++_util/hibernator.WINDOWS.cpp
+++ b/src/condor_c++_util/hibernator.WINDOWS.cpp
@@ -24,6 +24,7 @@
 #include "condor_common.h"
 #include "hibernator.WINDOWS.h"
 #include "security.WINDOWS.h"
+#include "deprintf.h"
 
 /* Remove me when NMI updates the SDKs.  Need for the XP SDKs which
    do NOT declare the functions as C functions... */
@@ -56,13 +57,9 @@ MsWindowsHibernator::initStates () {
 
 	if ( !privileged ) {
 
-		dprintf ( 
-			D_ALWAYS, 
+		deprintf(D_ALWAYS,GetLastError(),
 			"MsWindowsHibernator::initStates: Failed to grant "
-			"Condor the ability to shutdown this machine. "
-			"(last-error = %d)\n",
-			GetLastError () );
-
+			"Condor the ability to shutdown this machine.\n");
 		return;
 
 	}
@@ -79,13 +76,9 @@ MsWindowsHibernator::initStates () {
 		sizeof ( SYSTEM_POWER_CAPABILITIES ) );
 	
 	if ( ERROR_SUCCESS != status ) {
-		
-		dprintf ( 
-			D_ALWAYS, 
+		deprintf(D_ALWAYS,GetLastError(),
 			"MsWindowsHibernator::initStates: Failed to retrieve "
-			"power information. (last-error = %d)\n",
-			GetLastError () );
-
+			"power information.\n");
 		return;
 	}
 
@@ -120,14 +113,8 @@ MsWindowsHibernator::tryShutdown ( bool force ) const
 		if ( ERROR_SHUTDOWN_IN_PROGRESS == last_error ) {
 			return true;
 		}
-
 		/* otherwise, it's an error and we'll tell the user so */
-		dprintf ( 
-			D_ALWAYS,
-			"MsWindowsHibernator::tryShutdown(): Shutdown failed. "
-			"(last-error = %d)\n",
-			last_error );
-
+		deprintf(D_ALWAYS,last_error,"MsWindowsHibernator::tryShutdown(): Shutdown failed.\n");
 	}
 
 	return ok;
diff --git a/src/condor_c++_util/killfamily.cpp b/src/condor_c++_util/killfamily.cpp
index 95febe7..5049e30 100644
--- a/src/condor_c++_util/killfamily.cpp
+++ b/src/condor_c++_util/killfamily.cpp
@@ -22,6 +22,7 @@
 #include "killfamily.h"
 #include "../condor_procapi/procapi.h"
 #include "dynuser.h"
+#include "deprintf.h"
 
 #ifdef WIN32
 extern dynuser *myDynuser;
@@ -177,8 +178,10 @@ KillFamily::safe_kill(a_pid *pid, int sig)
 		pHnd = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, inpid);
 
 		if ( pHnd == NULL ) {
-			dprintf(D_ALWAYS, "Procfamily: ERROR: Could not open pid %d "
-				"(err=%d). Maybe it exited already?\n", inpid, GetLastError());
+			/*dprintf(D_ALWAYS, "Procfamily: ERROR: Could not open pid %d "
+				"(err=%d). Maybe it exited already?\n", inpid, GetLastError());*/
+			deprintf(D_ALWAYS,GetLastError(),
+				"Procfamily: ERROR: Could not open pid %d. Maybe it exited already?\n", inpid);
 		}
 
 		if ( ProcAPI::getProcInfo(inpid, pi, status) == PROCAPI_SUCCESS ) {
diff --git a/src/condor_c++_util/link.cpp b/src/condor_c++_util/link.cpp
index 5da0d9d..18d3f96 100644
--- a/src/condor_c++_util/link.cpp
+++ b/src/condor_c++_util/link.cpp
@@ -20,6 +20,7 @@
 #include "condor_common.h"
 #include "condor_debug.h"
 #include "link.h"
+#include "deprintf.h"
 
 #if defined(WIN32)
 
@@ -38,9 +39,11 @@ link(const char* oldpath, const char* newpath)
 			// for anything but the ENOENT-equivalent, we'll
 			// log the error and set errno to something generic-
 			// sounding ("operation not permitted")
-			dprintf(D_ALWAYS,
-			        "link: CreateHardLink error: %u\n",
-			        (unsigned)error);
+
+			//dprintf(D_ALWAYS,
+			//        "link: CreateHardLink error: %u\n",
+			//        (unsigned)error);
+			deprintf(D_ALWAYS,(unsigned)error,"link: CreateHardLink error.\n");
 			errno = EPERM;
 		}
 		return -1;
@@ -60,9 +63,10 @@ link_count(const char* path)
 	                           0,
 	                           NULL);
 	if (handle == INVALID_HANDLE_VALUE) {
-		dprintf(D_ALWAYS,
+		/*dprintf(D_ALWAYS,
 		        "link_count: CreateFile error: %u\n",
-		        (unsigned)GetLastError());
+		        (unsigned)GetLastError());*/
+		deprintf(D_ALWAYS,GetLastError(),"link count: CreateFile error.\n");
 		return -1;
 	}
 	BY_HANDLE_FILE_INFORMATION bhfi;
@@ -70,9 +74,7 @@ link_count(const char* path)
 	DWORD err = GetLastError();
 	CloseHandle(handle);
 	if (!ret) {
-		dprintf(D_ALWAYS,
-		        "link_count: GetFileInformationByHandle error: %u\n",
-		        (unsigned)err);
+		deprintf(D_ALWAYS,err,"link_count: GetFileInformationByHandle error.\n");
 		return -1;
 	}
 	return (int)bhfi.nNumberOfLinks;
diff --git a/src/condor_c++_util/lsa_mgr.cpp b/src/condor_c++_util/lsa_mgr.cpp
index 0009de1..2f526f1 100644
--- a/src/condor_c++_util/lsa_mgr.cpp
+++ b/src/condor_c++_util/lsa_mgr.cpp
@@ -1,661 +1,662 @@
-/***************************************************************
- *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
- * University of Wisconsin-Madison, WI.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you
- * may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ***************************************************************/
-
-
-#include "condor_common.h"
-
-#ifdef WIN32
-
-#include "lsa_mgr.h"
-
-//----------------------------------
-// class lsa_mgr
-// 
-// manages password storage on win32
-// You must be Local System in order
-// to run this code successfully.
-//----------------------------------
-
-
-//-----------------
-// public methods
-//-----------------
-
-lsa_mgr::lsa_mgr() {
-	Data_string = NULL;
-	DataBuffer = NULL;
-}
-
-lsa_mgr::~lsa_mgr() {
-	freeBuffers();
-}
-
-
-// careful with this one...it prints out everything in the clear
-// It's really just for debugging purposes
-void 
-lsa_mgr::printAllData() {
-	if ( loadDataFromRegistry() ) {
-
-		printf("%S\n", (this->Data_string) ? this->Data_string : L"Null");
-		freeBuffers(); // free buffers
-	} else {
-		printf("No data to print!\n");
-	}
-}
-
-// careful with this one too--it clears all passwords
-bool
-lsa_mgr::purgeAllData() {
-
-	LSA_HANDLE policyHandle;
-	LSA_UNICODE_STRING keyName;
-	NTSTATUS ntsResult;
-	LSA_OBJECT_ATTRIBUTES obj_attribs;
-
-	// Object attributes are reserved, so initialize to zeros
-	ZeroMemory(&obj_attribs, sizeof(obj_attribs));
-	
-	// first open a policy handle 
-	ntsResult = LsaOpenPolicy(
-			NULL, 							// machine name or NULL for local
-			&obj_attribs,					// object attributes (?)
-			POLICY_CREATE_SECRET,			// policy rights
-			&policyHandle					// policy handle ptr
-		);
-
-	if (ntsResult != ERROR_SUCCESS) {
-		wprintf(L"OpenPolicy returned %lu\n", LsaNtStatusToWinError(ntsResult));
-		return NULL;
-	}
-
-	// init keyname we want to erase
-	InitLsaString( &keyName, CONDOR_PASSWORD_KEYNAME );
-	
-	// now we can (finally) do the actual delete
-	ntsResult = LsaStorePrivateData(
-				policyHandle, 		/* LSA_HANDLE */
-				&keyName,			/* LSA_UNICODE_STRING registry key name */
-				NULL				/* Passing NULL to erase the key */
-		);
-	
-	// be tidy with the silly policy handles
-	LsaClose(policyHandle);
-
-	return (ntsResult == ERROR_SUCCESS);
-}
-
-// an attempt to add a Login that already exists will
-// result in a failure
-bool
-lsa_mgr::add( const LPWSTR Login, const LPWSTR Passwd ) {  
-
-	wchar_t* new_buffer = NULL; 
-	LSA_UNICODE_STRING lsa_new_data;
-	bool result = false;
-
-	// sanity checks for input strings
-	if ( !Login || 0 == wcslen(Login) ) {
-		printf("Must specify a Login!\n");
-		return false;
-	}else if ( !Passwd || 0 == wcslen(Passwd) ) {
-		printf("Must specify a Password!\n");
-		return false;
-	}
-
-	int new_buffer_len = 	wcslen(Login) + 1 + // Login delimiter
-							wcslen(Passwd) + 3;  // newline + null terminator
-
-	if ( loadDataFromRegistry() ) { // if there's already password information in the registry
-		if ( findInDataString(Login) ) { // check for a duplicate
-			
-			// if we find the login is already in the stash, nuke it
-			
-			freeBuffers();				// clean up buffers so we don't leak memory
-			remove(Login);				// nuke the login
-			loadDataFromRegistry();		// now reload the data
-		}
-
-
-		new_buffer_len += wcslen(this->Data_string);
-		new_buffer = new wchar_t[new_buffer_len];
-		wcscpy(new_buffer, this->Data_string);
-	} else {
-		new_buffer = new wchar_t[new_buffer_len];	
-		new_buffer[0] = CC_RECORD_DELIM; // init with empty record
-		new_buffer[1] = L'\0'; // 
-	}
-
-	wcscat(new_buffer, Login );
-	new_buffer[wcslen(new_buffer)+1] = L'\0';
-	new_buffer[wcslen(new_buffer)] = CC_DATA_DELIM;
-
-	wcscat(new_buffer, Passwd );
-	new_buffer[wcslen(new_buffer)+1] = L'\0';
-	new_buffer[wcslen(new_buffer)] = CC_RECORD_DELIM;
-
-	//first close up the data buffer if it's open already
-	freeBuffers();
-	
-	// prepare new data buffer
-	InitLsaString(&lsa_new_data, new_buffer);
-
-	result = storeDataToRegistry(&lsa_new_data);
-	
-	if (! result ) {
-		printf("lsa_mgr::storeDataToRegistry() failed!\n");
-	}
-
-	// clean up the new buffer after its stored
-	ZeroMemory(new_buffer, sizeof(WCHAR)*wcslen(new_buffer));
-	delete[] new_buffer;
-
-	return result;
-}
-
-bool
-lsa_mgr::remove( const LPWSTR Login ) {
-	
-	LSA_UNICODE_STRING newBuffer; // new data (with stuff removed) to store in registry
-	int remove_len; // size of record to remove from stash
-	wchar_t* newData; // string containing new data
-
-
-	if ( loadDataFromRegistry() ) {
-		
-		// first find out where the record is that we want to remove
-		wchar_t* result = findInDataString( Login );
-
-		if ( result ) {
-			// now if we found something, move past the first delimiter
-			result++; 
-			
-			// now calculate how much we have to skip over when we rewrite the data buffer to 
-			// the registry
-			remove_len = wcschr(result, CC_RECORD_DELIM) - (result); // how many chars to remove
-			remove_len++; // remove the extra newline too
-
-			// create a new buffer and copy everything we want to keep into it
-			newData = new wchar_t[(wcslen(Data_string) - remove_len) +1];
-			
-			// copy everything up to recrd
-			wcsncpy(newData, Data_string, (result - Data_string) ); 
-			newData[(result - Data_string)] = L'\0';
-
-			// now skip over the record we're removing
-			result += remove_len;
-			
-			// and copy what comes after it
-			wcscat(newData, result);
-
-			// finally, store it to the registry and clean up
-			InitLsaString( &newBuffer, newData );
-			storeDataToRegistry( &newBuffer );
-
-			delete[] newData;
-			freeBuffers();
-			return true;
-		}
-
-		freeBuffers();
-		return false;
-	} else {
-		return false; // no data in registry
-	}
-}
-
-bool
-lsa_mgr::isStored( const LPWSTR Login ) {
-	wchar_t* pw = NULL;
-
-	pw = query(Login);
-	if ( pw ) {
-		// we found something, but don't leak memory
-		ZeroMemory(pw, wcslen(pw));
-		delete[] pw;
-		return true;
-	} else {
-		return false;
-	}
-}
-
-LPWSTR
-lsa_mgr::query( const LPWSTR Login ) {
-	
-	wchar_t* pw;	// pointer to new buffer containing requested password
-	int pwlen;		// length of password
-
-	if ( loadDataFromRegistry() ) {
-	
-		int query_str_size = wcslen(Login) + 2; // delimiter+null
-
-		// locate login and peel off the password part
-		wchar_t* result = findInDataString( Login );
-		
-		if ( result ) {
-			result += query_str_size; // move ptr to password part
-			pwlen = wcschr(result+1, CC_RECORD_DELIM) - result;
-			pw = new wchar_t[pwlen+1];
-			wcsncpy(pw, result, pwlen);
-			pw[pwlen] = L'\0';  // make sure it's null terminated!
-			return pw;
-		} else { 
-			return NULL;
-		}
-	} else { return NULL; } // this happens if there's no data to retrieve from registry
-}
-
-// convert char to unicode. You must free what is returned!
-LPWSTR
-lsa_mgr::charToUnicode( char* str ) {
-	LPWSTR str_unicode = new wchar_t[strlen(str)+1];
-	MultiByteToWideChar(CP_ACP, 0, str, -1, str_unicode, strlen(str)+1);
-	return str_unicode;
-}
-
-//-----------------
-// private methods
-//-----------------
-
-bool 
-lsa_mgr::loadDataFromRegistry() {
-
-	LSA_HANDLE policyHandle;
-	LSA_UNICODE_STRING keyName;
-	NTSTATUS ntsResult;
-	LSA_OBJECT_ATTRIBUTES obj_attribs;
-
-	// Object attributes are reserved, so initialize to zeros
-	ZeroMemory(&obj_attribs, sizeof(obj_attribs));
-	
-	// first open a policy handle 
-	ntsResult = LsaOpenPolicy(
-			NULL, 							// machine name or NULL for local
-			&obj_attribs,					// object attributes (?)
-			POLICY_GET_PRIVATE_INFORMATION, // policy rights
-			&policyHandle					// policy handle ptr
-		);
-
-	if (ntsResult != ERROR_SUCCESS) {
-		wprintf(L"OpenPolicy returned %lu\n", LsaNtStatusToWinError(ntsResult));
-		return NULL;
-	}
-
-	// init keyname we want to grab
-	InitLsaString( &keyName, CONDOR_PASSWORD_KEYNAME );
-	
-	// now we can (finally) grab the private data
-	ntsResult = LsaRetrievePrivateData(
-				policyHandle, 		/* LSA_HANDLE */
-				&keyName,			/* LSA_UNICODE_STRING registry key name */
-				&DataBuffer 		/* LSA_UNICODE_STRING private data */
-		);
-
-	// be tidy with the silly policy handle 
-	LsaClose(policyHandle);
-
-	if (ntsResult == ERROR_SUCCESS) {
-		
-		// decrypt our data so we can read it, but be careful...
-		// we may not have to decrypt it if users have stored 
-		// the passwords with a pre 6.6.3 version of Condor,
-		// (but next time we store it, it'll be encrypted)
-		
-		DATA_BLOB DataIn, DataOut;
-		LPWSTR pDescrOut =  NULL;
-
-		DataOut.pbData = NULL;
-		DataIn.pbData = (BYTE*)DataBuffer->Buffer;
-		DataIn.cbData = DataBuffer->Length;
-
-		if (!CryptUnprotectData(
-			&DataIn,
-			&pDescrOut,			// Description string
-			NULL,				// Optional Entropy,
-			NULL,				// Reserved
-			NULL,				// optional promptstruct
-			CRYPTPROTECT_UI_FORBIDDEN, // No GUI prompt!
-			&DataOut)){
-			
-			DWORD err = GetLastError();
-
-			if ( err == ERROR_PASSWORD_RESTRICTION ) {
-
-				// this means the password wasn't encypted 
-				// when we got it, so do nothing, and pass
-				// the data on to extractDataString() 
-				// untouched.
-
-			} else {
-
-				// this means decryption failed for some
-				// other reason, so return failure.
-				return false;
-			}
-			
-		} else {
-			DataBuffer->Buffer = (PWSTR) DataOut.pbData;
-			DataBuffer->Length = (USHORT) DataOut.cbData;
-		}
-		
-		extractDataString();
-
+/***************************************************************
+ *
+ * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+
+#include "condor_common.h"
+
+#ifdef WIN32
+
+#include "lsa_mgr.h"
+#include "deprintf.h"
+
+//----------------------------------
+// class lsa_mgr
+// 
+// manages password storage on win32
+// You must be Local System in order
+// to run this code successfully.
+//----------------------------------
+
+
+//-----------------
+// public methods
+//-----------------
+
+lsa_mgr::lsa_mgr() {
+	Data_string = NULL;
+	DataBuffer = NULL;
+}
+
+lsa_mgr::~lsa_mgr() {
+	freeBuffers();
+}
+
+
+// careful with this one...it prints out everything in the clear
+// It's really just for debugging purposes
+void 
+lsa_mgr::printAllData() {
+	if ( loadDataFromRegistry() ) {
+
+		printf("%S\n", (this->Data_string) ? this->Data_string : L"Null");
+		freeBuffers(); // free buffers
+	} else {
+		printf("No data to print!\n");
+	}
+}
+
+// careful with this one too--it clears all passwords
+bool
+lsa_mgr::purgeAllData() {
+
+	LSA_HANDLE policyHandle;
+	LSA_UNICODE_STRING keyName;
+	NTSTATUS ntsResult;
+	LSA_OBJECT_ATTRIBUTES obj_attribs;
+
+	// Object attributes are reserved, so initialize to zeros
+	ZeroMemory(&obj_attribs, sizeof(obj_attribs));
+	
+	// first open a policy handle 
+	ntsResult = LsaOpenPolicy(
+			NULL, 							// machine name or NULL for local
+			&obj_attribs,					// object attributes (?)
+			POLICY_CREATE_SECRET,			// policy rights
+			&policyHandle					// policy handle ptr
+		);
+
+	if (ntsResult != ERROR_SUCCESS) {
+		wprintf(L"OpenPolicy returned %lu\n", LsaNtStatusToWinError(ntsResult));
+		return NULL;
+	}
+
+	// init keyname we want to erase
+	InitLsaString( &keyName, CONDOR_PASSWORD_KEYNAME );
+	
+	// now we can (finally) do the actual delete
+	ntsResult = LsaStorePrivateData(
+				policyHandle, 		/* LSA_HANDLE */
+				&keyName,			/* LSA_UNICODE_STRING registry key name */
+				NULL				/* Passing NULL to erase the key */
+		);
+	
+	// be tidy with the silly policy handles
+	LsaClose(policyHandle);
+
+	return (ntsResult == ERROR_SUCCESS);
+}
+
+// an attempt to add a Login that already exists will
+// result in a failure
+bool
+lsa_mgr::add( const LPWSTR Login, const LPWSTR Passwd ) {  
+
+	wchar_t* new_buffer = NULL; 
+	LSA_UNICODE_STRING lsa_new_data;
+	bool result = false;
+
+	// sanity checks for input strings
+	if ( !Login || 0 == wcslen(Login) ) {
+		printf("Must specify a Login!\n");
+		return false;
+	}else if ( !Passwd || 0 == wcslen(Passwd) ) {
+		printf("Must specify a Password!\n");
+		return false;
+	}
+
+	int new_buffer_len = 	wcslen(Login) + 1 + // Login delimiter
+							wcslen(Passwd) + 3;  // newline + null terminator
+
+	if ( loadDataFromRegistry() ) { // if there's already password information in the registry
+		if ( findInDataString(Login) ) { // check for a duplicate
+			
+			// if we find the login is already in the stash, nuke it
+			
+			freeBuffers();				// clean up buffers so we don't leak memory
+			remove(Login);				// nuke the login
+			loadDataFromRegistry();		// now reload the data
+		}
+
+
+		new_buffer_len += wcslen(this->Data_string);
+		new_buffer = new wchar_t[new_buffer_len];
+		wcscpy(new_buffer, this->Data_string);
+	} else {
+		new_buffer = new wchar_t[new_buffer_len];	
+		new_buffer[0] = CC_RECORD_DELIM; // init with empty record
+		new_buffer[1] = L'\0'; // 
+	}
+
+	wcscat(new_buffer, Login );
+	new_buffer[wcslen(new_buffer)+1] = L'\0';
+	new_buffer[wcslen(new_buffer)] = CC_DATA_DELIM;
+
+	wcscat(new_buffer, Passwd );
+	new_buffer[wcslen(new_buffer)+1] = L'\0';
+	new_buffer[wcslen(new_buffer)] = CC_RECORD_DELIM;
+
+	//first close up the data buffer if it's open already
+	freeBuffers();
+	
+	// prepare new data buffer
+	InitLsaString(&lsa_new_data, new_buffer);
+
+	result = storeDataToRegistry(&lsa_new_data);
+	
+	if (! result ) {
+		printf("lsa_mgr::storeDataToRegistry() failed!\n");
+	}
+
+	// clean up the new buffer after its stored
+	ZeroMemory(new_buffer, sizeof(WCHAR)*wcslen(new_buffer));
+	delete[] new_buffer;
+
+	return result;
+}
+
+bool
+lsa_mgr::remove( const LPWSTR Login ) {
+	
+	LSA_UNICODE_STRING newBuffer; // new data (with stuff removed) to store in registry
+	int remove_len; // size of record to remove from stash
+	wchar_t* newData; // string containing new data
+
+
+	if ( loadDataFromRegistry() ) {
+		
+		// first find out where the record is that we want to remove
+		wchar_t* result = findInDataString( Login );
+
+		if ( result ) {
+			// now if we found something, move past the first delimiter
+			result++; 
+			
+			// now calculate how much we have to skip over when we rewrite the data buffer to 
+			// the registry
+			remove_len = wcschr(result, CC_RECORD_DELIM) - (result); // how many chars to remove
+			remove_len++; // remove the extra newline too
+
+			// create a new buffer and copy everything we want to keep into it
+			newData = new wchar_t[(wcslen(Data_string) - remove_len) +1];
+			
+			// copy everything up to recrd
+			wcsncpy(newData, Data_string, (result - Data_string) ); 
+			newData[(result - Data_string)] = L'\0';
+
+			// now skip over the record we're removing
+			result += remove_len;
+			
+			// and copy what comes after it
+			wcscat(newData, result);
+
+			// finally, store it to the registry and clean up
+			InitLsaString( &newBuffer, newData );
+			storeDataToRegistry( &newBuffer );
+
+			delete[] newData;
+			freeBuffers();
+			return true;
+		}
+
+		freeBuffers();
+		return false;
+	} else {
+		return false; // no data in registry
+	}
+}
+
+bool
+lsa_mgr::isStored( const LPWSTR Login ) {
+	wchar_t* pw = NULL;
+
+	pw = query(Login);
+	if ( pw ) {
+		// we found something, but don't leak memory
+		ZeroMemory(pw, wcslen(pw));
+		delete[] pw;
+		return true;
+	} else {
+		return false;
+	}
+}
+
+LPWSTR
+lsa_mgr::query( const LPWSTR Login ) {
+	
+	wchar_t* pw;	// pointer to new buffer containing requested password
+	int pwlen;		// length of password
+
+	if ( loadDataFromRegistry() ) {
+	
+		int query_str_size = wcslen(Login) + 2; // delimiter+null
+
+		// locate login and peel off the password part
+		wchar_t* result = findInDataString( Login );
+		
+		if ( result ) {
+			result += query_str_size; // move ptr to password part
+			pwlen = wcschr(result+1, CC_RECORD_DELIM) - result;
+			pw = new wchar_t[pwlen+1];
+			wcsncpy(pw, result, pwlen);
+			pw[pwlen] = L'\0';  // make sure it's null terminated!
+			return pw;
+		} else { 
+			return NULL;
+		}
+	} else { return NULL; } // this happens if there's no data to retrieve from registry
+}
+
+// convert char to unicode. You must free what is returned!
+LPWSTR
+lsa_mgr::charToUnicode( char* str ) {
+	LPWSTR str_unicode = new wchar_t[strlen(str)+1];
+	MultiByteToWideChar(CP_ACP, 0, str, -1, str_unicode, strlen(str)+1);
+	return str_unicode;
+}
+
+//-----------------
+// private methods
+//-----------------
+
+bool 
+lsa_mgr::loadDataFromRegistry() {
+
+	LSA_HANDLE policyHandle;
+	LSA_UNICODE_STRING keyName;
+	NTSTATUS ntsResult;
+	LSA_OBJECT_ATTRIBUTES obj_attribs;
+
+	// Object attributes are reserved, so initialize to zeros
+	ZeroMemory(&obj_attribs, sizeof(obj_attribs));
+	
+	// first open a policy handle 
+	ntsResult = LsaOpenPolicy(
+			NULL, 							// machine name or NULL for local
+			&obj_attribs,					// object attributes (?)
+			POLICY_GET_PRIVATE_INFORMATION, // policy rights
+			&policyHandle					// policy handle ptr
+		);
+
+	if (ntsResult != ERROR_SUCCESS) {
+		wprintf(L"OpenPolicy returned %lu\n", LsaNtStatusToWinError(ntsResult));
+		return NULL;
+	}
+
+	// init keyname we want to grab
+	InitLsaString( &keyName, CONDOR_PASSWORD_KEYNAME );
+	
+	// now we can (finally) grab the private data
+	ntsResult = LsaRetrievePrivateData(
+				policyHandle, 		/* LSA_HANDLE */
+				&keyName,			/* LSA_UNICODE_STRING registry key name */
+				&DataBuffer 		/* LSA_UNICODE_STRING private data */
+		);
+
+	// be tidy with the silly policy handle 
+	LsaClose(policyHandle);
+
+	if (ntsResult == ERROR_SUCCESS) {
+		
+		// decrypt our data so we can read it, but be careful...
+		// we may not have to decrypt it if users have stored 
+		// the passwords with a pre 6.6.3 version of Condor,
+		// (but next time we store it, it'll be encrypted)
+		
+		DATA_BLOB DataIn, DataOut;
+		LPWSTR pDescrOut =  NULL;
+
+		DataOut.pbData = NULL;
+		DataIn.pbData = (BYTE*)DataBuffer->Buffer;
+		DataIn.cbData = DataBuffer->Length;
+
+		if (!CryptUnprotectData(
+			&DataIn,
+			&pDescrOut,			// Description string
+			NULL,				// Optional Entropy,
+			NULL,				// Reserved
+			NULL,				// optional promptstruct
+			CRYPTPROTECT_UI_FORBIDDEN, // No GUI prompt!
+			&DataOut)){
+			
+			DWORD err = GetLastError();
+
+			if ( err == ERROR_PASSWORD_RESTRICTION ) {
+
+				// this means the password wasn't encypted 
+				// when we got it, so do nothing, and pass
+				// the data on to extractDataString() 
+				// untouched.
+
+			} else {
+
+				// this means decryption failed for some
+				// other reason, so return failure.
+				return false;
+			}
+			
+		} else {
+			DataBuffer->Buffer = (PWSTR) DataOut.pbData;
+			DataBuffer->Length = (USHORT) DataOut.cbData;
+		}
+		
+		extractDataString();
+
 		if ( DataOut.pbData != NULL ) {
-			LocalFree(DataOut.pbData);
-		}
-
-		if ( pDescrOut != NULL ) {
-			LocalFree(pDescrOut);
-		}
-
-		return true;
-	} else {
-		return false;
-	}
-}
-
-bool 
-lsa_mgr::storeDataToRegistry( const PLSA_UNICODE_STRING lsaString ) {
-
-	LSA_HANDLE policyHandle;
-	LSA_UNICODE_STRING keyName;
-	NTSTATUS ntsResult;
-	LSA_OBJECT_ATTRIBUTES obj_attribs;
-
-	// Object attributes are reserved, so initialize to zeros
-	ZeroMemory(&obj_attribs, sizeof(obj_attribs));
-	
-	// first open a policy handle 
-	ntsResult = LsaOpenPolicy(
-			NULL, 							// machine name or NULL for local
-			&obj_attribs,					// object attributes (?)
-			POLICY_CREATE_SECRET,			// policy rights
-			&policyHandle					// policy handle ptr
-		);
-
-	if (ntsResult != ERROR_SUCCESS) {
-		dprintf(D_ALWAYS, "OpenPolicy returned %lu\n", 
-			LsaNtStatusToWinError(ntsResult));
-		return NULL;
-	}
-
-	// init keyname we want to grab
-	InitLsaString( &keyName, CONDOR_PASSWORD_KEYNAME );
-
-	// Encrypt data before storing it
-	DATA_BLOB DataIn, DataOut;
-
-	DataOut.pbData = NULL;
-	DataIn.pbData = (BYTE*) lsaString->Buffer;
-	DataIn.cbData = lsaString->Length;
-
-	if(!CryptProtectData(
-        &DataIn,
-        L"Condor",			// A description sting. 
-        NULL,				// Optional entropy not used
-        NULL,				// Reserved
-        NULL,				// a promptstruct
-        CRYPTPROTECT_UI_FORBIDDEN,
-        &DataOut)){
-    
-		// The function failed. Report the error.   
-		dprintf(D_ALWAYS, "Encryption error! errorcode=%lu \n",
-			GetLastError());
-    }
-
-
-	lsaString->Buffer = (PWSTR)DataOut.pbData;
-	lsaString->Length = (USHORT)DataOut.cbData;
-
-	dprintf(D_FULLDEBUG, "Attempting to store %d bytes to reg key...\n",
-		 lsaString->Length);
-	
-	// now we can (finally) grab the private data
-	ntsResult = LsaStorePrivateData(
-				policyHandle, 		/* LSA_HANDLE */
-				&keyName,			/* LSA_UNICODE_STRING registry key name */
-				lsaString	 		/* LSA_UNICODE_STRING private data */
-		);
-	
-	// be tidy with the silly policy handles
-	LsaClose(policyHandle);
-
-	// clean up our encrypted data
-	if ( DataOut.pbData != NULL ) {
-		LocalFree(DataOut.pbData);
-	}
-
-	return (ntsResult == ERROR_SUCCESS);
-}
-
-
-void
-lsa_mgr::InitLsaString( PLSA_UNICODE_STRING LsaString, const LPWSTR String ) {
-	DWORD StringLength;
-	if(String == NULL) {
-		LsaString->Buffer = NULL;
-		LsaString->Length = 0;
-		LsaString->MaximumLength = 0;
-		return;
-	}
-	//StringLength = lstrlenW(String);
-	StringLength = wcslen(String);
-	LsaString->Buffer = String;
-	LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
-	LsaString->MaximumLength = (USHORT) (StringLength + 1) * sizeof(WCHAR);
-}
-
-// the purpose of this method is to guarantee that the data buffer is null terminated
-void
-lsa_mgr::extractDataString() {
-	if ( this->DataBuffer ) { // no op if there's no data
-		int strlength = this->DataBuffer->Length/sizeof(WCHAR);
-		this->Data_string = new wchar_t[ strlength +1]; //length + null
-		wcsncpy( Data_string, DataBuffer->Buffer, strlength );
-		Data_string[strlength] = L'\0'; // make sure it's null terminated
-	} else {
-		dprintf(D_ALWAYS, "lsa_mgr::extractDataString() has been "
-			"called with no data\n");
-	}
-}
-
-LPWSTR
-lsa_mgr::findInDataString( const LPWSTR Login, bool case_sensitive ) {
-	int look_for_size = wcslen(Login) + 3; // delimiter+delimiter+null
-	wchar_t* look_for = new wchar_t[look_for_size];
-	
-	// we're gonna look though the data string hoping to find this:
-	// \nDesired_Login\t
-	
-	look_for[0] = CC_RECORD_DELIM;
-	look_for[1] = L'\0';
-	
-	wcscat(look_for, Login );
-	look_for[wcslen(look_for)+1] = L'\0';
-	look_for[wcslen(look_for)] = CC_DATA_DELIM;
-		
-//	wprintf(L"Looking for '%s'\n", look_for);
-	wchar_t* result; 
-	if ( case_sensitive ) {
-		result = wcsstr(Data_string, look_for);
-	} else {
-		result = wcsstri(Data_string, look_for);
-	}
-	delete[] look_for;
-	return result;
-}
-
-// strstr that's case insensitive
-wchar_t* 
-lsa_mgr::wcsstri(wchar_t* haystack, wchar_t* needle) {
-	wchar_t* h_lwr = NULL; // lowercase versions of
-	wchar_t* n_lwr = NULL; // the above args
-	wchar_t* match = NULL;
-
-	if ( haystack && needle ) {
-		h_lwr = new wchar_t[wcslen(haystack)+1];
-		n_lwr = new wchar_t[wcslen(needle)+1];
-		
-		// make lowercase copies
-		wcscpy(h_lwr, haystack);
-		wcscpy(n_lwr, needle);
-		wcslwr(h_lwr);
-		wcslwr(n_lwr);
-
-		// do the strstr
-		match = wcsstr(h_lwr, n_lwr);
-		if ( match ) {
-			// set match to point to original haystack
-			// using offset
-			match = &haystack[match-h_lwr];
-		} else {
-			match = NULL;
-		}
-		
-		delete[] h_lwr;
-		delete[] n_lwr;
-	}
-
-	return match;
-}
-
-
-void 
-doAdd() {
-	char inBuf[1024];
-	wchar_t *Login=NULL, *Passw=NULL;
-	
-	lsa_mgr* foo = new lsa_mgr();
-	
-	printf("Enter Login: ");
-	gets(inBuf);
-	Login = foo->charToUnicode( inBuf );
-	
-	printf("Enter Password: ");
-	gets(inBuf);
-	Passw = foo->charToUnicode( inBuf );
-
-	foo->add( Login, Passw );
-
-	ZeroMemory(Passw, sizeof(WCHAR)*wcslen(Passw)+1);
-	delete[] Passw;
-	Passw = NULL;
-
-	ZeroMemory(Login, sizeof(WCHAR)*wcslen(Login)+1);
-	delete[] Login;
-	Login = NULL;
-
-	// cleanup 
-	delete foo;
-}
-
-void doRemove() {
-	char inBuf[1024];
-	wchar_t *Login=NULL;
-	
-	lsa_mgr* foo = new lsa_mgr();
-	
-	printf("Enter Login: ");
-	gets(inBuf);
-	Login = foo->charToUnicode( inBuf );
-	
-	foo->remove( Login );
-
-	// cleanup 
-	delete foo;
-
-	ZeroMemory(Login, sizeof(WCHAR)*wcslen(Login)+1);
-	delete[] Login;
-	Login = NULL;
-}
-
-void doQuery() {
-	char inBuf[1024];
-	wchar_t *Login=NULL, *Passw=NULL;
-	
-	lsa_mgr* foo = new lsa_mgr();
-	
-	printf("Enter Login: ");
-	gets(inBuf);
-	Login = foo->charToUnicode( inBuf );
-	
-	
-	Passw = foo->query( Login );
-
-	printf("Password is %S\n", Passw ? Passw : L"Not Found");
-
-	// cleanup 
-
-	if ( Passw ) {
-		ZeroMemory(Passw, sizeof(WCHAR)*wcslen(Passw));
-		delete[] Passw;
-		Passw = NULL;
-	}
-
-	ZeroMemory(Login, sizeof(WCHAR)*wcslen(Login)+1);
-	delete[] Login;
-	Login = NULL;
-		
-	delete foo;
-}
-
-void doPrintAll() {
-
-	lsa_mgr *foo = new lsa_mgr();
-	foo->printAllData();
-	delete foo;
-}
-
-void doClearAll() {
-	lsa_mgr *foo = new lsa_mgr();
-	foo->purgeAllData();
-	delete foo;
-}
-
-void printMenu() {
-
-	printf("\n\n1. %s\n2. %s\n3. %s\n4. %s\n5. %s\nExit\n\n> ", 
-			"Add new password",
-			"Remove a password",
-			"Query",
-			"Print all passwords",
-			"Clear all passwords" );
-}
-
-int interactive() {
-
-	char inBuf[256];
-
-	while (1) {
-		printMenu();
-		gets(inBuf);
-		switch( inBuf[0] ) {
-			case '1' : doAdd(); break;
-			case '2' : doRemove(); break;
-			case '3' : doQuery(); break;
-			case '4' : doPrintAll(); break;
-			case '5' : doClearAll(); break;
-			default: return 0; break;
-		}
-	}
-
-}
-
-#endif // WIN32
-
+			LocalFree(DataOut.pbData);
+		}
+
+		if ( pDescrOut != NULL ) {
+			LocalFree(pDescrOut);
+		}
+
+		return true;
+	} else {
+		return false;
+	}
+}
+
+bool 
+lsa_mgr::storeDataToRegistry( const PLSA_UNICODE_STRING lsaString ) {
+
+	LSA_HANDLE policyHandle;
+	LSA_UNICODE_STRING keyName;
+	NTSTATUS ntsResult;
+	LSA_OBJECT_ATTRIBUTES obj_attribs;
+
+	// Object attributes are reserved, so initialize to zeros
+	ZeroMemory(&obj_attribs, sizeof(obj_attribs));
+	
+	// first open a policy handle 
+	ntsResult = LsaOpenPolicy(
+			NULL, 							// machine name or NULL for local
+			&obj_attribs,					// object attributes (?)
+			POLICY_CREATE_SECRET,			// policy rights
+			&policyHandle					// policy handle ptr
+		);
+
+	if (ntsResult != ERROR_SUCCESS) {
+		dprintf(D_ALWAYS, "OpenPolicy returned %lu\n", 
+			LsaNtStatusToWinError(ntsResult));
+		return NULL;
+	}
+
+	// init keyname we want to grab
+	InitLsaString( &keyName, CONDOR_PASSWORD_KEYNAME );
+
+	// Encrypt data before storing it
+	DATA_BLOB DataIn, DataOut;
+
+	DataOut.pbData = NULL;
+	DataIn.pbData = (BYTE*) lsaString->Buffer;
+	DataIn.cbData = lsaString->Length;
+
+	if(!CryptProtectData(
+        &DataIn,
+        L"Condor",			// A description sting. 
+        NULL,				// Optional entropy not used
+        NULL,				// Reserved
+        NULL,				// a promptstruct
+        CRYPTPROTECT_UI_FORBIDDEN,
+        &DataOut)){
+			// The function failed. Report the error.   
+    
+			deprintf(D_ALWAYS,GetLastError(),"Encryption error!\n");
+		
+    }
+
+
+	lsaString->Buffer = (PWSTR)DataOut.pbData;
+	lsaString->Length = (USHORT)DataOut.cbData;
+
+	dprintf(D_FULLDEBUG, "Attempting to store %d bytes to reg key...\n",
+		 lsaString->Length);
+	
+	// now we can (finally) grab the private data
+	ntsResult = LsaStorePrivateData(
+				policyHandle, 		/* LSA_HANDLE */
+				&keyName,			/* LSA_UNICODE_STRING registry key name */
+				lsaString	 		/* LSA_UNICODE_STRING private data */
+		);
+	
+	// be tidy with the silly policy handles
+	LsaClose(policyHandle);
+
+	// clean up our encrypted data
+	if ( DataOut.pbData != NULL ) {
+		LocalFree(DataOut.pbData);
+	}
+
+	return (ntsResult == ERROR_SUCCESS);
+}
+
+
+void
+lsa_mgr::InitLsaString( PLSA_UNICODE_STRING LsaString, const LPWSTR String ) {
+	DWORD StringLength;
+	if(String == NULL) {
+		LsaString->Buffer = NULL;
+		LsaString->Length = 0;
+		LsaString->MaximumLength = 0;
+		return;
+	}
+	//StringLength = lstrlenW(String);
+	StringLength = wcslen(String);
+	LsaString->Buffer = String;
+	LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
+	LsaString->MaximumLength = (USHORT) (StringLength + 1) * sizeof(WCHAR);
+}
+
+// the purpose of this method is to guarantee that the data buffer is null terminated
+void
+lsa_mgr::extractDataString() {
+	if ( this->DataBuffer ) { // no op if there's no data
+		int strlength = this->DataBuffer->Length/sizeof(WCHAR);
+		this->Data_string = new wchar_t[ strlength +1]; //length + null
+		wcsncpy( Data_string, DataBuffer->Buffer, strlength );
+		Data_string[strlength] = L'\0'; // make sure it's null terminated
+	} else {
+		dprintf(D_ALWAYS, "lsa_mgr::extractDataString() has been "
+			"called with no data\n");
+	}
+}
+
+LPWSTR
+lsa_mgr::findInDataString( const LPWSTR Login, bool case_sensitive ) {
+	int look_for_size = wcslen(Login) + 3; // delimiter+delimiter+null
+	wchar_t* look_for = new wchar_t[look_for_size];
+	
+	// we're gonna look though the data string hoping to find this:
+	// \nDesired_Login\t
+	
+	look_for[0] = CC_RECORD_DELIM;
+	look_for[1] = L'\0';
+	
+	wcscat(look_for, Login );
+	look_for[wcslen(look_for)+1] = L'\0';
+	look_for[wcslen(look_for)] = CC_DATA_DELIM;
+		
+//	wprintf(L"Looking for '%s'\n", look_for);
+	wchar_t* result; 
+	if ( case_sensitive ) {
+		result = wcsstr(Data_string, look_for);
+	} else {
+		result = wcsstri(Data_string, look_for);
+	}
+	delete[] look_for;
+	return result;
+}
+
+// strstr that's case insensitive
+wchar_t* 
+lsa_mgr::wcsstri(wchar_t* haystack, wchar_t* needle) {
+	wchar_t* h_lwr = NULL; // lowercase versions of
+	wchar_t* n_lwr = NULL; // the above args
+	wchar_t* match = NULL;
+
+	if ( haystack && needle ) {
+		h_lwr = new wchar_t[wcslen(haystack)+1];
+		n_lwr = new wchar_t[wcslen(needle)+1];
+		
+		// make lowercase copies
+		wcscpy(h_lwr, haystack);
+		wcscpy(n_lwr, needle);
+		wcslwr(h_lwr);
+		wcslwr(n_lwr);
+
+		// do the strstr
+		match = wcsstr(h_lwr, n_lwr);
+		if ( match ) {
+			// set match to point to original haystack
+			// using offset
+			match = &haystack[match-h_lwr];
+		} else {
+			match = NULL;
+		}
+		
+		delete[] h_lwr;
+		delete[] n_lwr;
+	}
+
+	return match;
+}
+
+
+void 
+doAdd() {
+	char inBuf[1024];
+	wchar_t *Login=NULL, *Passw=NULL;
+	
+	lsa_mgr* foo = new lsa_mgr();
+	
+	printf("Enter Login: ");
+	gets(inBuf);
+	Login = foo->charToUnicode( inBuf );
+	
+	printf("Enter Password: ");
+	gets(inBuf);
+	Passw = foo->charToUnicode( inBuf );
+
+	foo->add( Login, Passw );
+
+	ZeroMemory(Passw, sizeof(WCHAR)*wcslen(Passw)+1);
+	delete[] Passw;
+	Passw = NULL;
+
+	ZeroMemory(Login, sizeof(WCHAR)*wcslen(Login)+1);
+	delete[] Login;
+	Login = NULL;
+
+	// cleanup 
+	delete foo;
+}
+
+void doRemove() {
+	char inBuf[1024];
+	wchar_t *Login=NULL;
+	
+	lsa_mgr* foo = new lsa_mgr();
+	
+	printf("Enter Login: ");
+	gets(inBuf);
+	Login = foo->charToUnicode( inBuf );
+	
+	foo->remove( Login );
+
+	// cleanup 
+	delete foo;
+
+	ZeroMemory(Login, sizeof(WCHAR)*wcslen(Login)+1);
+	delete[] Login;
+	Login = NULL;
+}
+
+void doQuery() {
+	char inBuf[1024];
+	wchar_t *Login=NULL, *Passw=NULL;
+	
+	lsa_mgr* foo = new lsa_mgr();
+	
+	printf("Enter Login: ");
+	gets(inBuf);
+	Login = foo->charToUnicode( inBuf );
+	
+	
+	Passw = foo->query( Login );
+
+	printf("Password is %S\n", Passw ? Passw : L"Not Found");
+
+	// cleanup 
+
+	if ( Passw ) {
+		ZeroMemory(Passw, sizeof(WCHAR)*wcslen(Passw));
+		delete[] Passw;
+		Passw = NULL;
+	}
+
+	ZeroMemory(Login, sizeof(WCHAR)*wcslen(Login)+1);
+	delete[] Login;
+	Login = NULL;
+		
+	delete foo;
+}
+
+void doPrintAll() {
+
+	lsa_mgr *foo = new lsa_mgr();
+	foo->printAllData();
+	delete foo;
+}
+
+void doClearAll() {
+	lsa_mgr *foo = new lsa_mgr();
+	foo->purgeAllData();
+	delete foo;
+}
+
+void printMenu() {
+
+	printf("\n\n1. %s\n2. %s\n3. %s\n4. %s\n5. %s\nExit\n\n> ", 
+			"Add new password",
+			"Remove a password",
+			"Query",
+			"Print all passwords",
+			"Clear all passwords" );
+}
+
+int interactive() {
+
+	char inBuf[256];
+
+	while (1) {
+		printMenu();
+		gets(inBuf);
+		switch( inBuf[0] ) {
+			case '1' : doAdd(); break;
+			case '2' : doRemove(); break;
+			case '3' : doQuery(); break;
+			case '4' : doPrintAll(); break;
+			case '5' : doClearAll(); break;
+			default: return 0; break;
+		}
+	}
+
+}
+
+#endif // WIN32
+
diff --git a/src/condor_c++_util/network_adapter.WINDOWS.cpp b/src/condor_c++_util/network_adapter.WINDOWS.cpp
index 4f20819..7755b23 100644
--- a/src/condor_c++_util/network_adapter.WINDOWS.cpp
+++ b/src/condor_c++_util/network_adapter.WINDOWS.cpp
@@ -1,123 +1,124 @@
-/***************************************************************
-*
-* Copyright (C) 1990-2008, Condor Team, Computer Sciences Department,
-* University of Wisconsin-Madison, WI.
-* 
-* Licensed under the Apache License, Version 2.0 (the "License"); you
-* may not use this file except in compliance with the License.  You may
-* obtain a copy of the License at
-* 
-*    http://www.apache.org/licenses/LICENSE-2.0
-* 
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*
-***************************************************************/
-
-#include "condor_common.h"
-#include "network_adapter.WINDOWS.h"
-#include "my_hostname.h"
-
-#include <iphlpapi.h>
-
-/***************************************************************
- * Ripped from the MS DDK
- ***************************************************************/
-
-/*  {6B29FC40-CA47-1067-B31D-00DD010662DA}
-    Length = 1[{] + 32[sizeof(GUID)*2] + 4[-] + 1[}]
-    */
-#define GUID_STR_LENGTH ((sizeof(GUID)*2)+6)
-
-#define CONDOR_DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
-    extern const GUID name \
-                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
-
-/*    Guid for Lan Class. (From DDK)
-*/
-CONDOR_DEFINE_GUID(CONDOR_GUID_NDIS_LAN_CLASS, 0xad498944, 0x762f,
-                    0x11d0, 0x8d, 0xcb, 0x00, 0xc0, 0x4f, 0xc3,
-                    0x35, 0x8c);
-
-/***************************************************************
- * Defines
- ***************************************************************/
-
-#define WAKE_FROM_ANY_SUPPORTED (PDCAP_WAKE_FROM_D0_SUPPORTED| \
-                                 PDCAP_WAKE_FROM_D1_SUPPORTED| \
-                                 PDCAP_WAKE_FROM_D2_SUPPORTED| \
-                                 PDCAP_WAKE_FROM_D3_SUPPORTED)
-
-/***************************************************************
- * WindowsNetworkAdapter class
- ***************************************************************/
-
-WindowsNetworkAdapter::WindowsNetworkAdapter (void) throw () 
-: _exists ( false ) {
+/***************************************************************
+*
+* Copyright (C) 1990-2008, Condor Team, Computer Sciences Department,
+* University of Wisconsin-Madison, WI.
+* 
+* Licensed under the Apache License, Version 2.0 (the "License"); you
+* may not use this file except in compliance with the License.  You may
+* obtain a copy of the License at
+* 
+*    http://www.apache.org/licenses/LICENSE-2.0
+* 
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+***************************************************************/
+
+#include "condor_common.h"
+#include "network_adapter.WINDOWS.h"
+#include "my_hostname.h"
+#include "deprintf.h"
+
+#include <iphlpapi.h>
+
+/***************************************************************
+ * Ripped from the MS DDK
+ ***************************************************************/
+
+/*  {6B29FC40-CA47-1067-B31D-00DD010662DA}
+    Length = 1[{] + 32[sizeof(GUID)*2] + 4[-] + 1[}]
+    */
+#define GUID_STR_LENGTH ((sizeof(GUID)*2)+6)
+
+#define CONDOR_DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
+    extern const GUID name \
+                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
+
+/*    Guid for Lan Class. (From DDK)
+*/
+CONDOR_DEFINE_GUID(CONDOR_GUID_NDIS_LAN_CLASS, 0xad498944, 0x762f,
+                    0x11d0, 0x8d, 0xcb, 0x00, 0xc0, 0x4f, 0xc3,
+                    0x35, 0x8c);
+
+/***************************************************************
+ * Defines
+ ***************************************************************/
+
+#define WAKE_FROM_ANY_SUPPORTED (PDCAP_WAKE_FROM_D0_SUPPORTED| \
+                                 PDCAP_WAKE_FROM_D1_SUPPORTED| \
+                                 PDCAP_WAKE_FROM_D2_SUPPORTED| \
+                                 PDCAP_WAKE_FROM_D3_SUPPORTED)
+
+/***************************************************************
+ * WindowsNetworkAdapter class
+ ***************************************************************/
+
+WindowsNetworkAdapter::WindowsNetworkAdapter (void) throw () 
+: _exists ( false ) {
     strncpy ( _ip_address, my_ip_string (), IP_STRING_BUF_SIZE );
-    _description[0] = '\0';
-}
-
-WindowsNetworkAdapter::WindowsNetworkAdapter ( LPCSTR ip_addr,
-											   unsigned int /*ip*/) throw ()
+    _description[0] = '\0';
+}
+
+WindowsNetworkAdapter::WindowsNetworkAdapter ( LPCSTR ip_addr,
+											   unsigned int /*ip*/) throw ()
 : _exists ( false ) {
     strncpy ( _ip_address, ip_addr, IP_STRING_BUF_SIZE );
-    _description[0] = '\0';
-}
-
-WindowsNetworkAdapter::WindowsNetworkAdapter ( LPCSTR description ) throw ()
-: _exists ( false ) {
-    strncpy ( _description, description,
+    _description[0] = '\0';
+}
+
+WindowsNetworkAdapter::WindowsNetworkAdapter ( LPCSTR description ) throw ()
+: _exists ( false ) {
+    strncpy ( _description, description,
         MAX_ADAPTER_DESCRIPTION_LENGTH + 4 );
-    _ip_address[0] = '\0';
-}
-
-WindowsNetworkAdapter::~WindowsNetworkAdapter (void) throw () {
-}
-
-/***************************************************************
- * WindowsNetworkAdapter class
- ***************************************************************/
-
-bool
+    _ip_address[0] = '\0';
+}
+
+WindowsNetworkAdapter::~WindowsNetworkAdapter (void) throw () {
+}
+
+/***************************************************************
+ * WindowsNetworkAdapter class
+ ***************************************************************/
+
+bool
 WindowsNetworkAdapter::initialize (void) {
 
-    PIP_ADAPTER_INFO    adapters    = NULL,
-                        current     = NULL;
-	DWORD               error       = 0,
+    PIP_ADAPTER_INFO    adapters    = NULL,
+                        current     = NULL;
+	DWORD               error       = 0,
                         supports    = 0;
-    UINT                length      = 0;
-	ULONG               size;
+    UINT                length      = 0;
+	ULONG               size;
     LPCSTR              other       = NULL;
-    LPSTR               offset      = _hardware_address;
-    unsigned int        i           = 0;
-    PCM_POWER_DATA      power_data  = NULL;
-    bool                ok          = false;
-
-    __try {
-
-        /* allocate a very small ammount of ram, which will cause the
-           call for information to fail, but will reveal the size
-           of the true structure */
-        size = sizeof ( IP_ADAPTER_INFO );
-        adapters = (PIP_ADAPTER_INFO) malloc ( size );
-        
-        if ( ERROR_SUCCESS != GetAdaptersInfo ( adapters, &size ) ) {
-            free ( adapters );
-            adapters = (PIP_ADAPTER_INFO) malloc ( size );
+    LPSTR               offset      = _hardware_address;
+    unsigned int        i           = 0;
+    PCM_POWER_DATA      power_data  = NULL;
+    bool                ok          = false;
+
+    __try {
+
+        /* allocate a very small ammount of ram, which will cause the
+           call for information to fail, but will reveal the size
+           of the true structure */
+        size = sizeof ( IP_ADAPTER_INFO );
+        adapters = (PIP_ADAPTER_INFO) malloc ( size );
+        
+        if ( ERROR_SUCCESS != GetAdaptersInfo ( adapters, &size ) ) {
+            free ( adapters );
+            adapters = (PIP_ADAPTER_INFO) malloc ( size );
 	    }
 
-        /* now attempt to grab all the information we can for each 
-           adapter, then search through them until we find the one
-           which matches the IP we are looking for */
-        if ( NO_ERROR != ( error = GetAdaptersInfo ( adapters, &size ) ) ) {
-
-            /* failed to get the adapter information */
-            __leave;
-
+        /* now attempt to grab all the information we can for each 
+           adapter, then search through them until we find the one
+           which matches the IP we are looking for */
+        if ( NO_ERROR != ( error = GetAdaptersInfo ( adapters, &size ) ) ) {
+
+            /* failed to get the adapter information */
+            __leave;
+
         } else {
 
             /* initialize the Setup DLL */
@@ -133,70 +134,70 @@ WindowsNetworkAdapter::initialize (void) {
                 __leave;
 
             }
-
-            /* reset any bits set from a previous initialization */
-            wolResetSupportBits ();
-            wolResetEnableBits ();
-
-            /* got it, lets run through them and the one we 
-            are interested in */
+
+            /* reset any bits set from a previous initialization */
+            wolResetSupportBits ();
+            wolResetEnableBits ();
+
+            /* got it, lets run through them and the one we 
+            are interested in */
             current = adapters;
 
-            while ( current ) {
-                
-                char *ip = current->IpAddressList.IpAddress.String,
+            while ( current ) {
+                
+                char *ip = current->IpAddressList.IpAddress.String,
                      *description = current->Description;
 
-                if ( MATCH == strcmp ( _ip_address, ip ) ||
-                     MATCH == strcmp ( _description, description ) ) {
+                if ( MATCH == strcmp ( _ip_address, ip ) ||
+                     MATCH == strcmp ( _description, description ) ) {
 
-                    /* we do exist! */
+                    /* we do exist! */
                     _exists = true;
 
-                    /* record the adpater GUID */
-                    strncpy (
-                        _adapter_name, 
-                        current->AdapterName, 
-                        MAX_ADAPTER_NAME_LENGTH + 4 );
+                    /* record the adpater GUID */
+                    strncpy (
+                        _adapter_name, 
+                        current->AdapterName, 
+                        MAX_ADAPTER_NAME_LENGTH + 4 );
                     
-                    /* using the GUID, get the device's power 
-                    capabilities */ 
-                    power_data = getPowerData ();
+                    /* using the GUID, get the device's power 
+                    capabilities */ 
+                    power_data = getPowerData ();
                     if ( power_data ) {
 
-                        /* shorten the variable we need to use */
-                        supports = power_data->PD_Capabilities;
+                        /* shorten the variable we need to use */
+                        supports = power_data->PD_Capabilities;
                         
-                        /* do we support waking from any state? */
+                        /* do we support waking from any state? */
                         if ( supports & WAKE_FROM_ANY_SUPPORTED ) {
 
                             dprintf ( 
                                 D_FULLDEBUG, 
                                 "WOL_MAGIC enabled\n" );
-
-                            wolEnableSupportBit ( WOL_MAGIC );
-                            wolEnableEnableBit ( WOL_MAGIC );
-                        }
-
+
+                            wolEnableSupportBit ( WOL_MAGIC );
+                            wolEnableEnableBit ( WOL_MAGIC );
+                        }
+
                         LocalFree ( power_data );
                         power_data = NULL;
-
+
                     }
 
-                    /* copy over the adapter's subnet */
-                    strncpy (
-                        _subnet,
-                        current->IpAddressList.IpMask.String,
-                        IP_STRING_BUF_SIZE );
+                    /* copy over the adapter's subnet */
+                    strncpy (
+                        _subnet,
+                        current->IpAddressList.IpMask.String,
+                        IP_STRING_BUF_SIZE );
 
-                    /* finally, format the hardware address in the 
-                    format our tools expect */
+                    /* finally, format the hardware address in the 
+                    format our tools expect */
                     length = current->AddressLength;
-                    for ( i = 0; i < length; ++i ) {
+                    for ( i = 0; i < length; ++i ) {
                         sprintf ( offset, "%.2X%c", 
-                            current->Address[i], 
+                            current->Address[i], 
 				            i == length - 1 ? '\0' : ':' );
-                        offset += 3;
+                        offset += 3;
                     }
 
                     dprintf ( 
@@ -207,386 +208,360 @@ WindowsNetworkAdapter::initialize (void) {
                     /* if we got here, then the world is a happy place */
                     ok = true;
 
-                    /* we found the one we want, so bail out early */
-                    __leave;
-
-                } 
-
-                /* move on to the next one */
+                    /* we found the one we want, so bail out early */
+                    __leave;
+
+                } 
+
+                /* move on to the next one */
                 current = current->Next;
-
-            }
-
-        }       
-
-    }
-    __finally {
-
-        if ( adapters ) {
-            free ( adapters );
-        }
-
+
+            }
+
+        }       
+
+    }
+    __finally {
+
+        if ( adapters ) {
+            free ( adapters );
+        }
+
     }
 
-    return ok;
-
-}
-
-const char* 
-WindowsNetworkAdapter::hardwareAddress (void) const {
-    return _hardware_address;
-}
-
-unsigned
-WindowsNetworkAdapter::ipAddress (void) const {
-    return 0; /* not used on Windows */
-}
-
-const char*
-WindowsNetworkAdapter::subnet (void) const {
-    return _subnet;
-}
-
-bool
-WindowsNetworkAdapter::exists (void) const {
-    return _exists;
-}
-
-/*    The power data registry values requires some preprocessing before 
-    it can be queried, so we allow a user to specify a function to handle 
-    preprocessing.
-*/
-static void 
-processPowerData ( IN PBYTE p ) {
-    PCM_POWER_DATA ppd = (PCM_POWER_DATA) p;
-    ppd->PD_Size = sizeof ( ppd );
-}
-
-PCM_POWER_DATA 
-WindowsNetworkAdapter::getPowerData (void) const {
-
-    return (PCM_POWER_DATA) getRegistryProperty ( 
-        SPDRP_DEVICE_POWER_DATA, &processPowerData );
-
-}
-
-
-PBYTE 
-WindowsNetworkAdapter::getRegistryProperty ( 
-    IN DWORD registry_property,
-    IN PRE_PROCESS_REISTRY_VALUE preprocess ) const {
-
-        PVOID   device_information      = INVALID_HANDLE_VALUE;
-        DWORD   error                   = NO_ERROR, 
-                required                = 0,
-                index                   = 0,
-                last_error              = ERROR_SUCCESS;
-        SetupApiDLL::PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd = NULL;
-        PCHAR   short_name              = NULL;
-        PBYTE   value                   = NULL;
-        BOOL    enumerated_devices      = FALSE,
-                got_device_details      = FALSE,
-                got_registry_property   = FALSE,    
-                ok                      = FALSE;
-
-        __try {
-
-            device_information = SetupApiDLL::SetupDiGetClassDevs ( 
-                &CONDOR_GUID_NDIS_LAN_CLASS, 
-                0, 
-                0, 
-                DIGCF_PRESENT | DIGCF_DEVICEINTERFACE );
-
-            if ( INVALID_HANDLE_VALUE == device_information ) {
-                
-                last_error = GetLastError ();
-
-                dprintf ( 
-                    D_FULLDEBUG, 
-                    "WindowsNetworkAdapter::getRegistryProperty: "
-                    "SetupDiGetClassDevs call failed: "
-                    "(last-error = %d)\n",
-                    last_error );
-
-                __leave;
-
-            }
-
-            while ( true ) {
-
-                //
-                // We loop indefinitely because the number of 
-                // interfaces is only known to us when we run 
-                // out of them: it is at this time that we 
-                // break out of the loop.
-                //
-
-                SetupApiDLL::SP_DEVICE_INTERFACE_DATA did = { 
-                    sizeof ( SetupApiDLL::SP_DEVICE_INTERFACE_DATA ) };
-
-                enumerated_devices = SetupApiDLL::SetupDiEnumDeviceInterfaces (
-                    device_information,
-                    NULL,
-                    &CONDOR_GUID_NDIS_LAN_CLASS,
-                    index++,
-                    &did );            
-
-                if ( !enumerated_devices ) {
-
-                    last_error = GetLastError ();
-
-                    //
-                    // Perhaps there are no more interfaces, in 
-                    // which case it is ok that we failed.
-                    //
-                    if ( ERROR_NO_MORE_ITEMS == last_error ) {                
-                        
-                        ok = TRUE;
-
-                    }
-
-                    __leave;
-
-                } 
-
-                SetupApiDLL::SP_DEVINFO_DATA dd 
-                    = { sizeof ( SetupApiDLL::SP_DEVINFO_DATA ) };
-
-                got_device_details = SetupApiDLL::SetupDiGetDeviceInterfaceDetail ( 
-                    device_information,
-                    &did,
-                    NULL,
-                    0,
-                    &required,
-                    &dd );    // MSDN says this is optional,
-                              // but it is not... here...
-
-                if ( !got_device_details ) {
-
-                    last_error = GetLastError ();
-
-                    if ( ERROR_INSUFFICIENT_BUFFER == last_error ) {
-
-                        pdidd = (SetupApiDLL::PSP_DEVICE_INTERFACE_DETAIL_DATA)
-                            LocalAlloc ( 
-                                LPTR, 
-                                required );
-
-                        if  ( !pdidd ) {
-                            
-                            last_error = GetLastError ();
-                            
-                            dprintf ( 
-                                D_FULLDEBUG, 
-                                "WindowsNetworkAdapter::"
-                                "getRegistryProperty: "
-                                "LocalAlloc call failed: "
-                                "(last-error = %d)\n",
-                                last_error );
-                            
-                            __leave;
-
-                        }
-
-                        pdidd->cbSize = sizeof ( *pdidd );
-
-                    } else {
-
-                        dprintf ( 
-                            D_FULLDEBUG, 
-                            "WindowsNetworkAdapter::"
-                            "getRegistryProperty: "
-                            "SetupDiGetDeviceInterfaceDetail (1st) "
-                            "call failed: (last-error = %d)\n",
-                            last_error );
-                        
-                        __leave;
-
-                    }
-
-                } 
-
-                got_registry_property = SetupApiDLL::SetupDiGetDeviceInterfaceDetail (
-                    device_information,
-                    &did,
-                    pdidd,
-                    required,
-                    NULL,
-                    NULL ); // here, however, it *is* optional?!
-                            // (WTF!?!--pardon my French)
-
-                if ( !got_registry_property ) {
-                    
-                    last_error = GetLastError ();
-                    
-                    dprintf ( 
-                        D_FULLDEBUG, 
-                        "WindowsNetworkAdapter::getRegistryProperty: "
-                        "SetupDiGetDeviceInterfaceDetail (2nd) call "
-                        "failed: (last-error = %d)\n",
-                        last_error );
-
-                    __leave;
-
-                }
-
-                //dprintf ( D_FULLDEBUG, "DevicePath: %s\n", pdidd->DevicePath );
-
-                // 
-                // Device paths are of the form:
-                //
-                // \\?\root#ms_ptiminiport#0000#{ad498944-762f-11d0-8dcb \
-                //   -00c04fc3358c}\{5a8445c2-ecd0-407d-a359-e1a98fb299b4}
-                //
-                // Where the final guid is the device name or 
-                // "id"; that is to say: it is the part we are 
-                // interested in.
-                //
-                short_name = strrchr ( 
-                    pdidd->DevicePath, 
-                    '\\' ) + 1;
-
-                if ( 0 != strnicmp ( 
-                        _adapter_name, 
-                        short_name, 
-                        GUID_STR_LENGTH ) ) {
-
-                    //
-                    // If this is not the guid we are looking for,
-                    // then keep on searching...
-                    //
-                    LocalFree ( pdidd );
-                    continue;
-
-                }
-
+    return ok;
+
+}
+
+const char* 
+WindowsNetworkAdapter::hardwareAddress (void) const {
+    return _hardware_address;
+}
+
+unsigned
+WindowsNetworkAdapter::ipAddress (void) const {
+    return 0; /* not used on Windows */
+}
+
+const char*
+WindowsNetworkAdapter::subnet (void) const {
+    return _subnet;
+}
+
+bool
+WindowsNetworkAdapter::exists (void) const {
+    return _exists;
+}
+
+/*    The power data registry values requires some preprocessing before 
+    it can be queried, so we allow a user to specify a function to handle 
+    preprocessing.
+*/
+static void 
+processPowerData ( IN PBYTE p ) {
+    PCM_POWER_DATA ppd = (PCM_POWER_DATA) p;
+    ppd->PD_Size = sizeof ( ppd );
+}
+
+PCM_POWER_DATA 
+WindowsNetworkAdapter::getPowerData (void) const {
+
+    return (PCM_POWER_DATA) getRegistryProperty ( 
+        SPDRP_DEVICE_POWER_DATA, &processPowerData );
+
+}
+
+
+PBYTE 
+WindowsNetworkAdapter::getRegistryProperty ( 
+    IN DWORD registry_property,
+    IN PRE_PROCESS_REISTRY_VALUE preprocess ) const {
+
+        PVOID   device_information      = INVALID_HANDLE_VALUE;
+        DWORD   error                   = NO_ERROR, 
+                required                = 0,
+                index                   = 0,
+                last_error              = ERROR_SUCCESS;
+        SetupApiDLL::PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd = NULL;
+        PCHAR   short_name              = NULL;
+        PBYTE   value                   = NULL;
+        BOOL    enumerated_devices      = FALSE,
+                got_device_details      = FALSE,
+                got_registry_property   = FALSE,    
+                ok                      = FALSE;
+
+        __try {
+
+            device_information = SetupApiDLL::SetupDiGetClassDevs ( 
+                &CONDOR_GUID_NDIS_LAN_CLASS, 
+                0, 
+                0, 
+                DIGCF_PRESENT | DIGCF_DEVICEINTERFACE );
+
+            if ( INVALID_HANDLE_VALUE == device_information ) {
+                
+                last_error = GetLastError ();
+
+				deprintf(D_FULLDEBUG,last_error,
+					"WindowsNetworkAdapter::getRegistryProperty: "
+                    "SetupDiGetClassDevs call failed.\n");
+                __leave;
+
+            }
+
+            while ( true ) {
+
+                //
+                // We loop indefinitely because the number of 
+                // interfaces is only known to us when we run 
+                // out of them: it is at this time that we 
+                // break out of the loop.
+                //
+
+                SetupApiDLL::SP_DEVICE_INTERFACE_DATA did = { 
+                    sizeof ( SetupApiDLL::SP_DEVICE_INTERFACE_DATA ) };
+
+                enumerated_devices = SetupApiDLL::SetupDiEnumDeviceInterfaces (
+                    device_information,
+                    NULL,
+                    &CONDOR_GUID_NDIS_LAN_CLASS,
+                    index++,
+                    &did );            
+
+                if ( !enumerated_devices ) {
+
+                    last_error = GetLastError ();
+
+                    //
+                    // Perhaps there are no more interfaces, in 
+                    // which case it is ok that we failed.
+                    //
+                    if ( ERROR_NO_MORE_ITEMS == last_error ) {                
+                        
+                        ok = TRUE;
+
+                    }
+
+                    __leave;
+
+                } 
+
+                SetupApiDLL::SP_DEVINFO_DATA dd 
+                    = { sizeof ( SetupApiDLL::SP_DEVINFO_DATA ) };
+
+                got_device_details = SetupApiDLL::SetupDiGetDeviceInterfaceDetail ( 
+                    device_information,
+                    &did,
+                    NULL,
+                    0,
+                    &required,
+                    &dd );    // MSDN says this is optional,
+                              // but it is not... here...
+
+                if ( !got_device_details ) {
+
+                    last_error = GetLastError ();
+
+                    if ( ERROR_INSUFFICIENT_BUFFER == last_error ) {
+
+                        pdidd = (SetupApiDLL::PSP_DEVICE_INTERFACE_DETAIL_DATA)
+                            LocalAlloc ( 
+                                LPTR, 
+                                required );
+
+                        if  ( !pdidd ) {
+                            
+                            last_error = GetLastError ();
+                            deprintf(D_FULLDEBUG,last_error,
+								"WindowsNetworkAdapter::"
+                                "getRegistryProperty: "
+                                "LocalAlloc call failed.\n");                        
+                            __leave;
+
+                        }
+
+                        pdidd->cbSize = sizeof ( *pdidd );
+
+                    } else {
+
+                        dprintf ( 
+                            D_FULLDEBUG, 
+                            "WindowsNetworkAdapter::"
+                            "getRegistryProperty: "
+                            "SetupDiGetDeviceInterfaceDetail (1st) "
+                            "call failed: (last-error = %d)\n",
+                            last_error );
+                        
+                        __leave;
+
+                    }
+
+                } 
+
+                got_registry_property = SetupApiDLL::SetupDiGetDeviceInterfaceDetail (
+                    device_information,
+                    &did,
+                    pdidd,
+                    required,
+                    NULL,
+                    NULL ); // here, however, it *is* optional?!
+                            // (WTF!?!--pardon my French)
+
+                if ( !got_registry_property ) {
+                    
+                    last_error = GetLastError ();
+                    deprintf(D_FULLDEBUG,last_error,
+						"WindowsNetworkAdapter::getRegistryProperty: "
+                        "SetupDiGetDeviceInterfaceDetail (2nd) call.\n");
+                    __leave;
+
+                }
+
+                //dprintf ( D_FULLDEBUG, "DevicePath: %s\n", pdidd->DevicePath );
+
+                // 
+                // Device paths are of the form:
+                //
+                // \\?\root#ms_ptiminiport#0000#{ad498944-762f-11d0-8dcb \
+                //   -00c04fc3358c}\{5a8445c2-ecd0-407d-a359-e1a98fb299b4}
+                //
+                // Where the final guid is the device name or 
+                // "id"; that is to say: it is the part we are 
+                // interested in.
+                //
+                short_name = strrchr ( 
+                    pdidd->DevicePath, 
+                    '\\' ) + 1;
+
+                if ( 0 != strnicmp ( 
+                        _adapter_name, 
+                        short_name, 
+                        GUID_STR_LENGTH ) ) {
+
+                    //
+                    // If this is not the guid we are looking for,
+                    // then keep on searching...
+                    //
+                    LocalFree ( pdidd );
+                    continue;
+
+                }
+
                 //dprintf ( D_FULLDEBUG, "DeviceName: %s\n", _adapter_name );
 
-                got_registry_property = SetupApiDLL::SetupDiGetDeviceRegistryProperty (
-                    device_information,
-                    &dd,
-                    registry_property,
-                    NULL,
-                    NULL,
-                    0,
-                    &required );
-
-                //dprintf ( D_FULLDEBUG, "registry_property required: %d\n", required );
-
-                if ( !got_registry_property ) {
-
-                    last_error = GetLastError ();
-
-                    if ( ERROR_INSUFFICIENT_BUFFER == last_error ) {
-
-                        value = (PBYTE) LocalAlloc ( 
-                            LPTR, 
-                            required );
-
-                        if  ( !value ) {
-
-                            last_error = GetLastError ();
-                            
-                            dprintf ( 
-                                D_FULLDEBUG, 
-                                "WindowsNetworkAdapter::"
-                                "getRegistryProperty: "
-                                "LocalAlloc call "
-                                "failed: (last-error = %d)\n",
-                                last_error );
-                            
-                            __leave;
-
-                        }
-
-                    } else {
-
-                        last_error = GetLastError ();
-                        
-                        dprintf ( 
-                            D_FULLDEBUG, 
-                            "WindowsNetworkAdapter::"
-                            "getRegistryProperty: "
-                            "SetupDiGetDeviceRegistryProperty (1st) "
-                            "call failed: (last-error = %d)\n",
-                            last_error );
-                        
-                        __leave;
-
-                    }
-
-                } 
-
-                //
-                // Do any preprocessing that may be required
-                //
-                if ( preprocess ) {
-                    preprocess ( value );
-                }
-
-                got_registry_property = SetupApiDLL::SetupDiGetDeviceRegistryProperty (
-                    device_information,
-                    &dd,
-                    registry_property,
-                    NULL,
-                    value,
-                    required,
-                    NULL );
-
-                if ( !got_registry_property ) {
-
-                    last_error = GetLastError ();
-
-                    dprintf ( 
-                        D_FULLDEBUG, 
-                        "WindowsNetworkAdapter::getRegistryProperty: "
-                        "SetupDiGetDeviceRegistryProperty (2nd) "
-                        "call failed: (last-error = %d)\n",
-                        last_error );
-
-                    __leave;
-
-                }            
-
-                // 
-                // If we get here, then it means we have found the 
-                // device information we were looking for and can 
-                // return it.
-                //
-                ok = TRUE;
-
-                __leave;
-
-            }             
-
-        }
-        __finally {
-
-            //
-            // Propagate the last error 
-            //
-            SetLastError ( ok ? ERROR_SUCCESS : last_error );
-
-            if ( INVALID_HANDLE_VALUE != device_information ) {
-                SetupApiDLL::SetupDiDestroyDeviceInfoList ( device_information );
-            }
-
-            if ( pdidd ) {
-                LocalFree ( pdidd );
-                pdidd = NULL;
-            }
-
-            if ( !ok && value ) {
-                LocalFree ( value );
-                value = NULL;
-            }
-
-        }
-
-        //
-        // If we found the device information, the following will be a 
-        // valid pointer to it; otherwise, it will be NULL.
-        //
-        return value;
-
-}
+                got_registry_property = SetupApiDLL::SetupDiGetDeviceRegistryProperty (
+                    device_information,
+                    &dd,
+                    registry_property,
+                    NULL,
+                    NULL,
+                    0,
+                    &required );
+
+                //dprintf ( D_FULLDEBUG, "registry_property required: %d\n", required );
+
+                if ( !got_registry_property ) {
+
+                    last_error = GetLastError ();
+
+                    if ( ERROR_INSUFFICIENT_BUFFER == last_error ) {
+
+                        value = (PBYTE) LocalAlloc ( 
+                            LPTR, 
+                            required );
+
+                        if  ( !value ) {
+
+                            last_error = GetLastError ();
+                            deprintf(D_FULLDEBUG,last_error,
+								"WindowsNetworkAdapter::"
+                                "getRegistryProperty: "
+                                "LocalAlloc call failed.\n"
+								);                        
+                            __leave;
+
+                        }
+
+                    } else {
+
+                        last_error = GetLastError ();
+                        deprintf(D_FULLDEBUG,last_error,
+							"WindowsNetworkAdapter::"
+                            "getRegistryProperty: "
+                            "SetupDiGetDeviceRegistryProperty (1st) "
+							"call failed.\n");
+                        __leave;
+
+                    }
+
+                } 
+
+                //
+                // Do any preprocessing that may be required
+                //
+                if ( preprocess ) {
+                    preprocess ( value );
+                }
+
+                got_registry_property = SetupApiDLL::SetupDiGetDeviceRegistryProperty (
+                    device_information,
+                    &dd,
+                    registry_property,
+                    NULL,
+                    value,
+                    required,
+                    NULL );
+
+                if ( !got_registry_property ) {
+
+                    last_error = GetLastError ();
+					deprintf(D_FULLDEBUG,last_error, 
+						"WindowsNetworkAdapter::getRegistryProperty: "
+                        "SetupDiGetDeviceRegistryProperty (2nd) "
+						"call failed.\n");
+                    __leave;
+
+                }            
+
+                // 
+                // If we get here, then it means we have found the 
+                // device information we were looking for and can 
+                // return it.
+                //
+                ok = TRUE;
+
+                __leave;
+
+            }             
+
+        }
+        __finally {
+
+            //
+            // Propagate the last error 
+            //
+            SetLastError ( ok ? ERROR_SUCCESS : last_error );
+
+            if ( INVALID_HANDLE_VALUE != device_information ) {
+                SetupApiDLL::SetupDiDestroyDeviceInfoList ( device_information );
+            }
+
+            if ( pdidd ) {
+                LocalFree ( pdidd );
+                pdidd = NULL;
+            }
+
+            if ( !ok && value ) {
+                LocalFree ( value );
+                value = NULL;
+            }
+
+        }
+
+        //
+        // If we found the device information, the following will be a 
+        // valid pointer to it; otherwise, it will be NULL.
+        //
+        return value;
+
+}
diff --git a/src/condor_c++_util/ntsysinfo.cpp b/src/condor_c++_util/ntsysinfo.cpp
index 0217314..e2cc10e 100644
--- a/src/condor_c++_util/ntsysinfo.cpp
+++ b/src/condor_c++_util/ntsysinfo.cpp
@@ -33,6 +33,7 @@
 #include "condor_common.h"
 #include "ntsysinfo.h"
 #include <psapi.h>
+#include "deprintf.h"
 
 // Initialize static members in the class
 int CSysinfo::reference_count = 0;
@@ -526,8 +527,7 @@ CSysinfo::GetProcessBirthday(pid_t pid, FILETIME* ft) {
 			pid );
 
 	if ( pidHnd == NULL ) {
-		dprintf(D_ALWAYS, "CSysinfo::GetProcessBirthday() - OpenProcess() "
-			   "failed with err=%d\n", GetLastError());	
+		deprintf(D_ALWAYS,GetLastError(),"CSysinfo::GetProcessBirthday() - OpenProcess() failed.\n");
 		return false;
 	}
 
@@ -535,8 +535,7 @@ CSysinfo::GetProcessBirthday(pid_t pid, FILETIME* ft) {
 	result = GetProcessTimes(pidHnd, &crtime, &extime, &kerntime, &usertime);
 
 	if ( result == 0 ) {
-		dprintf(D_ALWAYS, "CSysinfo::GetProcessBirthday() - GetProcessTimes() "
-			   "failed with err=%d\n", GetLastError());	
+		deprintf(D_ALWAYS,GetLastError(),"CSysinfo::GetProcessBirthday() - GetProcessTimes() failed.\n");
 		CloseHandle(pidHnd);
 		return false;
 	}
diff --git a/src/condor_c++_util/perm.cpp b/src/condor_c++_util/perm.cpp
index fd545ea..e4b3bde 100644
--- a/src/condor_c++_util/perm.cpp
+++ b/src/condor_c++_util/perm.cpp
@@ -23,6 +23,7 @@
 #include "domain_tools.h"
 #include "Lm.h"
 #include "dynuser.h"
+#include "deprintf.h"
 
 //
 // get_permissions:  1 = yes, 0 = no, -1 = unknown/error
@@ -83,7 +84,9 @@ int perm::get_permissions( const char *file_name, ACCESS_MASK &AccessRights ) {
 			
 			return retVal;
 		}
-		dprintf(D_ALWAYS, "perm::GetFileSecurity failed (err=%d)\n", GetLastError());
+
+		deprintf(D_ALWAYS,GetLastError(), "perm::GetFileSecurity failed.\n");
+
 		return -1;
 	}
 	
@@ -101,7 +104,7 @@ int perm::get_permissions( const char *file_name, ACCESS_MASK &AccessRights ) {
 		pSD_length, 				// size of security descriptor buffer
 		&pSD_length_needed			// address of required size of buffer
 		) ) {
-		dprintf(D_ALWAYS, "perm::GetFileSecurity(%s) failed (err=%d)\n", file_name, GetLastError());
+			deprintf(D_ALWAYS,GetLastError(), "perm::GetFileSecurity(%s) failed.\n", file_name);
 		delete pSD;
 		return -1;
 	}
@@ -112,8 +115,9 @@ int perm::get_permissions( const char *file_name, ACCESS_MASK &AccessRights ) {
 		&acl_present,					// address of flag for presence of disc. ACL
 		&pacl,							// address of pointer to ACL
 		&acl_defaulted					// address of flag for default disc. ACL
-		) ) {
-		dprintf(D_ALWAYS, "perm::GetSecurityDescriptorDacl failed (file=%s err=%d)\n", file_name, GetLastError());
+		) ) 
+	{
+		deprintf(D_ALWAYS,GetLastError(),"perm::GetSecurityDescriptorDacl failed (file=%s)\n",file_name);
 		delete pSD;
 		return -1;
 	}
@@ -136,8 +140,9 @@ int perm::get_permissions( const char *file_name, ACCESS_MASK &AccessRights ) {
 								acl_info,	// buffer to receive info
 								24,			// size in bytes of buffer
 								AclSizeInformation // class of info to retrieve
-								) ) {
-			dprintf(D_ALWAYS, "Perm::GetAclInformation failed with error %d\n", GetLastError() );
+								) ) 
+		{
+			deprintf(D_ALWAYS,GetLastError(),"Perm::GetAclInformation failed.\n");
 			return -1;
 		}
 
@@ -157,8 +162,9 @@ int perm::get_permissions( const char *file_name, ACCESS_MASK &AccessRights ) {
 			if (! GetAce(	pacl,	// pointer to ACL 
 							i,		// index of ACE we want
 							&current_ace	// pointer to ACE
-							) ) {
-				dprintf(D_ALWAYS, "Perm::GetAce() failed! Error code %d\n", GetLastError() );
+							) ) 
+			{
+				deprintf(D_ALWAYS,GetLastError(),"Perm::GetAce() failed!\n");
 				return -1;
 			}
 
@@ -335,8 +341,8 @@ int perm::userInGlobalGroup( const char *account, const char *domain, const char
 		case NERR_GroupNotFound:
 			char* DCname = new char[ wcslen( DomainController )+1 ];
 			wsprintf(DCname, "%ws", DomainController);
-			dprintf(D_ALWAYS, "perm::NetGroupGetUsers failed: (domain: %s, domain controller: %s, total entries: %d, entries read: %d, err=%d)",
-				group_domain, DCname, total_entries, entries_read, GetLastError());
+			deprintf(D_ALWAYS,GetLastError(),"perm::NetGroupGetUsers failed: (domain: %s, domain controller: %s, total entries: %d, entries read: %d.\n",
+				group_domain, DCname, total_entries, entries_read);
 			delete[] DCname;
 			NetApiBufferFree( BufPtr );
 			NetApiBufferFree( DomainController );
@@ -415,7 +421,7 @@ int perm::userInAce ( const LPVOID cur_ace, const char *account, const char *dom
 		);	
 
 	if ( ! success ) {
-		dprintf(D_ALWAYS, "perm::LookupAccountSid failed (err=%d)\n", GetLastError());
+		deprintf(D_ALWAYS,GetLastError(), "perm::LookupAccountSid failed.\n");
 		if (trustee_name) { delete[] trustee_name; trustee_name = NULL; }
 		if (trustee_domain) { delete[] trustee_domain; trustee_domain = NULL; }
 		return -1;
@@ -444,7 +450,7 @@ int perm::userInAce ( const LPVOID cur_ace, const char *account, const char *dom
 		
 		if (! success ) {
 			// this should never happen
-			dprintf(D_ALWAYS, "perm::GetComputerName failed: (Err: %d)", GetLastError());
+			deprintf(D_ALWAYS,GetLastError(),"perm::GetComputerName failed.\n");
 			result = -1; // failure
 		} else if ( strcmp( trustee_name, "Everyone" ) == 0 ) { 
 			// if file is in group Everyone, we're done.
@@ -546,9 +552,8 @@ bool perm::init( const char *accountname, const char *domain )
 		&snu ) )							// SID TYPE
 	{
 		
-		dprintf(D_ALWAYS,
-			"perm::init: Lookup Account Name %s failed (err=%lu), using Everyone\n",
-			accountname, GetLastError());
+		deprintf(D_ALWAYS,GetLastError(),"perm::init: Lookup Account Name %s failed, using Everyone.\n",
+			accountname);
 		
 		// SID_IDENTIFIER_AUTHORITY  NTAuth = SECURITY_NT_AUTHORITY;
 		SID_IDENTIFIER_AUTHORITY  NTAuth = SECURITY_WORLD_SID_AUTHORITY;
@@ -687,10 +692,7 @@ bool perm::volume_has_acls( const char *filename )
 	if ( !GetVolumeInformation(root_path,NULL,0,NULL,&foo,&fsflags,
 		NULL,0) ) 
 	{
-		dprintf(D_ALWAYS,
-		        "perm: GetVolumeInformation on volume %s FAILED err=%d\n",
-				root_path ? root_path : "(null)",
-		        GetLastError());
+		deprintf(D_ALWAYS,GetLastError(),"perm: GetVolumeInformation on volume %s FAILED\n", root_path ? root_path : "(null)");
 		if (root_path) {
 			free(root_path);
 		}
@@ -835,10 +837,10 @@ perm::set_acls( const char *filename )
 		HANDLE hToken = NULL;
 
 		if (!OpenProcessToken(GetCurrentProcess(), 
-			TOKEN_ADJUST_PRIVILEGES, &hToken)) {
+			TOKEN_ADJUST_PRIVILEGES, &hToken)) 
+		{
 
-          dprintf(D_ALWAYS, "perm: OpenProcessToken failed: %u\n",
-				  GetLastError()); 
+			deprintf(D_ALWAYS,GetLastError(),"perm: OpenProcessToken failed.\n");
        } else {
 
 	    	// Enable the SE_SECURITY_NAME privilege.
@@ -860,8 +862,7 @@ perm::set_acls( const char *filename )
 
 	if (err != ERROR_SUCCESS)
 	{
-		dprintf(D_ALWAYS, "perm::set_acls(%s): Unable to set file ACL"
-				"(err=%d).\n", filename,GetLastError() );
+		deprintf(D_ALWAYS,GetLastError(),"perm::set_acls(%s): Unable to set file ACL.\n", filename);
 		return false;
 	}
 	
@@ -903,9 +904,9 @@ bool perm::set_owner( const char *location ) {
 		qualified_name,						// Account name
 		owner_SID, &sidBufferSize,			// Sid
 		domainBuffer, &domainBufferSize,	// Domain
-		&usage) ) {							// SID TYPE
-		dprintf(D_ALWAYS, "perm: LookupAccountName(%s, size) failed "
-				"(err=%d)\n", qualified_name, GetLastError());
+		&usage) )							// SID TYPE
+	{							
+		deprintf(D_ALWAYS,GetLastError(), "perm: LookupAccountName(%s, size) failed.\n", qualified_name);
 		return false;
 	}
 
@@ -928,8 +929,7 @@ bool perm::set_owner( const char *location ) {
 		if (!OpenProcessToken(GetCurrentProcess(), 
 			TOKEN_ADJUST_PRIVILEGES, &hToken)) 
        {
-          dprintf(D_ALWAYS, "perm: OpenProcessToken failed: %u\n",
-				  GetLastError()); 
+		  deprintf(D_ALWAYS,GetLastError(), "perm: OpenProcessToken failed.\n");
        } else {
 
 	    	// Enable the SE_TAKE_OWNERSHIP_NAME privilege.
@@ -975,7 +975,7 @@ bool SetPrivilege(
 		lpszPrivilege,   // privilege to lookup 
 		&luid ) )        // receives LUID of privilege
 	{
-		dprintf(D_ALWAYS, "LookupPrivilegeValue error: %u\n", GetLastError() ); 
+		deprintf(D_ALWAYS,GetLastError(),"LookupPrivilegeValue error.\n");
 		return false; 
 	}
 
@@ -997,7 +997,7 @@ bool SetPrivilege(
 		(PTOKEN_PRIVILEGES) NULL, 
 		(PDWORD) NULL) )
 	{ 
-		dprintf(D_ALWAYS, "AdjustTokenPrivileges error: %u\n", GetLastError()); 
+		deprintf(D_ALWAYS,GetLastError(), "AdjustTokenPrivileges error.\n");
 		return false; 
 	} 
 
diff --git a/src/condor_c++_util/process_control.WINDOWS.cpp b/src/condor_c++_util/process_control.WINDOWS.cpp
index 6e6d2f2..9b6db43 100644
--- a/src/condor_c++_util/process_control.WINDOWS.cpp
+++ b/src/condor_c++_util/process_control.WINDOWS.cpp
@@ -24,6 +24,7 @@
 #include "ntsysinfo.h"
 #include "HashTable.h"
 #include "condor_softkill.h"
+#include "deprintf.h"
 
 static char* soft_kill_binary = NULL;
 
@@ -93,9 +94,7 @@ windows_soft_kill(DWORD pid)
 	                  &si,
 	                  &pi) == FALSE)
 	{
-		dprintf(D_ALWAYS,
-		        "windows_soft_kill: CreateProcess error: %u\n",
-		        GetLastError());
+		deprintf(D_ALWAYS, GetLastError(), "windows_soft_kill: CreateProcess error.\n");
 		return false;
 	}
 	CloseHandle(pi.hThread);
@@ -104,18 +103,15 @@ windows_soft_kill(DWORD pid)
 	// it indicates failure
 	//
 	if (WaitForSingleObject(pi.hProcess, INFINITE) != WAIT_OBJECT_0) {
-		dprintf(D_ALWAYS,
-		        "windows_soft_kill: WaitForSingleObject error: %u\n",
-		        GetLastError());
+		deprintf(D_ALWAYS, GetLastError(), "windows_soft_kill: WaitForSingleObject error.\n");
+		
 	}
 	DWORD exit_code;
 	BOOL result = GetExitCodeProcess(pi.hProcess, &exit_code);
 	DWORD error = GetLastError();
 	CloseHandle(pi.hProcess);
 	if (result == FALSE) {
-		dprintf(D_ALWAYS,
-		        "windows_soft_kill: GetExitCodeProcess error: %u\n",
-		        GetLastError());
+		deprintf(D_ALWAYS, GetLastError(), "windows_soft_kill: GetExitCodeProcess error.\n");
 		return false;
 	}
 	if (exit_code != SOFTKILL_SUCCESS) {
@@ -135,18 +131,15 @@ windows_hard_kill(DWORD pid)
 {
 	HANDLE process = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
 	if (process == NULL) {
-		dprintf(D_ALWAYS,
-		        "windows_hard_kill: OpenProcess error: %u\n",
-		        GetLastError());
+		deprintf(D_ALWAYS,GetLastError(), "windows_hard_kill: OpenProcess error.\n");
 		return false;
 	}
 	BOOL ok = TerminateProcess(process, 0);
 	DWORD err = GetLastError();
 	CloseHandle(process);
+	
 	if (ok == FALSE) {
-		dprintf(D_ALWAYS,
-		        "windows_hard_kill: TerminateProcess error: %u\n",
-		        (unsigned)err);
+		deprintf(D_ALWAYS,err,"windows_hard_kill: TerminateProcess error.\n");
 		return false;
 	}
 	return true;
@@ -244,9 +237,7 @@ windows_suspend(DWORD pid)
 					// or CreateThread first, so we'll have to loop again
 					//
 					finished = false;
-					dprintf(D_FULLDEBUG,
-					        "windows_suspend_process: OpenThread error: %u\n",
-					        GetLastError());
+					deprintf(D_FULLDEBUG,GetLastError(),"windows_suspend_process: OpenThread error.\n");
 					continue;
 				}
 
@@ -268,9 +259,7 @@ windows_suspend(DWORD pid)
 				// how can this happen? maybe the thread exited?
 				//
 				finished = false;
-				dprintf(D_FULLDEBUG,
-						"windows_suspend_process: SuspendThread error: %u\n",
-						GetLastError());
+				deprintf(D_FULLDEBUG,GetLastError(),"windows_suspend_process: SuspendThread error.\n");
 				continue;
 			}
 
@@ -309,18 +298,14 @@ windows_continue(DWORD pid)
 		//
 		for (int i = 0; i < st->num_suspends; i++) {
 			if (ResumeThread(st->handle) == (DWORD)-1) {
-				dprintf(D_FULLDEBUG,
-				        "windows_continue_process: ResumeThread error: %u\n",
-				        GetLastError());
+				deprintf(D_FULLDEBUG,GetLastError(), "windows_continue_process: ResumeThread error.\n");
 			}
 		}
 
 		// close our handle to this thread
 		//
 		if (CloseHandle(st->handle) == FALSE) {
-			dprintf(D_FULLDEBUG,
-			        "windows_continue_process: CloseHandle error: %u\n",
-			        GetLastError());
+			deprintf(D_FULLDEBUG,GetLastError(),"windows_continue_process: CloseHandle error.\n");
 		}
 
 		// clean up this SuspendedThread object
diff --git a/src/condor_c++_util/profile.WINDOWS.cpp b/src/condor_c++_util/profile.WINDOWS.cpp
index 1ecbc9a..d458701 100644
--- a/src/condor_c++_util/profile.WINDOWS.cpp
+++ b/src/condor_c++_util/profile.WINDOWS.cpp
@@ -29,6 +29,7 @@
 #include "remote_close.WINDOWS.h"
 #include "directory.WINDOWS.h"
 #include "security.WINDOWS.h"
+#include "deprintf.h"
 
 #include <userenv.h>    // for LoadUserProfile, etc.
 #include <sddl.h>       // for ConvertSidToStringSid
@@ -303,15 +304,17 @@ OwnerProfile::destroy () const {
             user_token_, 
             &user_sid );
 
+		if(got_user_sid)
+		{
         dprintf ( 
             D_FULLDEBUG, 
             "UserProfile::destroy: Loading %s's SID "
-            "%s. (last-error = %u)\n", 
-            user_name_,
-            got_user_sid ? "succeeded" : "failed", 
-            got_user_sid ? 0 : GetLastError () );
-
-        if ( !got_user_sid ) {
+            "succeeded.\n", 
+            user_name_);
+		}
+		else
+		{
+			deprintf(D_FULLDEBUG,GetLastError(),"UserProfile::destroy: Loading %s's SID failed.\n", user_name_);
             __leave;
         }
 
@@ -320,15 +323,17 @@ OwnerProfile::destroy () const {
             user_sid,
             &user_sid_string );
 
+		if(got_sid_string)
+		{
         dprintf ( 
             D_FULLDEBUG, 
             "UserProfile::destroy: Converting SID to a string "
-            "%s. (last-error = %u)\n", 
-            got_sid_string ? "succeeded" : "failed", 
-            got_sid_string ? 0 : GetLastError () );
-        
-        if ( !got_sid_string ) {
-            __leave;
+            "succeeded\n" );
+		}
+		else
+		{
+			deprintf(D_FULLDEBUG, GetLastError(), "UserProfile::destroy: Converting SID to a string failed.\n");
+		   __leave;
         }
 
         /* let Windows remove the profile for us */
@@ -336,16 +341,17 @@ OwnerProfile::destroy () const {
             user_sid_string,
             profile_directory_,
             NULL /* local computer */ );
-
-        dprintf ( 
-            D_FULLDEBUG, 
-            "UserProfile::destroy: Removing %s's profile "
-            "directory %s. (last-error = %u)\n", 
-            user_name_,
-            profile_deleted ? "succeeded" : "failed", 
-            profile_deleted ? 0 : GetLastError () );
-        
-        if ( !profile_deleted ) {
+		if(profile_deleted)
+		{
+			dprintf ( 
+				D_FULLDEBUG, 
+				"UserProfile::destroy: Removing %s's profile "
+				"directory succeeeded.\n", 
+				user_name_);
+		}
+        else
+		{
+			deprintf(D_FULLDEBUG,GetLastError(),"UserProfile::destroy: Removing %s's profile directory failed.\n", user_name_);
             __leave;
         }
 
@@ -437,13 +443,7 @@ OwnerProfile::load () {
         resources). */
         if ( profile_directory_ ) {
 
-            dprintf ( 
-                D_FULLDEBUG, 
-                "OwnerProfile::load: %s's profile directory: '%s'. "
-                "(last-error = %u)\n",
-                user_name_,
-                profile_directory_, 
-                GetLastError () );
+			deprintf(D_FULLDEBUG,GetLastError(),"OwnerProfile::load: %s's profile directory '%s'.\n", user_name_, profile_directory_);
             
             dprintf ( 
                 D_FULLDEBUG, 
@@ -462,13 +462,7 @@ OwnerProfile::load () {
             if ( INVALID_HANDLE_VALUE == have_access ) {
 
                 last_error = GetLastError ();
-
-                dprintf ( 
-                    D_FULLDEBUG, 
-                    "OwnerProfile::load: Failed to access '%s'. "
-                    "(last-error = %u)\n",
-                    profile_directory_,
-                    last_error );
+				deprintf(D_FULLDEBUG,last_error,"OwnerProfile::load: Failed to access '%s'.\n", profile_directory_);
 
                 if (   ERROR_ACCESS_DENIED     == last_error 
                     || ERROR_SHARING_VIOLATION == last_error ) {
@@ -484,15 +478,17 @@ OwnerProfile::load () {
                     and create a new one (see bellow) */
                     profile_destroyed = destroy ();
 
+					if(profile_destroyed)
+					{
                     dprintf ( 
                         D_FULLDEBUG, 
                         "OwnerProfile::load: Destruction of %s's "
-                        "profile %s. (last-error = %u)\n",
-                        user_name_,
-                        profile_destroyed ? "succeeded" : "failed", 
-                        profile_destroyed ? 0 : GetLastError () );
-
-                    if ( !profile_destroyed ) {
+                        "profile succeeded.\n",
+                        user_name_);
+					}
+					else
+					{
+						deprintf(D_FULLDEBUG,GetLastError(),"OwnerProfile::load: Destruction of %s's profile failed.\n", user_name_);
                         __leave;
                     }
 
@@ -517,16 +513,16 @@ OwnerProfile::load () {
             up directly */
             profile_exists = create ();
 
+			if(profile_exists)
+			{
             dprintf ( 
                 D_FULLDEBUG, 
-                "OwnerProfile::load: Creation of profile for %s %s. "
-                "(last-error = %u)\n",
-                user_name_,
-                profile_exists ? "succeeded" : "failed", 
-                profile_exists ? 0 : GetLastError () );
-
-            /* if the profile still does not exist, then bail */
-            if ( !profile_exists ) {
+                "OwnerProfile::load: Creation of profile for %s succeeded.\n",
+                user_name_);
+			}
+			else
+			{
+				deprintf(D_FULLDEBUG,GetLastError(), "OwnerProfile::load: Creation of profile for %s failed.\n",user_name_);
                 __leave;
             }
 
@@ -689,15 +685,17 @@ OwnerProfile::environment ( Env &env ) {
             FALSE ); /* we already have the current process env */
         ASSERT ( penv );
 
-        dprintf ( 
-            D_FULLDEBUG, 
-            "OwnerProfile::environment: Loading %s while retrieving "
-            "%s's environment (last-error = %u)\n",
-            created ? "succeeded" : "failed", 
-            user_name_,
-            GetLastError () );
-
-        if ( !created ) {
+		if(created)
+		{
+			dprintf ( 
+				D_FULLDEBUG, 
+				"OwnerProfile::environment: Loading succeeded while retrieving "
+				"%s's environment\n",
+				user_name_);
+		}
+		else
+		{
+			deprintf(D_FULLDEBUG,GetLastError(),"OwnerProfile::environment: Loading failed while retrieving %s's environment.\n", user_name_);
             __leave;
         }
 
@@ -723,12 +721,7 @@ OwnerProfile::environment ( Env &env ) {
         /* rid ourselves of the user's environment information */
         if ( penv ) {
             if ( !DestroyEnvironmentBlock ( penv ) ) {
-                dprintf ( 
-                    D_ALWAYS, 
-                    "OwnerProfile::environment: "
-                    "DestroyEnvironmentBlock() failed "
-                    "(last-error = %u)\n", 
-                    GetLastError () );
+				deprintf(D_ALWAYS,GetLastError(),"OwnerProfile::environment: DestroyEnvironmentBlock() failed.\n");
             }
         }
 
@@ -793,13 +786,7 @@ OwnerProfile::directory () {
                     user_token_, 
                     buffer,
                     &size ) ) {
-                        
-                        dprintf ( 
-                            D_FULLDEBUG, 
-                            "OwnerProfile::directory: could not get "
-                            "profile directory. (last-error = %u)\n",
-                            GetLastError () );
-                        
+						deprintf(D_FULLDEBUG,GetLastError(),"OwnerProfile::directory: could not get profile directory.\n");                        
                         __leave;
 
                 }
@@ -890,17 +877,20 @@ OwnerProfile::backup () {
             profile_directory_, 
             profile_backup_ );
 
+		if(backup_created)
+		{
         dprintf ( 
             D_FULLDEBUG, 
-            "OwnerProfile::backup: Copying '%s' to '%s' %s. "
-            "(last-error = %u)\n", 
+            "OwnerProfile::backup: Copying '%s' to '%s' succeeded.\n",
             profile_directory_,
-            profile_backup_,
-            backup_created ? "succeeded" : "failed", 
-            backup_created ? 0 : GetLastError () );
-
-        if ( !backup_created ) {
-            __leave;
+            profile_backup_
+           );
+		}
+		else
+		{
+			deprintf(D_FULLDEBUG,GetLastError(),"OwnerProfile::backup: Copying '%s' to '%s' failed.\n", profile_directory_,profile_backup_);
+
+			__leave;
         }
 
         /* if we've arrived here, then all it well */
@@ -958,14 +948,16 @@ OwnerProfile::restore () {
         profile_deleted = 
             CondorRemoveDirectory ( profile_directory_ );
         
-        dprintf ( 
-            D_FULLDEBUG, 
-            "OwnerProfile::restore: Deleting the "
-            "modified profile %s. (last-error = %u)\n", 
-            profile_deleted ? "succeeded" : "failed", 
-            profile_deleted ? 0 : GetLastError () );
-
-        if ( !profile_deleted ) {
+		if(profile_deleted)
+		{
+			dprintf ( 
+				D_FULLDEBUG, 
+				"OwnerProfile::restore: Deleting the "
+				"modified profile succeeded.\n");
+		}
+		else
+        {
+			deprintf(D_FULLDEBUG,GetLastError(),"OwnerProfile::restore: Deleting the modified profile failed.\n");
             __leave;
         }
 
@@ -975,14 +967,17 @@ OwnerProfile::restore () {
             profile_backup_,
             profile_directory_ );
 
-        dprintf ( 
-            D_FULLDEBUG, 
-            "OwnerProfile::restore: Deleting the "
-            "profile backup %s. (last-error = %u)\n", 
-            backup_restored ? "succeeded" : "failed", 
-            backup_restored ? 0 : GetLastError () );
+		if(backup_restored)
+		{
+			dprintf ( 
+				D_FULLDEBUG, 
+				"OwnerProfile::restore: Deleting the "
+				"profile backup succeeded.\n");
+		}
+		else
+		{
+			deprintf(D_FULLDEBUG,GetLastError(),"OwnerProfile::restore: Deleting the profile backup failed.\n");
 
-        if ( !backup_restored ) {
             __leave;
         }
 
@@ -991,14 +986,16 @@ OwnerProfile::restore () {
         backup_deleted = 
             CondorRemoveDirectory ( profile_backup_ );
 
-        dprintf ( 
-            D_FULLDEBUG, 
-            "OwnerProfile::restore: Deleting the "
-            "back-up directory %s. (last-error = %u)\n", 
-            backup_deleted ? "succeeded" : "failed", 
-            backup_deleted ? 0 : GetLastError () );
-
-        if ( !backup_deleted ) {
+		if(backup_deleted)
+		{
+			dprintf ( 
+				D_FULLDEBUG, 
+				"OwnerProfile::restore: Deleting the "
+				"back-up directory succeeded.\n");
+		}
+		else
+		{
+			deprintf(D_FULLDEBUG,GetLastError(),"OwnerProfile::restore: Deleting the back-up directory failed.\n");
             __leave;
         }
 
@@ -1067,15 +1064,17 @@ OwnerProfile::loadProfile () {
             user_token_, 
             &user_profile_ );
 
-        dprintf ( 
-            D_FULLDEBUG, 
-            "OwnerProfile::loadProfile: Loading the %s's "
-            "profile %s. (last-error = %u)\n",
-            user_profile_.lpUserName,
-            profile_loaded ? "succeeded" : "failed", 
-            profile_loaded ? 0 : GetLastError () );
-
-        if ( !profile_loaded ) {
+		if(profile_loaded)
+		{
+			dprintf ( 
+				D_FULLDEBUG, 
+				"OwnerProfile::loadProfile: Loading the %s's "
+				"profile succeeded.\n",
+				user_profile_.lpUserName);
+		}
+		else
+		{
+			deprintf(D_FULLDEBUG,GetLastError(),"OwnerProfile::loadProfile: Loading the %s's profile failed.\n", user_profile_.lpUserName);
             __leave;
         }
 
@@ -1115,15 +1114,17 @@ OwnerProfile::unloadProfile () {
             user_token_, 
             user_profile_.hProfile ); 
 
+		if(profile_unloaded)
+		{
         dprintf ( 
             D_FULLDEBUG, 
             "OwnerProfile::unloadProfile: Unloading %s's "
-            "profile %s. (last-error = %u)\n",
-            user_name_,
-            profile_unloaded ? "succeeded" : "failed", 
-            profile_unloaded ? 0 : GetLastError () );
-
-        if ( !profile_unloaded ) {
+            "profile succeeded.\n",
+            user_name_);
+		}
+		else
+        {
+			deprintf(D_FULLDEBUG,GetLastError(),"OwnerProfile::unloadProfile: Unloading %s's profile failed.\n",user_name_);
             __leave;
         }
 
diff --git a/src/condor_c++_util/remote_close.WINDOWS.cpp b/src/condor_c++_util/remote_close.WINDOWS.cpp
index 9e4baba..8495493 100644
--- a/src/condor_c++_util/remote_close.WINDOWS.cpp
+++ b/src/condor_c++_util/remote_close.WINDOWS.cpp
@@ -23,6 +23,7 @@
 #include "condor_debug.h"
 #include "condor_uid.h"
 #include "perm.h"
+#include "deprintf.h"
 
 #include "remote_close.WINDOWS.h "
 #include "string_conversion.WINDOWS.h"
@@ -53,8 +54,8 @@ CloseRemoteHandle ( DWORD pid, HANDLE handle ) {
         
         if ( NULL == process_handle ) {
             last_error = GetLastError ();
-            dprintf ( D_FULLDEBUG, "CloseRemoteHandle: OpenProcess "
-                "failed (last-error = %u)", last_error );            
+			deprintf(D_FULLDEBUG, last_error,"CloseRemoteHandle: OpenProcess failed.\n");
+
             __leave;
         }
 
@@ -75,11 +76,8 @@ CloseRemoteHandle ( DWORD pid, HANDLE handle ) {
             /* something is wrong with the privileges, or the process 
             doesn't like us */
             last_error = GetLastError ();
-            dprintf ( 
-                D_FULLDEBUG, 
-                "CloseRemoteHandle: CreateRemoteThread() failed "
-                "(last-error = %u)", 
-                last_error );            
+			deprintf(D_FULLDEBUG, GetLastError(),"CloseRemoteHandle: CreateRemoteThread() failed.\n" );
+
             __leave;
         }
 
@@ -97,11 +95,8 @@ CloseRemoteHandle ( DWORD pid, HANDLE handle ) {
             the 20 unit heuristic might shed some light on this 
             problem */
             last_error = GetLastError ();
-            dprintf ( 
-                D_FULLDEBUG, 
-                "CloseRemoteHandle: our remote CloseHandle() call "
-                "failed (last-error = %u)", 
-                last_error );            
+			deprintf(D_FULLDEBUG, last_error, "CloseRemoteHandle: our remote CloseHandle() call.\n");
+
             __leave;
             break;
         }
@@ -285,15 +280,17 @@ BOOL RemoteDeleteW ( PCWSTR w_filename, PCWSTR w_filter ) {
         
         deleted = DeleteFile ( filename );
 
-        dprintf ( 
-            D_FULLDEBUG, 
-            "RemoteDeleteW: Deleting %s %s. "
-            "(last-error = %u)\n",
-            filename,
-            deleted ? "succeeded" : "failed",
-            deleted ? 0 : GetLastError () );
-
-        if ( !deleted ) {
+		if(deleted)
+		{
+			dprintf ( 
+				D_FULLDEBUG, 
+				"RemoteDeleteW: Deleting %s succeeded.\n",
+				filename);
+		}
+		else
+		{
+			deprintf(D_FULLDEBUG, GetLastError(), "RemoteDeleteW: Deleting %s failed.\n", filename);
+			
             __leave;
         }
 
diff --git a/src/condor_c++_util/security.WINDOWS.cpp b/src/condor_c++_util/security.WINDOWS.cpp
index 5b4b2ed..80ecac0 100644
--- a/src/condor_c++_util/security.WINDOWS.cpp
+++ b/src/condor_c++_util/security.WINDOWS.cpp
@@ -21,6 +21,7 @@
 #include "condor_debug.h"
 
 #include "security.WINDOWS.h"
+#include "deprintf.h"
 
 /***************************************************************
 /* Macros                                                       
@@ -170,12 +171,7 @@ ModifyPrivilege ( LPCTSTR privilege, BOOL enable ) {
         if ( !have_pricess_token ) { 
         
             last_error = GetLastError ();
-
-            dprintf ( 
-                D_FULLDEBUG, 
-                "ModifyPrivilege: Failed to retrieve "
-                "the process' ptoken. (last-error = %d)\n", 
-                last_error ); 
+			deprintf(D_FULLDEBUG, last_error, "ModifyPrivilege: Failed to retrieve the process' ptoken.\n");
         
             __leave;
         
@@ -190,11 +186,8 @@ ModifyPrivilege ( LPCTSTR privilege, BOOL enable ) {
         if ( !found_privelage ) { 
         
             last_error = GetLastError ();
-        
-            dprintf ( D_FULLDEBUG, "ModifyTokenPrivilege: Failed to "
-                "retrieve privilege name. (last-error = %d)\n", 
-                last_error ); 
-        
+			deprintf(D_FULLDEBUG, last_error, "ModifyTokenPrivilege: Failed to retrieve privilege name.\n");
+
             __leave;
         
         } 
@@ -217,10 +210,7 @@ ModifyPrivilege ( LPCTSTR privilege, BOOL enable ) {
         if ( !privelages_adjusted ) { 
         
             last_error = GetLastError ();
-        
-            dprintf ( D_FULLDEBUG, "ModifyPrivilege: Failed to adjust "
-                "privilege. (last-error = %d)\n", 
-                last_error ); 
+			deprintf(D_FULLDEBUG, last_error, "ModifyPrivilege: Failed to adjust privilege.\n");
         
             __leave;
         
@@ -271,14 +261,8 @@ LoadUserSid ( HANDLE token, PSID *sid ) {
         if ( size <= 0 ) {
             
             last_error = GetLastError ();
-            
-            dprintf ( 
-                D_FULLDEBUG, 
-                "GetUserSid: failed determine how much memory "
-                "is required to store TOKEN_USER. "
-                "(last-error = %d)\n",
-                last_error );
-            
+			deprintf(D_FULLDEBUG, last_error, "GetUserSid: failed to determine how much memory is required to store TOKEN_USER.\n");
+
             __leave;
 
         }
@@ -289,12 +273,7 @@ LoadUserSid ( HANDLE token, PSID *sid ) {
         if ( !ptoken ) {
             
             last_error = GetLastError ();
-            
-            dprintf ( 
-                D_FULLDEBUG, 
-                "GetUserSid: failed to allocate memory for "
-                "TOKEN_USER. (last-error = %d)\n",
-                last_error );
+			deprintf(D_FULLDEBUG, last_error, "GetUserSid: failed to allocate memory for TOKEN_USER.\n");
             
             __leave;
             
@@ -312,13 +291,8 @@ LoadUserSid ( HANDLE token, PSID *sid ) {
         if ( !got_token ) {
 
             last_error = GetLastError ();
+			deprintf(D_FULLDEBUG, last_error, "GetUserSid: failed to get user's token information.\n");
 
-            dprintf ( 
-                D_FULLDEBUG, 
-                "GetUserSid: failed to get user's token information. "
-                "(last-error = %d)\n",
-                last_error );
-            
             __leave;
 
         }
@@ -330,14 +304,8 @@ LoadUserSid ( HANDLE token, PSID *sid ) {
         if ( !*sid ) {
             
             last_error = GetLastError ();
+			deprintf(D_FULLDEBUG, last_error, "GetUserSid: failed to allocate memory for the SID to be returned.\n");
 
-            dprintf ( 
-                D_FULLDEBUG, 
-                "GetUserSid: failed to allocate memory for "
-                "the SID to be returned. (last-error = %d)\n",
-                last_error );
-
-            
             __leave;
             
         }
@@ -351,12 +319,7 @@ LoadUserSid ( HANDLE token, PSID *sid ) {
         if ( !copied ) {
             
             last_error = GetLastError ();
-            
-            dprintf ( 
-                D_FULLDEBUG, 
-                "GetUserSid: failed to copy the user's SID. "
-                "(last-error = %d)\n",
-                last_error );
+			deprintf(D_FULLDEBUG, last_error, "GetUserSid: failed to copy the user's SID.\n");
             
             __leave;
             
diff --git a/src/condor_c++_util/setenv.cpp b/src/condor_c++_util/setenv.cpp
index 195d823..3e29dfa 100644
--- a/src/condor_c++_util/setenv.cpp
+++ b/src/condor_c++_util/setenv.cpp
@@ -21,6 +21,7 @@
 #include "condor_common.h"
 #include "condor_debug.h"
 #include "classad_hashtable.h"
+#include "deprintf.h"
 
 #include "setenv.h"
 
@@ -47,9 +48,8 @@ int SetEnv( const char *key, const char *value)
 	assert(value);
 #ifdef WIN32
 	if ( !SetEnvironmentVariable(key, value) ) {
-		dprintf(D_ALWAYS,
-			"SetEnv(%s, %s): SetEnvironmentVariable failed, "
-			"errno=%d\n", key, value, GetLastError());
+		deprintf(D_ALWAYS, GetLastError(), "SetEnv(%s, %s): SetEnvironmentVariable failed.\n", key, value);
+
 		return FALSE;
 	}
 #else
@@ -129,9 +129,8 @@ int UnsetEnv( const char *env_var )
 
 #ifdef WIN32
 	if ( !SetEnvironmentVariable(env_var, NULL) ) {
-		dprintf(D_ALWAYS,
-			"UnsetEnv(%s): SetEnvironmentVariable failed, errno=%d\n",
-			env_var, GetLastError());
+		deprintf(D_ALWAYS, GetLastError(), "UnsetEnv(%s): SetEnvironmentVariable failed.\n", env_var);
+		
 		return FALSE;
 	}
 #else
@@ -198,9 +197,7 @@ const char *GetEnv( const char *env_var, MyString &result )
 	} else if ( rc == 0 ) {
 		DWORD error = GetLastError();
 		if ( error != ERROR_ENVVAR_NOT_FOUND ) {
-			dprintf( D_ALWAYS,
-					 "GetEnv(): GetEnvironmentVariable() failed, error=%d\n",
-					 error );
+			deprintf(D_ALWAYS, error, "GetEnv(): GetEnvironmentVariable() failed.\n");
 		}
 		free( value );
 		return NULL;
diff --git a/src/condor_c++_util/setup_api_dll.cpp b/src/condor_c++_util/setup_api_dll.cpp
index 2a9af37..0c295bb 100644
--- a/src/condor_c++_util/setup_api_dll.cpp
+++ b/src/condor_c++_util/setup_api_dll.cpp
@@ -23,6 +23,7 @@
 
 #include "condor_common.h"
 #include "setup_api_dll.h"
+#include "deprintf.h"
 
 /***************************************************************
  * Static initialization
@@ -74,8 +75,8 @@ SetupApiDLL::load () {
 
         CHAR file_name[] = "setupapi.dll";
         if ( !_dll.load ( file_name ) ) {
-            printf ( "ERROR: failed to load: %s (%d)\n", 
-                file_name, GetLastError () );
+			deprintf(D_ALWAYS, GetLastError(), "ERROR: failed to load: %s\n");
+            
             __leave;
 	    }	
 
diff --git a/src/condor_c++_util/store_cred.cpp b/src/condor_c++_util/store_cred.cpp
index 49da998..f317958 100644
--- a/src/condor_c++_util/store_cred.cpp
+++ b/src/condor_c++_util/store_cred.cpp
@@ -27,6 +27,7 @@
 #include "lsa_mgr.h"
 #include "store_cred.h"
 #include "condor_config.h"
+#include "deprintf.h"
 
 static int code_store_cred(Stream *socket, char* &user, char* &pw, int &mode);
 
@@ -536,8 +537,7 @@ isValidCredential( const char *input_user, const char* input_pw ) {
 	}
 
 	if ( retval == 0 ) {
-		dprintf(D_ALWAYS, "Failed to log in %s with err=%d\n", 
-				input_user, LogonUserError);
+		deprintf(D_ALWAYS,LogonUserError, "Failed to log in %s.\n", input_user);
 		return false;
 	} else {
 		dprintf(D_FULLDEBUG, "Succeeded to log in %s\n", input_user);
diff --git a/src/condor_c++_util/system_info.WINDOWS.cpp b/src/condor_c++_util/system_info.WINDOWS.cpp
index 1a5f1e1..cbf32a2 100644
--- a/src/condor_c++_util/system_info.WINDOWS.cpp
+++ b/src/condor_c++_util/system_info.WINDOWS.cpp
@@ -1,20 +1,20 @@
-/***************************************************************
-*
-* Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
-* University of Wisconsin-Madison, WI.
-* 
-* Licensed under the Apache License, Version 2.0 (the "License"); you
-* may not use this file except in compliance with the License.  You may
-* obtain a copy of the License at
-* 
-*    http://www.apache.org/licenses/LICENSE-2.0
-* 
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*
+/***************************************************************
+*
+* Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+* University of Wisconsin-Madison, WI.
+* 
+* Licensed under the Apache License, Version 2.0 (the "License"); you
+* may not use this file except in compliance with the License.  You may
+* obtain a copy of the License at
+* 
+*    http://www.apache.org/licenses/LICENSE-2.0
+* 
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
 ***************************************************************/
 
 // Written by Zoltan Csizmadia, zoltan_csizmadia@yahoo.com
diff --git a/src/condor_c++_util/udp_waker.cpp b/src/condor_c++_util/udp_waker.cpp
index b48b076..02a74d5 100644
--- a/src/condor_c++_util/udp_waker.cpp
+++ b/src/condor_c++_util/udp_waker.cpp
@@ -25,6 +25,7 @@
 #include "condor_attributes.h"
 #include "condor_adtypes.h"
 #include "my_hostname.h"
+#include "deprintf.h"
 
 #ifndef INADDR_NONE		/* Solaris */
 #  define INADDR_NONE	((in_addr_t) 0xffffffff)
@@ -363,12 +364,7 @@ UdpWakeOnLanWaker::printLastSocketError (void) const
         if ( 0 == length ) {
 
             last_error = GetLastError ();
-
-            dprintf (
-                D_ALWAYS,
-                "PrintFormatedErrorMessage: failed to retrieve error "
-                "message. (last-error = %u)\n",
-                last_error );
+			deprintf(D_ALWAYS, last_error,"PrintFormatedErrorMessage: failed to retrieve error message.\n");
 
             __leave;
 
diff --git a/src/condor_c++_util/uids.cpp b/src/condor_c++_util/uids.cpp
index 4c06d38..d27dba3 100644
--- a/src/condor_c++_util/uids.cpp
+++ b/src/condor_c++_util/uids.cpp
@@ -28,6 +28,7 @@
 #include "my_username.h"
 #include "daemon.h"
 #include "store_cred.h"
+#include "deprintf.h"
 
 /* See condor_uid.h for description. */
 static char* CondorUserName = NULL;
@@ -388,8 +389,9 @@ init_user_ids(const char username[], const char domain[])
 			UserDomainName = strdup(domain);
 
 			if ( !retval ) {
-				dprintf(D_ALWAYS, "init_user_ids: LogonUser failed with NT Status %ld\n", 
-					GetLastError());
+				DWORD last_error = GetLastError();
+				deprintf(D_ALWAYS,last_error,"init_user_ids: LogonUser failed with NT Status %ld.\n", last_error);
+
 				UserIdsInited = false;
 				retval =  0;	// return of 0 means FAILURE
 			} else {
