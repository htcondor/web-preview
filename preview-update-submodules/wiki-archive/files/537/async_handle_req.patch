commit 59613b411e26e0545dae3bb6d1c88e16a09f8855
Author: Dan Bradley <dan@hep.wisc.edu>
Date:   Fri Feb 10 17:11:02 2012 -0600

    Refactored DaemonCore's HandleReq into an asynchronous protocol object. #2817
    
    The first read by the server during authentication is now done
    asynchronously: the server selects for read before
    calling authenticate().

diff --git a/src/condor_daemon_core.V6/condor_daemon_core.h b/src/condor_daemon_core.V6/condor_daemon_core.h
index 3562577..f130003 100644
--- a/src/condor_daemon_core.V6/condor_daemon_core.h
+++ b/src/condor_daemon_core.V6/condor_daemon_core.h
@@ -291,6 +291,7 @@ class DaemonCore : public Service
   friend unsigned pidWatcherThread(void*);
 #endif
   friend int dc_main(int, char**);
+  friend class DaemonCommandProtocol;
     
   public:
     
diff --git a/src/condor_daemon_core.V6/daemon_core.cpp b/src/condor_daemon_core.V6/daemon_core.cpp
index 79cc89b..29e795d 100644
--- a/src/condor_daemon_core.V6/daemon_core.cpp
+++ b/src/condor_daemon_core.V6/daemon_core.cpp
@@ -4113,224 +4113,327 @@ int DaemonCore::ServiceCommandSocket()
 	return commands_served;
 }
 
+void
+DaemonCore::HandleReqAsync(Stream *stream)
+{
+		// HandleReq() is now asynchronous, so just call it
+	if( HandleReq(stream) != KEEP_STREAM ) {
+		delete stream;
+	}
+}
 
-int DaemonCore::HandleReqSocketTimerHandler()
+int DaemonCore::HandleReq(int socki, Stream* asock)
 {
-	Stream *stream = NULL;
+	Stream *insock;
+	
+	insock = (*sockTable)[socki].iosock;
 
-	/*  We have been waiting for an incoming connection to have something
-		to read.  If this timer handler fired, we are sick of waiting.
-		So cancel the socket registration and close the incoming socket.
-	*/
+	return HandleReq(insock, asock);
+}
 
-		// get the socket stream we've been waiting for.
-	stream = (Stream*) GetDataPtr();
-	ASSERT(stream);
-	ASSERT( stream->type() == Stream::reli_sock );
+class DaemonCommandProtocol: Service, public ClassyCountedPtr {
+public:
+	DaemonCommandProtocol(Stream *insock, Stream* asock);
+	~DaemonCommandProtocol();
 
-		// cancel its registration
-	Cancel_Socket(stream);
-		
-		// and blow it away
-	dprintf(D_ALWAYS,"Closing socket from %s - no data received\n",
-			((Sock*)stream)->peer_addr().to_sinful().Value());
-	delete stream;
+	int doProtocol();
 
-	return TRUE;
-}
+private:
+
+	enum CommandProtocolState {
+		CommandProtocolAcceptTCPRequest,
+		CommandProtocolAcceptUDPRequest,
+		CommandProtocolReadCommand,
+		CommandProtocolAuthenticate,
+		CommandProtocolPostAuthenticate,
+		CommandProtocolExecCommand
+	} m_state;
+
+	enum CommandProtocolResult {
+		CommandProtocolContinue,
+		CommandProtocolFinished,
+		CommandProtocolInProgress
+	};
+
+	Stream *m_insock;
+	Stream *m_asock;
+	Sock   *m_sock;
 
+#ifdef HAVE_EXT_GSOAP
+	bool m_is_http_post;	// must initialize to false
+	bool m_is_http_get;   // must initialize to false
+#endif
 
-int DaemonCore::HandleReqSocketHandler(Stream *stream)
+	bool m_nonblocking;
+	bool m_sock_had_no_deadline;
+	int	m_is_tcp;
+	int m_req;
+	int	m_index;
+	int	m_reqFound;
+	int	m_result;
+    int m_perm;
+	MyString m_user;
+    ClassAd *m_policy;
+	ClassAd m_auth_info;
+    KeyInfo *m_key;
+    char    *m_sid;
+
+	UtcTime m_handle_req_start_time;
+	UtcTime m_async_waiting_start_time;
+	float m_async_waiting_time;
+	SecMan *m_sec_man;
+	DaemonCore::CommandEnt *m_comTable;
+	int m_cmd_index;
+	int m_real_cmd;
+	int m_tmp_cmd;
+
+	bool m_new_session;
+	SecMan::sec_feat_act m_will_enable_encryption;
+	SecMan::sec_feat_act m_will_enable_integrity;
+
+	CommandProtocolResult AcceptTCPRequest();
+	CommandProtocolResult AcceptUDPRequest();
+	CommandProtocolResult ReadCommand();
+	CommandProtocolResult Authenticate();
+	CommandProtocolResult PostAuthenticate();
+	CommandProtocolResult ExecCommand();
+	CommandProtocolResult WaitForSocketData();
+	int SocketCallback( Stream *stream );
+	int finalize();
+};
+
+int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 {
-	int* timeout_tid = NULL;
+	classy_counted_ptr<DaemonCommandProtocol> r = new DaemonCommandProtocol(insock,asock);
 
-	/*  We have been waiting for an incoming connection to have something
-		to read.  If this timer handler fired, our wait is over.
-		So cancel the timer we set to test
-		for a timeout, and handle the request.
-	*/
+	return r->doProtocol();
+}
 
-	timeout_tid = (int *) GetDataPtr();
-	ASSERT(timeout_tid);
+DaemonCommandProtocol::DaemonCommandProtocol(Stream *insock, Stream* asock):
+	m_insock(insock),
+	m_asock(asock),
+	m_sock(NULL),
+#ifdef HAVE_EXT_GSOAP
+	m_is_http_post(false),
+	m_is_http_get(false),
+#endif
+	m_nonblocking(true),
+	m_sock_had_no_deadline(false),
+	m_is_tcp(0),
+	m_req(0),
+	m_reqFound(FALSE),
+	m_result(FALSE),
+    m_perm(USER_AUTH_FAILURE),
+    m_policy(NULL),
+    m_key(NULL),
+    m_sid(NULL),
+	m_async_waiting_time(0),
+	m_cmd_index(0),
+	m_real_cmd(0),
+	m_tmp_cmd(0),
+	m_new_session(false),
+	m_will_enable_encryption(SecMan::SEC_FEAT_ACT_UNDEFINED),
+	m_will_enable_integrity(SecMan::SEC_FEAT_ACT_UNDEFINED)
+{
+	m_sec_man = daemonCore->getSecMan();
+	m_comTable = daemonCore->comTable;
+
+	m_handle_req_start_time.getTime();
+
+	ASSERT(m_insock);
+
+	switch ( m_insock->type() ) {
+		case Stream::reli_sock :
+			m_is_tcp = TRUE;
+			m_state = CommandProtocolAcceptTCPRequest;
+			break;
+		case Stream::safe_sock :
+			m_is_tcp = FALSE;
+			m_state = CommandProtocolAcceptUDPRequest;
+			break;
+		default:
+			// unrecognized Stream sock
+			EXCEPT("DaemonCore: HandleReq(): unrecognized Stream sock");
+	}
+}
 
-	Cancel_Timer(*timeout_tid);
-	delete timeout_tid;	// was allocated in HandleReq() with new
+DaemonCommandProtocol::~DaemonCommandProtocol()
+{
+    if (m_policy) {
+        delete m_policy;
+    }
+    if (m_key) {
+        delete m_key;
+    }
+    if (m_sid) {
+        free(m_sid);
+    }
+}
 
-	// now cancel the socket callback registration that got us here.
-	// we need to cancel before we call HandleReq(), because the command
-	// handler invoked by HandleReq() may also decide to register this socket,
-	// and we don't want it registered twice.
-	Cancel_Socket(stream);
+int DaemonCommandProtocol::doProtocol()
+{
 
-	// now call HandleReq to actually do the work of servicing this request.
-	int ret_val =  HandleReq(stream);
+	CommandProtocolResult what_next = CommandProtocolContinue;
 
-	// if the handler doesn't want to keep the socket, delete it here.
-	if ( ret_val != KEEP_STREAM ) {
-		delete stream;
-	}
+	if( m_sock ) {
+		if( m_sock->deadline_expired() ) {
+			MyString msg;
+			dprintf(D_ALWAYS,"DaemonCommandProtocol: deadline for security handshake with %s has expired.\n",
+					m_sock->peer_description());
 
-	// always tell the driver to leave the stream alone, since we already
-	// deleted it above if it needed to go away.
-	return KEEP_STREAM;
-}
+			m_result = FALSE;
+			what_next = CommandProtocolFinished;
+		}
+		else if( m_nonblocking && m_sock->is_connect_pending() ) {
+			what_next = WaitForSocketData();
+		}
+		else if( m_is_tcp && !m_sock->is_connected()) {
+			MyString msg;
+			dprintf(D_ALWAYS,"DaemonCommandProtocol: TCP connection to %s failed.\n",
+					m_sock->peer_description());
 
-bool
-DaemonCore::RegisterSocketForHandleReq(Stream *stream)
-{
-		// set a timer for 200 seconds, in case nothing ever arrives...
-		// why 200 seconds -vs- the time honored 20 seconds?  
-		// since we are not blocking, we can afford to be more patient,
-		// and in fact it helps to be more patient here because 
-		// if a client does a non-blocking connect to us and then gets
-		// blocked talking to someone else, we want to minimize the chance
-		// of a timeout when the client gets back around to giving us
-		// some love.
-	int tid = daemonCore->Register_Timer(
-		200,		
-		(TimerHandlercpp) &DaemonCore::HandleReqSocketTimerHandler,
-		"DaemonCore::HandleReqSocketTimerHandler",
-		this);
-		// stash the socket with the timer 
-	daemonCore->Register_DataPtr((void*)stream);
-		// now register the socket itself.  note we needed to set the
-		// timer first because we want to register the timer id with 
-		// the socket handler, and Register_DataPtr only effects the
-		// most recent event handler registered.
-	int tmp_result = daemonCore->Register_Socket(stream,
-		"Incoming command",
-		(SocketHandlercpp) &DaemonCore::HandleReqSocketHandler,
-		"DaemonCore::HandleReqSocketHandler",
-		this);
-	if ( tmp_result >= 0 )  {	
-			// on socket register success
-		int* stashed_tid = new int;
-		*stashed_tid = tid;
-			// register the timer id with the sock, so we can cancel it.
-		daemonCore->Register_DataPtr((void*)stashed_tid);
-			// return -- we'll come back when there is something to read
-			// use KEEP_STREAM so the socket we just registered isn't closed.
-		return true;
-	} else {
-			// on socket register failure
-			// just cancel the timeout and fall-thru (i.e. service
-			// the request synchronously with a 1 second timeout
-			// reading the command int).
-		daemonCore->Cancel_Timer(tid);
+			m_result = FALSE;
+			what_next = CommandProtocolFinished;
+		}
 	}
-	return false;
-}
 
-void
-DaemonCore::HandleReqAsync(Stream *stream)
-{
-	if( !RegisterSocketForHandleReq(stream) ) {
-		if( HandleReq(stream) != KEEP_STREAM ) {
-			delete stream;
+	while( what_next == CommandProtocolContinue ) {
+		switch(m_state) {
+		case CommandProtocolAcceptTCPRequest:
+			what_next = AcceptTCPRequest();
+			break;
+		case CommandProtocolAcceptUDPRequest:
+			what_next = AcceptUDPRequest();
+			break;
+		case CommandProtocolReadCommand:
+			what_next = ReadCommand();
+			break;
+		case CommandProtocolAuthenticate:
+			what_next = Authenticate();
+			break;
+		case CommandProtocolPostAuthenticate:
+			what_next = PostAuthenticate();
+			break;
+		case CommandProtocolExecCommand:
+			what_next = ExecCommand();
+			break;
 		}
 	}
-}
 
-int DaemonCore::HandleReq(int socki, Stream* asock)
-{
-	Stream *insock;
-	
-	insock = (*sockTable)[socki].iosock;
+	if( what_next == CommandProtocolInProgress ) {
+		return KEEP_STREAM;
+	}
 
-	return HandleReq(insock, asock);
+	return finalize();
 }
 
-int DaemonCore::HandleReq(Stream *insock, Stream* asock)
+DaemonCommandProtocol::CommandProtocolResult DaemonCommandProtocol::WaitForSocketData()
 {
-	Sock				*sock = NULL;
-
-	int					is_tcp=0;
-	int                 req = 0;
-	int					index;
-	int					reqFound = FALSE;
-	int					result = FALSE;
-    int                 perm         = USER_AUTH_FAILURE;
-	MyString            user;
-    ClassAd *the_policy     = NULL;
-    KeyInfo *the_key        = NULL;
-    char    *the_sid        = NULL;
-    char    * who = NULL;   // Remote user
-#ifdef HAVE_EXT_GSOAP
-	bool is_http_post = false;	// must initialize to false
-	bool is_http_get = false;   // must initialize to false
-#endif
+	if( m_sock->get_deadline() == 0 ) {
+		int TCP_SESSION_DEADLINE = param_integer("SEC_TCP_SESSION_DEADLINE",120);
+		m_sock->set_deadline_timeout(TCP_SESSION_DEADLINE);
+		m_sock_had_no_deadline = true;
+	}
 
-	UtcTime handle_req_start_time;
-	handle_req_start_time.getTime();
+	int reg_rc = daemonCore->Register_Socket(
+		m_sock,
+		m_sock->peer_description(),
+		(SocketHandlercpp)&DaemonCommandProtocol::SocketCallback,
+		"DaemonCommandProtocol::WaitForSocketData",
+		this,
+		ALLOW);
 
-	ASSERT(insock);
+	if(reg_rc < 0) {
+		dprintf(D_ALWAYS, "DaemonCommandProtocol failed to process command from %s because "
+				"Register_Socket returned %d.\n",
+				m_sock->get_sinful_peer(),
+				reg_rc);
 
-	switch ( insock->type() ) {
-		case Stream::reli_sock :
-			is_tcp = TRUE;
-			break;
-		case Stream::safe_sock :
-			is_tcp = FALSE;
-			break;
-		default:
-			// unrecognized Stream sock
-			EXCEPT("DaemonCore: HandleReq(): unrecognized Stream sock");
+		m_result = FALSE;
+		return CommandProtocolFinished;
 	}
 
-	CondorError errstack;
+		// Do not allow ourselves to be deleted until after
+		// SocketCallback is called.
+	incRefCount();
 
-	// set up a connection for a tcp socket
-	if ( is_tcp ) {
+	m_async_waiting_start_time.getTime();
 
-		// if the connection was received on a listen socket, do an accept.
-		if ( ((ReliSock *)insock)->_state == Sock::sock_special &&
-			((ReliSock *)insock)->_special_state == ReliSock::relisock_listen )
-		{
-			if ( asock ) {
-				sock = (Sock *)asock;
-			} else {
-				sock = ((ReliSock *)insock)->accept();
-			}
-			if ( !sock ) {
-				dprintf(D_ALWAYS, "DaemonCore: accept() failed!");
-				// return KEEP_STEAM cuz insock is a listen socket
-				return KEEP_STREAM;
-			}
+	return CommandProtocolInProgress;
+}
 
-				// we have just accepted a socket.  if there is nothing available yet
-				// to read on this socket, we don't want to block here, so instead
-				// register it.  Also set a timer just in case nothing ever arrives, so 
-				// we can reclaim our socket.  
-			if ( ((ReliSock *)sock)->bytes_available_to_read() < 4 ) 
-			{
-				if( RegisterSocketForHandleReq( sock ) ) {
-					return KEEP_STREAM;
-				}
-			}
+int
+DaemonCommandProtocol::SocketCallback( Stream *stream )
+{
+	UtcTime async_waiting_stop_time;
+	async_waiting_stop_time.getTime();
+	m_async_waiting_time += async_waiting_stop_time.difference(&m_async_waiting_start_time);
+
+	daemonCore->Cancel_Socket( stream );
+
+	int rc = doProtocol();
+
+		// get rid of ref counted when callback was registered
+	decRefCount();
+
+	return rc;
+}
+
+DaemonCommandProtocol::CommandProtocolResult DaemonCommandProtocol::AcceptTCPRequest()
+{
+
+	// if the connection was received on a listen socket, do an accept.
+	if ( ((ReliSock *)m_insock)->isListenSock() )
+	{
+		if ( m_asock ) {
+			m_sock = (Sock *)m_asock;
+		} else {
+			m_sock = ((ReliSock *)m_insock)->accept();
 		}
-		// if the not a listen socket, then just assign sock to insock
-		else {
-			sock = (Sock *)insock;
+		if ( !m_sock ) {
+			dprintf(D_ALWAYS, "DaemonCore: accept() failed!\n");
+			// return KEEP_STEAM cuz m_insock is a listen socket
+			m_result = KEEP_STREAM;
+			return CommandProtocolFinished;
 		}
-
 	}
-	// set up a connection for a udp socket
+	// if the not a listen socket, then just assign sock to m_insock
 	else {
+		m_sock = (Sock *)m_insock;
+	}
+
+	m_state = CommandProtocolReadCommand;
+
+		// we have just accepted a socket or perhaps been given a
+		// socket from HandleReqAsync().  if there is nothing
+		// available yet to read on this socket, we don't want to
+		// block when reading the command, so register it
+	if ( m_nonblocking && ((ReliSock *)m_sock)->bytes_available_to_read() < 4 ) {
+		return WaitForSocketData();
+	}
+
+	return CommandProtocolContinue;
+}
+
+DaemonCommandProtocol::CommandProtocolResult DaemonCommandProtocol::AcceptUDPRequest()
+{
+	std::string who;
+
 		// on UDP, we do not have a seperate listen and accept sock.
 		// our "listen sock" is also our "accept" sock, so just
-		// assign sock to the insock. UDP = connectionless, get it?
-		sock = (Sock *)insock;
+		// assign sock to the m_insock. UDP = connectionless, get it?
+		m_sock = (Sock *)m_insock;
 		// in UDP we cannot display who the command is from until
 		// we read something off the socket, so we display who from
 		// after we read the command below...
 
 		dprintf ( D_SECURITY,
 				  "DC_AUTHENTICATE: received UDP packet from %s.\n",
-				  sock->peer_description());
+				  m_sock->peer_description());
 
 
 		// get the info, if there is any
-		const char * cleartext_info = ((SafeSock*)sock)->isIncomingDataMD5ed();
+		const char * cleartext_info = ((SafeSock*)m_sock)->isIncomingDataMD5ed();
 		char * sess_id = NULL;
 		char * return_address_ss = NULL;
 
@@ -4360,15 +4463,15 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 
 		if (sess_id) {
 			KeyCacheEntry *session = NULL;
-			bool found_sess = sec_man->session_cache->lookup(sess_id, session);
+			bool found_sess = m_sec_man->session_cache->lookup(sess_id, session);
 
 			if (!found_sess) {
-				dprintf ( D_ALWAYS, "DC_AUTHENTICATE: session %s NOT FOUND; this session was requested by %s with return address %s\n", sess_id, sock->peer_description(), return_address_ss ? return_address_ss : "(none)");
+				dprintf ( D_ALWAYS, "DC_AUTHENTICATE: session %s NOT FOUND; this session was requested by %s with return address %s\n", sess_id, m_sock->peer_description(), return_address_ss ? return_address_ss : "(none)");
 				// no session... we outta here!
 
 				// but first, we should be nice and send a message back to
 				// the people who sent us the wrong session id.
-				send_invalidate_session ( return_address_ss, sess_id );
+				daemonCore->send_invalidate_session ( return_address_ss, sess_id );
 
 				if( return_address_ss ) {
 					free( return_address_ss );
@@ -4376,14 +4479,14 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 				}
 				free( sess_id );
 				sess_id = NULL;
-				result = FALSE;
-				goto finalize;
+				m_result = FALSE;
+				return CommandProtocolFinished;
 			}
 
 			session->renewLease();
 
 			if (!session->key()) {
-				dprintf ( D_ALWAYS, "DC_AUTHENTICATE: session %s is missing the key! This session was requested by %s with return address %s\n", sess_id, sock->peer_description(), return_address_ss ? return_address_ss : "(none)");
+				dprintf ( D_ALWAYS, "DC_AUTHENTICATE: session %s is missing the key! This session was requested by %s with return address %s\n", sess_id, m_sock->peer_description(), return_address_ss ? return_address_ss : "(none)");
 				// uhm, there should be a key here!
 				if( return_address_ss ) {
 					free( return_address_ss );
@@ -4391,27 +4494,27 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 				}
 				free( sess_id );
 				sess_id = NULL;
-				result = FALSE;
-				goto finalize;
+				m_result = FALSE;
+				return CommandProtocolFinished;
 			}
 
-			if (!sock->set_MD_mode(MD_ALWAYS_ON, session->key())) {
-				dprintf (D_ALWAYS, "DC_AUTHENTICATE: unable to turn on message authenticator for session %s, failing; this session was requested by %s with return address %s\n",sess_id, sock->peer_description(), return_address_ss ? return_address_ss : "(none)");
+			if (!m_sock->set_MD_mode(MD_ALWAYS_ON, session->key())) {
+				dprintf (D_ALWAYS, "DC_AUTHENTICATE: unable to turn on message authenticator for session %s, failing; this session was requested by %s with return address %s\n",sess_id, m_sock->peer_description(), return_address_ss ? return_address_ss : "(none)");
 				if( return_address_ss ) {
 					free( return_address_ss );
 					return_address_ss = NULL;
 				}
 				free( sess_id );
 				sess_id = NULL;
-				result = FALSE;
-				goto finalize;
+				m_result = FALSE;
+				return CommandProtocolFinished;
 			} else {
 				dprintf (D_SECURITY, "DC_AUTHENTICATE: message authenticator enabled with key id %s.\n", sess_id);
-				sec_man->key_printf (D_SECURITY, session->key());
+				m_sec_man->key_printf (D_SECURITY, session->key());
 			}
 
             // Lookup remote user
-            session->policy()->LookupString(ATTR_SEC_USER, &who);
+            session->policy()->LookupString(ATTR_SEC_USER, who);
 
 			free( sess_id );
 
@@ -4422,7 +4525,7 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 
 
 		// get the info, if there is any
-		cleartext_info = ((SafeSock*)sock)->isIncomingDataEncrypted();
+		cleartext_info = ((SafeSock*)m_sock)->isIncomingDataEncrypted();
 		sess_id = NULL;
 		return_address_ss = NULL;
 
@@ -4454,14 +4557,14 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 
 		if (sess_id) {
 			KeyCacheEntry *session = NULL;
-			bool found_sess = sec_man->session_cache->lookup(sess_id, session);
+			bool found_sess = m_sec_man->session_cache->lookup(sess_id, session);
 
 			if (!found_sess) {
-				dprintf ( D_ALWAYS, "DC_AUTHENTICATE: session %s NOT FOUND; this session was requested by %s with return address %s\n", sess_id, sock->peer_description(), return_address_ss ? return_address_ss : "(none)");
+				dprintf ( D_ALWAYS, "DC_AUTHENTICATE: session %s NOT FOUND; this session was requested by %s with return address %s\n", sess_id, m_sock->peer_description(), return_address_ss ? return_address_ss : "(none)");
 				// no session... we outta here!
 
 				// but first, see above behavior in MD5 code above.
-				send_invalidate_session( return_address_ss, sess_id );
+				daemonCore->send_invalidate_session( return_address_ss, sess_id );
 
 				if( return_address_ss ) {
 					free( return_address_ss );
@@ -4469,14 +4572,14 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 				}
 				free( sess_id );
 				sess_id = NULL;
-				result = FALSE;
-				goto finalize;
+				m_result = FALSE;
+				return CommandProtocolFinished;
 			}
 
 			session->renewLease();
 
 			if (!session->key()) {
-				dprintf ( D_ALWAYS, "DC_AUTHENTICATE: session %s is missing the key! This session was requested by %s with return address %s\n", sess_id, sock->peer_description(), return_address_ss ? return_address_ss : "(none)");
+				dprintf ( D_ALWAYS, "DC_AUTHENTICATE: session %s is missing the key! This session was requested by %s with return address %s\n", sess_id, m_sock->peer_description(), return_address_ss ? return_address_ss : "(none)");
 				// uhm, there should be a key here!
 				if( return_address_ss ) {
 					free( return_address_ss );
@@ -4484,8 +4587,8 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 				}
 				free( sess_id );
 				sess_id = NULL;
-				result = FALSE;
-				goto finalize;
+				m_result = FALSE;
+				return CommandProtocolFinished;
 			}
 
 				// NOTE: prior to 7.1.3, we _always_ set the encryption
@@ -4497,33 +4600,33 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 				// versions older than 7.1.3, we could allow the sender to
 				// set the encryption id and trust that we will set the mode
 				// as was previously negotiated.
-			SecMan::sec_feat_act will_enable_encryption = sec_man->sec_lookup_feat_act(*session->policy(), ATTR_SEC_ENCRYPTION);
+			SecMan::sec_feat_act will_enable_encryption = m_sec_man->sec_lookup_feat_act(*session->policy(), ATTR_SEC_ENCRYPTION);
 			bool turn_encryption_on = will_enable_encryption == SecMan::SEC_FEAT_ACT_YES;
 
-			if (!sock->set_crypto_key(turn_encryption_on, session->key())) {
-				dprintf (D_ALWAYS, "DC_AUTHENTICATE: unable to turn on encryption for session %s, failing; this session was requested by %s with return address %s\n",sess_id, sock->peer_description(), return_address_ss ? return_address_ss : "(none)");
+			if (!m_sock->set_crypto_key(turn_encryption_on, session->key())) {
+				dprintf (D_ALWAYS, "DC_AUTHENTICATE: unable to turn on encryption for session %s, failing; this session was requested by %s with return address %s\n",sess_id, m_sock->peer_description(), return_address_ss ? return_address_ss : "(none)");
 				if( return_address_ss ) {
 					free( return_address_ss );
 					return_address_ss = NULL;
 				}
 				free( sess_id );
 				sess_id = NULL;
-				result = FALSE;
-				goto finalize;
+				m_result = FALSE;
+				return CommandProtocolFinished;
 			} else {
 				dprintf (D_SECURITY,
 					"DC_AUTHENTICATE: encryption enabled with key id %s%s.\n",
 					sess_id,
 					turn_encryption_on ? "" : " (but encryption mode is off by default for this packet)");
-				sec_man->key_printf (D_SECURITY, session->key());
+				m_sec_man->key_printf (D_SECURITY, session->key());
 			}
             // Lookup user if necessary
-            if (who == NULL) {
-                session->policy()->LookupString(ATTR_SEC_USER, &who);
+            if (who.empty()) {
+                session->policy()->LookupString(ATTR_SEC_USER, who);
             }
 			bool tried_authentication = false;
 			session->policy()->LookupBool(ATTR_SEC_TRIED_AUTHENTICATION,tried_authentication);
-			sock->setTriedAuthentication(tried_authentication);
+			m_sock->setTriedAuthentication(tried_authentication);
 
 			free( sess_id );
 			if (return_address_ss) {
@@ -4531,14 +4634,20 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 			}
 		}
 
-        if (who != NULL) {
-            sock->setFullyQualifiedUser(who);
-			dprintf (D_SECURITY, "DC_AUTHENTICATE: UDP message is from %s.\n", who);
+        if (!who.empty()) {
+            m_sock->setFullyQualifiedUser(who.c_str());
+			dprintf (D_SECURITY, "DC_AUTHENTICATE: UDP message is from %s.\n", who.c_str());
         }
-	}
 
+		m_state = CommandProtocolReadCommand;
+		return CommandProtocolContinue;
+}
+
+DaemonCommandProtocol::CommandProtocolResult DaemonCommandProtocol::ReadCommand()
+{
+	CondorError errstack;
 
-	sock->decode();
+	m_sock->decode();
 
 		// Determine if incoming socket is HTTP over TCP, or if it is CEDAR.
 		// For better or worse, we figure this out by seeing if the socket
@@ -4548,49 +4657,49 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 		// with a more foolproof method.
 	char tmpbuf[5];
 	memset(tmpbuf,0,sizeof(tmpbuf));
-	if ( is_tcp ) {
+	if ( m_is_tcp ) {
 			// TODO Should we be ignoring the return value of condor_read?
-		condor_read(sock->peer_description(), sock->get_file_desc(),
+		condor_read(m_sock->peer_description(), m_sock->get_file_desc(),
 			tmpbuf, sizeof(tmpbuf) - 1, 1, MSG_PEEK);
 	}
 #ifdef HAVE_EXT_GSOAP
 	if ( strstr(tmpbuf,"GET") ) {
 		if ( param_boolean("ENABLE_WEB_SERVER",false) ) {
 			// mini-web server requires READ authorization.
-			if ( Verify("HTTP GET", READ,sock->peer_addr(),NULL) ) {
-				is_http_get = true;
+			if ( daemonCore->Verify("HTTP GET", READ,m_sock->peer_addr(),NULL) ) {
+				m_is_http_get = true;
 			}
 		} else {
 			dprintf(D_ALWAYS,"Received HTTP GET connection from %s -- "
 				             "DENIED because ENABLE_WEB_SERVER=FALSE\n",
-							 sock->peer_description());
+							 m_sock->peer_description());
 		}
 	} else {
 		if ( strstr(tmpbuf,"POST") ) {
 			if ( param_boolean("ENABLE_SOAP",false) ) {
 				// SOAP requires SOAP authorization.
-				if ( Verify("HTTP POST",SOAP_PERM,sock->peer_addr(),NULL) ) {
-					is_http_post = true;
+				if ( daemonCore->Verify("HTTP POST",SOAP_PERM,m_sock->peer_addr(),NULL) ) {
+					m_is_http_post = true;
 				}
 			} else {
 				dprintf(D_ALWAYS,"Received HTTP POST connection from %s -- "
 							 "DENIED because ENABLE_SOAP=FALSE\n",
-							 sock->peer_description());
+							 m_sock->peer_description());
 			}
 		}
 	}
-	if ( is_http_post || is_http_get )
+	if ( m_is_http_post || m_is_http_get )
 	{
 		struct soap *cursoap;
 
 			// Socket appears to be HTTP, so deal with it.
 		dprintf(D_ALWAYS, "Received HTTP %s connection from %s\n",
-			is_http_get ? "GET" : "POST",
-			sock->peer_description() );
+			m_is_http_get ? "GET" : "POST",
+			m_sock->peer_description() );
 
 
-		ASSERT( soap );
-		cursoap = dc_soap_accept(sock, soap);
+		ASSERT( daemonCore->soap );
+		cursoap = dc_soap_accept(m_sock, daemonCore->soap);
 
 			// Now, process the Soap RPC request and dispatch it
 		dprintf(D_ALWAYS,"About to serve HTTP request...\n");
@@ -4601,109 +4710,108 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 			// gsoap already closed the socket.  so set the socket in
 			// the underlying CEDAR object to INVALID_SOCKET, so
 			// CEDAR won't close it again when we delete the object.
-		sock->_sock = INVALID_SOCKET; 
+		m_sock->invalidateSock();
 
-		result = TRUE;
-		goto finalize;
+		m_result = TRUE;
+		return CommandProtocolFinished;
 	}
 #endif // HAVE_EXT_GSOAP
 
 	// read in the command from the sock with a timeout value of just 1 second,
 	// since we know there is already some data waiting for us.
-	sock->timeout(1);
-	result = sock->code(req);
+	m_sock->timeout(1);
+	m_result = m_sock->code(m_req);
 	// For now, lets set a 20 second timeout, so all command handlers are called with
 	// a timeout of 20 seconds on their socket.
-	sock->timeout(20);
-	if(!result) {
-		char const *ip = sock->peer_ip_str();
+	m_sock->timeout(20);
+	if(!m_result) {
+		char const *ip = m_sock->peer_ip_str();
 		if(!ip) {
 			ip = "unknown address";
 		}
 		dprintf(D_ALWAYS,
 			"DaemonCore: Can't receive command request from %s (perhaps a timeout?)\n", ip);
-		result = FALSE;
-		goto finalize;
+		m_result = FALSE;
+		return CommandProtocolFinished;
 	}
 
-	if (req == DC_AUTHENTICATE) {
+	if (m_req == DC_AUTHENTICATE) {
 
 		// Allow thread to yield during all the authentication network round-trips
 		ScopedEnableParallel(true);
 
-		sock->decode();
+		m_sock->decode();
 
-		dprintf (D_SECURITY, "DC_AUTHENTICATE: received DC_AUTHENTICATE from %s\n", sock->peer_description());
+		dprintf (D_SECURITY, "DC_AUTHENTICATE: received DC_AUTHENTICATE from %s\n", m_sock->peer_description());
 
-		ClassAd auth_info;
-		if( !auth_info.initFromStream(*sock)) {
+		if( !m_auth_info.initFromStream(*m_sock)) {
 			dprintf (D_ALWAYS, "ERROR: DC_AUTHENTICATE unable to "
-					 "receive auth_info from %s!\n", sock->peer_description());
-			result = FALSE;
-			goto finalize;
+					 "receive auth_info from %s!\n", m_sock->peer_description());
+			m_result = FALSE;
+			return CommandProtocolFinished;
 		}
 
-		if ( is_tcp && !sock->end_of_message()) {
+		if ( m_is_tcp && !m_sock->end_of_message()) {
 			dprintf (D_ALWAYS, "ERROR: DC_AUTHENTICATE is TCP, unable to "
 					   "receive eom!\n");
-			result = FALSE;
-			goto finalize;
+			m_result = FALSE;
+			return CommandProtocolFinished;
 		}
 
 		if (DebugFlags & D_FULLDEBUG) {
 			dprintf (D_SECURITY, "DC_AUTHENTICATE: received following ClassAd:\n");
-			auth_info.dPrint (D_SECURITY);
+			m_auth_info.dPrint (D_SECURITY);
 		}
 
 		MyString peer_version;
-		if( auth_info.LookupString( ATTR_SEC_REMOTE_VERSION, peer_version ) ) {
+		if( m_auth_info.LookupString( ATTR_SEC_REMOTE_VERSION, peer_version ) ) {
 			CondorVersionInfo ver_info( peer_version.Value() );
-			sock->set_peer_version( &ver_info );
+			m_sock->set_peer_version( &ver_info );
 		}
 
 		// look at the ad.  get the command number.
-		int real_cmd = 0;
-		int tmp_cmd = 0;
-		auth_info.LookupInteger(ATTR_SEC_COMMAND, real_cmd);
+		m_real_cmd = 0;
+		m_tmp_cmd = 0;
+		m_auth_info.LookupInteger(ATTR_SEC_COMMAND, m_real_cmd);
 
-		if (real_cmd == DC_AUTHENTICATE) {
-			// we'll set tmp_cmd temporarily to
-			auth_info.LookupInteger(ATTR_SEC_AUTH_COMMAND, tmp_cmd);
+		if (m_real_cmd == DC_AUTHENTICATE) {
+			// we'll set m_tmp_cmd temporarily to
+			m_auth_info.LookupInteger(ATTR_SEC_AUTH_COMMAND, m_tmp_cmd);
 		} else {
-			tmp_cmd = real_cmd;
+			m_tmp_cmd = m_real_cmd;
 		}
 
 		// get the auth level of this command
 		// locate the hash table entry
-		int cmd_index = 0;
-		reqFound = CommandNumToTableIndex(tmp_cmd,&cmd_index);
+		m_cmd_index = 0;
+		m_reqFound = daemonCore->CommandNumToTableIndex(m_tmp_cmd,&m_cmd_index);
 
-		if (!reqFound) {
+		if (!m_reqFound) {
 			// we have no idea what command they want to send.
 			// too bad, bye bye
 
 			dprintf(D_ALWAYS,
 					"Received %s command (%d) (%s) from %s %s\n",
-					(is_tcp) ? "TCP" : "UDP",
-					tmp_cmd,
+					(m_is_tcp) ? "TCP" : "UDP",
+					m_tmp_cmd,
 					"UNREGISTERED COMMAND!",
-					user.Value(),
-					sock->peer_description());
+					m_user.Value(),
+					m_sock->peer_description());
 
-			result = FALSE;
-			goto finalize;
+			m_result = FALSE;
+			return CommandProtocolFinished;
 		}
 
-		bool new_session        = false;
+		m_new_session        = false;
 		bool using_cookie       = false;
 		bool valid_cookie		= false;
 
 		// check if we are using a cookie
 		char *incoming_cookie   = NULL;
-		if( auth_info.LookupString(ATTR_SEC_COOKIE, &incoming_cookie)) {
+		if( m_auth_info.LookupString(ATTR_SEC_COOKIE, &incoming_cookie)) {
 			// compare it to the one we have internally
 
-			valid_cookie = cookie_is_valid((unsigned char*)incoming_cookie);
+			valid_cookie = daemonCore->cookie_is_valid((unsigned char*)incoming_cookie);
 			free (incoming_cookie);
 
 			if ( valid_cookie ) {
@@ -4711,9 +4819,9 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 				using_cookie = true;
 			} else {
 				// bad cookie!!!
-				dprintf ( D_ALWAYS, "DC_AUTHENTICATE: recieved invalid cookie from %s!!!\n", sock->peer_description());
-				result = FALSE;
-				goto finalize;
+				dprintf ( D_ALWAYS, "DC_AUTHENTICATE: recieved invalid cookie from %s!!!\n", m_sock->peer_description());
+				m_result = FALSE;
+				return CommandProtocolFinished;
 			}
 		}
 
@@ -4721,42 +4829,42 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 
 		if (!using_cookie) {
 
-			if ( sec_man->sec_lookup_feat_act(auth_info, ATTR_SEC_USE_SESSION) == SecMan::SEC_FEAT_ACT_YES) {
+			if ( m_sec_man->sec_lookup_feat_act(m_auth_info, ATTR_SEC_USE_SESSION) == SecMan::SEC_FEAT_ACT_YES) {
 
 				KeyCacheEntry *session = NULL;
 
-				if( ! auth_info.LookupString(ATTR_SEC_SID, &the_sid)) {
+				if( ! m_auth_info.LookupString(ATTR_SEC_SID, &m_sid)) {
 					dprintf (D_ALWAYS, "ERROR: DC_AUTHENTICATE unable to "
 							 "extract auth_info.%s from %s!\n", ATTR_SEC_SID,
-							 sock->peer_description());
-					result = FALSE;
-					goto finalize;
+							 m_sock->peer_description());
+					m_result = FALSE;
+					return CommandProtocolFinished;
 				}
 
 				// lookup the suggested key
-				if (!sec_man->session_cache->lookup(the_sid, session)) {
+				if (!m_sec_man->session_cache->lookup(m_sid, session)) {
 
 					// the key id they sent was not in our cache.  this is a
 					// problem.
 
 					char * return_addr = NULL;
-					auth_info.LookupString(ATTR_SEC_SERVER_COMMAND_SOCK, &return_addr);
+					m_auth_info.LookupString(ATTR_SEC_SERVER_COMMAND_SOCK, &return_addr);
 
 					dprintf (D_ALWAYS, "DC_AUTHENTICATE: attempt to open "
-							   "invalid session %s, failing; this session was requested by %s with return address %s\n", the_sid, sock->peer_description(), return_addr ? return_addr : "(none)");
+							   "invalid session %s, failing; this session was requested by %s with return address %s\n", m_sid, m_sock->peer_description(), return_addr ? return_addr : "(none)");
 
 					if( return_addr ) {
-						send_invalidate_session( return_addr, the_sid );
+						daemonCore->send_invalidate_session( return_addr, m_sid );
 						free (return_addr);
 					}
 
 					// consume the rejected message
-					sock->decode();
-					sock->end_of_message();
+					m_sock->decode();
+					m_sock->end_of_message();
 
 					// close the connection.
-					result = FALSE;
-					goto finalize;
+					m_result = FALSE;
+					return CommandProtocolFinished;
 
 				} else {
 					// the session->id() and the_sid strings should be identical.
@@ -4778,52 +4886,52 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 
 				if (session->key()) {
 					// copy this to the HandleReq() scope
-					the_key = new KeyInfo(*session->key());
+					m_key = new KeyInfo(*session->key());
 				}
 
 				if (session->policy()) {
 					// copy this to the HandleReq() scope
-					the_policy = new ClassAd(*session->policy());
+					m_policy = new ClassAd(*session->policy());
 					if (DebugFlags & D_FULLDEBUG) {
 						dprintf (D_SECURITY, "DC_AUTHENTICATE: Cached Session:\n");
-						the_policy->dPrint (D_SECURITY);
+						m_policy->dPrint (D_SECURITY);
 					}
 				}
 
 				// grab the user out of the policy.
-				if (the_policy) {
+				if (m_policy) {
 					char *the_user  = NULL;
-					the_policy->LookupString( ATTR_SEC_USER, &the_user);
+					m_policy->LookupString( ATTR_SEC_USER, &the_user);
 					if (the_user) {
 						// copy this to the HandleReq() scope
-						user = the_user;
+						m_user = the_user;
 						free( the_user );
 						the_user = NULL;
 					}
 
 					bool tried_authentication=false;
-					the_policy->LookupBool(ATTR_SEC_TRIED_AUTHENTICATION,tried_authentication);
-					sock->setTriedAuthentication(tried_authentication);
+					m_policy->LookupBool(ATTR_SEC_TRIED_AUTHENTICATION,tried_authentication);
+					m_sock->setTriedAuthentication(tried_authentication);
 				}
-				new_session = false;
+				m_new_session = false;
 
 			} else {
 					// they did not request a cached session.  see if they
 					// want to start one.  look at our security policy.
 				ClassAd our_policy;
-				if( ! sec_man->FillInSecurityPolicyAd(
-					comTable[cmd_index].perm,
+				if( ! m_sec_man->FillInSecurityPolicyAd(
+					m_comTable[m_cmd_index].perm,
 					&our_policy,
 					false,
 					false,
-					comTable[cmd_index].force_authentication ) )
+					m_comTable[m_cmd_index].force_authentication ) )
 				{
 						// our policy is invalid even without the other
 						// side getting involved.
 					dprintf( D_ALWAYS, "DC_AUTHENTICATE: "
 							 "Our security policy is invalid!\n" );
-					result = FALSE;
-					goto finalize;
+					m_result = FALSE;
+					return CommandProtocolFinished;
 				}
 
 				if (DebugFlags & D_FULLDEBUG) {
@@ -4832,45 +4940,45 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 				}
 
 				// reconcile.  if unable, close socket.
-				the_policy = sec_man->ReconcileSecurityPolicyAds( auth_info,
+				m_policy = m_sec_man->ReconcileSecurityPolicyAds( m_auth_info,
 																  our_policy );
 
-				if (!the_policy) {
+				if (!m_policy) {
 					dprintf(D_ALWAYS, "DC_AUTHENTICATE: Unable to reconcile!\n");
-					result = FALSE;
-					goto finalize;
+					m_result = FALSE;
+					return CommandProtocolFinished;
 				} else {
 					if (DebugFlags & D_FULLDEBUG) {
 						dprintf ( D_SECURITY, "DC_AUTHENTICATE: the_policy:\n" );
-						the_policy->dPrint(D_SECURITY);
+						m_policy->dPrint(D_SECURITY);
 					}
 				}
 
 				// add our version to the policy to be sent over
-				the_policy->Assign(ATTR_SEC_REMOTE_VERSION, CondorVersion());
+				m_policy->Assign(ATTR_SEC_REMOTE_VERSION, CondorVersion());
 
 				// handy policy vars
-				SecMan::sec_feat_act will_authenticate      = sec_man->sec_lookup_feat_act(*the_policy, ATTR_SEC_AUTHENTICATION);
+				SecMan::sec_feat_act will_authenticate      = m_sec_man->sec_lookup_feat_act(*m_policy, ATTR_SEC_AUTHENTICATION);
 
-				if (sec_man->sec_lookup_feat_act(auth_info, ATTR_SEC_NEW_SESSION) == SecMan::SEC_FEAT_ACT_YES) {
+				if (m_sec_man->sec_lookup_feat_act(m_auth_info, ATTR_SEC_NEW_SESSION) == SecMan::SEC_FEAT_ACT_YES) {
 
 					// generate a new session
 
 					// generate a unique ID.
 					MyString tmpStr;
 					tmpStr.sprintf( "%s:%i:%i:%i", 
-									get_local_hostname().Value(), mypid,
+									get_local_hostname().Value(), daemonCore->mypid,
 							 (int)time(0), ZZZ_always_increase() );
-					assert (the_sid == NULL);
-					the_sid = strdup(tmpStr.Value());
+					assert (m_sid == NULL);
+					m_sid = strdup(tmpStr.Value());
 
 					if (will_authenticate == SecMan::SEC_FEAT_ACT_YES) {
 
 						char *crypto_method = NULL;
-						if (!the_policy->LookupString(ATTR_SEC_CRYPTO_METHODS, &crypto_method)) {
-							dprintf ( D_ALWAYS, "DC_AUTHENTICATE: tried to enable encryption for request from %s, but we have none!\n", sock->peer_description() );
-							result = FALSE;
-							goto finalize;
+						if (!m_policy->LookupString(ATTR_SEC_CRYPTO_METHODS, &crypto_method)) {
+							dprintf ( D_ALWAYS, "DC_AUTHENTICATE: tried to enable encryption for request from %s, but we have none!\n", m_sock->peer_description() );
+							m_result = FALSE;
+							return CommandProtocolFinished;
 						}
 
 						unsigned char* rkey = Condor_Crypt_Base::randomKey(24);
@@ -4881,66 +4989,66 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 							free (rkey);
 						} else {
 							memset (rbuf, 0, 24);
-							dprintf ( D_ALWAYS, "DC_AUTHENTICATE: unable to generate key for request from %s - no crypto available!\n", sock->peer_description() );							
+							dprintf ( D_ALWAYS, "DC_AUTHENTICATE: unable to generate key for request from %s - no crypto available!\n", m_sock->peer_description() );							
 							free( crypto_method );
 							crypto_method = NULL;
-							result = FALSE;
-							goto finalize;
+							m_result = FALSE;
+							return CommandProtocolFinished;
 						}
 
 						switch (toupper(crypto_method[0])) {
 							case 'B': // blowfish
-								dprintf (D_SECURITY, "DC_AUTHENTICATE: generating BLOWFISH key for session %s...\n", the_sid);
-								the_key = new KeyInfo(rbuf, 24, CONDOR_BLOWFISH);
+								dprintf (D_SECURITY, "DC_AUTHENTICATE: generating BLOWFISH key for session %s...\n", m_sid);
+								m_key = new KeyInfo(rbuf, 24, CONDOR_BLOWFISH);
 								break;
 							case '3': // 3des
 							case 'T': // Tripledes
-								dprintf (D_SECURITY, "DC_AUTHENTICATE: generating 3DES key for session %s...\n", the_sid);
-								the_key = new KeyInfo(rbuf, 24, CONDOR_3DES);
+								dprintf (D_SECURITY, "DC_AUTHENTICATE: generating 3DES key for session %s...\n", m_sid);
+								m_key = new KeyInfo(rbuf, 24, CONDOR_3DES);
 								break;
 							default:
-								dprintf (D_SECURITY, "DC_AUTHENTICATE: generating RANDOM key for session %s...\n", the_sid);
-								the_key = new KeyInfo(rbuf, 24);
+								dprintf (D_SECURITY, "DC_AUTHENTICATE: generating RANDOM key for session %s...\n", m_sid);
+								m_key = new KeyInfo(rbuf, 24);
 								break;
 						}
 
 						free( crypto_method );
 						crypto_method = NULL;
 
-						if (!the_key) {
-							result = FALSE;
-							goto finalize;
+						if (!m_key) {
+							m_result = FALSE;
+							return CommandProtocolFinished;
 						}
 
-						sec_man->key_printf (D_SECURITY, the_key);
+						m_sec_man->key_printf (D_SECURITY, m_key);
 					}
 
-					new_session = true;
+					m_new_session = true;
 				}
 
 				// if they asked, tell them
-				if (is_tcp && (sec_man->sec_lookup_feat_act(auth_info, ATTR_SEC_ENACT) == SecMan::SEC_FEAT_ACT_NO)) {
+				if (m_is_tcp && (m_sec_man->sec_lookup_feat_act(m_auth_info, ATTR_SEC_ENACT) == SecMan::SEC_FEAT_ACT_NO)) {
 					if (DebugFlags & D_FULLDEBUG) {
 						dprintf (D_SECURITY, "SECMAN: Sending following response ClassAd:\n");
-						the_policy->dPrint( D_SECURITY );
+						m_policy->dPrint( D_SECURITY );
 					}
-					sock->encode();
-					if (!the_policy->put(*sock) ||
-						!sock->end_of_message()) {
-						dprintf (D_ALWAYS, "SECMAN: Error sending response classad to %s!\n", sock->peer_description());
-						auth_info.dPrint (D_ALWAYS);
-						result = FALSE;
-						goto finalize;
+					m_sock->encode();
+					if (!m_policy->put(*m_sock) ||
+						!m_sock->end_of_message()) {
+						dprintf (D_ALWAYS, "SECMAN: Error sending response classad to %s!\n", m_sock->peer_description());
+						m_auth_info.dPrint (D_ALWAYS);
+						m_result = FALSE;
+						return CommandProtocolFinished;
 					}
-					sock->decode();
+					m_sock->decode();
 				} else {
 					dprintf( D_SECURITY, "SECMAN: Enact was '%s', not sending response.\n",
-						SecMan::sec_feat_act_rev[sec_man->sec_lookup_feat_act(auth_info, ATTR_SEC_ENACT)] );
+						SecMan::sec_feat_act_rev[m_sec_man->sec_lookup_feat_act(m_auth_info, ATTR_SEC_ENACT)] );
 				}
 
 			}
 
-			if( !is_tcp ) {
+			if( !m_is_tcp ) {
 					// For UDP, if encryption is not on by default,
 					// configure it with the session key so that it
 					// can be programmatically toggled on and off for
@@ -4950,24 +5058,24 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 					// on by now, because the UDP header contains the
 					// encryption key in that case.
 
-				SecMan::sec_feat_act will_enable_encryption = sec_man->sec_lookup_feat_act(*the_policy, ATTR_SEC_ENCRYPTION);
+				SecMan::sec_feat_act will_enable_encryption = m_sec_man->sec_lookup_feat_act(*m_policy, ATTR_SEC_ENCRYPTION);
 
 				if( will_enable_encryption != SecMan::SEC_FEAT_ACT_YES
-					&& the_key )
+					&& m_key )
 				{
-					sock->set_crypto_key(false, the_key);
-					dprintf(D_SECURITY, "DC_AUTHENTICATE: encryption enabled with session key id %s (but encryption mode is off by default for this packet).\n", the_sid ? the_sid : "(null)");
+					m_sock->set_crypto_key(false, m_key);
+					dprintf(D_SECURITY, "DC_AUTHENTICATE: encryption enabled with session key id %s (but encryption mode is off by default for this packet).\n", m_sid ? m_sid : "(null)");
 				}
 			}
 
-			if (is_tcp) {
+			if (m_is_tcp) {
 
 				// do what we decided
 
 				// handy policy vars
-				SecMan::sec_feat_act will_authenticate      = sec_man->sec_lookup_feat_act(*the_policy, ATTR_SEC_AUTHENTICATION);
-				SecMan::sec_feat_act will_enable_encryption = sec_man->sec_lookup_feat_act(*the_policy, ATTR_SEC_ENCRYPTION);
-				SecMan::sec_feat_act will_enable_integrity  = sec_man->sec_lookup_feat_act(*the_policy, ATTR_SEC_INTEGRITY);
+				SecMan::sec_feat_act will_authenticate      = m_sec_man->sec_lookup_feat_act(*m_policy, ATTR_SEC_AUTHENTICATION);
+				m_will_enable_encryption = m_sec_man->sec_lookup_feat_act(*m_policy, ATTR_SEC_ENCRYPTION);
+				m_will_enable_integrity  = m_sec_man->sec_lookup_feat_act(*m_policy, ATTR_SEC_INTEGRITY);
 
 
 				// protocol fix:
@@ -4977,14 +5085,14 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 				// this is not necessary.
 				//
 				// so, as of 6.6.1, if we are resuming a session (as determined
-				// by the expression (!new_session), AND the other side is
+				// by the expression (!m_new_session), AND the other side is
 				// 6.6.1 or higher, we will force will_authenticate to
 				// SEC_FEAT_ACT_NO.
 
 				if ((will_authenticate == SecMan::SEC_FEAT_ACT_YES)) {
-					if ((!new_session)) {
+					if ((!m_new_session)) {
 						char * remote_version = NULL;
-						the_policy->LookupString(ATTR_SEC_REMOTE_VERSION, &remote_version);
+						m_policy->LookupString(ATTR_SEC_REMOTE_VERSION, &remote_version);
 						if(remote_version) {
 							// this attribute was added in 6.6.1.  it's mere
 							// presence means that the remote side is 6.6.1 or
@@ -5003,266 +5111,292 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 
 
 
-				if (is_tcp && (will_authenticate == SecMan::SEC_FEAT_ACT_YES)) {
+				if (m_is_tcp && (will_authenticate == SecMan::SEC_FEAT_ACT_YES)) {
 
-					// we are going to authenticate.  this could one of two ways.
-					// the "real" way or the "quick" way which is by presenting a
-					// session ID.  the fact that the private key matches on both
-					// sides proves the authenticity.  if the key does not match,
-					// it will be detected as long as some crypto is used.
+					m_state = CommandProtocolAuthenticate;
+					return CommandProtocolContinue;
 
 
-					// we know the ..METHODS_LIST attribute exists since it was put
-					// in by us.  pre 6.5.0 protocol does not put it in.
-					char * auth_methods = NULL;
-					the_policy->LookupString(ATTR_SEC_AUTHENTICATION_METHODS_LIST, &auth_methods);
-
-					if (!auth_methods) {
-						dprintf (D_SECURITY, "DC_AUTHENTICATE: no auth methods in response ad from %s, failing!\n", sock->peer_description());
-						result = FALSE;
-						goto finalize;
-					}
-
+				} else {
 					if (DebugFlags & D_FULLDEBUG) {
-						dprintf (D_SECURITY, "DC_AUTHENTICATE: authenticating RIGHT NOW.\n");
+						dprintf (D_SECURITY, "DC_AUTHENTICATE: not authenticating.\n");
 					}
+					m_state = CommandProtocolPostAuthenticate;
+					return CommandProtocolContinue;
+				}
+			}
+		}
+	}
+	m_state = CommandProtocolExecCommand;
+	return CommandProtocolContinue;
+}
 
-					int auth_timeout = getSecMan()->getSecTimeout( comTable[cmd_index].perm );
-					char *method_used = NULL;
-					bool auth_success = sock->authenticate(the_key, auth_methods, &errstack, auth_timeout, &method_used);
+DaemonCommandProtocol::CommandProtocolResult DaemonCommandProtocol::Authenticate()
+{
+	CondorError errstack;
 
-					if ( method_used ) {
-						the_policy->Assign(ATTR_SEC_AUTHENTICATION_METHODS, method_used);
-					}
+	if( m_nonblocking && !m_sock->readReady() ) {
+		return WaitForSocketData();
+	}
 
-					free( auth_methods );
-					free( method_used );
+	// we know the ..METHODS_LIST attribute exists since it was put
+	// in by us.  pre 6.5.0 protocol does not put it in.
+	char * auth_methods = NULL;
+	m_policy->LookupString(ATTR_SEC_AUTHENTICATION_METHODS_LIST, &auth_methods);
 
-					if( comTable[cmd_index].force_authentication &&
-						!sock->isMappedFQU() )
-					{
-						dprintf(D_ALWAYS, "DC_AUTHENTICATE: authentication of %s did not result in a valid mapped user name, which is required for this command (%d %s), so aborting.\n",
-								sock->peer_description(),
-								tmp_cmd,
-								comTable[cmd_index].command_descrip );
-						if( !auth_success ) {
-							dprintf( D_ALWAYS,
-									 "DC_AUTHENTICATE: reason for authentication failure: %s\n",
-									 errstack.getFullText() );
-						}
-						result = FALSE;
-						goto finalize;
-					}
+	if (!auth_methods) {
+		dprintf (D_SECURITY, "DC_AUTHENTICATE: no auth methods in response ad from %s, failing!\n", m_sock->peer_description());
+		m_result = FALSE;
+		return CommandProtocolFinished;
+	}
 
-					if( auth_success ) {
-						dprintf (D_SECURITY, "DC_AUTHENTICATE: authentication of %s complete.\n", sock->peer_ip_str());
-					}
-					else {
-						bool auth_required = true;
-						the_policy->LookupBool(ATTR_SEC_AUTH_REQUIRED,auth_required);
-
-						if( !auth_required ) {
-							dprintf( D_SECURITY|D_FULLDEBUG,
-									 "DC_SECURITY: authentication of %s failed but was not required, so continuing.\n",
-									 sock->peer_ip_str());
-							if( the_key ) {
-									// Since we did not authenticate, we have not exchanged a key with our peer.
-								delete the_key;
-								the_key = NULL;
-							}
-						}
-						else {
-							dprintf( D_ALWAYS,
-									 "DC_AUTHENTICATE: required authentication of %s failed: %s\n",
-									 sock->peer_ip_str(),
-									 errstack.getFullText() );
-							result = FALSE;
-							goto finalize;
-						}
-					}
+	if (DebugFlags & D_FULLDEBUG) {
+		dprintf (D_SECURITY, "DC_AUTHENTICATE: authenticating RIGHT NOW.\n");
+	}
 
-				} else {
-					if (DebugFlags & D_FULLDEBUG) {
-						dprintf (D_SECURITY, "DC_AUTHENTICATE: not authenticating.\n");
-					}
-				}
+	int auth_timeout = daemonCore->getSecMan()->getSecTimeout( m_comTable[m_cmd_index].perm );
 
+	char *method_used = NULL;
+	bool auth_success = m_sock->authenticate(m_key, auth_methods, &errstack, auth_timeout, &method_used);
 
-				if (will_enable_integrity == SecMan::SEC_FEAT_ACT_YES) {
+	if ( method_used ) {
+		m_policy->Assign(ATTR_SEC_AUTHENTICATION_METHODS, method_used);
+	}
 
-					if (!the_key) {
-						// uhm, there should be a key here!
-						result = FALSE;
-						goto finalize;
-					}
+	free( auth_methods );
+	free( method_used );
 
-					sock->decode();
-					if (!sock->set_MD_mode(MD_ALWAYS_ON, the_key)) {
-						dprintf (D_ALWAYS, "DC_AUTHENTICATE: unable to turn on message authenticator, failing request from %s.\n", sock->peer_description());
-						result = FALSE;
-						goto finalize;
-					} else {
-						dprintf (D_SECURITY, "DC_AUTHENTICATE: message authenticator enabled with key id %s.\n", the_sid);
-						sec_man->key_printf (D_SECURITY, the_key);
-					}
-				} else {
-					sock->set_MD_mode(MD_OFF, the_key);
-				}
+	if( m_comTable[m_cmd_index].force_authentication &&
+		!m_sock->isMappedFQU() )
+	{
+		dprintf(D_ALWAYS, "DC_AUTHENTICATE: authentication of %s did not result in a valid mapped user name, which is required for this command (%d %s), so aborting.\n",
+				m_sock->peer_description(),
+				m_tmp_cmd,
+				m_comTable[m_cmd_index].command_descrip );
+		if( !auth_success ) {
+			dprintf( D_ALWAYS,
+					 "DC_AUTHENTICATE: reason for authentication failure: %s\n",
+					 errstack.getFullText() );
+		}
+		m_result = FALSE;
+		return CommandProtocolFinished;
+	}
 
+	if( auth_success ) {
+		dprintf (D_SECURITY, "DC_AUTHENTICATE: authentication of %s complete.\n", m_sock->peer_ip_str());
+	}
+	else {
+		bool auth_required = true;
+		m_policy->LookupBool(ATTR_SEC_AUTH_REQUIRED,auth_required);
+
+		if( !auth_required ) {
+			dprintf( D_SECURITY|D_FULLDEBUG,
+					 "DC_SECURITY: authentication of %s failed but was not required, so continuing.\n",
+					 m_sock->peer_ip_str());
+			if( m_key ) {
+					// Since we did not authenticate, we have not exchanged a key with our peer.
+				delete m_key;
+				m_key = NULL;
+			}
+		}
+		else {
+			dprintf( D_ALWAYS,
+					 "DC_AUTHENTICATE: required authentication of %s failed: %s\n",
+					 m_sock->peer_ip_str(),
+					 errstack.getFullText() );
+			m_result = FALSE;
+			return CommandProtocolFinished;
+		}
+	}
 
-				if (will_enable_encryption == SecMan::SEC_FEAT_ACT_YES) {
+	m_state = CommandProtocolPostAuthenticate;
+	return CommandProtocolContinue;
+}
 
-					if (!the_key) {
-						// uhm, there should be a key here!
-						result = FALSE;
-						goto finalize;
-					}
+DaemonCommandProtocol::CommandProtocolResult DaemonCommandProtocol::PostAuthenticate()
+{
+	if (m_will_enable_integrity == SecMan::SEC_FEAT_ACT_YES) {
 
-					sock->decode();
-					if (!sock->set_crypto_key(true, the_key) ) {
-						dprintf (D_ALWAYS, "DC_AUTHENTICATE: unable to turn on encryption, failing request from %s.\n", sock->peer_description());
-						result = FALSE;
-						goto finalize;
-					} else {
-						dprintf (D_SECURITY, "DC_AUTHENTICATE: encryption enabled for session %s\n", the_sid);
-					}
-				} else {
-					sock->set_crypto_key(false, the_key);
-				}
+		if (!m_key) {
+			// uhm, there should be a key here!
+			m_result = FALSE;
+			return CommandProtocolFinished;
+		}
 
+		m_sock->decode();
+		if (!m_sock->set_MD_mode(MD_ALWAYS_ON, m_key)) {
+			dprintf (D_ALWAYS, "DC_AUTHENTICATE: unable to turn on message authenticator, failing request from %s.\n", m_sock->peer_description());
+			m_result = FALSE;
+			return CommandProtocolFinished;
+		} else {
+			dprintf (D_SECURITY, "DC_AUTHENTICATE: message authenticator enabled with key id %s.\n", m_sid);
+			m_sec_man->key_printf (D_SECURITY, m_key);
+		}
+	} else {
+		m_sock->set_MD_mode(MD_OFF, m_key);
+	}
 
-				if (new_session) {
-					// clear the buffer
-					sock->decode();
-					sock->end_of_message();
 
-					// ready a classad to send
-					ClassAd pa_ad;
+	if (m_will_enable_encryption == SecMan::SEC_FEAT_ACT_YES) {
 
-					// session user
-					const char *fully_qualified_user = sock->getFullyQualifiedUser();
-					if ( fully_qualified_user ) {
-						pa_ad.Assign(ATTR_SEC_USER,fully_qualified_user);
-					}
+		if (!m_key) {
+			// uhm, there should be a key here!
+			m_result = FALSE;
+			return CommandProtocolFinished;
+		}
 
-					if (sock->triedAuthentication()) {
-							// Clients older than 7.1.2 behave differently when re-using a
-							// security session.  If they reach a point in the code where
-							// authentication is forced (e.g. to submit jobs), they will
-							// always re-authenticate at that point.  Therefore, we only
-							// set TriedAuthentication=True for newer clients which respect
-							// that setting.  When the setting is not there or false, the server
-							// and client will re-authenticate at such points because
-							// triedAuthentication() (or isAuthenticated() in the older code)
-							// will be false.
-						char * remote_version = NULL;
-						the_policy->LookupString(ATTR_SEC_REMOTE_VERSION, &remote_version);
-						CondorVersionInfo verinfo(remote_version);
-						free(remote_version);
+		m_sock->decode();
+		if (!m_sock->set_crypto_key(true, m_key) ) {
+			dprintf (D_ALWAYS, "DC_AUTHENTICATE: unable to turn on encryption, failing request from %s.\n", m_sock->peer_description());
+			m_result = FALSE;
+			return CommandProtocolFinished;
+		} else {
+			dprintf (D_SECURITY, "DC_AUTHENTICATE: encryption enabled for session %s\n", m_sid);
+		}
+	} else {
+		m_sock->set_crypto_key(false, m_key);
+	}
 
-						if (verinfo.built_since_version(7,1,2)) {
-							pa_ad.Assign(ATTR_SEC_TRIED_AUTHENTICATION,sock->triedAuthentication());
-						}
 
-					}
+	if (m_new_session) {
+		// clear the buffer
+		m_sock->decode();
+		m_sock->end_of_message();
 
-						// remember on the server side what we told the client
-					sec_man->sec_copy_attribute( *the_policy, pa_ad, ATTR_SEC_TRIED_AUTHENTICATION );
+		// ready a classad to send
+		ClassAd pa_ad;
 
-					// session id
-					pa_ad.Assign(ATTR_SEC_SID, the_sid);
+		// session user
+		const char *fully_qualified_user = m_sock->getFullyQualifiedUser();
+		if ( fully_qualified_user ) {
+			pa_ad.Assign(ATTR_SEC_USER,fully_qualified_user);
+		}
 
-					// other commands this session is good for
-					pa_ad.Assign(ATTR_SEC_VALID_COMMANDS, GetCommandsInAuthLevel(comTable[cmd_index].perm,sock->isMappedFQU()).Value());
+		if (m_sock->triedAuthentication()) {
+				// Clients older than 7.1.2 behave differently when re-using a
+				// security session.  If they reach a point in the code where
+				// authentication is forced (e.g. to submit jobs), they will
+				// always re-authenticate at that point.  Therefore, we only
+				// set TriedAuthentication=True for newer clients which respect
+				// that setting.  When the setting is not there or false, the server
+				// and client will re-authenticate at such points because
+				// triedAuthentication() (or isAuthenticated() in the older code)
+				// will be false.
+			char * remote_version = NULL;
+			m_policy->LookupString(ATTR_SEC_REMOTE_VERSION, &remote_version);
+			CondorVersionInfo verinfo(remote_version);
+			free(remote_version);
 
-					// also put some attributes in the policy classad we are caching.
-					sec_man->sec_copy_attribute( *the_policy, auth_info, ATTR_SEC_SUBSYSTEM );
-					sec_man->sec_copy_attribute( *the_policy, auth_info, ATTR_SEC_SERVER_COMMAND_SOCK );
-					sec_man->sec_copy_attribute( *the_policy, auth_info, ATTR_SEC_PARENT_UNIQUE_ID );
-					sec_man->sec_copy_attribute( *the_policy, auth_info, ATTR_SEC_SERVER_PID );
-					// it matters if the version is empty, so we must explicitly delete it
-					the_policy->Delete( ATTR_SEC_REMOTE_VERSION );
-					sec_man->sec_copy_attribute( *the_policy, auth_info, ATTR_SEC_REMOTE_VERSION );
-					sec_man->sec_copy_attribute( *the_policy, pa_ad, ATTR_SEC_USER );
-					sec_man->sec_copy_attribute( *the_policy, pa_ad, ATTR_SEC_SID );
-					sec_man->sec_copy_attribute( *the_policy, pa_ad, ATTR_SEC_VALID_COMMANDS );
+			if (verinfo.built_since_version(7,1,2)) {
+				pa_ad.Assign(ATTR_SEC_TRIED_AUTHENTICATION,m_sock->triedAuthentication());
+			}
 
-					if (DebugFlags & D_FULLDEBUG) {
-						dprintf (D_SECURITY, "DC_AUTHENTICATE: sending session ad:\n");
-						pa_ad.dPrint( D_SECURITY );
-					}
+		}
 
-					sock->encode();
-					if (! pa_ad.put(*sock) ||
-						! sock->end_of_message() ) {
-						dprintf (D_ALWAYS, "DC_AUTHENTICATE: unable to send session %s info to %s!\n", the_sid, sock->peer_description());
-						result = FALSE;
-						goto finalize;
-					} else {
-						if (DebugFlags & D_FULLDEBUG) {
-							dprintf (D_SECURITY, "DC_AUTHENTICATE: sent session %s info!\n", the_sid);
-						}
-					}
+			// remember on the server side what we told the client
+		m_sec_man->sec_copy_attribute( *m_policy, pa_ad, ATTR_SEC_TRIED_AUTHENTICATION );
 
-					// extract the session duration
-					char *dur = NULL;
-					the_policy->LookupString(ATTR_SEC_SESSION_DURATION, &dur);
-
-					char *return_addr = NULL;
-					the_policy->LookupString(ATTR_SEC_SERVER_COMMAND_SOCK, &return_addr);
-
-					// we add 20 seconds for "slop".  the idea is that if the client were
-					// to start a session just as it was expiring, the server will allow a
-					// window of 20 seconds to receive the command before throwing out the
-					// cached session.
-					int slop = param_integer("SEC_SESSION_DURATION_SLOP", 20);
-					int durint = atoi(dur) + slop;
-					time_t now = time(0);
-					int expiration_time = now + durint;
-
-					// extract the session lease time (max unused time)
-					int session_lease = 0;
-					the_policy->LookupInteger(ATTR_SEC_SESSION_LEASE, session_lease);
-					if( session_lease ) {
-							// Add some slop on the server side to avoid
-							// expiration right before the client tries
-							// to renew the lease.
-						session_lease += slop;
-					}
+		// session id
+		pa_ad.Assign(ATTR_SEC_SID, m_sid);
 
+		// other commands this session is good for
+		pa_ad.Assign(ATTR_SEC_VALID_COMMANDS, daemonCore->GetCommandsInAuthLevel(m_comTable[m_cmd_index].perm,m_sock->isMappedFQU()).Value());
 
-					// add the key to the cache
+		// also put some attributes in the policy classad we are caching.
+		m_sec_man->sec_copy_attribute( *m_policy, m_auth_info, ATTR_SEC_SUBSYSTEM );
+		m_sec_man->sec_copy_attribute( *m_policy, m_auth_info, ATTR_SEC_SERVER_COMMAND_SOCK );
+		m_sec_man->sec_copy_attribute( *m_policy, m_auth_info, ATTR_SEC_PARENT_UNIQUE_ID );
+		m_sec_man->sec_copy_attribute( *m_policy, m_auth_info, ATTR_SEC_SERVER_PID );
+		// it matters if the version is empty, so we must explicitly delete it
+		m_policy->Delete( ATTR_SEC_REMOTE_VERSION );
+		m_sec_man->sec_copy_attribute( *m_policy, m_auth_info, ATTR_SEC_REMOTE_VERSION );
+		m_sec_man->sec_copy_attribute( *m_policy, pa_ad, ATTR_SEC_USER );
+		m_sec_man->sec_copy_attribute( *m_policy, pa_ad, ATTR_SEC_SID );
+		m_sec_man->sec_copy_attribute( *m_policy, pa_ad, ATTR_SEC_VALID_COMMANDS );
 
-					// This is a session for incoming connections, so
-					// do not pass in sock->peer_addr() as addr,
-					// because then this key would get confused for an
-					// outgoing session to a daemon with that IP and
-					// port as its command socket.
-					KeyCacheEntry tmp_key(the_sid, NULL, the_key, the_policy, expiration_time, session_lease );
-					sec_man->session_cache->insert(tmp_key);
-					dprintf (D_SECURITY, "DC_AUTHENTICATE: added incoming session id %s to cache for %i seconds (lease is %ds, return address is %s).\n", the_sid, durint, session_lease, return_addr ? return_addr : "unknown");
-					if (DebugFlags & D_FULLDEBUG) {
-						the_policy->dPrint(D_SECURITY);
-					}
+		if (DebugFlags & D_FULLDEBUG) {
+			dprintf (D_SECURITY, "DC_AUTHENTICATE: sending session ad:\n");
+			pa_ad.dPrint( D_SECURITY );
+		}
 
-					free( dur );
-					dur = NULL;
-					free( return_addr );
-					return_addr = NULL;
-				}
+		m_sock->encode();
+		if (! pa_ad.put(*m_sock) ||
+			! m_sock->end_of_message() ) {
+			dprintf (D_ALWAYS, "DC_AUTHENTICATE: unable to send session %s info to %s!\n", m_sid, m_sock->peer_description());
+			m_result = FALSE;
+			return CommandProtocolFinished;
+		} else {
+			if (DebugFlags & D_FULLDEBUG) {
+				dprintf (D_SECURITY, "DC_AUTHENTICATE: sent session %s info!\n", m_sid);
 			}
 		}
 
-		if (real_cmd == DC_AUTHENTICATE) {
-			result = TRUE;
-			goto finalize;
+		// extract the session duration
+		char *dur = NULL;
+		m_policy->LookupString(ATTR_SEC_SESSION_DURATION, &dur);
+
+		char *return_addr = NULL;
+		m_policy->LookupString(ATTR_SEC_SERVER_COMMAND_SOCK, &return_addr);
+
+		// we add 20 seconds for "slop".  the idea is that if the client were
+		// to start a session just as it was expiring, the server will allow a
+		// window of 20 seconds to receive the command before throwing out the
+		// cached session.
+		int slop = param_integer("SEC_SESSION_DURATION_SLOP", 20);
+		int durint = atoi(dur) + slop;
+		time_t now = time(0);
+		int expiration_time = now + durint;
+
+		// extract the session lease time (max unused time)
+		int session_lease = 0;
+		m_policy->LookupInteger(ATTR_SEC_SESSION_LEASE, session_lease);
+		if( session_lease ) {
+				// Add some slop on the server side to avoid
+				// expiration right before the client tries
+				// to renew the lease.
+			session_lease += slop;
 		}
 
-		req = real_cmd;
-		result = TRUE;
 
-		sock->decode();
-		if( comTable[cmd_index].wait_for_payload == 0 ) {
+		// add the key to the cache
+
+		// This is a session for incoming connections, so
+		// do not pass in m_sock->peer_addr() as addr,
+		// because then this key would get confused for an
+		// outgoing session to a daemon with that IP and
+		// port as its command socket.
+		KeyCacheEntry tmp_key(m_sid, NULL, m_key, m_policy, expiration_time, session_lease );
+		m_sec_man->session_cache->insert(tmp_key);
+		dprintf (D_SECURITY, "DC_AUTHENTICATE: added incoming session id %s to cache for %i seconds (lease is %ds, return address is %s).\n", m_sid, durint, session_lease, return_addr ? return_addr : "unknown");
+		if (DebugFlags & D_FULLDEBUG) {
+			m_policy->dPrint(D_SECURITY);
+		}
+
+		free( dur );
+		dur = NULL;
+		free( return_addr );
+		return_addr = NULL;
+	}
+
+	m_state = CommandProtocolExecCommand;
+	return CommandProtocolContinue;
+}
+
+DaemonCommandProtocol::CommandProtocolResult DaemonCommandProtocol::ExecCommand()
+{
+	CondorError errstack;
+
+	if (m_req == DC_AUTHENTICATE) {
+		if (m_real_cmd == DC_AUTHENTICATE) {
+			m_result = TRUE;
+			return CommandProtocolFinished;
+		}
+
+		m_req = m_real_cmd;
+		m_result = TRUE;
+
+		m_sock->decode();
+		if( m_comTable[m_cmd_index].wait_for_payload == 0 ) {
 
 				// This command _might_ be one with no further data.
 				// Because of the way DC_AUTHENTICATE was implemented,
@@ -5271,18 +5405,18 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 				// error, because we have already consumed the end of
 				// message.  Therefore, we set a flag on the socket:
 
-			sock->allow_one_empty_message();
+			m_sock->allow_one_empty_message();
 		}
 
 		// fill in the command info
-		reqFound = TRUE;
-		index = cmd_index;
+		m_reqFound = TRUE;
+		m_index = m_cmd_index;
 
 		dprintf (D_SECURITY, "DC_AUTHENTICATE: Success.\n");
 	} else {
 		// we received some command other than DC_AUTHENTICATE
 		// get the handler function
-		reqFound = CommandNumToTableIndex(req,&index);
+		m_reqFound = daemonCore->CommandNumToTableIndex(m_req,&m_index);
 
 			// There are two cases where we get here:
 			//  1. receiving unauthenticated command
@@ -5290,224 +5424,224 @@ int DaemonCore::HandleReq(Stream *insock, Stream* asock)
 
 			// See if we should force authentication for this command.
 			// The client is expected to do the same.
-		if (reqFound &&
-			is_tcp &&
-			!sock->isAuthenticated() &&
-			comTable[index].force_authentication &&
-			!sock->triedAuthentication() )
+		if (m_reqFound &&
+			m_is_tcp &&
+			!m_sock->isAuthenticated() &&
+			m_comTable[m_index].force_authentication &&
+			!m_sock->triedAuthentication() )
 		{
-			SecMan::authenticate_sock(sock, WRITE, &errstack);
+			SecMan::authenticate_sock(m_sock, WRITE, &errstack);
 				// we don't check the return value, because the code below
 				// handles what to do with unauthenticated connections
 		}
 
-		if (reqFound && !sock->isAuthenticated()) {
+		if (m_reqFound && !m_sock->isAuthenticated()) {
 			// need to check our security policy to see if this is allowed.
 
-			dprintf (D_SECURITY, "DaemonCore received UNAUTHENTICATED command %i %s.\n", req, comTable[index].command_descrip);
+			dprintf (D_SECURITY, "DaemonCore received UNAUTHENTICATED command %i %s.\n", m_req, m_comTable[m_index].command_descrip);
 
 			// if the command was registered as "ALLOW", then it doesn't matter what the
 			// security policy says, we just allow it.
-			if (comTable[index].perm != ALLOW) {
+			if (m_comTable[m_index].perm != ALLOW) {
 
 				ClassAd our_policy;
-				if( ! sec_man->FillInSecurityPolicyAd(
-					comTable[index].perm,
+				if( ! m_sec_man->FillInSecurityPolicyAd(
+					m_comTable[m_index].perm,
 					&our_policy,
 					false,
 					false,
-					comTable[index].force_authentication ) )
+					m_comTable[m_index].force_authentication ) )
 				{
 					dprintf( D_ALWAYS, "DC_AUTHENTICATE: "
 							 "Our security policy is invalid!\n" );
-					result = FALSE;
-					goto finalize;
+					m_result = FALSE;
+					return CommandProtocolFinished;
 				}
 
 				// well, they didn't authenticate, turn on encryption,
 				// or turn on integrity.  check to see if any of those
 				// were required.
 
-				if (  (sec_man->sec_lookup_req(our_policy, ATTR_SEC_NEGOTIATION)
+				if (  (m_sec_man->sec_lookup_req(our_policy, ATTR_SEC_NEGOTIATION)
 					   == SecMan::SEC_REQ_REQUIRED)
-				   || (sec_man->sec_lookup_req(our_policy, ATTR_SEC_AUTHENTICATION)
+				   || (m_sec_man->sec_lookup_req(our_policy, ATTR_SEC_AUTHENTICATION)
 					   == SecMan::SEC_REQ_REQUIRED)
-				   || (sec_man->sec_lookup_req(our_policy, ATTR_SEC_ENCRYPTION)
+				   || (m_sec_man->sec_lookup_req(our_policy, ATTR_SEC_ENCRYPTION)
 					   == SecMan::SEC_REQ_REQUIRED)
-				   || (sec_man->sec_lookup_req(our_policy, ATTR_SEC_INTEGRITY)
+				   || (m_sec_man->sec_lookup_req(our_policy, ATTR_SEC_INTEGRITY)
 					   == SecMan::SEC_REQ_REQUIRED) ) {
 
 					// yep, they were.  deny.
 
 					dprintf(D_ALWAYS,
 						"DaemonCore: PERMISSION DENIED for %d (%s) via %s%s%s from host %s (access level %s)\n",
-						req,
-						comTable[index].command_descrip,
-						(is_tcp) ? "TCP" : "UDP",
-						!user.IsEmpty() ? " from " : "",
-						user.Value(),
-						sock->peer_description(),
-						PermString(comTable[index].perm));
-
-					result = FALSE;
-					goto finalize;
+						m_req,
+						m_comTable[m_index].command_descrip,
+						(m_is_tcp) ? "TCP" : "UDP",
+						!m_user.IsEmpty() ? " from " : "",
+						m_user.Value(),
+						m_sock->peer_description(),
+						PermString(m_comTable[m_index].perm));
+
+					m_result = FALSE;
+					return CommandProtocolFinished;
 				}
 			}
 		}
 	}
 
 
-	if ( reqFound == TRUE ) {
+	if ( m_reqFound == TRUE ) {
 
 		// Check the daemon core permission for this command handler
 
 		// When re-using security sessions, need to set the socket's
 		// authenticated user name from the value stored in the cached
 		// session.
-		if( user.Length() && !sock->isAuthenticated() ) {
-			sock->setFullyQualifiedUser(user.Value());
+		if( m_user.Length() && !m_sock->isAuthenticated() ) {
+			m_sock->setFullyQualifiedUser(m_user.Value());
 		}
 
 		// grab the user from the socket
-        if (is_tcp) {
-            const char *u = sock->getFullyQualifiedUser();
+        if (m_is_tcp) {
+            const char *u = m_sock->getFullyQualifiedUser();
 			if (u) {
-				user = u;
+				m_user = u;
 			}
 		}
 
 		MyString command_desc;
-		command_desc.sprintf("command %d (%s)",req,comTable[index].command_descrip);
+		command_desc.sprintf("command %d (%s)",m_req,m_comTable[m_index].command_descrip);
 
-		if( comTable[index].force_authentication &&
-			!sock->isMappedFQU() )
+		if( m_comTable[m_index].force_authentication &&
+			!m_sock->isMappedFQU() )
 		{
 			dprintf(D_ALWAYS, "DC_AUTHENTICATE: authentication of %s did not result in a valid mapped user name, which is required for this command (%d %s), so aborting.\n",
-					sock->peer_description(),
-					req,
-					comTable[index].command_descrip );
+					m_sock->peer_description(),
+					m_req,
+					m_comTable[m_index].command_descrip );
 
-			perm = USER_AUTH_FAILURE;
+			m_perm = USER_AUTH_FAILURE;
 		}
 		else {
-			perm = Verify(
+			m_perm = daemonCore->Verify(
 						  command_desc.Value(),
-						  comTable[index].perm,
-						  sock->peer_addr(),
-						  user.Value() );
+						  m_comTable[m_index].perm,
+						  m_sock->peer_addr(),
+						  m_user.Value() );
 		}
 
-		if( perm != USER_AUTH_SUCCESS )
+		if( m_perm != USER_AUTH_SUCCESS )
 		{
 			// Permission check FAILED
-			reqFound = FALSE;	// so we do not call the handler function below
+			m_reqFound = FALSE;	// so we do not call the handler function below
 			// make result != to KEEP_STREAM, so we blow away this socket below
-			result = 0;
+			m_result = 0;
 
 			// if UDP, consume the rest of this message to try to stay "in-sync"
-			if ( !is_tcp)
-				sock->end_of_message();
+			if ( !m_is_tcp)
+				m_sock->end_of_message();
 
 		} else {
-			dprintf(comTable[index].dprintf_flag | D_COMMAND,
+			dprintf(m_comTable[m_index].dprintf_flag | D_COMMAND,
 					"Received %s command %d (%s) from %s %s, access level %s\n",
-					(is_tcp) ? "TCP" : "UDP",
-					req,
-					comTable[index].command_descrip,
-					user.Value(),
-					sock->peer_description(),
-					PermString(comTable[index].perm));
+					(m_is_tcp) ? "TCP" : "UDP",
+					m_req,
+					m_comTable[m_index].command_descrip,
+					m_user.Value(),
+					m_sock->peer_description(),
+					PermString(m_comTable[m_index].perm));
 		}
 
 	} else {
 			dprintf(D_ALWAYS,
 					"Received %s command %d (%s) from %s %s\n",
-					(is_tcp) ? "TCP" : "UDP",
-					req,
+					(m_is_tcp) ? "TCP" : "UDP",
+					m_req,
 					"UNREGISTERED COMMAND!",
-					user.Value(),
-					sock->peer_description());
+					m_user.Value(),
+					m_sock->peer_description());
 		// make result != to KEEP_STREAM, so we blow away this socket below
-		result = 0;
+		m_result = 0;
 		// if UDP, consume the rest of this message to try to stay "in-sync"
-		if ( !is_tcp)
-			sock->end_of_message();
+		if ( !m_is_tcp)
+			m_sock->end_of_message();
 	}
 /*
     // Send authorization message
-    if (is_tcp) {
-        sock->encode();
-        if (!sock->code(perm) || !sock->end_of_message()) {
+    if (m_is_tcp) {
+        m_sock->encode();
+        if (!m_sock->code(m_perm) || !m_sock->end_of_message()) {
             dprintf(D_ALWAYS, "DaemonCore: Unable to send permission results\n");
         }
     }
 */
-	if ( reqFound == TRUE ) {
+	if ( m_reqFound == TRUE ) {
 		// Handlers should start out w/ parallel mode disabled by default
 		ScopedEnableParallel(false);
 
 		UtcTime handler_start_time;
 		handler_start_time.getTime();
-		float sec_time = handler_start_time.difference(&handle_req_start_time);
+		float sec_time = handler_start_time.difference(&m_handle_req_start_time);
+		sec_time -= m_async_waiting_time;
 
-		result = CallCommandHandler(req,sock,false /*do not delete sock*/,true /*do check for payload*/,sec_time,0);
+		if( m_sock_had_no_deadline ) {
+				// unset the deadline we assigned in WaitForSocketData
+			m_sock->set_deadline(0);
+		}
+
+		m_result = daemonCore->CallCommandHandler(m_req,m_sock,false /*do not delete m_sock*/,true /*do check for payload*/,sec_time,0);
 	}
 
-finalize:
+	return CommandProtocolFinished;
+}
+
 
-	// finalize; the handler is done with the command.  the handler will return
+int DaemonCommandProtocol::finalize()
+{
+	// the handler is done with the command.  the handler will return
 	// with KEEP_STREAM if we should not touch the sock; otherwise, cleanup
 	// the sock.  On tcp, we just delete it since the sock is the one we got
 	// from accept and our listen socket is still out there.  on udp,
 	// however, we cannot just delete it or we will not be "listening"
 	// anymore, so we just do an eom flush all buffers, etc.
 	// HACK: keep all UDP sockets as well for now.
-    if (the_policy) {
-        delete the_policy;
-    }
-    if (the_key) {
-        delete the_key;
-    }
-    if (the_sid) {
-        free(the_sid);
-    }
-    if (who) {
-        free(who);
-    }
-	if ( result != KEEP_STREAM ) {
-		if ( is_tcp ) {
-			sock->encode();	// we wanna "flush" below in the encode direction
-			sock->end_of_message();  // make certain data flushed to the wire
-			if ( insock != sock )	   // delete the sock only if we did an accept; if we
-				delete sock;		   //     did not do an accept, Driver() will delete the sock.
+	if ( m_result != KEEP_STREAM ) {
+		if ( m_is_tcp ) {
+			m_sock->encode();	// we wanna "flush" below in the encode direction
+			m_sock->end_of_message();  // make certain data flushed to the wire
+			if ( m_insock != m_sock ) {	   // delete the sock only if we did an accept; if we
+				delete m_sock;		   //     did not do an accept, Driver() will delete the sock.
+				m_sock = NULL;
+			}
 		} else {
-			sock->decode();
-			sock->end_of_message();
+			m_sock->decode();
+			m_sock->end_of_message();
 
 			// we need to reset the crypto keys
-			sock->set_MD_mode(MD_OFF);
-			sock->set_crypto_key(false, NULL);
+			m_sock->set_MD_mode(MD_OFF);
+			m_sock->set_crypto_key(false, NULL);
 
 			// we also need to reset the FQU
-			sock->setFullyQualifiedUser(NULL);
+			m_sock->setFullyQualifiedUser(NULL);
 
-			result = KEEP_STREAM;	// HACK: keep all UDP sockets for now.  The only ones
+			m_result = KEEP_STREAM;	// HACK: keep all UDP sockets for now.  The only ones
 									// in Condor so far are Initial command socks, so keep it.
 		}
 	} else {
-		if (!is_tcp) {
-			sock->decode();
-			sock->end_of_message();
-			sock->set_MD_mode(MD_OFF);
-			sock->set_crypto_key(false, NULL);
-			sock->setFullyQualifiedUser(NULL);
+		if (!m_is_tcp) {
+			m_sock->decode();
+			m_sock->end_of_message();
+			m_sock->set_MD_mode(MD_OFF);
+			m_sock->set_crypto_key(false, NULL);
+			m_sock->setFullyQualifiedUser(NULL);
 		}
 	}
 
-	// Now return KEEP_STREAM only if the user said to _OR_ if insock
+	// Now return KEEP_STREAM only if the user said to _OR_ if m_insock
 	// is a listen socket.  Why?  we always wanna keep a listen socket.
 	// Also, if we did an accept, we already deleted the sock socket above.
-	if ( result == KEEP_STREAM || insock != sock )
+	if ( m_result == KEEP_STREAM || m_insock != m_sock )
 		return KEEP_STREAM;
 	else
 		return TRUE;
diff --git a/src/condor_includes/reli_sock.h b/src/condor_includes/reli_sock.h
index 1a383b4..b48ce8d 100644
--- a/src/condor_includes/reli_sock.h
+++ b/src/condor_includes/reli_sock.h
@@ -120,6 +120,7 @@ public:
 	inline int listen(int p) { if (!bind(FALSE,p)) return FALSE; return listen(); }
     /// FALSE means this is an incoming connection
 	inline int listen(char *s) { if (!bind(FALSE,s)) return FALSE; return listen(); }
+	bool isListenSock() { return _state == sock_special && _special_state == relisock_listen; }
 
     ///
 	ReliSock *accept();
diff --git a/src/condor_includes/sock.h b/src/condor_includes/sock.h
index f13b441..5a51c36 100644
--- a/src/condor_includes/sock.h
+++ b/src/condor_includes/sock.h
@@ -345,11 +345,18 @@ public:
 		/// authenticated
 	bool isAuthenticated() const;
 
+    ///
+	virtual int authenticate(const char * auth_methods, CondorError* errstack, int timeout);
+    ///
+	// method_used should be freed by the caller when finished with it
+	virtual int authenticate(KeyInfo *&ki, const char * auth_methods, CondorError* errstack, int timeout, char **method_used=NULL);
 
 	/// if we are connecting, merges together Stream::get_deadline
 	/// and connect_timeout_time()
 	virtual time_t get_deadline();
 
+	void invalidateSock();
+
 
 //	PRIVATE INTERFACE TO ALL SOCKS
 //
@@ -424,11 +431,6 @@ protected:
 	///
 	virtual bool is_hdr_encrypt();
     ///
-	virtual int authenticate(const char * auth_methods, CondorError* errstack, int timeout);
-    ///
-	// method_used should be freed by the caller when finished with it
-	virtual int authenticate(KeyInfo *&ki, const char * auth_methods, CondorError* errstack, int timeout, char **method_used=NULL);
-    ///
 	virtual bool is_encrypt();
 #ifdef WIN32
 	int set_inheritable( int flag );
@@ -445,7 +447,6 @@ protected:
 	///
 	int move_descriptor_up();
 
-
     /// called whenever the bound or connected state changes
     void addr_changed();
 
diff --git a/src/condor_io/sock.cpp b/src/condor_io/sock.cpp
index 544c56f..067d362 100644
--- a/src/condor_io/sock.cpp
+++ b/src/condor_io/sock.cpp
@@ -2460,3 +2460,9 @@ Sock::canEncrypt()
 {
 	return crypto_ != NULL;
 }
+
+void
+Sock::invalidateSock()
+{
+	_sock = INVALID_SOCKET; 
+}
