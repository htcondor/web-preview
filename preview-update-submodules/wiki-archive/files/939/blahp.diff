Only in blahp-osg/: blah_description.txt
diff -ur blahp-condor/bootstrap blahp-osg/bootstrap
--- blahp-condor/bootstrap	2010-12-12 08:15:54.000000000 -0600
+++ blahp-osg/bootstrap	2016-04-26 11:19:29.367403369 -0500
@@ -20,7 +20,13 @@
 
 mkdir -p src/autogen
 set -x
-aclocal -I project
+
+if [ -d ../org.glite/project ]; then
+  aclocal -I project -I ../org.glite/project
+else
+  aclocal -I project -I /usr/share/glite-build-common-cpp/m4
+fi
+
 libtoolize --force
 autoheader
 automake --foreign --add-missing --copy
Only in blahp-osg/: build.xml
Only in blahp-osg/: CMakeLists.txt
Only in blahp-condor/config: batch_gahp.config.template
Only in blahp-osg/config: blah.config.template
Only in blahp-osg/config: CMakeLists.txt
diff -ur blahp-condor/config/glite-ce-blahparser blahp-osg/config/glite-ce-blahparser
--- blahp-condor/config/glite-ce-blahparser	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/config/glite-ce-blahparser	2016-04-26 11:19:29.376396411 -0500
@@ -34,15 +34,15 @@
 fi
 
 if [ ! -r "$BLAHPD_CONFIG_LOCATION" ]; then
-  if [ -r "/etc/batch_gahp.config" ]; then
-    export BLAHPD_CONFIG_LOCATION="/etc/batch_gahp.config"
-  elif [ -r "${BLAHPD_LOCATION:-/opt/glite}/etc/batch_gahp.config" ]; then
-    export BLAHPD_CONFIG_LOCATION="${BLAHPD_LOCATION:-/opt/glite}/etc/batch_gahp.config"
+  if [ -r "/etc/blah.config" ]; then
+    export BLAHPD_CONFIG_LOCATION="/etc/blah.config"
+  elif [ -r "${BLAHPD_LOCATION:-/opt/glite}/etc/blah.config" ]; then
+    export BLAHPD_CONFIG_LOCATION="${BLAHPD_LOCATION:-/opt/glite}/etc/blah.config"
   fi
 fi
 
 if [ ! -r "$BLAHPD_CONFIG_LOCATION" ]; then
-  echo "$0: Cannot read BLAH config file (\$BLAHPD_CONFIG_LOCATION, or /etc/batch_gahp.config, or /opt/glite/etc/batch_gahp.config)"
+  echo "$0: Cannot read BLAH config file (\$BLAHPD_CONFIG_LOCATION, or /etc/blah.config, or /opt/glite/etc/blah.config)"
   exit 1
 fi
 
Only in blahp-osg/config: glite-ce-blah-parser
diff -ur blahp-condor/config/glite-ce-blparser blahp-osg/config/glite-ce-blparser
--- blahp-condor/config/glite-ce-blparser	2011-03-11 09:36:15.000000000 -0600
+++ blahp-osg/config/glite-ce-blparser	2016-04-26 11:19:29.377397502 -0500
@@ -24,14 +24,22 @@
 # Source function library
 . /etc/rc.d/init.d/functions
 
-if [ "x${BLAHPD_LOCATION}" != "x" -a -d "${BLAHPD_LOCATION}/bin" ]; then
-  blparser_bin_directory="${BLAHPD_LOCATION}/bin"
+if [ -e "/usr/libexec/grid-env.sh" ]; then
+ . /usr/libexec/grid-env.sh
+fi
+
+if [ -e "${LSF_BASE_DIR}/conf/profile.lsf" ]; then
+ . ${LSF_BASE_DIR}/conf/profile.lsf
+fi
+
+if [ "x${BLAHPD_LOCATION}" != "x" -a -d "${BLAHPD_LOCATION}/libexec" ]; then
+  blparser_bin_directory="${BLAHPD_LOCATION}/libexec"
 else
   if [ "x${GLITE_LOCATION}" != "x" -a -d "${GLITE_LOCATION}/bin" ]; then
     blparser_bin_directory="${GLITE_LOCATION}/bin"
   else
 #   Default value when everything else fails.
-    blparser_bin_directory="/usr/bin"
+    blparser_bin_directory="/usr/libexec"
   fi
 fi
 
diff -ur blahp-condor/config/glite-ce-check-blparser blahp-osg/config/glite-ce-check-blparser
--- blahp-condor/config/glite-ce-check-blparser	2011-03-11 04:54:07.000000000 -0600
+++ blahp-osg/config/glite-ce-check-blparser	2016-04-26 11:19:29.378396580 -0500
@@ -24,14 +24,14 @@
 # Source function library
 . /etc/rc.d/init.d/functions
 
-if [ "x${BLAHPD_LOCATION}" != "x" -a -d "${BLAHPD_LOCATION}/bin" ]; then
-  blparser_bin_directory="${BLAHPD_LOCATION}/bin"
+if [ "x${BLAHPD_LOCATION}" != "x" -a -d "${BLAHPD_LOCATION}/libexec" ]; then
+  blparser_bin_directory="${BLAHPD_LOCATION}/libexec"
 else
   if [ "x${GLITE_LOCATION}" != "x" -a -d "${GLITE_LOCATION}/bin" ]; then
     blparser_bin_directory="${GLITE_LOCATION}/bin"
   else
 #   Default when everything else fails.
-    blparser_bin_directory="/usr/bin"
+    blparser_bin_directory="/usr/libexec/blahp"
   fi
 fi
 
Only in blahp-condor/config: Makefile
diff -ur blahp-condor/config/Makefile.am blahp-osg/config/Makefile.am
--- blahp-condor/config/Makefile.am	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/config/Makefile.am	2016-04-26 11:19:29.372396655 -0500
@@ -2,7 +2,7 @@
 # * BLAHP daemon * 
 # ****************
 #
-# $Id: Makefile.am,v 1.12.4.1 2011/02/07 15:49:47 pandreet Exp $ 
+# $Id: Makefile.am,v 1.16 2012/02/06 13:06:42 pandreet Exp $ 
 #
 # File:           Makefile.am
 #
@@ -15,20 +15,20 @@
 #
 
 wletcwmdir = $(sysconfdir)
-wletcwm_DATA = batch_gahp.config.template blparser.conf.template
+wletcwm_DATA = blah.config.template blparser.conf.template
 
-install-data-hook:
-	/bin/cp $(DESTDIR)$(sysconfdir)/batch_gahp.config.template $(DESTDIR)$(sysconfdir)/batch_gahp.config
+#install-data-hook:
+#        /bin/cp $(DESTDIR)$(sysconfdir)/blah.config.template $(DESTDIR)$(sysconfdir)/blah.config
 
 
-EXTRA_DIST = batch_gahp.config.template \
+EXTRA_DIST = blah.config.template \
              blparser.conf.template \
-             glite-ce-blparser \
-             glite-ce-blahparser \
+             glite-ce-blah-parser \
              glite-ce-check-blparser 
 
+initdir = rc.d/init.d
 bldir = $(sysconfdir)/$(initdir)
-bl_SCRIPTS = glite-ce-blparser glite-ce-blahparser glite-ce-check-blparser
+bl_SCRIPTS = glite-ce-blah-parser glite-ce-check-blparser
 
 CLEANFILES =
 
Only in blahp-condor/config: Makefile.in
diff -ur blahp-condor/configure.ac blahp-osg/configure.ac
--- blahp-condor/configure.ac	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/configure.ac	2016-04-26 11:19:29.379396610 -0500
@@ -12,15 +12,162 @@
 #       Council for the Central Laboratory of the Research Councils (CCLRC), United Kingdom
 #
 #       Authors: Francesco Prelz <francesco.prelz@mi.infn.it>
-#       Version info: $Id: configure.ac,v 1.46.2.13 2012/03/09 08:32:06 pandreet Exp $
-#       Release: $Name: glite-ce-blahp_R_1_16_5_1 $
+#       Version info: $Id: configure.ac,v 1.54 2012/03/01 13:26:54 pandreet Exp $
+#       Release: $Name:  $
+#
+#       Revision history:
+#       $Log: configure.ac,v $
+#       Revision 1.54  2012/03/01 13:26:54  pandreet
+#       Changed version number
+#
+#       Revision 1.53  2012/02/15 13:55:15  pandreet
+#       Disabled build for BPR; replaced macro for globus
+#
+#       Revision 1.52  2011/12/09 10:42:38  pandreet
+#       version definition from autoconf
+#
+#       Revision 1.51  2011/12/07 10:59:57  pandreet
+#       Fixes for sl6
+#
+#       Revision 1.50  2011/11/29 14:11:38  pandreet
+#       Templates for man pages
+#
+#       Revision 1.49  2011/09/22 08:12:13  pandreet
+#       Changes for the new packager
+#
+#       Revision 1.48  2010/10/08 14:55:48  fprelz
+#       Added an option to access the job registry index in a shared fashion
+#       by multiple blahpd processes via mmap.
+#
+#       Revision 1.47  2010/05/26 09:30:44  fprelz
+#       Bumped version up to 1.17.0
+#
+#       Revision 1.46  2009/07/21 15:08:56  fprelz
+#       Bumped version up to 1.15.0.
+#
+#       Revision 1.45  2009/05/19 09:04:56  drebatto
+#       Added BLAH_SET_SUDO_ID and BLAH_SET_SUDO_OFF commands.
+#       Bumped version to 1.13.4.
+#
+#       Revision 1.44  2009/04/24 23:38:09  fprelz
+#       Bumped version up to 1.13.3.
+#
+#       Revision 1.43  2009/03/12 11:58:23  fprelz
+#       Increased version number.
+#
+#       Revision 1.42  2009/03/12 11:56:18  fprelz
+#       Increased version number.
+#
+#       Revision 1.41  2008/12/11 09:21:00  fprelz
+#       Bumped version up to 1.13.0.
+#
+#       Revision 1.40  2008/07/03 14:42:05  fprelz
+#       Increased version to 1.11.2.
+#
+#       Revision 1.39  2008/06/30 15:56:58  fprelz
+#       Increased version again.
+#
+#       Revision 1.38  2008/06/30 15:54:16  fprelz
+#       Rolled back version temporarily. Added automake conditional for Globus.
+#
+#       Revision 1.36  2008/02/05 14:31:57  fprelz
+#       Bump up version for ANT builds.
+#
+#       Revision 1.35  2008/02/05 13:50:11  fprelz
+#       Bump version up for ANT builds.
+#
+#       Revision 1.34  2007/10/25 13:02:37  fprelz
+#       Increased version to 1.9.0.
+#
+#       Revision 1.33  2006/11/30 17:53:03  drebatto
+#       Fixed wrong version number
+#
+#       Revision 1.32  2006/11/30 17:36:11  drebatto
+#       Bug #20357 addressed. Other race conditions and memory corruption found and solved.
+#
+#       Revision 1.31  2006/06/20 12:46:13  mezzadri
+#       increased version
+#
+#       Revision 1.30  2006/03/31 07:30:32  pandreet
+#       Incremented version number
+#
+#       Revision 1.29  2006/02/20 09:06:54  pandreet
+#       Incremented version number
+#
+#       Revision 1.28  2006/02/16 10:49:47  mezzadri
+#       changed version number
+#
+#       Revision 1.27  2005/12/01 16:19:17  gfiorent
+#       Fixed bug #14007, filtered "env" attribute in submission classad
+#
+#       Revision 1.26  2005/11/28 10:05:25  mezzadri
+#       added config file for blah
+#
+#       Revision 1.25  2005/10/05 10:11:36  pandreet
+#       Increased version number
+#
+#       Revision 1.24  2005/08/05 15:15:48  pandreet
+#       Changed version to 1.5
+#
+#       Revision 1.23  2005/07/27 10:23:33  pandreet
+#       Modified version number
+#
+#       Revision 1.22  2005/07/27 09:35:47  pandreet
+#       Modified version number
+#
+#       Revision 1.21  2005/06/08 14:12:30  mezzadri
+#       changed version from 1.2.2 to 1.2.4
+#
+#       Revision 1.20  2005/03/23 11:12:19  drebatto
+#       Some more files to align...
+#
+#       Revision 1.14.2.4  2005/03/11 19:42:26  fprelz
+#       Added support for the BLAH_JOB_REFRESH_PROXY command in blahpd.
+#       Revised the batch system submit and status scripts.
+#
+#       Revision 1.14.2.3  2005/02/25 14:25:37  mezzadri
+#       changed minor version number
+#
+#       Revision 1.14.2.2  2005/02/03 16:19:04  drebatto
+#       Version number incremented
+#
+#       Revision 1.14.2.1  2005/02/01 13:54:26  drebatto
+#       Aligned to MAIN
+#
+#       Revision 1.14  2004/12/09 13:59:13  mezzadri
+#       changed version number
+#
+#       Revision 1.13  2004/11/25 14:53:34  mezzadri
+#       changed version number
+#
+#       Revision 1.12  2004/11/16 15:45:12  eronchie
+#       Increased version
+#
+#       Revision 1.11  2004/10/05 16:05:45  drebatto
+#       Support for "gridtype" added.
+#       Patched a bug preventing classad with both "Args" and "Queue" to be parsed correctly.
+#
+#       Revision 1.10  2004/09/22 11:44:20  pandreet
+#       Runtime scripts in tarball and rpms
+#
+#       Revision 1.9  2004/09/22 09:16:56  glbuild
+#       Removed AM_CONFIG_HEADER
+#
+#       Revision 1.8  2004/09/22 01:54:20  dimeglio
+#       Added AM_CONFIG_HEADER
+#
+#       Revision 1.7  2004/09/22 00:15:23  dimeglio
+#       Fixed missing parenthesis in AC_INIT
+#       Added default prefix
+#
 #
 
 AC_PREREQ(2.57)
-AC_INIT([GLite CE blahp], [1.16.5])
+AC_INIT([GLite CE blahp], [1.19.0])
 AC_CONFIG_AUX_DIR([./project])
 AM_INIT_AUTOMAKE([1.6.3 subdir-objects])
 AC_CONFIG_SRCDIR([src/main.c])
+AC_CONFIG_HEADERS([src/autogen/acconfig.h])
                                                                                 
 #Environment.
 WORKDIR=`pwd`
@@ -48,34 +195,67 @@
 AC_HEADER_TIME
 
 dnl Checks for library functions.
-AC_CHECK_FUNCS(select socket strdup strerror bsearch vsnprintf)
-AC_CHECK_FUNC(dlopen, ,AC_CHECK_LIB(dl, dlopen))
+AC_CHECK_FUNCS(select socket strdup strerror bsearch vsnprintf mmap munmap)
+AC_CHECK_FUNCS(dlopen, ,AC_CHECK_LIB(dl, dlopen))
+
+dnl GLITE_CHECK_LIBDIR
+dnl GLITE_CHECK_INITDIR
+dnl AC_GLITE_DOCBOOK
 
-GLITE_CHECK_LIBDIR
-GLITE_CHECK_INITDIR
+GLITE_DB_MANPAGES_STYLESHEET="/usr/share/sgml/docbook/xsl-stylesheets/manpages/docbook.xsl"
+
+AC_ARG_WITH(manpage_stylesheet,
+   [  --with-manpage-stylesheet=PATH     (path to the docbook stylesheet for man pages ($GLITE_DB_MANPAGES_STYLESHEET)],
+   [],
+   with_manpage_stylesheet=$GLITE_DB_MANPAGES_STYLESHEET)
+
+if ! test -r "$with_manpage_stylesheet" ; then
+  AC_MSG_ERROR("$with_manpage_stylesheet not found. Try setting --with-manpage-stylesheet.")
+fi
+
+GLITE_DB_MANPAGES_STYLESHEET=$with_manpage_stylesheet
+AC_SUBST(GLITE_DB_MANPAGES_STYLESHEET)
 
 AC_ARG_WITH(dist_location,
    [  --with-dist-location=PFX     prefix where DIST location is. (pwd)],
    [],
    with_dist_location=$WORKDIR/../dist)
 
+AC_ARG_ENABLE(bprserver,
+   [  --enable-bprserver Enable BPR server],
+   [ if test "$enableval" = "yes" ; then
+         bprserver=$enableval
+     else
+         bprserver="no"
+     fi],
+   bprserver="no")
+
 DISTTAR=$with_dist_location
 
 AC_SUBST(DISTTAR)
 
 AC_CLASSADS([], AC_MSG_RESULT(["CLASSADS ok"]), AC_MSG_ERROR(["CLASSADS not found"]))
 
-have_globus=no
 AC_GLOBUS([], have_globus=yes, have_globus=no)
-AC_MSG_RESULT(["GLOBUS found $have_globus"])
-AM_CONDITIONAL([HAVE_GLOBUS], [test x$have_globus = xyes])
+
+if test $have_globus = no; then
+  have_globus=yes
+  PKG_CHECK_MODULES(GLOBUS_GSI_CRED, globus-gsi-credential, , have_globus=no)
+  PKG_CHECK_MODULES(GLOBUS_GSI_PROXY, globus-gsi-proxy-core, , have_globus=no)
+  PKG_CHECK_MODULES(GLOBUS_GSI_UTILS, globus-gsi-cert-utils, , have_globus=no)
+  PKG_CHECK_MODULES(GLOBUS_GSS_ASSIST, globus-gss-assist, , have_globus=no)
+  PKG_CHECK_MODULES(GLOBUS_GSI_SYSCFG, globus-gsi-sysconfig, , have_globus=no)
+  PKG_CHECK_MODULES(GLOBUS_GSSAPI_GSI, globus-gssapi-gsi, , have_globus=no)
+fi
+AC_MSG_RESULT(["GLOBUS found: $have_globus"])
+AM_CONDITIONAL([HAVE_GLOBUS], [test "x$bprserver" == "xyes" -a "x$have_globus" == "xyes"])
 
 dnl Temporarily built with no optimisation
 
 CXXFLAGS="-g -O0"
 CFLAGS="-g -O0"
 
-AC_DEFINE(BLAHPD_BINDIR,"@bindir@")
+AC_DEFINE_UNQUOTED([VERSION], ["${PVER}"], [Package version from ETICS])
 
 # Configuration items
 AC_PREFIX_DEFAULT([/opt/glite])
@@ -83,5 +263,6 @@
 AC_CONFIG_FILES([config/Makefile])
 AC_CONFIG_FILES([src/Makefile])
 AC_CONFIG_FILES([src/scripts/Makefile])
+AC_CONFIG_FILES([doc/Makefile])
 
 AC_OUTPUT
Only in blahp-osg/doc: blah_check_config.xml
Only in blahp-osg/doc: blah_job_registry_add.xml
Only in blahp-osg/doc: blah_job_registry_dump.xml
Only in blahp-osg/doc: blah_job_registry_lkup.xml
Only in blahp-osg/doc: blah_job_registry_scan_by_subject.xml
Only in blahp-osg/doc: blahpd.xml
Only in blahp-osg/doc: CMakeLists.txt
Only in blahp-osg/doc: Makefile.am
Only in blahp-osg/: .git
Only in blahp-osg/: .gitignore
diff -ur blahp-condor/Makefile.am blahp-osg/Makefile.am
--- blahp-condor/Makefile.am	2011-06-22 05:01:15.000000000 -0500
+++ blahp-osg/Makefile.am	2016-04-26 11:19:29.366398162 -0500
@@ -22,10 +22,10 @@
 doc_DATA = LICENSE
 
 ## Subdirectories list
-SUBDIRS = src config
+SUBDIRS = src config doc
 
 ## Default flags to run aclocal
-ACLOCAL_AMFLAGS = -I project -I ../org.glite/project
+ACLOCAL_AMFLAGS = -I project 
 
 stage:
 	@set fnord $(MAKEFLAGS); amf=$$2; \
Only in blahp-osg/project: build.number
Only in blahp-osg/project: build.properties
diff -ur blahp-condor/project/classads.m4 blahp-osg/project/classads.m4
--- blahp-condor/project/classads.m4	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/project/classads.m4	2016-04-26 11:19:29.391398897 -0500
@@ -6,26 +6,30 @@
 dnl - CLASSAD_INSTALL_PATH
 dnl - CLASSAD_PATH
 
-AC_DEFUN(AC_CLASSADS,
+AC_DEFUN([AC_CLASSADS],
 [
     AC_ARG_WITH(classads_prefix, 
-	[  --with-classads-prefix=PFX    prefix where the Classad is installed.],
+	[  --with-classads-prefix=PFX   prefix where the Classad libraries are installed (/usr)],
 	[], 
-	with_classads_prefix="/opt/classads")
+	with_classads_prefix="/usr")
 
     AC_MSG_CHECKING([for CLASSAD installation])
 
     CLASSAD_CFLAGS=""
-    CLASSAD_LIBS="-lclassad -lpcre -Wl,--enable-new-dtags"
-    CLASSAD_DL_LIBS="-lclassad_dl"
-    if test -n "$with_classads_prefix" -a "$with_classads_prefix" != "/usr" ; then
-            AC_MSG_RESULT([prefix: $with_classads_prefix])
-
-            ac_classads_prefix=$with_classads_prefix
-
-            CLASSAD_CFLAGS="-I$with_classads_prefix/include"
-            CLASSAD_LIBS="-L$with_classads_prefix/lib $CLASSAD_LIBS"
-	    CLASSAD_DL_LIBS="-L$with_classads_prefix/lib $CLASSAD_DL_LIBS"
+    if test -n "$with_classads_prefix" ; then
+        AC_MSG_RESULT([prefix: $with_classads_prefix])
+
+        ac_classads_prefix=$with_classads_prefix
+        if test "$with_classads_prefix" != "/usr"; then
+
+            CLASSAD_CFLAGS="-I$with_classads_prefix/include -I$with_classads_prefix/include/classad"
+            CLASSAD_LIBS="-L$with_classads_prefix/lib -lclassad"
+	    CLASSAD_DL_LIBS="-L$with_classads_prefix/lib -lclassad_dl"
+        else
+            CLASSAD_CFLAGS="-I$with_classads_prefix/include/classad"
+            CLASSAD_LIBS="-lclassad"
+	    CLASSAD_DL_LIBS="-lclassad_dl"
+        fi
     fi
 
     AC_LANG_SAVE
@@ -33,15 +37,18 @@
     ac_save_cppflags=$CPPFLAGS
     ac_save_libs=$LIBS
     CPPFLAGS="$CLASSAD_CFLAGS $CPPFLAGS"
+    BASE_LIBS="$LIBS"
     LIBS="$CLASSAD_LIBS $LIBS"
     AC_MSG_CHECKING([if a small classads program compiles])
-    AC_TRY_LINK([ #include <classad/classad_distribution.h> ],
+    AC_TRY_LINK([ #include <classad_distribution.h> ],
 		[ classad::ClassAd ad; classad::ClassAdParser parser; ],
 		[ ac_have_classads=yes ], [ ac_have_classads=no ])
     if test x$ac_have_classads = xno ; then
-        CLASSAD_CFLAGS="$CLASSAD_CFLAGS -DWANT_CLASSAD_NAMESPACE"
+        CLASSAD_CFLAGS="$CLASSAD_CFLAGS -DWANT_CLASSAD_NAMESPACE -DWANT_NAMESPACES"
+        CLASSAD_LIBS="-L$with_classads_prefix/lib -lclassad_ns"
+        LIBS="$CLASSAD_LIBS $BASE_LIBS"
         CPPFLAGS="$CLASSAD_CFLAGS $ac_save_cppflags"
-        AC_TRY_LINK([ #include <classad/classad_distribution.h> ],
+        AC_TRY_LINK([ #include <classad_distribution.h> ],
                     [ classad::ClassAd ad; classad::ClassAdParser parser; ],
                     [ ac_have_classads=yes ], [ ac_have_classads=no ])	
     fi
Only in blahp-condor/project: compile
Only in blahp-condor/project: config.guess
Only in blahp-condor/project: config.sub
Only in blahp-osg/project: configure.properties.xml
diff -ur blahp-condor/project/debfiles/control blahp-osg/project/debfiles/control
--- blahp-condor/project/debfiles/control	2011-08-31 09:46:00.000000000 -0500
+++ blahp-osg/project/debfiles/control	2016-04-26 11:19:29.393396620 -0500
@@ -2,7 +2,7 @@
 Section:  net
 Priority:  optional
 Maintainer:  CREAM group <cream-support@lists.infn.it>
-Build-Depends: debhelper (>= 8.0.0~)
+Build-Depends: debhelper (>= 8.0.0~), libtool, libclassad-dev, docbook-xsl, xsltproc
 Standards-Version:  3.9.1
 Homepage: http://glite.cern.ch/
 
diff -ur blahp-condor/project/debfiles/glite-ce-blahp.install blahp-osg/project/debfiles/glite-ce-blahp.install
--- blahp-condor/project/debfiles/glite-ce-blahp.install	2011-08-31 09:46:00.000000000 -0500
+++ blahp-osg/project/debfiles/glite-ce-blahp.install	2016-04-26 11:19:29.395406497 -0500
@@ -1,2 +1,4 @@
 usr/bin/*
+usr/sbin/*
 etc/*.template
+usr/share/man/man1/*.1.gz
Only in blahp-osg/project/debfiles: glite-ce-blahp.postinst
Only in blahp-osg/project/debfiles: glite-ce-blahp.prerm
diff -ur blahp-condor/project/debfiles/rules blahp-osg/project/debfiles/rules
--- blahp-condor/project/debfiles/rules	2011-08-31 09:46:00.000000000 -0500
+++ blahp-osg/project/debfiles/rules	2016-04-26 11:19:29.397397075 -0500
@@ -31,7 +31,7 @@
 else
 	make install
 endif
-	mv $(INSTALLDIR)/etc/init.d/glite-ce-blahparser $(CURDIR)/debian/glite-ce-blahp.init
+	mv $(INSTALLDIR)/etc/init.d/glite-ce-blah-parser $(CURDIR)/debian/glite-ce-blahp.init
 
 binary-indep: build install
 
Only in blahp-condor/project: depcomp
diff -ur blahp-condor/project/glite-ce-blahp.post blahp-osg/project/glite-ce-blahp.post
--- blahp-condor/project/glite-ce-blahp.post	2011-03-11 06:49:13.000000000 -0600
+++ blahp-osg/project/glite-ce-blahp.post	2016-04-26 11:19:29.398396899 -0500
@@ -21,5 +21,13 @@
   blah_install_prefix="/usr"
 fi
 
-/bin/mv ${blah_install_prefix}/bin/condor_status.sh ${blah_install_prefix}/bin/condor_status.sh.save
-/bin/cp ${blah_install_prefix}/bin/blah_job_registry_lkup ${blah_install_prefix}/bin/condor_status.sh
+if [ -e ${blah_install_prefix}/libexec/condor_status.sh ]; then
+  /bin/mv ${blah_install_prefix}/libexec/condor_status.sh ${blah_install_prefix}/libexec/condor_status.sh.save
+elif [ -e ${blah_install_prefix}/bin/condor_status.sh ]; then
+  /bin/mv ${blah_install_prefix}/bin/condor_status.sh ${blah_install_prefix}/bin/condor_status.sh.save
+fi
+if [ -e ${blah_install_prefix}/libexec/blah_job_registry_lkup ]; then
+  /bin/cp ${blah_install_prefix}/libexec/blah_job_registry_lkup ${blah_install_prefix}/libexec/condor_status.sh
+elif [ -e ${blah_install_prefix}/bin/blah_job_registry_lkup ]; then
+  /bin/cp ${blah_install_prefix}/bin/blah_job_registry_lkup ${blah_install_prefix}/bin/condor_status.sh
+fi
Only in blahp-condor/project: glite-ce-blahp_sl5_x86_64.spec
Only in blahp-osg/project: glite-ce-blahp_sl_any.spec
diff -ur blahp-condor/project/glite.m4 blahp-osg/project/glite.m4
--- blahp-condor/project/glite.m4	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/project/glite.m4	2016-04-26 11:19:29.401397510 -0500
@@ -4,7 +4,7 @@
 dnl - GLITE_CFLAGS
 dnl - DISTTAR
 
-AC_DEFUN(AC_GLITE,
+AC_DEFUN([AC_GLITE],
 [
     AC_ARG_WITH(glite_location,
         [  --with-glite-location=PFX     prefix where GLITE is installed. (/opt/glite)],
diff -ur blahp-condor/project/globus.m4 blahp-osg/project/globus.m4
--- blahp-condor/project/globus.m4	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/project/globus.m4	2016-04-26 11:19:29.402396976 -0500
@@ -1,117 +1,233 @@
-dnl Usage:
-dnl AC_GLOBUS(MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
-dnl - GLOBUS_LOCATION
-dnl - GLOBUS_NOTHR_FLAVOR
-dnl - GLOBUS_NOTHR_CFLAGS
-dnl - GLOBUS_NOTHR_LIBS
-dnl - GLOBUS_COMMON_NOTHR_LIBS
-dnl - GLOBUS_STATIC_COMMON_NOTHR_LIBS
-dnl - GLOBUS_FTP_CLIENT_NOTHR_LIBS
-dnl - GLOBUS_SSL_NOTHR_LIBS
-dnl - GLOBUS_STATIC_SSL_NOTHR_LIBS
-dnl - GLOBUS_GSS_NOTHR_LIBS
-
-AC_DEFUN(AC_GLOBUS,
-[
-    AC_ARG_WITH(openssl_prefix,
-	[  --with-openssl-prefix=PFX     prefix where OpenSSL is installed. (/)],
-	[],
-        with_openssl_prefix=/usr)
-
-    AC_ARG_WITH(globus_prefix,
-	[  --with-globus-prefix=PFX     prefix where GLOBUS is installed. (/opt/globus)],
-	[],
-        with_globus_prefix=${GLOBUS_LOCATION:-/opt/globus})
-
-    AC_ARG_WITH(globus_nothr_flavor,
-	[  --with-globus-nothr-flavor=flavor [default=gcc32dbg]],
-	[],
-        with_globus_nothr_flavor=${GLOBUS_FLAVOR:-gcc32dbg})
-
-    AC_MSG_RESULT(["GLOBUS nothread flavor is $with_globus_nothr_flavor"])
-
-    ac_cv_globus_nothr_valid=no
-
-    GLOBUS_NOTHR_CFLAGS="$with_openssl_prefix/include -I$with_globus_prefix/include/globus"
-
-    ac_globus_ldlib="-L$with_globus_prefix/lib"
-
-    GLOBUS_COMMON_NOTHR_LIBS="$ac_globus_ldlib -lglobus_common"
-
-    GLOBUS_STATIC_COMMON_NOTHR_LIBS="$with_globus_prefix/lib/libglobus_common_$with_globus_nothr_flavor.a"
-
-    GLOBUS_FTP_CLIENT_NOTHR_LIBS="$ac_globus_ldlib -lglobus_ftp_client"
-
-    GLOBUS_GSS_NOTHR_LIBS="$ac_globus_ldlib -lglobus_gss_assist -lglobus_gssapi_gsi -lglobus_gsi_callback -lglobus_oldgaa -lglobus_gsi_proxy_core -lglobus_gsi_credential -lglobus_gsi_cert_utils -lglobus_gsi_sysconfig -lglobus_openssl -lglobus_proxy_ssl -lglobus_openssl_error -lglobus_callout -lglobus_common -lltdl -lssl"
-
-    GLOBUS_SSL_NOTHR_LIBS="-lssl -lcrypto"
-
-    GLOBUS_STATIC_SSL_NOTHR_LIBS="$with_openssl_prefix/lib/libssl.a $with_openssl_prefix/lib/libcrypto.a"
-
-    dnl Needed by LCAS/LCMAPS voms plugins
-    GLOBUS_GSI_NOTHR_LIBS="$ac_globus_ldlib -lglobus_gsi_credential"
-
-    dnl
-    dnl check nothr openssl header
-    dnl
-    ac_globus_nothr_ssl="$with_openssl_prefix/include/openssl"
-
-    AC_MSG_CHECKING([for $ac_globus_nothr_ssl/ssl.h])
-
-    if test ! -f "$ac_globus_nothr_ssl/ssl.h" ; then
-	ac_globus_nothr_ssl=""
-	AC_MSG_RESULT([no])
-    else
-	AC_MSG_RESULT([yes])
-    fi
-
-    AC_MSG_CHECKING([for openssl nothr])
-
-    if test -n "$ac_globus_nothr_ssl" ; then
-	GLOBUS_NOTHR_CFLAGS="-I$ac_globus_nothr_ssl -I$GLOBUS_NOTHR_CFLAGS"
-    fi
-
-    if test -n "$ac_globus_nothr_ssl" ; then
-        dnl
-        dnl maybe do some complex test of globus instalation here later
-        dnl
-        ac_save_CFLAGS=$CFLAGS
-        CFLAGS="$GLOBUS_NOTHR_CFLAGS $CFLAGS"
-        AC_TRY_COMPILE([
-             #include "ssl.h"
-             #include "globus_gss_assist.h"
-           ],
-           [globus_gss_assist_ex aex],
-           [ac_cv_globus_nothr_valid=yes],
-           [ac_cv_globus_nothr_valid=no])
-        CFLAGS=$ac_save_CFLAGS
-        AC_MSG_RESULT([$ac_cv_globus_nothr_valid])
-    fi
-
-    if test x$ac_cv_globus_nothr_valid = xyes ; then
-	GLOBUS_LOCATION=$with_globus_prefix
-	GLOBUS_NOTHR_FLAVOR=$with_globus_nothr_flavor
-	ifelse([$2], , :, [$2])
-    else
-	GLOBUS_NOTHR_CFLAGS=""
-	GLOBUS_NOTHR_LIBS=""
-	GLOBUS_COMMON_NOTHR_LIBS=""
-	GLOBUS_STATIC_COMMON_NOTHR_LIBS=""
-        GLOBUS_FTP_CLIENT_NOTHR_LIBS=""
-	GLOBUS_SSL_NOTHR_LIBS=""
-	GLOBUS_STATIC_SSL_NOTHR_LIBS=""
-	ifelse([$3], , :, [$3])
-    fi
-
-    AC_SUBST(GLOBUS_LOCATION)
-    AC_SUBST(GLOBUS_NOTHR_FLAVOR)
-    AC_SUBST(GLOBUS_NOTHR_CFLAGS)
-    AC_SUBST(GLOBUS_NOTHR_LIBS)
-    AC_SUBST(GLOBUS_COMMON_NOTHR_LIBS)
-    AC_SUBST(GLOBUS_STATIC_COMMON_NOTHR_LIBS)
-    AC_SUBST(GLOBUS_FTP_CLIENT_NOTHR_LIBS)
-    AC_SUBST(GLOBUS_SSL_NOTHR_LIBS)
-    AC_SUBST(GLOBUS_STATIC_SSL_NOTHR_LIBS)
-    AC_SUBST(GLOBUS_GSS_NOTHR_LIBS)
-])
-
+dnl Usage:
+dnl AC_GLOBUS(MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
+dnl - GLOBUS_LOCATION
+dnl - GLOBUS_NOTHR_FLAVOR
+dnl - GLOBUS_THR_FLAVOR
+dnl - GLOBUS_NOTHR_CFLAGS
+dnl - GLOBUS_THR_CFLAGS
+dnl - GLOBUS_NOTHR_LIBS
+dnl - GLOBUS_THR_LIBS
+dnl - GLOBUS_COMMON_NOTHR_LIBS
+dnl - GLOBUS_COMMON_THR_LIBS
+dnl - GLOBUS_STATIC_COMMON_NOTHR_LIBS
+dnl - GLOBUS_STATIC_COMMON_THR_LIBS
+dnl - GLOBUS_FTP_CLIENT_NOTHR_LIBS
+dnl - GLOBUS_FTP_CLIENT_THR_LIBS
+dnl - GLOBUS_SSL_NOTHR_LIBS
+dnl - GLOBUS_SSL_THR_LIBS
+dnl - GLOBUS_STATIC_SSL_NOTHR_LIBS
+dnl - GLOBUS_STATIC_SSL_THR_LIBS
+dnl - GLOBUS_GSS_NOTHR_LIBS
+dnl - GLOBUS_GSS_THR_LIBS
+dnl - GLOBUS_LDAP_THR_LIBS
+
+AC_DEFUN([AC_GLOBUS],
+[
+    AC_ARG_WITH(globus_prefix,
+	[  --with-globus-prefix=PFX     prefix where GLOBUS is installed. ($GLOBUS_LOCATION or /opt/globus or pkg-config)],
+	[],
+        with_globus_prefix=${GLOBUS_LOCATION:-/opt/globus})
+
+    AC_ARG_WITH(globus_nothr_flavor,
+	[  --with-globus-nothr-flavor=flavor [default=gcc32dbg]],
+	[],
+        with_globus_nothr_flavor=${GLOBUS_FLAVOR:-gcc32dbg})
+
+    AC_MSG_RESULT(["GLOBUS nothread flavor is $with_globus_nothr_flavor"])
+
+    AC_ARG_WITH(globus_thr_flavor,
+        [  --with-globus-thr-flavor=flavor [default=gcc32dbgpthr]],
+        [],
+        with_globus_thr_flavor=${GLOBUS_FLAVOR:-gcc32dbgpthr})
+
+    AC_MSG_RESULT(["GLOBUS thread flavor is $with_globus_thr_flavor"])
+
+    ac_cv_globus_nothr_valid=no
+    ac_cv_globus_thr_valid1=no
+    ac_cv_globus_thr_valid2=no
+
+    GLOBUS_NOTHR_CFLAGS="$with_globus_prefix/include/$with_globus_nothr_flavor"
+    GLOBUS_THR_CFLAGS="$with_globus_prefix/include/$with_globus_thr_flavor"
+
+    ac_globus_ldlib="-L$with_globus_prefix/lib"
+
+    GLOBUS_COMMON_NOTHR_LIBS="$ac_globus_ldlib -lglobus_common_$with_globus_nothr_flavor"
+    GLOBUS_COMMON_THR_LIBS="$ac_globus_ldlib -lglobus_common_$with_globus_thr_flavor"
+
+    GLOBUS_STATIC_COMMON_NOTHR_LIBS="$with_globus_prefix/lib/libglobus_common_$with_globus_nothr_flavor.a"
+    GLOBUS_STATIC_COMMON_THR_LIBS="$with_globus_prefix/lib/libglobus_common_$with_globus_thr_flavor.a"
+
+    GLOBUS_FTP_CLIENT_NOTHR_LIBS="$ac_globus_ldlib -lglobus_ftp_client_$with_globus_nothr_flavor"
+    GLOBUS_FTP_CLIENT_THR_LIBS="$ac_globus_ldlib -lglobus_ftp_client_$with_globus_thr_flavor"
+
+    GLOBUS_GSS_NOTHR_LIBS="$ac_globus_ldlib -lglobus_gssapi_gsi_$with_globus_nothr_flavor -lglobus_gss_assist_$with_globus_nothr_flavor"
+    GLOBUS_GSS_THR_LIBS="$ac_globus_ldlib -lglobus_gssapi_gsi_$with_globus_thr_flavor -lglobus_gss_assist_$with_globus_thr_flavor"
+
+    GLOBUS_SSL_NOTHR_LIBS="$ac_globus_ldlib -lssl_$with_globus_nothr_flavor -lcrypto_$with_globus_nothr_flavor"
+    GLOBUS_SSL_THR_LIBS="$ac_globus_ldlib -lssl_$with_globus_thr_flavor -lcrypto_$with_globus_thr_flavor"
+
+    GLOBUS_STATIC_SSL_NOTHR_LIBS="$with_globus_prefix/lib/libssl_$with_globus_nothr_flavor.a $with_globus_prefix/lib/libcrypto_$with_globus_nothr_flavor.a"
+    GLOBUS_STATIC_SSL_THR_LIBS="$with_globus_prefix/lib/libssl_$with_globus_thr_flavor.a $with_globus_prefix/lib/libcrypto_$with_globus_thr_flavor.a"
+
+    GLOBUS_LDAP_THR_LIBS="$ac_globus_ldlib -lldap_$with_globus_thr_flavor -llber_$with_globus_thr_flavor"
+
+    dnl Needed by LCAS/LCMAPS voms plugins
+    GLOBUS_GSI_NOTHR_LIBS="$ac_globus_ldlib -lglobus_gsi_credential_$with_globus_nothr_flavor"
+    GLOBUS_GSI_THR_LIBS="$ac_globus_ldlib -lglobus_gsi_credential_$with_globus_thr_flavor"
+
+    dnl
+    dnl check nothr openssl header
+    dnl
+    ac_globus_nothr_ssl="$with_globus_prefix/include/$with_globus_nothr_flavor/openssl"
+
+    AC_MSG_CHECKING([for $ac_globus_nothr_ssl/ssl.h])
+
+    if test ! -f "$ac_globus_nothr_ssl/ssl.h" ; then
+	ac_globus_nothr_ssl=""
+	AC_MSG_RESULT([no])
+    else
+	AC_MSG_RESULT([yes])
+    fi
+
+    AC_MSG_CHECKING([for openssl nothr])
+
+    if test -n "$ac_globus_nothr_ssl" ; then
+	GLOBUS_NOTHR_CFLAGS="-I$ac_globus_nothr_ssl -I$GLOBUS_NOTHR_CFLAGS"
+    fi
+
+    if test -n "$ac_globus_nothr_ssl" ; then
+        dnl
+        dnl maybe do some complex test of globus instalation here later
+        dnl
+        ac_save_CFLAGS=$CFLAGS
+        CFLAGS="$GLOBUS_NOTHR_CFLAGS $CFLAGS"
+        AC_TRY_COMPILE([
+             #include "ssl.h"
+             #include "globus_gss_assist.h"
+           ],
+           [globus_gss_assist_ex aex],
+           [ac_cv_globus_nothr_valid=yes],
+           [ac_cv_globus_nothr_valid=no])
+        CFLAGS=$ac_save_CFLAGS
+        AC_MSG_RESULT([$ac_cv_globus_nothr_valid])
+    fi
+
+    dnl
+    dnl check thr openssl header
+    dnl
+    ac_globus_thr_ssl="$with_globus_prefix/include/$with_globus_thr_flavor/openssl"
+
+    AC_MSG_CHECKING([for $ac_globus_thr_ssl/ssl.h])
+
+    if test ! -f "$ac_globus_thr_ssl/ssl.h" ; then
+        ac_globus_thr_ssl=""
+        AC_MSG_RESULT([no])
+    else
+        AC_MSG_RESULT([yes])
+    fi
+
+    if test -n "$ac_globus_thr_ssl" ; then
+        GLOBUS_THR_CFLAGS="-I$ac_globus_thr_ssl -I$GLOBUS_THR_CFLAGS"
+    fi
+
+    AC_MSG_CHECKING([checking openssl thr])
+
+    if test -n "$ac_globus_thr_ssl" ; then
+	dnl
+	dnl maybe do some complex test of globus instalation here later
+	dnl
+	ac_save_CFLAGS=$CFLAGS
+	CFLAGS="$GLOBUS_THR_CFLAGS $CFLAGS"
+	AC_TRY_COMPILE([
+	     #include "openssl/ssl.h"
+	     #include "globus_gss_assist.h"
+	   ],
+           [globus_gss_assist_ex aex],
+	   [ac_cv_globus_thr_valid1=yes],
+           [ac_cv_globus_thr_valid1=no])
+        CFLAGS=$ac_save_CFLAGS
+        AC_MSG_RESULT([$ac_cv_globus_thr_valid1])
+    fi
+
+    dnl
+    dnl check thr ldap header
+    dnl
+    ac_globus_thr_ldap="$with_globus_prefix/include/$with_globus_thr_flavor"
+                                                                                
+    AC_MSG_CHECKING([for $ac_globus_thr_ldap/lber.h])
+    
+    if test ! -f "$ac_globus_thr_ldap/lber.h" ; then
+	ac_globus_thr_ldap=""
+	AC_MSG_RESULT([no])
+    else
+        AC_MSG_RESULT([yes])
+    fi
+
+    AC_MSG_CHECKING([for ldap thr])
+
+    if test -n "$ac_globus_thr_ldap" ; then
+        dnl
+        dnl maybe do some complex test of globus instalation here later
+        dnl
+        ac_save_CFLAGS=$CFLAGS
+        CFLAGS="$GLOBUS_THR_CFLAGS $CFLAGS"
+	AC_TRY_COMPILE([
+              #include "ldap.h"
+              #include "lber.h"
+           ],
+           [
+           LDAPMessage *ldresult;
+           BerElement *ber;
+           ],
+           [ac_cv_globus_thr_valid2=yes],
+           [ac_cv_globus_thr_valid2=no])
+        CFLAGS=$ac_save_CFLAGS
+        AC_MSG_RESULT([$ac_cv_globus_thr_valid2])
+    fi
+
+    if test x$ac_cv_globus_nothr_valid = xyes -a x$ac_cv_globus_thr_valid1 = xyes -a x$ac_cv_globus_thr_valid2 = xyes ; then
+	GLOBUS_LOCATION=$with_globus_prefix
+	GLOBUS_NOTHR_FLAVOR=$with_globus_nothr_flavor
+        GLOBUS_THR_FLAVOR=$with_globus_thr_flavor
+	ifelse([$2], , :, [$2])
+    else
+	GLOBUS_NOTHR_CFLAGS=""
+	GLOBUS_THR_CFLAGS=""
+	GLOBUS_NOTHR_LIBS=""
+	GLOBUS_THR_LIBS=""
+	GLOBUS_COMMON_NOTHR_LIBS=""
+	GLOBUS_COMMON_THR_LIBS=""
+	GLOBUS_STATIC_COMMON_NOTHR_LIBS=""
+        GLOBUS_STATIC_COMMON_THR_LIBS=""
+        GLOBUS_FTP_CLIENT_NOTHR_LIBS=""
+	GLOBUS_FTP_CLIENT_THR_LIBS=""
+	GLOBUS_SSL_NOTHR_LIBS=""
+	GLOBUS_SSL_THR_LIBS=""
+	GLOBUS_STATIC_SSL_NOTHR_LIBS=""
+        GLOBUS_STATIC_SSL_THR_LIBS=""
+	GLOBUS_LDAP_THR_LIBS=""
+	ifelse([$3], , :, [$3])
+    fi
+
+    AC_SUBST(GLOBUS_LOCATION)
+    AC_SUBST(GLOBUS_NOTHR_FLAVOR)
+    AC_SUBST(GLOBUS_THR_FLAVOR)
+    AC_SUBST(GLOBUS_NOTHR_CFLAGS)
+    AC_SUBST(GLOBUS_THR_CFLAGS)
+    AC_SUBST(GLOBUS_NOTHR_LIBS)
+    AC_SUBST(GLOBUS_THR_LIBS)
+    AC_SUBST(GLOBUS_COMMON_NOTHR_LIBS)
+    AC_SUBST(GLOBUS_COMMON_THR_LIBS)
+    AC_SUBST(GLOBUS_STATIC_COMMON_NOTHR_LIBS)
+    AC_SUBST(GLOBUS_STATIC_COMMON_THR_LIBS)
+    AC_SUBST(GLOBUS_FTP_CLIENT_NOTHR_LIBS)
+    AC_SUBST(GLOBUS_FTP_CLIENT_THR_LIBS)
+    AC_SUBST(GLOBUS_SSL_NOTHR_LIBS)
+    AC_SUBST(GLOBUS_SSL_THR_LIBS)
+    AC_SUBST(GLOBUS_STATIC_SSL_NOTHR_LIBS)
+    AC_SUBST(GLOBUS_STATIC_SSL_THR_LIBS)
+    AC_SUBST(GLOBUS_GSS_NOTHR_LIBS)
+    AC_SUBST(GLOBUS_GSS_THR_LIBS)
+    AC_SUBST(GLOBUS_LDAP_THR_LIBS)
+])
+
Only in blahp-condor/project: install-sh
Only in blahp-condor/project: libtool.m4
Only in blahp-condor/project: ltmain.sh
Only in blahp-condor/project: lt~obsolete.m4
Only in blahp-condor/project: ltoptions.m4
Only in blahp-condor/project: ltsugar.m4
Only in blahp-condor/project: ltversion.m4
Only in blahp-condor/project: missing
Only in blahp-osg/project: properties.xml
Only in blahp-osg/project: version.properties
Only in blahp-osg/src: acconfig.h
diff -ur blahp-condor/src/Bfunctions.c blahp-osg/src/Bfunctions.c
--- blahp-condor/src/Bfunctions.c	2012-03-08 03:47:11.000000000 -0600
+++ blahp-osg/src/Bfunctions.c	2016-04-26 11:19:29.432396775 -0500
@@ -58,13 +58,13 @@
 				switch (fds[0].revents){
 				case POLLNVAL:
 					syserror("poll() file descriptor error in Readline: %r");
-					break;
+					return -1;
 				case POLLHUP:
 					syserror("Connection closed in Readline: %r");
-					break;
+					return -1;
 				case POLLERR:
 					syserror("poll() POLLERR in Readline: %r");
-					break;
+					return -1;
 				}
 			} else {
 
@@ -587,7 +587,7 @@
 }
 
 int
-bupdater_remove_active_job(bupdater_active_jobs *bact,
+bupdater_remove_active_job(bupdater_active_jobs *bact, 
                            const char *job_id)
 {
   int left, right, cur, cmp, resize;
@@ -603,6 +603,7 @@
     if (cmp == 0)
      {
       /* Job ID found. Remove it from list. */
+      free(bact->jobs[cur]);
       for (resize = cur+1; resize<bact->njobs; resize++)
        {
         bact->jobs[resize - 1] = bact->jobs[resize];
diff -ur blahp-condor/src/blah_job_registry_add.c blahp-osg/src/blah_job_registry_add.c
--- blahp-condor/src/blah_job_registry_add.c	2010-03-17 08:19:34.000000000 -0500
+++ blahp-osg/src/blah_job_registry_add.c	2016-04-26 11:19:29.442398477 -0500
@@ -2,7 +2,7 @@
  *  File :     blah_job_registry_add.c
  *
  *
- *  Author :   Francesco Prelz ($Author: mezzadri $)
+ *  Author :   Francesco Prelz ($Author: fprelz $)
  *  e-mail :   "francesco.prelz@mi.infn.it"
  *
  *  Revision history :
@@ -10,6 +10,7 @@
  *  27-Feb-2008 Added user_prefix.
  *   3-Mar-2008 Added non-privileged updates to fit CREAM's file and process
  *              ownership model.
+ *  14-Jul-2011 Added remote/multicast registry update if found in config file.
  *
  *  Description:
  *   Executable to add (append or update) an entry to the job registry.
@@ -39,6 +40,7 @@
 #include <time.h>
 #include <errno.h>
 #include "job_registry.h"
+#include "job_registry_updater.h"
 #include "config.h"
 
 int
@@ -59,11 +61,12 @@
   char *wn_addr = "";
   time_t udate=0;
   char *blah_id, *batch_id;
-  int ret, prret, rhret;
+  int ent, ret, prret, rhret;
   config_handle *cha;
-  config_entry *rge;
+  config_entry *rge, *remupd_conf;
   job_registry_handle *rha, *rhano;
   job_registry_index_mode rgin_mode = NO_INDEX;
+  job_registry_updater_endpoint *remupd_head = NULL;
 
   if (argc > 1 && (strcmp(argv[1], "-u") == 0))
    {
@@ -98,6 +101,20 @@
   if (cha != NULL)
    {
     rge = config_get("job_registry", cha);
+    remupd_conf = config_get("job_registry_add_remote", cha);
+    if (remupd_conf != NULL)
+     {
+      if (job_registry_updater_setup_sender(remupd_conf->values,
+                                            remupd_conf->n_values, 2,
+                                           &remupd_head) < 0)
+       {
+         fprintf(stderr,"%s: warning: cannot set network sender(s) up for remote update to:\n",argv[0]);
+         for (ent = 0; ent < remupd_conf->n_values; ent++)
+          {
+           fprintf(stderr," - %s\n", remupd_conf->values[ent]);
+          }
+       }
+     }
     if (rge != NULL) registry_file = rge->value;
    }
 
@@ -118,6 +135,7 @@
     else 
      {
       if (cha != NULL) config_free(cha);
+      if (remupd_head != NULL) job_registry_updater_free_endpoints(remupd_head);
       return 1;
      }
    }
@@ -163,9 +181,10 @@
          {
           fprintf(stderr,"%s: job_registry_append_nonpriv returns %d: ",argv[0],ret);
           perror("");
+          if (remupd_head != NULL) job_registry_updater_free_endpoints(remupd_head);
           return 4;
          } 
-        else return 0;
+        else goto happy_ending;
        }
      }
     else
@@ -173,6 +192,7 @@
       fprintf(stderr,"%s: error initialising job registry: ",argv[0]);
       perror("");
      }
+    if (remupd_head != NULL) job_registry_updater_free_endpoints(remupd_head);
     return 2;
    }
 
@@ -215,17 +235,32 @@
        {
         fprintf(stderr,"%s: job_registry_append_nonpriv returns %d: ",argv[0],ret);
         perror("");
+        if (remupd_head != NULL) job_registry_updater_free_endpoints(remupd_head);
         return 5;
        } 
-      else return 0;
+      else goto happy_ending;
      }
 
     fprintf(stderr,"%s: job_registry_append returns %d: ",argv[0],ret);
     perror("");
     job_registry_destroy(rha);
+    if (remupd_head != NULL) job_registry_updater_free_endpoints(remupd_head);
     return 3;
    } 
 
   job_registry_destroy(rha);
+
+ happy_ending:
+  if (remupd_head != NULL)
+   {
+    if (job_registry_send_update(remupd_head, &en,
+              (strlen(proxy_subject) > 0 ? proxy_subject : NULL),
+              (strlen(user_proxy) > 0 ? user_proxy : NULL)) < 0)
+     {
+      fprintf(stderr,"%s: warning: sending network update: ",argv[0]);
+      perror("");
+     }
+    job_registry_updater_free_endpoints(remupd_head);
+   }
   return 0;
 }
diff -ur blahp-condor/src/blah_job_registry_lkup.c blahp-osg/src/blah_job_registry_lkup.c
--- blahp-condor/src/blah_job_registry_lkup.c	2010-03-17 08:19:34.000000000 -0500
+++ blahp-osg/src/blah_job_registry_lkup.c	2016-04-26 11:19:29.444396127 -0500
@@ -1,7 +1,7 @@
 /*
  *  File :     blah_job_registry_lkup.c
  *
- *  Author :   Francesco Prelz ($Author: mezzadri $)
+ *  Author :   Francesco Prelz ($Author: fprelz $)
  *  e-mail :   "francesco.prelz@mi.infn.it"
  *
  *  Revision history :
@@ -61,10 +61,11 @@
   int opt_get_port = FALSE;
   char *anhname;
   struct utsname ruts;
+  const char *usage_string="1ERROR Usage: %s [-w (get worker node)] [-p (get user proxy)] [-n (get parser host:port)] [-b (look up for batch IDs)] <id>\n";
  
   if (argc < 2)
    {
-    fprintf(stdout,"1ERROR Usage: %s [-w (get worker node)] [-p (get user proxy)] [-n (get parser host:port)] [-b (look up for batch IDs)] <id>\n",argv[0]);
+    fprintf(stdout,usage_string,argv[0]);
     return 1;
    }
 
@@ -90,6 +91,11 @@
    }
 
   id = argv[idc];
+  if (id == NULL && (!opt_get_port)) /* Is there an argument that doesn't start with '-' ? */
+   {
+    fprintf(stdout,usage_string,argv[0]);
+    return 1;
+   }
 
   cha = config_read(NULL); /* Read config from default locations. */
   if (cha != NULL)
Only in blahp-osg/src: blah_job_registry_purge.c
diff -ur blahp-condor/src/BLfunctions.c blahp-osg/src/BLfunctions.c
--- blahp-condor/src/BLfunctions.c	2011-09-15 07:31:59.000000000 -0500
+++ blahp-osg/src/BLfunctions.c	2016-04-26 11:19:29.412396596 -0500
@@ -320,6 +320,38 @@
 
 }
 
+
+long GetHistorySeekPos(FILE *fp){
+
+	char *cp;
+	char *tline;
+	char *tlineout;
+	long lret=0;
+	
+	if((tline=calloc(NUM_CHARS,1)) == 0){
+		sysfatal("can't malloc tline in GetHistorySeekPos: %r");
+	}
+
+	
+	if(fseek(fp, 0L, SEEK_SET) < 0){
+		syserror("poll() timeout in NotifyCream: %r");
+		return 0L;
+	}
+        while(fgets(tline, NUM_CHARS, fp)){
+		if ((cp = strrchr (tline, '\n')) != NULL){
+			*cp = '\0';
+			tlineout=strdel(tline, "#");
+			lret=atol(tlineout);
+			free(tline);
+			free(tlineout);
+			return lret;
+       		}
+	}
+
+	return 0L;	
+}
+
+
 int 
 do_log(FILE *debuglogfile, int debuglevel, int dbgthresh, const char *fmt, ...)
 {
diff -ur blahp-condor/src/BLfunctions.h blahp-osg/src/BLfunctions.h
--- blahp-condor/src/BLfunctions.h	2010-12-13 08:30:03.000000000 -0600
+++ blahp-osg/src/BLfunctions.h	2016-04-26 11:19:29.413397258 -0500
@@ -22,6 +22,8 @@
 # 
 */
 
+#include "acconfig.h"
+
 #define _GNU_SOURCE
 #define _XOPEN_SOURCE
 #include <unistd.h>
@@ -100,6 +102,7 @@
 int str2epoch(char *str, char *f);
 char *iepoch2str(time_t epoch, char *f);
 char *GetPBSSpoolPath(char *binpath);
+long GetHistorySeekPos(FILE *fp);
 int do_log(FILE *debuglogfile, int debuglevel, int dbgthresh, const char *fmt, ...);
 void daemonize();
 void eprint(int err, char *fmt, va_list args);
diff -ur blahp-condor/src/BLParserLSF.c blahp-osg/src/BLParserLSF.c
--- blahp-condor/src/BLParserLSF.c	2011-10-20 04:34:59.000000000 -0500
+++ blahp-osg/src/BLParserLSF.c	2016-04-26 11:19:29.407397177 -0500
@@ -220,7 +220,9 @@
 		}
 		real_off=ftell(fp);
 		if(real_off < off){
-			off=0;
+			/*For the lsb.events file, the first line has the format "# <history seek position>", 
+			which indicates the file position of the first history event after log switch.*/ 
+			off=GetHistorySeekPos(fp);
 		}
 		
 		if(fseek(fp, off, SEEK_SET) < 0){
@@ -837,7 +839,7 @@
 		if(id>0 && j2js[id]!=NULL){
          
 			if(j2wn[id] && strcmp(j2wn[id],"\0")==0){
-				t_wnode[0]='\0';
+				t_wnode=make_message("");
 			}else{
 				t_wnode=make_message("WorkerNode=%s;",j2wn[id]);
 			}
@@ -857,6 +859,8 @@
 					exitreason=make_message(" ExitReason=\"FILEsize limit reached\";");
 				}else if(j2ec[id] && strcmp(j2ec[id],"157")==0){
 					exitreason=make_message(" ExitReason=\"Directory Access Error (No AFS token, dir does not exist)\";");
+				}else{
+					exitreason=make_message("");
 				}
 				out_buf=make_message("[BatchJobId=\"%s\"; %s JobStatus=%s; LRMSSubmissionTime=\"%s\"; LRMSStartRunningTime=\"%s\"; LRMSCompletedTime=\"%s\";%s JwExitCode=%s;]/%s\n",jobid, t_wnode, j2js[id], j2st[id], j2rt[id], j2ct[id], exitreason, j2ec[id], pr_removal);
 			}else if(j2rt[id] && strcmp(j2rt[id],"\0")!=0){
@@ -899,6 +903,8 @@
 						exitreason=make_message(" ExitReason=\"FILEsize limit reached\";");
 					}else if(j2ec[id] && strcmp(j2ec[id],"157")==0){
 						exitreason=make_message(" ExitReason=\"Directory Access Error (No AFS token, dir does not exist)\";");
+					}else{
+						exitreason=make_message("");
 					}
 					out_buf=make_message("[BatchJobId=\"%s\"; %s JobStatus=%s; LRMSSubmissionTime=\"%s\"; LRMSStartRunningTime=\"%s\"; LRMSCompletedTime=\"%s\";%s JwExitCode=%s;]/%s\n",jobid, t_wnode, j2js[id], j2st[id], j2rt[id], j2ct[id], exitreason, j2ec[id], pr_removal);
 				}else if(j2rt[id] && strcmp(j2rt[id],"\0")!=0){
@@ -1254,7 +1260,7 @@
 	} else {
 		while(n--) {
 			if( *(direntry[n]->d_name) == '.' ) continue;
-			s=make_message("%s/%s",direntry[n]->d_name);
+			s=make_message("%s/%s",ldir,direntry[n]->d_name);
 			rc=stat(s,&sbuf);
 			if(rc) {
 				syserror("Cannot stat file %s: %r", s);
diff -ur blahp-condor/src/blparser_master.c blahp-osg/src/blparser_master.c
--- blahp-condor/src/blparser_master.c	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/blparser_master.c	2016-04-26 11:19:29.450398490 -0500
@@ -34,11 +34,9 @@
 #include <sys/stat.h>
 #include <sys/wait.h>
 #include <syslog.h>
-
 #ifdef MTRACE_ON
 #include <mcheck.h>
 #endif
-
 #include <pthread.h>
 #include <wordexp.h>
 #include <signal.h>
@@ -483,14 +481,14 @@
 				}
 			}
 			
-			s=make_message("%s/bin/%s",blah_location,parser_names[0]);                
+			s=make_message("%s/libexec/%s",blah_location,parser_names[0]);                
 			if(access(s,X_OK)){
 				fprintf(stderr, "%s does not exist or it is not executable\n",s);
 				exit(EXIT_FAILURE);
 			}
 			free(s);
 			
-			parser_pbs[i].exefile = make_message("%s/bin/%s %s %s %s %s %s",blah_location,parser_names[0],debuglevelpbs,debuglogfilepbs,spooldirpbs,portpbs,creamportpbs);
+			parser_pbs[i].exefile = make_message("%s/libexec/%s %s %s %s %s %s",blah_location,parser_names[0],debuglevelpbs,debuglogfilepbs,spooldirpbs,portpbs,creamportpbs);
 			parser_pbs[i].pidfile = make_message("%s/%s%d.pid",PID_DIR,parser_names[0],i+1);
 
 			if(parser_pbs[i].exefile == NULL || parser_pbs[i].pidfile == NULL){
@@ -593,14 +591,14 @@
 				}
 			}
 			
-			s=make_message("%s/bin/%s",blah_location,parser_names[1]);                
+			s=make_message("%s/libexec/%s",blah_location,parser_names[1]);                
 			if(access(s,X_OK)){
 				fprintf(stderr, "%s does not exist or it is not executable\n",s);
 				exit(EXIT_FAILURE);
 			}
 			
 			free(s);
-			parser_lsf[i].exefile = make_message("%s/bin/%s %s %s %s %s %s %s",blah_location,parser_names[1],debuglevellsf,debuglogfilelsf,binpathlsf,confpathlsf,portlsf,creamportlsf);
+			parser_lsf[i].exefile = make_message("%s/libexec/%s %s %s %s %s %s %s",blah_location,parser_names[1],debuglevellsf,debuglogfilelsf,binpathlsf,confpathlsf,portlsf,creamportlsf);
 			parser_lsf[i].pidfile = make_message("%s/%s%d.pid",PID_DIR,parser_names[1],i+1);
 			
 			if(parser_lsf[i].exefile == NULL || parser_lsf[i].pidfile == NULL){
diff -ur blahp-condor/src/BNotifier.c blahp-osg/src/BNotifier.c
--- blahp-condor/src/BNotifier.c	2011-09-21 04:50:26.000000000 -0500
+++ blahp-osg/src/BNotifier.c	2016-04-26 11:19:29.414397952 -0500
@@ -24,6 +24,37 @@
 
 #include "BNotifier.h"
 
+/* Variables initialization */
+
+char *progname="BNotifier";
+
+char *registry_file;
+
+char *creamfilter="";
+
+int async_notif_port;
+
+int debug=FALSE;
+int nodmn=FALSE;
+
+FILE *debuglogfile;
+char *debuglogname;
+
+int  c_sock;
+
+/* moved to per-thread structure
+int startnotify=FALSE;
+int startnotifyjob=FALSE;
+int firstnotify=FALSE;
+int sentendonce=FALSE;
+char *joblist_string="";
+time_t lastnotiftime;
+ */
+ 
+int loop_interval=DEFAULT_LOOP_INTERVAL;
+
+creamConnection_t connections[MAX_CONNECTIONS] = { EMPTY_CONNECTION };
+
 int
 main(int argc, char *argv[])
 {
@@ -35,12 +66,13 @@
 	char ainfo_port_string[16];
 	struct addrinfo ai_req, *ai_ans, *cur_ans;
 	int address_found;
+	int new_connection_fd;
 
-	pthread_t CreamThd;
 	pthread_t PollThd;
 	config_handle *cha;
 	config_entry *ret;
 	char *pidfile=NULL;
+	int nocheck=0;
 	
 	int c;				
 
@@ -54,14 +86,16 @@
 		{
 		{"help",      no_argument,     &help,       1},
 		{"usage",     no_argument,     &short_help, 1},
+		{"nocheck",   no_argument,       0, 'n'},
 		{"nodaemon",  no_argument,       0, 'o'},
 		{"version",   no_argument,       0, 'v'},
+		{"prefix",    required_argument, 0, 'p'},
 		{0, 0, 0, 0}
 		};
 
 		int option_index = 0;
      
-		c = getopt_long (argc, argv, "vo",long_options, &option_index);
+		c = getopt_long (argc, argv, "vnop:",long_options, &option_index);
      
 		if (c == -1){
 			break;
@@ -79,10 +113,17 @@
 			version=1;
 			break;
 	       
+		case 'n':
+			nocheck=1;
+			break;
+			
 		case 'o':
 			nodmn=1;
 			break;
 
+		case 'p':
+			break;
+
 		case '?':
 			break;
      
@@ -112,7 +153,9 @@
 	}   
 
 	/* Checking configuration */
-	check_config_file("NOTIFIER");
+	if(!nocheck){
+		check_config_file("NOTIFIER");
+	}
 
 	/* Reading configuration */
 	cha = config_read(NULL);
@@ -241,9 +284,24 @@
        
 	config_free(cha);
 
-	pthread_create(&CreamThd, NULL, (void *(*)(void *))CreamConnection, (void *)list_c);
 	pthread_create(&PollThd, NULL, (void *(*)(void *))PollDB, (void *)NULL);
 
+	for ( ;; ) {
+		/* FIXME: exit condition??? */
+		do_log(debuglogfile, debug, 1, "Listening for new connection\n");
+		if ( (new_connection_fd = accept(list_c, NULL, NULL) ) < 0 ) 
+		{
+			do_log(debuglogfile, debug, 1, "Fatal Error:Error calling accept() on list_c\n");
+			sysfatal("Error calling accept(): %r");
+		}
+
+		if (add_cream_connection(new_connection_fd) != 0)
+		{
+			do_log(debuglogfile, debug, 1, "connection table full: unable to add the new connection\n");
+			close(new_connection_fd);
+		}
+	}
+
 	pthread_join(PollThd, (void **)&status);
 	pthread_exit(NULL);
  
@@ -262,7 +320,7 @@
 	char *finalbuffer=NULL;
         char *cdate=NULL;
 	time_t now;
-        int  maxtok,i,maxtokl;
+        int  maxtok,i,maxtokl,j;
         char **tbuf;
         char **lbuf;
 	int len=0,flen=0;
@@ -270,6 +328,8 @@
         int rc;
 	char *regfile;
         char *cp=NULL;
+	int to_sleep=FALSE;
+	int skip_reg_open=FALSE;
 	
 	rha=job_registry_init(registry_file, BY_BATCH_ID);
 	if (rha == NULL){
@@ -282,142 +342,167 @@
 	
 		now=time(NULL);
 	
-		if(!startnotify && !startnotifyjob && !(firstnotify && sentendonce)){
+		to_sleep=TRUE;
+		/* cycle over connections: sleep if startnotify, startnotifyjob and sentendonce are not set.
+		   If startnotifyjob is set the conn is served.
+		*/ 
+		for(i=0; i<MAX_CONNECTIONS; i++){
+		
+			if(!connections[i].startnotify && !connections[i].startnotifyjob && !(connections[i].firstnotify && connections[i].sentendonce)) continue;
+			if(connections[i].startnotify) to_sleep=FALSE;
+			
+			if(connections[i].startnotifyjob){
+				to_sleep=FALSE;
+				rhc=job_registry_init(registry_file, BY_USER_PREFIX);
+				if (rhc == NULL){
+					do_log(debuglogfile, debug, 1, "%s: Error initialising job registry %s\n",argv0,registry_file);
+					fprintf(stderr,"%s: Error initialising job registry %s :",argv0,registry_file);
+		 	   	  	perror("");
+		 	   	}
+		 	   	do_log(debuglogfile, debug, 2, "%s:Job list for notification:%s\n",argv0,connections[i].joblist_string);
+		 	   	maxtok=strtoken(connections[i].joblist_string,',',&tbuf);
+   		 	   	for(j=0;j<maxtok;j++){
+        	 	   	  	if ((en=job_registry_get(rhc, tbuf[j])) != NULL){
+						buffer=ComposeClassad(en);
+		 	   	  	}else{
+		 	   	  		cdate=iepoch2str(now);
+		 	   	  		maxtokl=strtoken(tbuf[j],'_',&lbuf);
+		 	   	  		if(lbuf[1]){
+		 	   	  			if ((cp = strrchr (lbuf[1], '\n')) != NULL){
+		 	   	  				*cp = '\0';
+		 	   	  			}
+		 	   	  			if ((cp = strrchr (lbuf[1], '\r')) != NULL){
+		 	   	  				*cp = '\0';
+		 	   	  			}
+		 	   	  			buffer=make_message("[BlahJobName=\"%s\"; ClientJobId=\"%s\"; JobStatus=4; JwExitCode=999; ExitReason=\"BUpdater is not able to find the job anymore\"; Reason=\"BUpdater is not able to find the job anymore\"; ChangeTime=\"%s\"; ]\n",tbuf[j],lbuf[1],cdate);
+		 	   	  		}
+		 	   	  		freetoken(&lbuf,maxtokl);
+		 	   	  		free(cdate);
+		 	   	  	}
+		 	   	  	free(en);
+		 	   	  	len=strlen(buffer);
+		 	   	  	if(connections[i].finalbuffer != NULL){
+		 	   	  		flen=strlen(connections[i].finalbuffer);
+		 	   	  	}else{
+		 	   	  		flen=0;
+		 	   	  	}
+		 	   	  	connections[i].finalbuffer = realloc(connections[i].finalbuffer,flen+len+2);
+		 	   	  	if (connections[i].finalbuffer == NULL){
+		 	   	  		sysfatal("can't realloc finalbuffer in PollDB: %r");
+		 	   	  	}
+		 	   	  	if(flen==0){
+		 	   	  		connections[i].finalbuffer[0]='\000';
+					}
+		 	   	  	strcat(connections[i].finalbuffer,buffer);
+		 	   	  	free(buffer);
+		 	   	}
+		 	   	freetoken(&tbuf,maxtok);
+		 	   
+		 	   	if(connections[i].finalbuffer != NULL){
+		 	   	  	if(NotifyCream(connections[i].finalbuffer,&connections[i])!=-1){
+	         	   	  		/* change last notification time */
+		 	   	  		connections[i].lastnotiftime=now;
+		 	   	  		connections[i].startnotifyjob=FALSE;
+		 	   	  	}
+		 	   	  	free(connections[i].finalbuffer);
+		 	   	  	connections[i].finalbuffer=NULL;
+		 	   	}
+		 	   	job_registry_destroy(rhc);
+			}
+			if(connections[i].firstnotify && connections[i].sentendonce){
+				to_sleep=FALSE;
+				if(NotifyCream("NTFDATE/END\n",&connections[i])!=-1){
+					connections[i].startnotify=TRUE;
+					connections[i].sentendonce=FALSE;
+		 	   	  	connections[i].firstnotify=FALSE;
+		 	   	  	connections[i].startnotifyjob=FALSE;
+				}
+			}
+			
+		}
+		
+		if(to_sleep){
 			sleep(loop_interval);
 			continue;
 		}
 
-		if(startnotify){
-
-                	regfile=make_message("%s/registry",registry_file);
-        		rc=stat(regfile,&sbuf);
-			free(regfile);
-			if(sbuf.st_mtime<lastnotiftime){
-				do_log(debuglogfile, debug, 3, "Skip registry opening: mtime:%d lastn:%d\n",sbuf.st_mtime,lastnotiftime);
-				sleep(loop_interval);
-				continue;
+                regfile=make_message("%s/registry",registry_file);
+        	rc=stat(regfile,&sbuf);
+		free(regfile);
+		
+		skip_reg_open=TRUE;
+		for(i=0; i<MAX_CONNECTIONS; i++){
+			if(sbuf.st_mtime>=connections[i].lastnotiftime){
+				skip_reg_open=FALSE;
+				break;
 			}
-			do_log(debuglogfile, debug, 3, "Normal registry opening: mtime:%d lastn:%d\n",sbuf.st_mtime,lastnotiftime);
+		}
+		if(skip_reg_open){
+			do_log(debuglogfile, debug, 3, "Skip registry opening: mtime:%d lastn:%d\n",sbuf.st_mtime,connections[i].lastnotiftime);
+			sleep(loop_interval);
+			continue;
+		}
+		
+		do_log(debuglogfile, debug, 3, "Normal registry opening\n");
 
-			fd = job_registry_open(rha, "r");
-			if (fd == NULL)
-			{
-				do_log(debuglogfile, debug, 1, "%s: Error opening job registry %s\n",argv0,registry_file);
-				fprintf(stderr,"%s: Error opening job registry %s :",argv0,registry_file);
-				perror("");
-				sleep(loop_interval);
-				continue;
-			}
-			if (job_registry_rdlock(rha, fd) < 0)
-			{
-				do_log(debuglogfile, debug, 1, "%s: Error read locking registry %s\n",argv0,registry_file);
-				fprintf(stderr,"%s: Error read locking registry %s :",argv0,registry_file);
-				perror("");
-				sleep(loop_interval);
-				continue;
-			}
-			while ((en = job_registry_get_next(rha, fd)) != NULL)
-			{
+		fd = job_registry_open(rha, "r");
+		if (fd == NULL)
+		{
+			do_log(debuglogfile, debug, 1, "%s: Error opening job registry %s\n",argv0,registry_file);
+			fprintf(stderr,"%s: Error opening job registry %s :",argv0,registry_file);
+			perror("");
+			sleep(loop_interval);
+			continue;
+		}
+		if (job_registry_rdlock(rha, fd) < 0)
+		{
+			do_log(debuglogfile, debug, 1, "%s: Error read locking registry %s\n",argv0,registry_file);
+			fprintf(stderr,"%s: Error read locking registry %s :",argv0,registry_file);
+			perror("");
+			sleep(loop_interval);
+			continue;
+		}
+		while ((en = job_registry_get_next(rha, fd)) != NULL)
+		{
 		
-				if(en->mdate >= lastnotiftime && en->mdate < now && en->user_prefix && strstr(en->user_prefix,creamfilter)!=NULL && strlen(en->updater_info)>0)
+			for(i=0; i<MAX_CONNECTIONS; i++){
+				if(connections[i].creamfilter==NULL) continue;
+				if(en->mdate >= connections[i].lastnotiftime && en->mdate < now && en->user_prefix && strstr(en->user_prefix,connections[i].creamfilter)!=NULL && strlen(en->updater_info)>0)
 				{
 					buffer=ComposeClassad(en);
 					len=strlen(buffer);
-					if(finalbuffer != NULL){
-						flen=strlen(finalbuffer);
+					if(connections[i].finalbuffer != NULL){
+						flen=strlen(connections[i].finalbuffer);
 					}else{
 						flen=0;
 					}
-					finalbuffer = realloc(finalbuffer,flen+len+2);
-					if (finalbuffer == NULL){
+					connections[i].finalbuffer = realloc(connections[i].finalbuffer,flen+len+2);
+					if (connections[i].finalbuffer == NULL){
 						sysfatal("can't realloc finalbuffer in PollDB: %r");
 					}
 					if(flen==0){
-						finalbuffer[0]='\000';
+						connections[i].finalbuffer[0]='\000';
 					}
-					strcat(finalbuffer,buffer);
+					strcat(connections[i].finalbuffer,buffer);
 					free(buffer);
 				}
-				free(en);
 			}
+			free(en);
+		}
 
-			if(finalbuffer != NULL){
-				if(NotifyCream(finalbuffer)!=-1){
-	        			/* change last notification time */
-					lastnotiftime=now;
-				}
-				free(finalbuffer);
-				finalbuffer=NULL;
-			}
-			
-			fclose(fd);
-			
-			
-		}else if(startnotifyjob){
-			rhc=job_registry_init(registry_file, BY_USER_PREFIX);
-			if (rhc == NULL){
-				do_log(debuglogfile, debug, 1, "%s: Error initialising job registry %s\n",argv0,registry_file);
-				fprintf(stderr,"%s: Error initialising job registry %s :",argv0,registry_file);
-				perror("");
-			}
-			do_log(debuglogfile, debug, 2, "%s:Job list for notification:%s\n",argv0,joblist_string);
-			maxtok=strtoken(joblist_string,',',&tbuf);
-   			for(i=0;i<maxtok;i++){
-        			if ((en=job_registry_get(rhc, tbuf[i])) != NULL){
-					buffer=ComposeClassad(en);
-				}else{
-					cdate=iepoch2str(now);
-					maxtokl=strtoken(tbuf[i],'_',&lbuf);
-					if(lbuf[1]){
-						if ((cp = strrchr (lbuf[1], '\n')) != NULL){
-							*cp = '\0';
-						}
-						if ((cp = strrchr (lbuf[1], '\r')) != NULL){
-							*cp = '\0';
-						}
-						buffer=make_message("[BlahJobName=\"%s\"; ClientJobId=\"%s\"; JobStatus=4; JwExitCode=999; ExitReason=\"BUpdater is not able to find the job anymore\"; Reason=\"BUpdater is not able to find the job anymore\"; ChangeTime=\"%s\"; ]\n",tbuf[i],lbuf[1],cdate);
-					}
-					freetoken(&lbuf,maxtokl);
-					free(cdate);
-				}
-				free(en);
-				len=strlen(buffer);
-				if(finalbuffer != NULL){
-					flen=strlen(finalbuffer);
-				}else{
-					flen=0;
-				}
-				finalbuffer = realloc(finalbuffer,flen+len+2);
-				if (finalbuffer == NULL){
-					sysfatal("can't realloc finalbuffer in PollDB: %r");
-				}
-				if(flen==0){
-					finalbuffer[0]='\000';
-				}
-				strcat(finalbuffer,buffer);
-				free(buffer);
-			}
-			freetoken(&tbuf,maxtok);
-			
-			if(finalbuffer != NULL){
-				if(NotifyCream(finalbuffer)!=-1){
+		for(i=0; i<MAX_CONNECTIONS; i++){
+			if(connections[i].finalbuffer != NULL){
+				if(NotifyCream(connections[i].finalbuffer,&connections[i])!=-1){
 	        			/* change last notification time */
-					lastnotiftime=now;
-					startnotifyjob=FALSE;
+					connections[i].lastnotiftime=now;
 				}
-				free(finalbuffer);
-				finalbuffer=NULL;
+				free(connections[i].finalbuffer);
+				connections[i].finalbuffer=NULL;
 			}
-			job_registry_destroy(rhc);
 		}
-
-		if(firstnotify && sentendonce){
-			if(NotifyCream("NTFDATE/END\n")!=-1){
-				startnotify=TRUE;
-				sentendonce=FALSE;
-				firstnotify=FALSE;
-			}
-		}		
+		
+		fclose(fd);
+		
 		sleep(loop_interval);
 	}
                 
@@ -488,7 +573,7 @@
 }
 
 void 
-CreamConnection(int c_sock)
+CreamConnection(creamConnection_t *connection)
 { 
 /*
 startnotify 	controls the normal operation in PollDB
@@ -514,95 +599,91 @@
 
 */
 
-	char      *buffer;
-	time_t    now;
+	char *buffer;
+	int  conn_c = connection->socket_fd;
 
 	if((buffer=calloc(LISTBUFFER,1)) == 0){
 		sysfatal("can't malloc buffer in CreamConnection: %r");
 	}
 
-	while ( 1 ) {
-	
-		do_log(debuglogfile, debug, 1, "Listening for new connection in CreamConnection\n");
-		if ( (conn_c = accept(c_sock, NULL, NULL) ) < 0 ) {
-			do_log(debuglogfile, debug, 1, "Fatal Error:Error calling accept() on c_sock in CreamConnection\n");
-			sysfatal("Error calling accept() in CreamConnection: %r");
-		}
-		while ( 1 ) {
-			*buffer = 0;
-			if(Readline(conn_c, buffer, LISTBUFFER-1)<=0){
-				close(conn_c);
-				creamisconn=FALSE;
-				break;
-			}
-
-			if(strlen(buffer)>0){
-				do_log(debuglogfile, debug, 1, "Received for Cream:%s\n",buffer);
-				if(buffer && strstr(buffer,"STARTNOTIFY/")!=NULL){
-					NotifyStart(buffer);
-					startnotify=TRUE;
-					firstnotify=TRUE;
-				} else if(buffer && strstr(buffer,"STARTNOTIFYJOBLIST/")!=NULL){
-					GetJobList(buffer);
-					startnotifyjob=TRUE;
-					startnotify=FALSE;
-                               	} else if(buffer && strstr(buffer,"STARTNOTIFYJOBEND/")!=NULL){
-					firstnotify=TRUE;
-					now=time(NULL);
-					lastnotiftime=now;
-				} else if(buffer && strstr(buffer,"CREAMFILTER/")!=NULL){
-                                        GetFilter(buffer);
-					creamisconn=TRUE;
-					sentendonce=TRUE;
-				} else if(buffer && strstr(buffer,"PARSERVERSION/")!=NULL){
-                                        GetVersion();
-                                }
+	while (Readline(conn_c, buffer, LISTBUFFER-1) > 0) {
+		if(strlen(buffer) > 0)
+		{
+			do_log(debuglogfile, debug, 1, "Received for Cream:%s\n", buffer);
+			if (strstr(buffer,"STARTNOTIFY/") != NULL) {
+				NotifyStart(buffer, &(connection->lastnotiftime));
+				connection->startnotify=TRUE;
+				connection->firstnotify=TRUE;
+			} else if (strstr(buffer,"STARTNOTIFYJOBLIST/") != NULL) {
+				GetJobList(buffer, &(connection->joblist_string));
+				connection->startnotifyjob = TRUE;
+				connection->startnotify = FALSE;
+			} else if (strstr(buffer,"STARTNOTIFYJOBEND/") != NULL) {
+				connection->firstnotify=TRUE;
+				connection->lastnotiftime = time(NULL);
+			} else if (strstr(buffer,"CREAMFILTER/") != NULL) {
+				GetFilter(buffer, connection->socket_fd, &(connection->creamfilter));
+				connection->creamisconn=TRUE;
+				connection->sentendonce=TRUE;
+			} else if (strstr(buffer,"PARSERVERSION/") != NULL) {
+				GetVersion(connection->socket_fd);
 			}
 		}
-	} 
+	}
+	connection->creamisconn=FALSE;
+	close(conn_c);
+	free(buffer);
+	connection->socket_fd = 0;
+	if (connection->creamfilter) 
+	{
+		free(connection->creamfilter);
+		connection->creamfilter = NULL;
+	}
 }
 
 int 
-GetVersion()
+GetVersion(const int conn_c)
 {
 
 	char *out_buf;
 
-	out_buf=make_message("%s__1\n",VERSION);
-	Writeline(conn_c, out_buf, strlen(out_buf));
-	do_log(debuglogfile, debug, 1, "Sent Reply for PARSERVERSION command:%s\n",out_buf);
-	free(out_buf);
-	
-	return 0;
-	
+	if ((out_buf = make_message("%s__1\n", VERSION)) != NULL)
+	{
+		Writeline(conn_c, out_buf, strlen(out_buf));
+		do_log(debuglogfile, debug, 1, "Sent Reply for PARSERVERSION command:%s\n",out_buf);
+		free(out_buf);
+		return 0;
+	}
+	else
+		return 1;
 }
 
 int 
-GetFilter(char *buffer)
+GetFilter(char *buffer, const int conn_c, char **creamfilter)
 {
 
-        int  maxtok;
-        char **tbuf;
-        char *cp=NULL;
-        char * out_buf;
+	int  maxtok;
+	char **tbuf;
+	char *cp=NULL;
+	char * out_buf;
 
-        maxtok=strtoken(buffer,'/',&tbuf);
+	maxtok = strtoken(buffer,'/',&tbuf);
 
-        if(tbuf[1]){
-		creamfilter=make_message("%s",tbuf[1]);
-        	if(creamfilter == NULL){
-                	sysfatal("strdup failed for creamfilter in GetFilter: %r");
-        	}
-                if ((cp = strrchr (creamfilter, '\n')) != NULL){
-                	*cp = '\0';
-                }
-                if ((cp = strrchr (creamfilter, '\r')) != NULL){
-                	*cp = '\0';
-                }
-		out_buf=make_message("CREAMFILTER set to %s\n",creamfilter);
+	if(tbuf[1]){
+		*creamfilter = make_message("%s",tbuf[1]);
+		if(*creamfilter == NULL){
+			sysfatal("strdup failed for creamfilter in GetFilter: %r");
+		}
+		if ((cp = strrchr (*creamfilter, '\n')) != NULL) {
+			*cp = '\0';
+		} 
+		if ((cp = strrchr (*creamfilter, '\r')) != NULL) {
+			*cp = '\0';
+		}
+		out_buf = make_message("CREAMFILTER set to %s\n", *creamfilter);
 
-        }else{
-		out_buf=make_message("CREAMFILTER ERROR\n");
+	} else {
+		out_buf = make_message("CREAMFILTER ERROR\n");
 	}
 		
 	Writeline(conn_c, out_buf, strlen(out_buf));
@@ -610,109 +691,100 @@
 	do_log(debuglogfile, debug, 1, "Sent Reply for CREAMFILTER command:%s\n",out_buf);
 
 	freetoken(&tbuf,maxtok);
-        free(out_buf);
+	free(out_buf);
 	
-        return 0;
-
+	return 0;
 }
 
 int 
-NotifyStart(char *buffer)
+NotifyStart(char *buffer, time_t *lastnotiftime)
 {
 
-        int  maxtok;
-        char **tbuf;
-        char *cp=NULL;
+	int  maxtok;
+	char **tbuf;
+	char *cp=NULL;
 	char *notifdate=NULL;
-        time_t   notifepoch;
 	
-        maxtok=strtoken(buffer,'/',&tbuf);
+	maxtok = strtoken(buffer,'/',&tbuf);
 
-        if(tbuf[1]){
-                notifdate=strdup(tbuf[1]);
-        	if(notifdate == NULL){
-                	sysfatal("strdup failed for notifdate in NotifyStart: %r");
-        	}
-                if ((cp = strrchr (notifdate, '\n')) != NULL){
-                        *cp = '\0';
-                }
-                if ((cp = strrchr (notifdate, '\r')) != NULL){
-                        *cp = '\0';
-                }
-        }
+	if(tbuf[1]){
+		notifdate=strdup(tbuf[1]);
+		if(notifdate == NULL){
+			sysfatal("strdup failed for notifdate in NotifyStart: %r");
+		}
+		if ((cp = strrchr (notifdate, '\n')) != NULL){
+			*cp = '\0';
+		}
+		if ((cp = strrchr (notifdate, '\r')) != NULL){
+			*cp = '\0';
+		}
+	}
 
 	freetoken(&tbuf,maxtok);
 
-	notifepoch=str2epoch(notifdate,"S");
+	*lastnotiftime = str2epoch(notifdate,"S");
 	free(notifdate);
 
-	lastnotiftime=notifepoch;
-	
 	return 0;
-
 }
 
 int 
-GetJobList(char *buffer)
+GetJobList(char *buffer, char **joblist_string)
 {
 
-        int  maxtok;
-        char **tbuf;
-        char *cp=NULL;
-	
-        maxtok=strtoken(buffer,'/',&tbuf);
+	int  maxtok;
+	char **tbuf;
+	char *cp=NULL;
 
-        if(tbuf[1]){
-                joblist_string=strdup(tbuf[1]);
-        	if(joblist_string == NULL){
-                	sysfatal("strdup failed for joblist_string in GetJobList: %r");
-        	}
-                if ((cp = strrchr (joblist_string, '\n')) != NULL){
-                        *cp = '\0';
-                }
-                if ((cp = strrchr (joblist_string, '\r')) != NULL){
-                        *cp = '\0';
-                }
-        }
+	maxtok=strtoken(buffer,'/',&tbuf);
+
+	if(tbuf[1]){
+		*joblist_string = strdup(tbuf[1]);
+		if(*joblist_string == NULL){
+			sysfatal("strdup failed for joblist_string in GetJobList: %r");
+		}
+		if ((cp = strrchr(*joblist_string, '\n')) != NULL) {
+			*cp = '\0';
+		} 
+		if ((cp = strrchr(*joblist_string, '\r')) != NULL){
+			*cp = '\0';
+		}
+	}
 
 	freetoken(&tbuf,maxtok);
 
 	return 0;
-
 }
 
 
 int
-NotifyCream(char *buffer)
+NotifyCream(char *buffer, creamConnection_t *connection)
 {
 
 	int      retcod;
-        
 	struct   pollfd fds[2];
-	struct   pollfd *pfds;
-	int      nfds = 1;
+
+	if (connection->creamfilter == NULL) return -1;
     
-	fds[0].fd = conn_c;
-	fds[0].events = 0;
+	fds[0].fd = connection->socket_fd;
 	fds[0].events = ( POLLOUT | POLLPRI | POLLERR | POLLHUP | POLLNVAL ) ;
-	pfds = fds;    
     
-	if(!creamisconn){
+	if(!connection->creamisconn){
 		return -1;
 	}
-    
-	retcod = poll(pfds, nfds, bfunctions_poll_timeout); 
+	
+	retcod = poll(fds, 1, bfunctions_poll_timeout); 
         
-	if(retcod <0){
-		close(conn_c);
+	if (retcod < 0) {
+		free_cream_connection(connection);
 		do_log(debuglogfile, debug, 1, "Fatal Error:Poll error in NotifyCream errno:%d\n",errno);
 		sysfatal("Poll error in NotifyCream: %r");
-	}else if ( retcod == 0 ){
+	} else if ( retcod == 0 ) {
 		do_log(debuglogfile, debug, 1, "Error:poll() timeout in NotifyCream\n");
 		syserror("poll() timeout in NotifyCream: %r");
 		return -1;
-	}else if ( retcod > 0 ){
-		if ( ( fds[0].revents & ( POLLERR | POLLNVAL | POLLHUP) )){
+	} else if ( retcod > 0 ) {
+		if (( fds[0].revents & ( POLLERR | POLLNVAL | POLLHUP) )){
 			switch (fds[0].revents){
 			case POLLNVAL:
 				do_log(debuglogfile, debug, 1, "Error:poll() file descriptor error in NotifyCream\n");
@@ -728,8 +800,7 @@
 				return -1;
 			}
 		} else {
-			
-			Writeline(conn_c, buffer, strlen(buffer));
+			Writeline(connection->socket_fd, buffer, strlen(buffer));
 			do_log(debuglogfile, debug, 1, "Sent for Cream:%s",buffer);
 		} 
 	}       
@@ -738,7 +809,59 @@
 
 }
 
-void sighup()
+int
+get_socket_by_creamprefix(const char* prefix)
+{
+	int i;
+
+	for(i=0; i<MAX_CONNECTIONS; i++)
+		if (connections[i].creamfilter != NULL && 
+                    strcmp(prefix, connections[i].creamfilter) == 0)
+			return connections[i].socket_fd;
+
+	return 0; /* creamfilter not found */
+}
+
+int
+add_cream_connection(const int socket_fd)
+/* This must be invoked by the main thread only */
+{
+	int i;
+
+	for(i=0; i<MAX_CONNECTIONS && connections[i].socket_fd != 0; i++);
+
+	if (i<MAX_CONNECTIONS)
+	{
+		connections[i].socket_fd = socket_fd;
+		pthread_create(&(connections[i].serving_thread), NULL, (void *(*)(void *))CreamConnection, (void *)(connections+i));
+		return 0;
+	}
+	else
+		return -1;
+}
+
+int
+free_cream_connection(creamConnection_t *connection)
+{
+	if (connection->socket_fd) close(connection->socket_fd);
+	if (connection->creamfilter) free (connection->creamfilter);
+	if (connection->joblist_string) free (connection->joblist_string);
+
+	connection->creamfilter = NULL;
+	connection->socket_fd = 0;
+	connection->lastnotiftime = 0;
+	connection->serving_thread = 0;
+	connection->startnotify = FALSE;
+	connection->startnotifyjob = FALSE;
+	connection->firstnotify = FALSE;
+	connection->sentendonce = FALSE;
+	connection->joblist_string = NULL;
+
+	return 0;
+}
+
+void
+sighup()
 {
         if(debug){
                 fclose(debuglogfile);
diff -ur blahp-condor/src/BNotifier.h blahp-osg/src/BNotifier.h
--- blahp-condor/src/BNotifier.h	2011-01-24 07:38:51.000000000 -0600
+++ blahp-osg/src/BNotifier.h	2016-04-26 11:19:29.415397740 -0500
@@ -22,12 +22,15 @@
 # 
 */
 
+#include "acconfig.h"
+
 #include "job_registry.h"
 #include "Bfunctions.h"
 #include "config.h"
 
 #define LISTENQ            1024
 #define LISTBUFFER         5000000
+#define MAX_CONNECTIONS    8
 
 #define DEFAULT_LOOP_INTERVAL 5
 
@@ -35,47 +38,37 @@
 #define VERSION            "1.8.0"
 #endif
 
+typedef struct creamConnection {
+	char      *creamfilter;
+	int       socket_fd;
+	time_t    lastnotiftime;
+	pthread_t serving_thread;
+	int       startnotify;
+	int       startnotifyjob;
+	int       firstnotify;
+	int       sentendonce;
+	int       creamisconn;
+	char      *joblist_string;
+	char      *finalbuffer;
+} creamConnection_t;
+
+#define EMPTY_CONNECTION {NULL,0,0,0,0,0,0,0,0,NULL,NULL}
+
 /*  Function declarations  */
 
 int PollDB();
 char *ComposeClassad(job_registry_entry *en);
-int NotifyStart(char *buffer);
-int GetVersion();
-int GetFilter(char *buffer);
-int GetJobList(char *buffer);
-void CreamConnection(int c_sock);
-int NotifyCream(char *buffer);
+int NotifyStart(char *buffer, time_t *lastnotiftime);
+int GetVersion(const int conn_c);
+int GetFilter(char *buffer, const int conn_c, char **creamfilter);
+int GetJobList(char *buffer, char **joblist_string);
+void CreamConnection(creamConnection_t *connection);
+int NotifyCream(char *buffer, creamConnection_t *connection);
 void sighup();
 int usage();
 int short_usage();
+int get_socket_by_creamprefix(const char* prefix);
+int add_cream_connection(const int socket_fd);
+int free_cream_connection(creamConnection_t *connection);
 
-/* Variables initialization */
-
-char *progname="BNotifier";
-
-char *registry_file;
-
-char *creamfilter="";
-
-int async_notif_port;
-
-int debug=FALSE;
-int nodmn=FALSE;
-
-FILE *debuglogfile;
-char *debuglogname;
-
-int  conn_c=-1;
-int  c_sock;
-
-int creamisconn=FALSE;
-int startnotify=FALSE;
-int startnotifyjob=FALSE;
-int firstnotify=FALSE;
-int sentendonce=FALSE;
-
-char *joblist_string="";
-
-int loop_interval=DEFAULT_LOOP_INTERVAL;
 
-time_t lastnotiftime;
diff -ur blahp-condor/src/BUpdaterCondor.c blahp-osg/src/BUpdaterCondor.c
--- blahp-condor/src/BUpdaterCondor.c	2011-12-15 04:07:35.000000000 -0600
+++ blahp-osg/src/BUpdaterCondor.c	2016-04-26 11:19:29.422397084 -0500
@@ -32,11 +32,15 @@
 	time_t purge_time=0;
 	time_t last_consistency_check=0;
 	char *constraint=NULL;
+	char *tconstraint=NULL;
 	char *query=NULL;
 	char *q=NULL;
 	char *pidfile=NULL;
 	char *first_duplicate=NULL;
 	
+	struct pollfd *remupd_pollset = NULL;
+	int remupd_nfds;
+	
 	int version=0;
 	int qlen=0;
 	int first=TRUE;
@@ -44,7 +48,12 @@
 	int loop_interval=DEFAULT_LOOP_INTERVAL;
 	
 	int c;				
+	int condor_ver=0;
+	int max_constr_len=0;
+	char *toadd=NULL;
 	
+	pthread_t RecUpdNetThd;
+
 	int confirm_time=0;	
 
         static int help;
@@ -57,12 +66,13 @@
 		{"usage",     no_argument,     &short_help, 1},
 		{"nodaemon",  no_argument,       0, 'o'},
 		{"version",   no_argument,       0, 'v'},
+		{"prefix",    required_argument, 0, 'p'},
 		{0, 0, 0, 0}
 		};
 
 		int option_index = 0;
      
-		c = getopt_long (argc, argv, "vo",long_options, &option_index);
+		c = getopt_long (argc, argv, "vop:",long_options, &option_index);
      
 		if (c == -1){
 			break;
@@ -84,6 +94,9 @@
 			nodmn=1;
 			break;
 
+		case 'p':
+			break;
+
 		case '?':
 			break;
      
@@ -237,15 +250,39 @@
 	}
 	
 	batch_command=(strcmp(condor_batch_caching_enabled,"yes")==0?make_message("%s ",batch_command_caching_filter):make_message(""));
-	
+
 	ret = config_get("job_registry_use_mmap",cha);
 	if (ret == NULL){
 		do_log(debuglogfile, debug, 1, "%s: key job_registry_use_mmap not found. Default is NO\n",argv0);
 	} else {
 		do_log(debuglogfile, debug, 1, "%s: key job_registry_use_mmap is set to %s\n",argv0,ret->value);
 	}
+	
+	remupd_conf = config_get("job_registry_add_remote",cha);
+	if (remupd_conf == NULL){
+		do_log(debuglogfile, debug, 1, "%s: key job_registry_add_remote not found\n",argv0);
+	}else{
+		if (job_registry_updater_setup_receiver(remupd_conf->values,remupd_conf->n_values,&remupd_head) < 0){
+			do_log(debuglogfile, debug, 1, "%s: Cannot set network receiver(s) up for remote update\n",argv0);
+			fprintf(stderr,"%s: Cannot set network receiver(s) up for remote update \n",argv0);
+       		}
+ 
+		if (remupd_head == NULL){
+			do_log(debuglogfile, debug, 1, "%s: Cannot find values for network endpoints in configuration file (attribute 'job_registry_add_remote').\n",argv0);
+			fprintf(stderr,"%s: Cannot find values for network endpoints in configuration file (attribute 'job_registry_add_remote').\n", argv0);
+		}
 
-
+		if ((remupd_nfds = job_registry_updater_get_pollfd(remupd_head, &remupd_pollset)) < 0){
+			do_log(debuglogfile, debug, 1, "%s: Cannot setup poll set for receiving data.\n",argv0);
+    			fprintf(stderr,"%s: Cannot setup poll set for receiving data.\n", argv0);
+		}
+		if (remupd_pollset == NULL || remupd_nfds == 0){
+			do_log(debuglogfile, debug, 1, "%s: No poll set available for receiving data.\n",argv0);
+			fprintf(stderr,"%s: No poll set available for receiving data.\n",argv0);
+		}
+	
+	}
+	
 	if( !nodmn ) daemonize();
 
 
@@ -254,8 +291,6 @@
 		free(pidfile);
 	}
 	
-	config_free(cha);
-	
 	rha=job_registry_init(registry_file, BY_BATCH_ID);
 	if (rha == NULL){
 		do_log(debuglogfile, debug, 1, "%s: Error initialising job registry %s\n",argv0,registry_file);
@@ -263,6 +298,31 @@
 		perror("");
 	}
 
+	if (remupd_conf != NULL){
+		pthread_create(&RecUpdNetThd, NULL, (void *(*)(void *))ReceiveUpdateFromNetwork, (void *)NULL);
+		
+		if (job_registry_updater_setup_sender(remupd_conf->values,remupd_conf->n_values,0,&remupd_head_send) < 0){
+			do_log(debuglogfile, debug, 1, "%s: Cannot set network sender(s) up for remote update\n",argv0);
+			fprintf(stderr,"%s: Cannot set network sender(s) up for remote update \n",argv0);
+       		}
+		if (remupd_head_send == NULL){
+			do_log(debuglogfile, debug, 1, "%s: Cannot find values for network endpoints in configuration file (attribute 'job_registry_add_remote').\n",argv0);
+			fprintf(stderr,"%s: Cannot find values for network endpoints in configuration file (attribute 'job_registry_add_remote').\n", argv0);
+		}
+	}
+	
+	config_free(cha);
+	
+	/* Get condor version to use or not a workaround for a bug in the max length of the constraint (-constraint) string
+	   that can be passed to condor_history. The limit is 511 byte if the version is prior 5.6.2 and 5.7.0*/
+	   
+	condor_ver=GetCondorVersion();
+	if(condor_ver>=762){
+		max_constr_len=511;
+	}else{
+		max_constr_len=-1;
+	}	
+
 	for(;;){
 		/* Purge old entries from registry */
 		now=time(0);
@@ -330,17 +390,35 @@
 				
 				if(now-confirm_time>finalstate_query_interval){
 					/* create the constraint that will be used in condor_history command in FinalStateQuery*/
-					if(!first) strcat(query," ||");	
+					if(first){
+						toadd=make_message("");
+					}else{
+						toadd=make_message(" || ");
+					}	
 					if(first) first=FALSE;
-					constraint=make_message(" ClusterId==%s",en->batch_id);
 					
-					if (query != NULL) qlen = strlen(query);
-					else               qlen = 0;
+					tconstraint=make_message("ClusterId==%s",en->batch_id);
+					
+					if (query != NULL){
+						qlen = strlen(query);
+					}else{
+						qlen = 0;
+					}
+					if(max_constr_len > 0 && tconstraint && ((strlen(tconstraint)+qlen)>max_constr_len)){
+						constraint=make_message(";%s",tconstraint);
+					}else{
+						constraint=make_message("%s%s",toadd,tconstraint);
+					}
+					free(tconstraint);
+					
 					q=realloc(query,qlen+strlen(constraint)+4);
 					
 					if(q != NULL){
-						if (query != NULL) strcat(q,constraint);
-						else               strcpy(q,constraint);
+						if (query != NULL){
+							strcat(q,constraint);
+						}else{
+							strcpy(q,constraint);
+						}
 						query=q;	
 					}else{
 						sysfatal("can't realloc query: %r");
@@ -370,6 +448,71 @@
 	
 }
 
+int 
+ReceiveUpdateFromNetwork()
+{
+	char *proxy_path, *proxy_subject;
+	int timeout_ms = 0;
+	int ent, ret, prret, rhret;
+	job_registry_entry *nen;
+	job_registry_entry *ren;
+  
+	proxy_path = NULL;
+	proxy_subject = NULL;
+	
+	while (nen = job_registry_receive_update(remupd_pollset, remupd_nfds,timeout_ms, &proxy_subject, &proxy_path)){
+	
+		JOB_REGISTRY_ASSIGN_ENTRY(nen->subject_hash,"\0");
+		JOB_REGISTRY_ASSIGN_ENTRY(nen->proxy_link,"\0");
+		
+		if ((ren=job_registry_get(rha, nen->batch_id)) == NULL){
+			if ((ret=job_registry_append(rha, nen)) < 0){
+				fprintf(stderr,"%s: Warning: job_registry_append returns %d: ",argv0,ret);
+				perror("");
+			} 
+		}else{
+		
+			if(ren->subject_hash!=NULL && strlen(ren->subject_hash) && ren->proxy_link!=NULL && strlen(ren->proxy_link)){
+				JOB_REGISTRY_ASSIGN_ENTRY(nen->subject_hash,ren->subject_hash);
+				JOB_REGISTRY_ASSIGN_ENTRY(nen->proxy_link,ren->proxy_link);
+			}else{
+				if (proxy_path != NULL && strlen(proxy_path) > 0){
+					prret = job_registry_set_proxy(rha, nen, proxy_path);
+     			 		if (prret < 0){
+						do_log(debuglogfile, debug, 1, "%s: warning: setting proxy to %s\n",argv0,proxy_path);
+        					fprintf(stderr,"%s: warning: setting proxy to %s: ",argv0,proxy_path);
+        					perror("");
+        					/* Make sure we don't renew non-existing proxies */
+						nen->renew_proxy = 0;  		
+					}
+					free(proxy_path);
+  
+					nen->subject_hash[0] = '\000';
+					if (proxy_subject != NULL && strlen(proxy_subject) > 0){
+						job_registry_compute_subject_hash(nen, proxy_subject);
+						rhret = job_registry_record_subject_hash(rha, nen->subject_hash, proxy_subject, TRUE);  
+						if (rhret < 0){
+							do_log(debuglogfile, debug, 1, "%s: warning: recording proxy subject %s (hash %s)\n",argv0, proxy_subject, nen->subject_hash);
+							fprintf(stderr,"%s: warning: recording proxy subject %s (hash %s): ",argv0, proxy_subject, nen->subject_hash);
+							perror("");
+						}
+					}
+					free(proxy_subject);
+  
+				}
+			}
+			if(job_registry_need_update(ren,nen,JOB_REGISTRY_UPDATE_ALL)){
+				if ((ret=job_registry_update(rha, nen)) < 0){
+					fprintf(stderr,"%s: Warning: job_registry_update returns %d: ",argv0,ret);
+					perror("");
+				}
+			} 
+		}
+		free(nen);
+	}
+  
+	return 0;
+}
 
 int
 IntStateQuery()
@@ -456,6 +599,11 @@
 						}else{
 							do_log(debuglogfile, debug, 2, "%s: registry update in IntStateQuery for: jobid=%s creamjobid=%s wn=%s status=%d\n",argv0,en.batch_id,en.user_prefix,en.wn_addr,en.status);
 						}
+						if (remupd_conf != NULL){
+							if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+								do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in IntStateQuery\n",argv0);
+							}
+						}
 					}
 				}
 			}
@@ -496,67 +644,81 @@
         FILE *fp;
 	char *line=NULL;
 	char **token;
+	char **ctoken;
 	int maxtok_t=0;
+	int maxtok_c=0;
 	job_registry_entry en;
 	int ret=0;
 	char *cp=NULL; 
 	char *command_string=NULL;
 	time_t now;
 	char *string_now=NULL;
+	int k=0;
 
-	command_string=make_message("%s%s/condor_history -constraint \"%s\" -format \"%%d \" ClusterId -format \"%%s \" Owner -format \"%%d \" JobStatus -format \"%%s \" Cmd -format \"%%s \" ExitStatus -format \"%%s\\n\" EnteredCurrentStatus",batch_command,condor_binpath,query);
-	do_log(debuglogfile, debug, 2, "%s: command_string in FinalStateQuery:%s\n",argv0,command_string);
-	fp = popen(command_string,"r");
+	maxtok_c = strtoken(query, ';', &ctoken);
 
-	if(fp!=NULL){
-		while(!feof(fp) && (line=get_line(fp))){
-			do_log(debuglogfile, debug, 3, "%s: Line in FSQ:%s\n",argv0,line);
-			if(line && (strlen(line)==0 || strncmp(line,"JOBID",5)==0)){
-				free(line);
-				continue;
-			}
-			if ((cp = strrchr (line, '\n')) != NULL){
-				*cp = '\0';
-			}
+	for(k=0;k<maxtok_c;k++){
+		command_string=make_message("%s%s/condor_history -constraint \"%s\" -format \"%%d \" ClusterId -format \"%%s \" Owner -format \"%%d \" JobStatus -format \"%%s \" Cmd -format \"%%s \" ExitStatus -format \"%%s\\n\" EnteredCurrentStatus",batch_command,condor_binpath,ctoken[k]);
+		do_log(debuglogfile, debug, 2, "%s: command_string in FinalStateQuery:%s\n",argv0,command_string);
+		fp = popen(command_string,"r");
+
+		if(fp!=NULL){
+			while(!feof(fp) && (line=get_line(fp))){
+				do_log(debuglogfile, debug, 3, "%s: Line in FSQ:%s\n",argv0,line);
+				if(line && (strlen(line)==0 || strncmp(line,"JOBID",5)==0)){
+					free(line);
+					continue;
+				}
+				if ((cp = strrchr (line, '\n')) != NULL){
+					*cp = '\0';
+				}
+				
+				maxtok_t = strtoken(line, ' ', &token);
+				if (maxtok_t < 6){
+					freetoken(&token,maxtok_t);
+					free(line);
+					continue;
+				}
+				
+				now=time(0);
+				string_now=make_message("%d",now);
 			
-			maxtok_t = strtoken(line, ' ', &token);
-			if (maxtok_t < 6){
-				freetoken(&token,maxtok_t);
-				free(line);
-				continue;
-			}
-			now=time(0);
-			string_now=make_message("%d",now);
-
-			JOB_REGISTRY_ASSIGN_ENTRY(en.batch_id,token[0]);
-			JOB_REGISTRY_ASSIGN_ENTRY(en.updater_info,string_now);
-			en.status=atoi(token[2]);
-			en.exitcode=atoi(token[4]);
-			en.udate=atoi(token[5]);
-                	JOB_REGISTRY_ASSIGN_ENTRY(en.wn_addr,"\0");
-                	JOB_REGISTRY_ASSIGN_ENTRY(en.exitreason,"\0");
-		
-			if(en.status!=UNDEFINED && en.status!=IDLE){	
-				if ((ret=job_registry_update(rha, &en)) < 0){
-					if(ret != JOB_REGISTRY_NOT_FOUND){
-						fprintf(stderr,"Update of record returns %d: ",ret);
-						perror("");
-					}
-				} else {
-					do_log(debuglogfile, debug, 2, "%s: registry update in FinalStateQuery for: jobid=%s creamjobid=%s wn=%s status=%d\n",argv0,en.batch_id,en.user_prefix,en.wn_addr,en.status);
-					if (en.status == REMOVED || en.status == COMPLETED){
-						job_registry_unlink_proxy(rha, &en);
+				JOB_REGISTRY_ASSIGN_ENTRY(en.batch_id,token[0]);
+				JOB_REGISTRY_ASSIGN_ENTRY(en.updater_info,string_now);
+				en.status=atoi(token[2]);
+				en.exitcode=atoi(token[4]);
+				en.udate=atoi(token[5]);
+		        	JOB_REGISTRY_ASSIGN_ENTRY(en.wn_addr,"\0");
+		        	JOB_REGISTRY_ASSIGN_ENTRY(en.exitreason,"\0");
+			
+				if(en.status!=UNDEFINED && en.status!=IDLE){	
+					if ((ret=job_registry_update(rha, &en)) < 0){
+						if(ret != JOB_REGISTRY_NOT_FOUND){
+							fprintf(stderr,"Update of record returns %d: ",ret);
+							perror("");
+						}
+					} else {
+						do_log(debuglogfile, debug, 2, "%s: registry update in FinalStateQuery for: jobid=%s creamjobid=%s wn=%s status=%d\n",argv0,en.batch_id,en.user_prefix,en.wn_addr,en.status);
+						if (en.status == REMOVED || en.status == COMPLETED){
+							job_registry_unlink_proxy(rha, &en);
+						}
+						if (remupd_conf != NULL){
+							if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+								do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in FinalStateQuery\n",argv0);
+							}
+						}
 					}
 				}
+				freetoken(&token,maxtok_t);
+				free(string_now);
+				free(line);
 			}
-			freetoken(&token,maxtok_t);
-			free(line);
-			free(string_now);
+			pclose(fp);
 		}
-		pclose(fp);
-	}
 
-	free(command_string);
+		free(command_string);
+	}
+	freetoken(&ctoken,maxtok_c);
 	return 0;
 }
 
@@ -583,11 +745,48 @@
 	} else {
 		do_log(debuglogfile, debug, 2, "%s: registry update in AssignStateQuery for: jobid=%s creamjobid=%s status=%d\n",argv0,en.batch_id,en.user_prefix,en.status);
 		job_registry_unlink_proxy(rha, &en);
+		if (remupd_conf != NULL){
+			if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+				do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in AssignFinalState\n",argv0);
+			}
+		}
 	}
 	
 	return 0;
 }
 
+int GetCondorVersion(){
+
+        char *command_string=NULL;
+        FILE *fp;
+        char *line=NULL;
+        char **token;
+        int maxtok_t=0;
+        char *condor_version=NULL;
+        int c_version=0;
+        char *cp=NULL;
+
+	command_string=make_message("%s/condor_version",condor_binpath);
+        fp = popen(command_string,"r");
+
+        if(fp!=NULL){
+                while(!feof(fp) && (line=get_line(fp))){
+                        if ((cp = strrchr (line, '\n')) != NULL){
+                                *cp = '\0';
+                        }
+
+                        if(line && strstr(line,"CondorVersion")!=0){
+                                maxtok_t = strtoken(line, ' ', &token);
+                                condor_version=strdel(token[1],".");
+                                freetoken(&token,maxtok_t);
+                                break;
+                        }
+                }
+        }
+        c_version=atoi(condor_version);
+        return c_version;
+}
+
 void sighup()
 {
         if(debug){
diff -ur blahp-condor/src/BUpdaterCondor.h blahp-osg/src/BUpdaterCondor.h
--- blahp-condor/src/BUpdaterCondor.h	2011-09-09 05:00:08.000000000 -0500
+++ blahp-osg/src/BUpdaterCondor.h	2016-04-26 11:19:29.423396914 -0500
@@ -22,7 +22,10 @@
 # 
 */
 
+#include "acconfig.h"
+
 #include "job_registry.h"
+#include "job_registry_updater.h"
 #include "Bfunctions.h"
 #include "config.h"
 
@@ -32,9 +35,11 @@
 #define VERSION            "1.8.0"
 #endif
 
+int ReceiveUpdateFromNetwork();
 int IntStateQuery();
 int FinalStateQuery(char *query);
 int AssignFinalState(char *batchid);
+int GetCondorVersion();
 void sighup();
 int usage();
 int short_usage(); 
@@ -60,3 +65,8 @@
 config_entry *ret;
 char *progname="BUpdaterCondor";
 
+struct pollfd *remupd_pollset = NULL;
+int remupd_nfds;
+job_registry_updater_endpoint *remupd_head = NULL;
+job_registry_updater_endpoint *remupd_head_send = NULL;
+config_entry *remupd_conf;
diff -ur blahp-condor/src/BUpdaterLSF.c blahp-osg/src/BUpdaterLSF.c
--- blahp-condor/src/BUpdaterLSF.c	2012-03-08 03:47:11.000000000 -0600
+++ blahp-osg/src/BUpdaterLSF.c	2016-04-26 11:19:29.425396323 -0500
@@ -34,6 +34,9 @@
 	char *pidfile=NULL;
 	char *first_duplicate=NULL;
 	
+	struct pollfd *remupd_pollset = NULL;
+	int remupd_nfds;
+	
 	int version=0;
 	int first=TRUE;
 	int tmptim;
@@ -42,12 +45,15 @@
 	
 	int rc;				
 	int c;				
+	int status;
 	
+	pthread_t RecUpdNetThd;
+
 	int confirm_time=0;	
 
         static int help;
         static int short_help;
-
+	
         struct stat sbuf;
         char *s;
 	
@@ -61,12 +67,13 @@
 		{"usage",     no_argument,     &short_help, 1},
 		{"nodaemon",  no_argument,       0, 'o'},
 		{"version",   no_argument,       0, 'v'},
+		{"prefix",    required_argument, 0, 'p'},
 		{0, 0, 0, 0}
 		};
 
 		int option_index = 0;
      
-		c = getopt_long (argc, argv, "vo",long_options, &option_index);
+		c = getopt_long (argc, argv, "vop:",long_options, &option_index);
      
 		if (c == -1){
 			break;
@@ -88,6 +95,9 @@
 			nodmn=1;
 			break;
 
+		case 'p':
+			break;
+
 		case '?':
 			break;
      
@@ -308,6 +318,16 @@
                 }
 	}
 	
+	ret = config_get("bupdater_use_bhist_for_idle",cha);
+	if (ret == NULL){
+		do_log(debuglogfile, debug, 1, "%s: key bupdater_use_bhist_for_idle not found - using the default:%s\n",argv0,use_bhist_for_idle);
+	} else {
+		use_bhist_for_idle=strdup(ret->value);
+                if(use_bhist_for_idle == NULL){
+                        sysfatal("strdup failed for use_bhist_for_idle in main: %r");
+                }
+	}
+	
 	ret = config_get("lsf_batch_caching_enabled",cha);
 	if (ret == NULL){
 		do_log(debuglogfile, debug, 1, "%s: key lsf_batch_caching_enabled not found using default\n",argv0,lsf_batch_caching_enabled);
@@ -336,7 +356,32 @@
 	} else {
 		do_log(debuglogfile, debug, 1, "%s: key job_registry_use_mmap is set to %s\n",argv0,ret->value);
 	}
+	
+	remupd_conf = config_get("job_registry_add_remote",cha);
+	if (remupd_conf == NULL){
+		do_log(debuglogfile, debug, 1, "%s: key job_registry_add_remote not found\n",argv0);
+	}else{
+		if (job_registry_updater_setup_receiver(remupd_conf->values,remupd_conf->n_values,&remupd_head) < 0){
+			do_log(debuglogfile, debug, 1, "%s: Cannot set network receiver(s) up for remote update\n",argv0);
+			fprintf(stderr,"%s: Cannot set network receiver(s) up for remote update \n",argv0);
+       		}
+ 
+		if (remupd_head == NULL){
+			do_log(debuglogfile, debug, 1, "%s: Cannot find values for network endpoints in configuration file (attribute 'job_registry_add_remote').\n",argv0);
+			fprintf(stderr,"%s: Cannot find values for network endpoints in configuration file (attribute 'job_registry_add_remote').\n", argv0);
+		}
 
+		if ((remupd_nfds = job_registry_updater_get_pollfd(remupd_head, &remupd_pollset)) < 0){
+			do_log(debuglogfile, debug, 1, "%s: Cannot setup poll set for receiving data.\n",argv0);
+    			fprintf(stderr,"%s: Cannot setup poll set for receiving data.\n", argv0);
+		}
+		if (remupd_pollset == NULL || remupd_nfds == 0){
+			do_log(debuglogfile, debug, 1, "%s: No poll set available for receiving data.\n",argv0);
+			fprintf(stderr,"%s: No poll set available for receiving data.\n",argv0);
+		}
+	
+	}
+	
 	if( !nodmn ) daemonize();
 
 
@@ -345,15 +390,28 @@
 		free(pidfile);
 	}
 	
-	config_free(cha);
-	
 	rha=job_registry_init(registry_file, BY_BATCH_ID);
 	if (rha == NULL){
 		do_log(debuglogfile, debug, 1, "%s: Error initialising job registry %s\n",argv0,registry_file);
 		fprintf(stderr,"%s: Error initialising job registry %s :",argv0,registry_file);
 		perror("");
 	}
+	
+	if (remupd_conf != NULL){
+		pthread_create(&RecUpdNetThd, NULL, (void *(*)(void *))ReceiveUpdateFromNetwork, (void *)NULL);
+	
+		if (job_registry_updater_setup_sender(remupd_conf->values,remupd_conf->n_values,0,&remupd_head_send) < 0){
+			do_log(debuglogfile, debug, 1, "%s: Cannot set network sender(s) up for remote update\n",argv0);
+			fprintf(stderr,"%s: Cannot set network sender(s) up for remote update \n",argv0);
+       		}
+		if (remupd_head_send == NULL){
+			do_log(debuglogfile, debug, 1, "%s: Cannot find values for network endpoints in configuration file (attribute 'job_registry_add_remote').\n",argv0);
+			fprintf(stderr,"%s: Cannot find values for network endpoints in configuration file (attribute 'job_registry_add_remote').\n", argv0);
+		}
+	}
 
+	config_free(cha);
+	
 	for(;;){
 		/* Purge old entries from registry */
 		now=time(0);
@@ -378,7 +436,8 @@
 				last_consistency_check=time(0);
 			}
 		}
-	       
+		
+
 		if(use_btools && strcmp(use_btools,"yes")==0){ 
 			IntStateQueryCustom();
 		}else if(bjobs_long_format && strcmp(bjobs_long_format,"yes")==0){
@@ -425,25 +484,27 @@
 				}
 				
 				/* Try to run FinalStateQuery reading older log files*/
-				if(now-confirm_time>bhist_finalstate_interval){
-					runfinal_oldlogs=TRUE;
-					free(en);
-					continue;
-				}
-				
-				if(en->status==IDLE && strlen(en->updater_info)>0){
+                                if(now-confirm_time>bhist_finalstate_interval && use_bhist_for_idle && strcmp(use_bhist_for_idle,"yes")==0){
+                                        do_log(debuglogfile, debug, 2, "%s: FinalStateQuery needed for jobid=%s with status=%d from old logs\n",argv0,en->batch_id,en->status);
+                                        runfinal_oldlogs=TRUE;
+                                        free(en);
+                                        continue;
+                                }
+	
+				if(en->status==IDLE && strlen(en->updater_info)>0 && use_bhist_for_idle && strcmp(use_bhist_for_idle,"yes")==0){
 					if (en->mdate < finalquery_start_date){
 						finalquery_start_date=en->mdate;
 					}
-					do_log(debuglogfile, debug, 2, "%s: FinalStateQuery needed for jobid=%s with status=%d\n",argv0,en->batch_id,en->status);
+					do_log(debuglogfile, debug, 2, "%s: FinalStateQuery needed for jobid=%s with status=%d v1\n",argv0,en->batch_id,en->status);
 					runfinal=TRUE;
-				}else if((now-confirm_time>finalstate_query_interval) && (now > next_finalstatequery)){
+				}else if((now-confirm_time>finalstate_query_interval) && (now > next_finalstatequery) && use_bhist_for_idle && strcmp(use_bhist_for_idle,"yes")==0){
 					if (en->mdate < finalquery_start_date){
 						finalquery_start_date=en->mdate;
 					}
-					do_log(debuglogfile, debug, 2, "%s: FinalStateQuery needed for jobid=%s with status=%d\n",argv0,en->batch_id,en->status);
+					do_log(debuglogfile, debug, 2, "%s: FinalStateQuery needed for jobid=%s with status=%d v2\n",argv0,en->batch_id,en->status);
 					runfinal=TRUE;
-				}				
+				}
+				
 			
 			}
 			free(en);
@@ -467,6 +528,72 @@
 	
 }
 
+int 
+ReceiveUpdateFromNetwork()
+{
+	char *proxy_path, *proxy_subject;
+	int timeout_ms = 0;
+	int ent, ret, prret, rhret;
+	job_registry_entry *nen;
+	job_registry_entry *ren;
+  
+	proxy_path = NULL;
+	proxy_subject = NULL;
+	
+	while (nen = job_registry_receive_update(remupd_pollset, remupd_nfds,timeout_ms, &proxy_subject, &proxy_path)){
+	
+		JOB_REGISTRY_ASSIGN_ENTRY(nen->subject_hash,"\0");
+		JOB_REGISTRY_ASSIGN_ENTRY(nen->proxy_link,"\0");
+		
+		if ((ren=job_registry_get(rha, nen->batch_id)) == NULL){
+			if ((ret=job_registry_append(rha, nen)) < 0){
+				fprintf(stderr,"%s: Warning: job_registry_append returns %d: ",argv0,ret);
+				perror("");
+			} 
+		}else{
+		
+			if(ren->subject_hash!=NULL && strlen(ren->subject_hash) && ren->proxy_link!=NULL && strlen(ren->proxy_link)){
+				JOB_REGISTRY_ASSIGN_ENTRY(nen->subject_hash,ren->subject_hash);
+				JOB_REGISTRY_ASSIGN_ENTRY(nen->proxy_link,ren->proxy_link);
+			}else{
+				if (proxy_path != NULL && strlen(proxy_path) > 0){
+					prret = job_registry_set_proxy(rha, nen, proxy_path);
+     			 		if (prret < 0){
+						do_log(debuglogfile, debug, 1, "%s: warning: setting proxy to %s\n",argv0,proxy_path);
+        					fprintf(stderr,"%s: warning: setting proxy to %s: ",argv0,proxy_path);
+        					perror("");
+        					/* Make sure we don't renew non-existing proxies */
+						nen->renew_proxy = 0;  		
+					}
+					free(proxy_path);
+  
+					nen->subject_hash[0] = '\000';
+					if (proxy_subject != NULL && strlen(proxy_subject) > 0){
+						job_registry_compute_subject_hash(nen, proxy_subject);
+						rhret = job_registry_record_subject_hash(rha, nen->subject_hash, proxy_subject, TRUE);  
+						if (rhret < 0){
+							do_log(debuglogfile, debug, 1, "%s: warning: recording proxy subject %s (hash %s)\n",argv0, proxy_subject, nen->subject_hash);
+							fprintf(stderr,"%s: warning: recording proxy subject %s (hash %s): ",argv0, proxy_subject, nen->subject_hash);
+							perror("");
+						}
+					}
+					free(proxy_subject);
+  
+				}
+			}
+			if(job_registry_need_update(ren,nen,JOB_REGISTRY_UPDATE_ALL)){
+				if ((ret=job_registry_update(rha, nen)) < 0){
+					fprintf(stderr,"%s: Warning: job_registry_update returns %d: ",argv0,ret);
+					perror("");
+				}
+			} 
+		}
+		free(nen);
+	}
+  
+	return 0;
+}
+
 int
 IntStateQueryCustom()
 {
@@ -494,7 +621,7 @@
 	int wexitcode=0;
 	int wexitinfo=0;
 
-	command_string=make_message("%s/bjobsinfo",btools_path);
+	command_string=make_message("%s%s/bjobsinfo -a",batch_command,btools_path);
 	fp = popen(command_string,"r");
 	
 	do_log(debuglogfile, debug, 3, "%s: command in IntStateQueryCustom is:%s\n",argv0,command_string);
@@ -546,6 +673,11 @@
 						}else{
 							do_log(debuglogfile, debug, 2, "%s: registry update in IntStateQueryCustom for: jobid=%s creamjobid=%s wn=%s status=%d\n",argv0,en.batch_id,en.user_prefix,en.wn_addr,en.status);
 						}
+						if (remupd_conf != NULL){
+							if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+								do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in IntStateQueryCustom\n",argv0);
+							}
+						}
 					}
 				}
 				en.status = UNDEFINED;
@@ -610,7 +742,7 @@
 							en.status=COMPLETED;
 							en.exitcode=wexitcode;
 						}
-					}
+					}	
 				}
 				
 				en.udate=strtoul(token[6],NULL,10);
@@ -645,6 +777,11 @@
 				}else{
 					do_log(debuglogfile, debug, 2, "%s: registry update in IntStateQueryCustom for: jobid=%s creamjobid=%s wn=%s status=%d\n",argv0,en.batch_id,en.user_prefix,en.wn_addr,en.status);
 				}
+				if (remupd_conf != NULL){
+					if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+						do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in IntStateQueryCustom\n",argv0);
+					}
+				}
 			}
 		}
 	}				
@@ -739,6 +876,11 @@
 						}else{
 							do_log(debuglogfile, debug, 2, "%s: registry update in IntStateQueryShort for: jobid=%s creamjobid=%s wn=%s status=%d\n",argv0,en.batch_id,en.user_prefix,en.wn_addr,en.status);
 						}
+						if (remupd_conf != NULL){
+							if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+								do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in IntStateQueryShort\n",argv0);
+							}
+						}
 					}
 				}
 				en.status = UNDEFINED;
@@ -811,6 +953,7 @@
 				fprintf(stderr,"Update of record returns %d: ",ret);
 				perror("");
 			}
+			
 		} else {
 			if(ret==JOB_REGISTRY_SUCCESS){
 				if (en.status == REMOVED || en.status == COMPLETED) {
@@ -819,6 +962,11 @@
 				}else{
 					do_log(debuglogfile, debug, 2, "%s: registry update in IntStateQueryShort for: jobid=%s creamjobid=%s wn=%s status=%d\n",argv0,en.batch_id,en.user_prefix,en.wn_addr,en.status);
 				}
+				if (remupd_conf != NULL){
+					if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+						do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in IntStateQueryShort\n",argv0);
+					}
+				}
 			}
 		}
 	}				
@@ -912,6 +1060,11 @@
 							}else{
 								do_log(debuglogfile, debug, 2, "%s: registry update in IntStateQuery for: jobid=%s creamjobid=%s wn=%s status=%d\n",argv0,en.batch_id,en.user_prefix,en.wn_addr,en.status);
 							}
+							if (remupd_conf != NULL){
+								if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+									do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in IntStateQuery\n",argv0);
+								}
+							}
 						}
 					}
 					en.status = UNDEFINED;
@@ -942,6 +1095,14 @@
 					}
 				}
 				first=FALSE;
+			}else if(line && strstr(line," Submitted from host ") && (en.status == IDLE)){
+				maxtok_t = strtoken(line, ' ', &token);
+				timestamp=make_message("%s %s %s %s",token[0],token[1],token[2],token[3]);
+				timestamp[strlen(timestamp)-1]='\0';
+				tmstampepoch=str2epoch(timestamp,"W");
+				en.udate=tmstampepoch;
+				free(timestamp);
+				freetoken(&token,maxtok_t);
 			}else if(line && strstr(line," <PEND>, ")){	
 				en.status=IDLE;
 				en.exitcode=-1;
@@ -990,7 +1151,7 @@
 				JOB_REGISTRY_ASSIGN_ENTRY(en.wn_addr,wn_str);
 				free(wn_str);
 				freetoken(&token,maxtok_t);
-			}else if(line && strstr(line," Exited with exit code") && en.status != REMOVED){
+			}else if(line && strstr(line," Exited with exit code") && en.status != REMOVED){	
 				if(use_bhist_for_killed && strcmp(use_bhist_for_killed,"yes")==0){ 
 					if(en.status == UNDEFINED){
 						en.status=IDLE;
@@ -1044,6 +1205,18 @@
 				en.exitcode=0;
 				JOB_REGISTRY_ASSIGN_ENTRY(en.exitreason,"\0");
 				freetoken(&token,maxtok_t);
+			}else if(line && strstr(line," Post job process failed") && en.status == COMPLETED){	
+				maxtok_t = strtoken(line, ' ', &token);
+				timestamp=make_message("%s %s %s %s",token[0],token[1],token[2],token[3]);
+				timestamp[strlen(timestamp)-1]='\0';
+				tmstampepoch=str2epoch(timestamp,"W");
+				en.udate=tmstampepoch;
+				en.status=COMPLETED;
+				free(timestamp);
+				en.exitcode=-998;
+				JOB_REGISTRY_ASSIGN_ENTRY(en.updater_info,string_now);
+				JOB_REGISTRY_ASSIGN_ENTRY(en.exitreason,"LSF Postjob failed");
+				freetoken(&token,maxtok_t);
 			}
 			free(line);
 			free(string_now);
@@ -1071,6 +1244,11 @@
 				}else{
 					do_log(debuglogfile, debug, 2, "%s: registry update in IntStateQuery for: jobid=%s creamjobid=%s wn=%s status=%d\n",argv0,en.batch_id,en.user_prefix,en.wn_addr,en.status);
 				}
+				if (remupd_conf != NULL){
+					if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+						do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in IntStateQuery\n",argv0);
+					}
+				}
 			}
 		}
 	}				
@@ -1146,10 +1324,10 @@
 	}else{
 			start_date_flagged=make_message("");
 	}
-	
+
 	command_string=make_message("%s%s/bhist -u all -d -l -n %d %s",batch_command,lsf_binpath,logs_to_read,start_date_flagged);
 	free(start_date_flagged);
-
+	
 	fp = popen(command_string,"r");
 	
 	do_log(debuglogfile, debug, 3, "%s: command_string in FinalStateQuery is:%s\n",argv0,command_string);
@@ -1170,6 +1348,7 @@
 			now=time(0);
 			string_now=make_message("%d",now);
 			if(line && strstr(line,"Job <")){	
+
 				if(!first && en.status!=UNDEFINED && en.status!=IDLE && ren && ren->status!=REMOVED && ren->status!=COMPLETED){	
 					if ((ret=job_registry_update_select(rha, &en,
 					JOB_REGISTRY_UPDATE_UDATE |
@@ -1187,6 +1366,11 @@
 							job_registry_unlink_proxy(rha, &en);
 						}
 					}
+					if (remupd_conf != NULL){
+						if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+							do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in FinalStateQuery\n",argv0);
+						}
+					}
 				}				
 				en.status = UNDEFINED;
 				maxtok_t = strtoken(line, ',', &token);
@@ -1252,13 +1436,25 @@
 				JOB_REGISTRY_ASSIGN_ENTRY(en.updater_info,string_now);
 				JOB_REGISTRY_ASSIGN_ENTRY(en.exitreason,"\0");
 				freetoken(&token,maxtok_t);
+			}else if(line && strstr(line," Post job process failed") && en.status == COMPLETED){	
+				maxtok_t = strtoken(line, ' ', &token);
+				timestamp=make_message("%s %s %s %s",token[0],token[1],token[2],token[3]);
+				timestamp[strlen(timestamp)-1]='\0';
+				tmstampepoch=str2epoch(timestamp,"W");
+				en.udate=tmstampepoch;
+				en.status=COMPLETED;
+				free(timestamp);
+				en.exitcode=-998;
+				JOB_REGISTRY_ASSIGN_ENTRY(en.updater_info,string_now);
+				JOB_REGISTRY_ASSIGN_ENTRY(en.exitreason,"LSF Postjob failed");
+				freetoken(&token,maxtok_t);
 			}
-			free(line);
 			free(string_now);
+			free(line);
 		}
 		pclose(fp);
 	}
-	
+
 	if(en.status!=UNDEFINED && en.status!=IDLE && ren && ren->status!=REMOVED && ren->status!=COMPLETED){	
 		if ((ret=job_registry_update_select(rha, &en,
 		JOB_REGISTRY_UPDATE_UDATE |
@@ -1275,6 +1471,11 @@
 			if (en.status == REMOVED || en.status == COMPLETED){
 				job_registry_unlink_proxy(rha, &en);
 			}
+			if (remupd_conf != NULL){
+				if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+					do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in FinalStateQuery\n",argv0);
+				}
+			}
 		}
 	}else{
 		failed_count++;
@@ -1285,6 +1486,7 @@
 	next_finalstatequery=now+time_to_add;
 	do_log(debuglogfile, debug, 3, "%s: next FinalStatequery will be in %d seconds\n",argv0,time_to_add);
 
+	free(ren);
 	free(command_string);
 	return 0;
 }
@@ -1444,6 +1646,11 @@
 	} else {
 		do_log(debuglogfile, debug, 2, "%s: registry update in AssignStateQuery for: jobid=%s creamjobid=%s status=%d\n",argv0,en.batch_id,en.user_prefix,en.status);
 		job_registry_unlink_proxy(rha, &en);
+		if (remupd_conf != NULL){
+			if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+				do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in AssignFinalState\n",argv0);
+			}
+		}
 	}
 
 	
diff -ur blahp-condor/src/BUpdaterLSF.h blahp-osg/src/BUpdaterLSF.h
--- blahp-condor/src/BUpdaterLSF.h	2012-03-08 03:47:11.000000000 -0600
+++ blahp-osg/src/BUpdaterLSF.h	2016-04-26 11:19:29.425396323 -0500
@@ -22,7 +22,10 @@
 # 
 */
 
+#include "acconfig.h"
+
 #include "job_registry.h"
+#include "job_registry_updater.h"
 #include "Bfunctions.h"
 #include "config.h"
 
@@ -32,6 +35,7 @@
 #define VERSION            "1.8.0"
 #endif
 
+int ReceiveUpdateFromNetwork();
 int IntStateQueryShort();
 int IntStateQueryCustom();
 int IntStateQuery();
@@ -65,7 +69,8 @@
 char *use_bhist_time_constraint="no";
 char *use_btools="no";
 char *btools_path="/usr/local/bin";
-char *use_bhist_for_killed="no";
+char *use_bhist_for_killed="yes";
+char *use_bhist_for_idle="yes";
 
 bupdater_active_jobs bact;
 
@@ -76,3 +81,9 @@
 config_handle *cha;
 config_entry *ret;
 char *progname="BUpdaterLSF";
+
+struct pollfd *remupd_pollset = NULL;
+int remupd_nfds;
+job_registry_updater_endpoint *remupd_head = NULL;
+job_registry_updater_endpoint *remupd_head_send = NULL;
+config_entry *remupd_conf;
diff -ur blahp-condor/src/BUpdaterPBS.c blahp-osg/src/BUpdaterPBS.c
--- blahp-condor/src/BUpdaterPBS.c	2011-12-15 04:07:35.000000000 -0600
+++ blahp-osg/src/BUpdaterPBS.c	2016-04-26 11:19:29.427406696 -0500
@@ -39,6 +39,9 @@
 	
 	char *first_duplicate=NULL;
 	
+	struct pollfd *remupd_pollset = NULL;
+	int remupd_nfds;
+	
 	int version=0;
 	int first=TRUE;
 	int tmptim;
@@ -49,6 +52,8 @@
 	
 	int c;				
 	
+	pthread_t RecUpdNetThd;
+
 	int confirm_time=0;	
 
         static int help;
@@ -64,12 +69,13 @@
 		{"usage",     no_argument,     &short_help, 1},
 		{"nodaemon",  no_argument,       0, 'o'},
 		{"version",   no_argument,       0, 'v'},
+		{"prefix",    required_argument, 0, 'p'},
 		{0, 0, 0, 0}
 		};
 
 		int option_index = 0;
      
-		c = getopt_long (argc, argv, "vo",long_options, &option_index);
+		c = getopt_long (argc, argv, "vop:",long_options, &option_index);
      
 		if (c == -1){
 			break;
@@ -91,6 +97,9 @@
 			nodmn=1;
 			break;
 
+		case 'p':
+			break;
+
 		case '?':
 			break;
      
@@ -275,7 +284,7 @@
 	}
 	
 	batch_command=(strcmp(pbs_batch_caching_enabled,"yes")==0?make_message("%s ",batch_command_caching_filter):make_message(""));
-	
+
 	ret = config_get("job_registry_use_mmap",cha);
 	if (ret == NULL){
 		do_log(debuglogfile, debug, 1, "%s: key job_registry_use_mmap not found. Default is NO\n",argv0);
@@ -283,6 +292,38 @@
 		do_log(debuglogfile, debug, 1, "%s: key job_registry_use_mmap is set to %s\n",argv0,ret->value);
 	}
 	
+	ret = config_get("tracejob_max_output",cha);
+	if (ret == NULL){
+		do_log(debuglogfile, debug, 1, "%s: key tracejob_max_output not found using default\n",argv0,tracejob_max_output);
+	} else {
+		tracejob_max_output==atoi(ret->value);
+	}
+	
+	remupd_conf = config_get("job_registry_add_remote",cha);
+	if (remupd_conf == NULL){
+		do_log(debuglogfile, debug, 1, "%s: key job_registry_add_remote not found\n",argv0);
+	}else{
+		if (job_registry_updater_setup_receiver(remupd_conf->values,remupd_conf->n_values,&remupd_head) < 0){
+			do_log(debuglogfile, debug, 1, "%s: Cannot set network receiver(s) up for remote update\n",argv0);
+			fprintf(stderr,"%s: Cannot set network receiver(s) up for remote update \n",argv0);
+       		}
+ 
+		if (remupd_head == NULL){
+			do_log(debuglogfile, debug, 1, "%s: Cannot find values for network endpoints in configuration file (attribute 'job_registry_add_remote').\n",argv0);
+			fprintf(stderr,"%s: Cannot find values for network endpoints in configuration file (attribute 'job_registry_add_remote').\n", argv0);
+		}
+
+		if ((remupd_nfds = job_registry_updater_get_pollfd(remupd_head, &remupd_pollset)) < 0){
+			do_log(debuglogfile, debug, 1, "%s: Cannot setup poll set for receiving data.\n",argv0);
+    			fprintf(stderr,"%s: Cannot setup poll set for receiving data.\n", argv0);
+		}
+		if (remupd_pollset == NULL || remupd_nfds == 0){
+			do_log(debuglogfile, debug, 1, "%s: No poll set available for receiving data.\n",argv0);
+			fprintf(stderr,"%s: No poll set available for receiving data.\n",argv0);
+		}
+	
+	}
+	
 	if( !nodmn ) daemonize();
 
 
@@ -291,8 +332,6 @@
 		free(pidfile);
 	}
 	
-	config_free(cha);
-
 	rha=job_registry_init(registry_file, BY_BATCH_ID);
 	if (rha == NULL){
 		do_log(debuglogfile, debug, 1, "%s: Error initialising job registry %s\n",argv0,registry_file);
@@ -300,6 +339,21 @@
 		perror("");
 	}
 	
+	if (remupd_conf != NULL){
+		pthread_create(&RecUpdNetThd, NULL, (void *(*)(void *))ReceiveUpdateFromNetwork, (void *)NULL);
+	
+		if (job_registry_updater_setup_sender(remupd_conf->values,remupd_conf->n_values,0,&remupd_head_send) < 0){
+			do_log(debuglogfile, debug, 1, "%s: Cannot set network sender(s) up for remote update\n",argv0);
+			fprintf(stderr,"%s: Cannot set network sender(s) up for remote update \n",argv0);
+       		}
+		if (remupd_head_send == NULL){
+			do_log(debuglogfile, debug, 1, "%s: Cannot find values for network endpoints in configuration file (attribute 'job_registry_add_remote').\n",argv0);
+			fprintf(stderr,"%s: Cannot find values for network endpoints in configuration file (attribute 'job_registry_add_remote').\n", argv0);
+		}
+	}
+
+	config_free(cha);
+
 	for(;;){
 		/* Purge old entries from registry */
 		now=time(0);
@@ -383,7 +437,7 @@
 			if (final_string[finstr_len-1] == ':' && (cp = strrchr (final_string, ':')) != NULL){
 				*cp = '\0';
 			}
-			
+				
 			if(fsq_ret != 0){
 				fsq_ret=FinalStateQuery(final_string,tracejob_logs_to_read);
 			}else{
@@ -407,6 +461,71 @@
 	
 }
 
+int 
+ReceiveUpdateFromNetwork()
+{
+	char *proxy_path, *proxy_subject;
+	int timeout_ms = 0;
+	int ent, ret, prret, rhret;
+	job_registry_entry *nen;
+	job_registry_entry *ren;
+  
+	proxy_path = NULL;
+	proxy_subject = NULL;
+	
+	while (nen = job_registry_receive_update(remupd_pollset, remupd_nfds,timeout_ms, &proxy_subject, &proxy_path)){
+	
+		JOB_REGISTRY_ASSIGN_ENTRY(nen->subject_hash,"\0");
+		JOB_REGISTRY_ASSIGN_ENTRY(nen->proxy_link,"\0");
+		
+		if ((ren=job_registry_get(rha, nen->batch_id)) == NULL){
+			if ((ret=job_registry_append(rha, nen)) < 0){
+				fprintf(stderr,"%s: Warning: job_registry_append returns %d: ",argv0,ret);
+				perror("");
+			} 
+		}else{
+		
+			if(ren->subject_hash!=NULL && strlen(ren->subject_hash) && ren->proxy_link!=NULL && strlen(ren->proxy_link)){
+				JOB_REGISTRY_ASSIGN_ENTRY(nen->subject_hash,ren->subject_hash);
+				JOB_REGISTRY_ASSIGN_ENTRY(nen->proxy_link,ren->proxy_link);
+			}else{
+				if (proxy_path != NULL && strlen(proxy_path) > 0){
+					prret = job_registry_set_proxy(rha, nen, proxy_path);
+     			 		if (prret < 0){
+						do_log(debuglogfile, debug, 1, "%s: warning: setting proxy to %s\n",argv0,proxy_path);
+        					fprintf(stderr,"%s: warning: setting proxy to %s: ",argv0,proxy_path);
+        					perror("");
+        					/* Make sure we don't renew non-existing proxies */
+						nen->renew_proxy = 0;  		
+					}
+					free(proxy_path);
+  
+					nen->subject_hash[0] = '\000';
+					if (proxy_subject != NULL && strlen(proxy_subject) > 0){
+						job_registry_compute_subject_hash(nen, proxy_subject);
+						rhret = job_registry_record_subject_hash(rha, nen->subject_hash, proxy_subject, TRUE);  
+						if (rhret < 0){
+							do_log(debuglogfile, debug, 1, "%s: warning: recording proxy subject %s (hash %s)\n",argv0, proxy_subject, nen->subject_hash);
+							fprintf(stderr,"%s: warning: recording proxy subject %s (hash %s): ",argv0, proxy_subject, nen->subject_hash);
+							perror("");
+						}
+					}
+					free(proxy_subject);
+  
+				}
+			}
+			if(job_registry_need_update(ren,nen,JOB_REGISTRY_UPDATE_ALL)){
+				if ((ret=job_registry_update(rha, nen)) < 0){
+					fprintf(stderr,"%s: Warning: job_registry_update returns %d: ",argv0,ret);
+					perror("");
+				}
+			} 
+		}
+		free(nen);
+	}
+  
+	return 0;
+}
 
 int
 IntStateQuery()
@@ -501,6 +620,11 @@
 								do_log(debuglogfile, debug, 2, "%s: registry update in IntStateQuery for: jobid=%s wn=%s status=%d\n",argv0,en.batch_id,en.wn_addr,en.status);
 							}
 						}
+						if (remupd_conf != NULL){
+							if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+								do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in IntStateQuery\n",argv0);
+							}
+						}
 					}
 					en.status = UNDEFINED;
 					JOB_REGISTRY_ASSIGN_ENTRY(en.wn_addr,"\0");
@@ -611,6 +735,11 @@
 					do_log(debuglogfile, debug, 2, "%s: registry update in IntStateQuery for: jobid=%s wn=%s status=%d\n",argv0,en.batch_id,en.wn_addr,en.status);
 				}
 			}
+			if (remupd_conf != NULL){
+				if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+					do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in IntStateQuery\n",argv0);
+				}
+			}
 		}
 	}				
 
@@ -680,6 +809,7 @@
 	char *command_string=NULL;
 	char *pbs_spool=NULL;
 	char *string_now=NULL;
+	int tracejob_line_counter=0;
 
 	do_log(debuglogfile, debug, 3, "%s: input_string in FinalStateQuery is:%s\n",argv0,input_string);
 	
@@ -702,14 +832,23 @@
 		
 		JOB_REGISTRY_ASSIGN_ENTRY(en.batch_id,jobid[k]);
 
+		tracejob_line_counter=0;
+		
 		if(fp!=NULL){
 			while(!feof(fp) && (line=get_line(fp))){
 				if(line && strlen(line)==0){
 					free(line);
 					continue;
 				}
+				if(tracejob_line_counter>tracejob_max_output){
+					do_log(debuglogfile, debug, 2, "%s: Tracejob output limit of %d lines reached. Skipping command.\n",argv0,tracejob_max_output);
+					free(line);
+					break;
+				}
 				if ((cp = strrchr (line, '\n')) != NULL){
 					*cp = '\0';
+					tracejob_line_counter++;
+					
 				}
                         	do_log(debuglogfile, debug, 3, "%s: line in FinalStateQuery is:%s\n",argv0,line);
 				now=time(0);
@@ -752,8 +891,8 @@
 					JOB_REGISTRY_ASSIGN_ENTRY(en.updater_info,string_now);
 					JOB_REGISTRY_ASSIGN_ENTRY(en.exitreason,"\0");
 				}
-				free(line);
 				free(string_now);
+				free(line);
 			}
 			pclose(fp);
 		}
@@ -774,6 +913,11 @@
 				if (en.status == REMOVED || en.status == COMPLETED){
 					job_registry_unlink_proxy(rha, &en);
 				}
+				if (remupd_conf != NULL){
+					if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+						do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in FinalStateQuery\n",argv0);
+					}
+				}
 			}
 		}else{
 			failed_count++;
@@ -816,6 +960,11 @@
 	} else {
 		do_log(debuglogfile, debug, 2, "%s: registry update in AssignStateQuery for: jobid=%s creamjobid=%s status=%d\n",argv0,en.batch_id,en.user_prefix,en.status);
 		job_registry_unlink_proxy(rha, &en);
+		if (remupd_conf != NULL){
+			if (ret=job_registry_send_update(remupd_head_send,&en,NULL,NULL)<=0){
+				do_log(debuglogfile, debug, 2, "%s: Error creating endpoint in AssignFinalState\n",argv0);
+			}
+		}
 	}
 
 	return 0;
diff -ur blahp-condor/src/BUpdaterPBS.h blahp-osg/src/BUpdaterPBS.h
--- blahp-condor/src/BUpdaterPBS.h	2011-09-09 05:00:09.000000000 -0500
+++ blahp-osg/src/BUpdaterPBS.h	2016-04-26 11:19:29.428396729 -0500
@@ -22,7 +22,10 @@
 # 
 */
 
+#include "acconfig.h"
+
 #include "job_registry.h"
+#include "job_registry_updater.h"
 #include "Bfunctions.h"
 #include "config.h"
 
@@ -32,6 +35,7 @@
 #define VERSION            "1.8.0"
 #endif
 
+int ReceiveUpdateFromNetwork();
 int IntStateQuery();
 int FinalStateQuery(char *input_string, int logs_to_read);
 int AssignFinalState(char *batchid);
@@ -54,6 +58,7 @@
 char *pbs_batch_caching_enabled="Not";
 char *batch_command_caching_filter=NULL;
 char *batch_command=NULL;
+int tracejob_max_output=1000;
 
 bupdater_active_jobs bact;
 
@@ -64,3 +69,9 @@
 config_handle *cha;
 config_entry *ret;
 char *progname="BUpdaterPBS";
+
+struct pollfd *remupd_pollset = NULL;
+int remupd_nfds;
+job_registry_updater_endpoint *remupd_head = NULL;
+job_registry_updater_endpoint *remupd_head_send = NULL;
+config_entry *remupd_conf;
diff -ur blahp-condor/src/BUpdaterSGE.c blahp-osg/src/BUpdaterSGE.c
--- blahp-condor/src/BUpdaterSGE.c	2011-12-13 11:23:41.000000000 -0600
+++ blahp-osg/src/BUpdaterSGE.c	2016-04-26 11:19:29.429398071 -0500
@@ -94,6 +94,17 @@
 	}
     }
     
+    //check if another instance is running 
+    char **ptr;
+    char out[3];
+    fgets(out, sizeof(out),popen("ps -d | grep -c BUpdaterSGE","r"));
+    strtoken(out,'\n',&ptr);
+    if (strcmp(ptr[0],"1")!=0){
+	fprintf(stderr,"There is another instance of BUpdaterSGE running.\nExiting ...\n");
+	return -1;
+    }
+    freetoken(&ptr,1);
+
     if(help){
 	usage();
     }
diff -ur blahp-condor/src/classad_binary_op_unwind.h blahp-osg/src/classad_binary_op_unwind.h
--- blahp-condor/src/classad_binary_op_unwind.h	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/classad_binary_op_unwind.h	2016-04-26 11:19:29.452396813 -0500
@@ -38,11 +38,9 @@
 #ifndef __CLASSAD_BINARY_OP_UNWIND_H__
 #define __CLASSAD_BINARY_OP_UNWIND_H__
 
-#if 1
 using namespace classad;
 
 namespace classad {
-#endif
 
 class BinaryOpUnwind : public ClassAdUnParser
 {
@@ -64,8 +62,6 @@
         std::vector<std::string> m_unwind_output;
 };
 
-#if 1
 } // end of classad namespace
-#endif
 
 #endif // defined __CLASSAD_BINARY_OP_UNWIND_H__
diff -ur blahp-condor/src/classad_c_helper.C blahp-osg/src/classad_c_helper.C
--- blahp-condor/src/classad_c_helper.C	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/classad_c_helper.C	2016-04-26 11:19:29.453397020 -0500
@@ -2,7 +2,7 @@
 #  File :     classad_c_helper.C
 #
 #
-#  Author :   Francesco Prelz ($Author: mezzadri $)
+#  Author :   Francesco Prelz ($Author: fprelz $)
 #  e-mail :   "francesco.prelz@mi.infn.it"
 #
 #  Revision history :
@@ -12,6 +12,8 @@
 #  19-Aug-2004 Added boolean attribute.
 #  30-Nov-2007 Added function to evaluate a boolean expression 
 #              in the context of a classad.
+#  15-Sep-2011 Added helper function to accumulate and return all the attribute 
+#              names in a classad.
 #
 #  Description:
 #  c-callable layer for handling Classad parse and unparse via the 'new'
@@ -41,7 +43,7 @@
 #include "classad/classad_distribution.h"
 #include "classad_binary_op_unwind.h"
 
-#if 1
+#ifdef WANT_NAMESPACES
 using namespace classad;
 #endif
 
@@ -108,6 +110,8 @@
     if (cad == NULL) return C_CLASSAD_INVALID_CONTEXT;
 
     ClassAd *ad = (ClassAd *)cad;
+    if (result != NULL) *result = NULL; /* For those who don't check */
+                                        /* the return code... */
 
     Value v;
     ad->EvaluateAttr(attribute_name, v);
@@ -163,7 +167,7 @@
       et_result->GetComponents(ads);
       // Get string values.
       for(std::vector<ExprTree*>::const_iterator it = ads.begin();
-          it != ads.end(); it++) 
+          it != ads.end(); ++it) 
        {
         if ((*it)->GetKind() == ExprTree::LITERAL_NODE) 
          {
@@ -404,7 +408,7 @@
 
     std::vector<std::string>::const_iterator it;
     for (it = res_unp.m_unwind_output.begin(); 
-         it != res_unp.m_unwind_output.end(); it++)
+         it != res_unp.m_unwind_output.end(); ++it)
      {
       n_results++;
       char **new_results;
@@ -482,4 +486,51 @@
     return retcod;
    }
 
+  int
+  classad_get_attribute_names(classad_context cad, char ***results) 
+   {
+    if (cad == NULL) return C_CLASSAD_INVALID_CONTEXT;
+    if (results == NULL)
+      return C_CLASSAD_INVALID_ARG;
+
+    ClassAd *ad = (ClassAd *)cad;
+
+    int n_results = 0;
+
+    ClassAd::const_iterator it;
+    for (it = ad->begin(); it != ad->end(); ++it)
+     {
+      n_results++;
+      char **new_results;
+      new_results = (char **)realloc(*results, (n_results+1)*sizeof(char *));
+      if (new_results == NULL)
+       {
+        return C_CLASSAD_OUT_OF_MEMORY;
+       }
+      (*results) = new_results;
+      (*results)[n_results] = NULL;
+      (*results)[n_results-1] = strdup(it->first.c_str());
+      if (((*results)[n_results-1]) == NULL)
+       {
+        return C_CLASSAD_OUT_OF_MEMORY;
+       }
+     }
+
+    return C_CLASSAD_NO_ERROR;
+   }
+
+  void
+  classad_free_results(char **results) 
+   {
+    char **cur;
+    if (results != NULL)
+     {
+      for(cur=results; (*cur)!=NULL; cur++)
+       {
+        free(*cur);
+       }
+      free(results);
+     }
+   }
+
  } // end of extern "C"
diff -ur blahp-condor/src/classad_c_helper.h blahp-osg/src/classad_c_helper.h
--- blahp-condor/src/classad_c_helper.h	2010-03-17 08:19:34.000000000 -0500
+++ blahp-osg/src/classad_c_helper.h	2016-04-26 11:19:29.454396551 -0500
@@ -2,7 +2,7 @@
   File :     classad_c_helper.h
 
 
-  Author :   Francesco Prelz ($Author: mezzadri $)
+  Author :   Francesco Prelz ($Author: fprelz $)
   e-mail :   "francesco.prelz@mi.infn.it"
 
   Revision history :
@@ -12,6 +12,8 @@
   19-Aug-2004 Added boolean attribute.
   30-Nov-2007 Added helper function to evaluate a boolean expression
               in a classad;
+  15-Sep-2011 Added helper function to accumulate and return all the attribute 
+              names in a classad.
 
   Description:
    Prototypes and typedefs for c-callable layer for handling Classad parse and 
@@ -80,5 +82,7 @@
 classad_expr_tree classad_parse_expr(const char *s_ex);
 int classad_evaluate_boolean_expr(const char *s_in, const classad_expr_tree t_ex, int *result);
 void classad_free_tree(classad_expr_tree t_ex);
+int classad_get_attribute_names(classad_context cad, char ***results);
+void classad_free_results(char **results);
 
 #endif /* defined CLASSAD_C_HELPER_INCLUDED */
Only in blahp-osg/src: CMakeLists.txt
Only in blahp-osg/src: cmdbuffer.c
Only in blahp-osg/src: cmdbuffer.h
Only in blahp-condor/src: condor_create_log.c
Only in blahp-condor/src: condor_create_log.h
diff -ur blahp-condor/src/config.c blahp-osg/src/config.c
--- blahp-condor/src/config.c	2011-03-04 06:56:04.000000000 -0600
+++ blahp-osg/src/config.c	2016-04-26 11:19:29.459398579 -0500
@@ -8,6 +8,9 @@
  *  Revision history :
  *  23-Nov-2007 Original release
  *  24-Apr-2009 Added parsing of shell arrays.
+ *  13-Jan-2012 Added sbin and libexec install dirs.
+ *  30-Nov-2012 Added ability to locally setenv the env variables
+ *              that are exported in the config file.
  *
  *  Description:
  *    Small library for access to the BLAH configuration file.
@@ -59,7 +62,7 @@
     while (regexec(&regbuf, match_start, 2, pmatch, 0) == 0)
      {
       value_len = pmatch[1].rm_eo - pmatch[1].rm_so;
-      new_values = (char **)realloc(en->values, sizeof(char *)*(en->n_values+1));
+      new_values = (char **)realloc(en->values, sizeof(char *)*(en->n_values+2));
       if (new_values == NULL) return -1;
       en->values = new_values;
       en->values[en->n_values] = (char *)malloc(value_len+1);
@@ -69,14 +72,55 @@
              value_len);
       en->values[en->n_values][value_len] = '\000';
       en->n_values++;
+      /* Keep list NULL-terminated */
+      en->values[en->n_values] = NULL;
       match_start += pmatch[0].rm_eo;
      }
    }
  }
 
+int
+config_setenv(const char *ipath)
+ {
+  const char *printenv_command_before = "printenv";
+  const char *printenv_command_after = ". %s;printenv";
+  config_handle *envs_before;
+  config_handle *envs_after;
+  config_entry *cur;
+  int n_added = 0;
+
+  envs_before = config_read_cmd(ipath, printenv_command_before);
+  envs_after  = config_read_cmd(ipath, printenv_command_after);
+
+
+  /* Set in the local environment all env variables that were exported in */
+  /* the config file. */
+
+  for (cur = envs_after->list; cur != NULL; cur=cur->next)
+   {
+    if (config_get(cur->key, envs_before) == NULL)
+     {
+      setenv(cur->key, cur->value, 1);
+      n_added++;
+     }
+   }
+  
+  config_free(envs_before);
+  config_free(envs_after);
+
+  return n_added;
+ }
+
 config_handle *
 config_read(const char *ipath)
  {
+  const char *set_command_format = ". %s; set";
+  return config_read_cmd(ipath, set_command_format);
+ }
+
+config_handle *
+config_read_cmd(const char *ipath, const char *set_command_format)
+ {
   char *path;
   char *install_location=NULL;
   char *line=NULL,*new_line=NULL;
@@ -88,7 +132,6 @@
   config_entry *c_tail = NULL;
   config_entry *found,*new_entry=NULL;
   char *set_command=NULL;
-  const char *set_command_format = ". %s; set";
   int set_command_size;
   int line_len = 0;
   int line_alloc = 0;
@@ -167,7 +210,9 @@
     config_free(rha);
     return NULL;
    }
-  rha->bin_path = NULL; /* May be filled out of config file contents. */
+  rha->bin_path = NULL; /* These may be filled out of config file contents. */
+  rha->sbin_path = NULL; 
+  rha->libexec_path = NULL;
 
   line_alloc = line_alloc_chunk;
   line = (char *)malloc(line_alloc);
@@ -307,6 +352,38 @@
     return NULL;
    }
 
+  if ((bp = config_get("blah_sbin_directory", rha)) != NULL)
+   {
+    rha->sbin_path = strdup(bp->value);
+   }
+  else
+   {
+    rha->sbin_path = (char *)malloc(strlen(install_location)+6);
+    if (rha->sbin_path != NULL) sprintf(rha->sbin_path,"%s/sbin",install_location);
+   }
+  if (rha->sbin_path == NULL)
+   {
+    /* Out of memory */
+    config_free(rha);
+    return NULL;
+   }
+
+  if ((bp = config_get("blah_libexec_directory", rha)) != NULL)
+   {
+    rha->libexec_path = strdup(bp->value);
+   }
+  else
+   {
+    rha->libexec_path = (char *)malloc(strlen(install_location)+9);
+    if (rha->libexec_path != NULL) sprintf(rha->libexec_path,"%s/libexec",install_location);
+   }
+  if (rha->libexec_path == NULL)
+   {
+    /* Out of memory */
+    config_free(rha);
+    return NULL;
+   }
+
   return rha;
  }
 
@@ -381,6 +458,8 @@
   if ((handle->config_path) != NULL) free(handle->config_path);
   if ((handle->install_path) != NULL) free(handle->install_path);
   if ((handle->bin_path) != NULL) free(handle->bin_path);
+  if ((handle->sbin_path) != NULL) free(handle->sbin_path);
+  if ((handle->libexec_path) != NULL) free(handle->libexec_path);
 
   free(handle);
  }
@@ -395,6 +474,8 @@
 main(int argc, char *argv[])
 {
   int tcf;
+  int n_env;
+  char *test_env;
   char *path;
   const char *test_config =
     "\n"
@@ -412,6 +493,7 @@
     "b4=0\n"
     "b4=\"   Junk\"\n"
     "b5=\" False\"\n"
+    "export e1=\" My Env Variable \"\n"
     "file=/tmp/test_`whoami`.bjr\n"
     "arr[0]=value_0\n"
     "arr[3]=value_3\n"
@@ -449,13 +531,27 @@
 
   setenv("BLAHPD_CONFIG_LOCATION",path,1);
   cha = config_read(NULL);
+  n_env = config_setenv(NULL);
   unlink(path);
   if (cha == NULL)
    {
     fprintf(stderr,"%s: Error reading config from %s: ",argv[0],path);
+    perror("");
     return 4;
    }
 
+  if (n_env <= 0)
+   {
+    fprintf(stderr,"%s: No new env variables found in %s.\n",argv[0],path);
+    r=30;
+   }
+  if ((test_env = getenv("e1")) == NULL)
+   {
+    fprintf(stderr,"%s: Env variable e1 not found in %s.\n",argv[0],path);
+    r=31;
+   }
+  else printf("e1 env == <%s>\n", test_env);
+
   ret = config_get("a",cha);
   if (ret == NULL) fprintf(stderr,"%s: key a not found\n",argv[0]),r=5;
   else if (atoi(ret->value) != 123) fprintf(stderr,"%s: key a != 123\n",argv[0]),r=6;
diff -ur blahp-condor/src/config.h blahp-osg/src/config.h
--- blahp-condor/src/config.h	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/config.h	2016-04-26 11:19:29.460397539 -0500
@@ -2,11 +2,14 @@
  *  File :     config.h
  *
  *
- *  Author :   Francesco Prelz ($Author: mezzadri $)
+ *  Author :   Francesco Prelz ($Author: fprelz $)
  *  e-mail :   "francesco.prelz@mi.infn.it"
  *
  *  Revision history :
  *  23-Nov-2007 Original release
+ *  13-Jan-2012 Added sbin and libexec install dirs.
+ *  30-Nov-2012 Added ability to locally setenv the env variables
+ *              that are exported in the config file.
  *
  *  Description:
  *    Prototypes of functions defined in config.c
@@ -47,16 +50,20 @@
  {
    char *install_path;
    char *bin_path;
+   char *sbin_path;
+   char *libexec_path;
    char *config_path;
    config_entry *list;
  } config_handle;
 
 config_handle *config_read(const char *path);
+config_handle *config_read_cmd(const char *path, const char *cmd);
+int config_setenv(const char *ipath);
 config_entry *config_get(const char *key, config_handle *handle);
 int config_test_boolean(const config_entry *entry);
 void config_free(config_handle *handle);
 
-#define CONFIG_FILE_BASE "batch_gahp.config"
+#define CONFIG_FILE_BASE "blah.config"
 
 #define CONFIG_SKIP_WHITESPACE_FWD(c) while ((*(c) == ' ')  || (*(c) == '\t') || \
                                   (*(c) == '\n') || (*(c) == '\r') ) (c)++;
Only in blahp-condor/src: .deps
Only in blahp-osg/src: FindClassAd.cmake
diff -ur blahp-condor/src/job_registry.c blahp-osg/src/job_registry.c
--- blahp-condor/src/job_registry.c	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/job_registry.c	2016-04-26 11:19:29.466404389 -0500
@@ -2,7 +2,7 @@
  *  File :     job_registry.c
  *
  *
- *  Author :   Francesco Prelz ($Author: mezzadri $)
+ *  Author :   Francesco Prelz ($Author: fprelz $)
  *  e-mail :   "francesco.prelz@mi.infn.it"
  *
  *  Revision history :
@@ -28,6 +28,8 @@
  *              (for efficiency reasons: ID uniqueness in that
  *              case is guaranteed by the invoking service).
  *              Added job_registry_check_index_key_uniqueness.
+ *  21-Jul-2011 Added job_registry_need_update function.
+ *  11-Sep-2015 Always return most recent job in job_registry_get_recnum.
  *
  *  Description:
  *    File-based container to cache job IDs and statuses to implement
@@ -293,7 +295,7 @@
      }
     if (ret == 0) break;
 
-    if (cur.cdate < oldest_creation_date && (cur.status != RUNNING && cur.status != IDLE && cur.status != HELD))
+    if (cur.cdate < oldest_creation_date)
      {
       job_registry_unlink_proxy(jra, &cur);
       continue;
@@ -1993,6 +1995,8 @@
    }
 
   /* Update original entry and rewrite it */
+  /* Warning: these checks should all be mirrored in job_registry_need_update */
+  /*          below */
   if (((upbits & JOB_REGISTRY_UPDATE_WN_ADDR) != 0) &&
       (strncmp(old_entry.wn_addr, entry->wn_addr, 
                sizeof(old_entry.wn_addr)) != 0))
@@ -2066,12 +2070,80 @@
 }
 
 /*
+ * job_registry_need_update
+ *
+ * Check two job registry entries, an 'old' and a 'new' one, and
+ * check whether job_registry_update would need to actually write
+ * an update to disk. This function is meant to save the unneeded
+ * acquisition of a write lock.
+ *
+ * @param olde pointer to an existing registry entry.
+ * @param newe pointer to a possibly updated registry entry.
+ * @param upbits Bitmask selecting which registry fields should be
+ *               checked. Or'ed combination of the following:
+ *         - JOB_REGISTRY_UPDATE_WN_ADDR 
+ *         - JOB_REGISTRY_UPDATE_STATUS  
+ *         - JOB_REGISTRY_UPDATE_EXITCODE 
+ *         - JOB_REGISTRY_UPDATE_UDATE 
+ *         - JOB_REGISTRY_UPDATE_EXITREASON 
+ *         - JOB_REGISTRY_UPDATE_UPDATER_INFO
+ *         or JOB_REGISTRY_UPDATE_ALL for all of the above fields.
+ *
+ * @return Boolean valued integer. TRUE (nonzero) if an update is
+ *         actually needed.
+ */
+
+int
+job_registry_need_update(const job_registry_entry *olde,
+                         const job_registry_entry *newe,
+                         job_registry_update_bitmask_t upbits)
+{
+  int need_to_update = FALSE;
+
+  if (((upbits & JOB_REGISTRY_UPDATE_WN_ADDR) != 0) &&
+      (strncmp(olde->wn_addr, newe->wn_addr, 
+               sizeof(olde->wn_addr)) != 0))
+   {
+    need_to_update = TRUE;
+   }
+  if (((upbits & JOB_REGISTRY_UPDATE_STATUS) != 0) &&
+       (olde->status != newe->status))
+   {
+    need_to_update = TRUE;
+   }
+  if (((upbits & JOB_REGISTRY_UPDATE_EXITCODE) != 0) &&
+       (olde->exitcode != newe->exitcode))
+   {
+    need_to_update = TRUE;
+   }
+  if (((upbits & JOB_REGISTRY_UPDATE_UDATE) != 0) &&
+       (olde->udate != newe->udate))
+   {
+    need_to_update = TRUE;
+   }
+  if (((upbits & JOB_REGISTRY_UPDATE_EXITREASON) != 0) &&
+       (strncmp(olde->exitreason, newe->exitreason, 
+                sizeof(olde->exitreason)) != 0))
+   {
+    need_to_update = TRUE;
+   }
+  if (((upbits & JOB_REGISTRY_UPDATE_UPDATER_INFO) != 0) &&
+       (strncmp(olde->updater_info, newe->updater_info, 
+                sizeof(olde->updater_info)) != 0))
+   {
+    need_to_update = TRUE;
+   }
+  return need_to_update;
+}
+
+/*
  * job_registry_get_recnum
  *
  * Binary search for an entry in the indexed, sorted job registry pointed to by
  * rha. The record number in the current JR cache is returned.
  * No file access is required.
- * In case multiple entries are found, the lowest recnum is returned.
+ * In case multiple entries are found, the highest (most recent) recnum 
+ * is returned.
  *
  * @param rha Pointer to a job registry handle returned by job_registry_init.
  * @param id Job id key to be looked up 
@@ -2101,12 +2173,12 @@
       /* Check for duplicates. */
       for (tcur=cur-1; tcur >=0 && strcmp(rha->entries[tcur].id,id)==0; tcur--)
        {
-        if (rha->entries[tcur].recnum < found) found = rha->entries[tcur].recnum;
+        if (rha->entries[tcur].recnum > found) found = rha->entries[tcur].recnum;
        }
       for (tcur=cur+1;tcur < rha->n_entries && 
                              strcmp(rha->entries[tcur].id,id)==0; tcur++)
        {
-        if (rha->entries[tcur].recnum < found) found = rha->entries[tcur].recnum;
+        if (rha->entries[tcur].recnum > found) found = rha->entries[tcur].recnum;
        }
       break;
      }
@@ -2241,6 +2313,33 @@
    }
 
   firstrec = job_registry_firstrec(rha,fd);
+
+  /* Determine if the job registry index must be resync'd.
+   * The record numbers are monotonically increasing through the lifetime
+   * of the registry; the firstrec we read from the data file above must
+   * match the firstrec in our in-memory index.  The firstrec on the index
+   * is guaranteed to change if a purge operation occurred.
+   */
+  if (firstrec != rha->firstrec)
+   {
+    int retval = job_registry_resync(rha, fd);
+    if (retval < 0)  // Registry failed to update.
+     {
+      fclose(fd);
+      return NULL;
+     }
+    if (retval > 0)  // Registry has been updated; our lookup was invalid.
+     {
+      found = job_registry_lookup(rha, id);
+      if (found == 0)
+       {
+        errno = ENOENT;
+        fclose(fd);
+        return NULL;
+       }
+     }
+   }
+
   /* Was this record just purged ? */
   if ((firstrec > rha->firstrec) && (found >= rha->firstrec) && (found < firstrec))
    {
Only in blahp-condor/src: job_registry.c.orig
diff -ur blahp-condor/src/job_registry.h blahp-osg/src/job_registry.h
--- blahp-condor/src/job_registry.h	2011-05-23 10:00:56.000000000 -0500
+++ blahp-osg/src/job_registry.h	2016-04-26 11:19:29.468396323 -0500
@@ -20,6 +20,7 @@
  *              of entry index.
  *  11-Mar-2010 Added JOB_REGISTRY_UNLINK_FAIL return code.
  *              Added job_registry_check_index_key_uniqueness.
+ *  21-Jul-2011 Added job_registry_need_update function.
  *
  *  Description:
  *    Prototypes of functions defined in job_registry.c
@@ -206,6 +207,11 @@
 #define JOB_REGISTRY_MUNMAP_FAIL     -19 
 #define JOB_REGISTRY_UPDATE_TIMEOUT  -20 
 #define JOB_REGISTRY_UNLINK_FAIL     -21 
+#define JOB_REGISTRY_SOCKET_FAIL     -22 
+#define JOB_REGISTRY_MCAST_FAIL      -23 
+#define JOB_REGISTRY_BIND_FAIL       -24 
+#define JOB_REGISTRY_CONNECT_FAIL    -25 
+#define JOB_REGISTRY_TTL_FAIL        -26 
 
 #define JOB_REGISTRY_TEST_FILE "/tmp/test_reg.bjr"
 #define JOB_REGISTRY_REGISTRY_NAME "registry"
@@ -265,6 +271,9 @@
                         job_registry_entry *entry,
                         int use_recn, FILE *fd,
                         job_registry_update_bitmask_t upbits);
+int job_registry_need_update(const job_registry_entry *olde,
+                             const job_registry_entry *newe,
+                             job_registry_update_bitmask_t upbits);
 job_registry_entry *job_registry_get(job_registry_handle *rhandle,
                                      const char *id);
 FILE *job_registry_open(job_registry_handle *rhandle, const char *mode);
Only in blahp-osg/src: job_registry_updater.c
Only in blahp-osg/src: job_registry_updater.h
diff -ur blahp-condor/src/job_status.c blahp-osg/src/job_status.c
--- blahp-condor/src/job_status.c	2010-03-17 08:19:34.000000000 -0500
+++ blahp-osg/src/job_status.c	2016-04-26 11:19:29.471397060 -0500
@@ -126,8 +126,15 @@
 		return(255);
 	}
 
-	exec_command.command = make_message("%s/%s_status.sh %s %s", blah_script_location,
-	                                    spid->lrms, (get_workernode ? "-w" : ""), jobDesc);
+	if (strcmp(spid->lrms, "pbs") == 0) {
+		exec_command.command = make_message("%s/%s_status.py %s %s", blah_script_location,
+		                                    spid->lrms, (get_workernode ? "-w" : ""), jobDesc);
+	}
+	else
+	{
+		exec_command.command = make_message("%s/%s_status.sh %s %s", blah_script_location,
+		                                    spid->lrms, (get_workernode ? "-w" : ""), jobDesc);
+	}
 	if (exec_command.command == NULL)
 	{
 		fprintf(stderr, "blahpd: out of memory");
diff -ur blahp-condor/src/main.c blahp-osg/src/main.c
--- blahp-condor/src/main.c	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/main.c	2016-04-26 11:19:29.473396513 -0500
@@ -43,11 +43,9 @@
 #include <sys/select.h>
 #include <sys/types.h>
 #include <sys/wait.h>
-
 #ifdef MTRACE_ON
 #include <mcheck.h>
 #endif
-
 #include "blahpd.h"
 #include "server.h"
 #include "console.h"
diff -ur blahp-condor/src/main_daemon.c blahp-osg/src/main_daemon.c
--- blahp-condor/src/main_daemon.c	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/main_daemon.c	2016-04-26 11:19:29.474397729 -0500
@@ -43,11 +43,9 @@
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <syslog.h>
-
 #ifdef MTRACE_ON
 #include <mcheck.h>
 #endif
-
 #include "blahpd.h"
 #include "server.h"
 #include "console.h"
Only in blahp-condor/src: Makefile
diff -ur blahp-condor/src/Makefile.am blahp-osg/src/Makefile.am
--- blahp-condor/src/Makefile.am	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/Makefile.am	2016-04-26 11:19:29.438398337 -0500
@@ -2,7 +2,7 @@
 # * BLAHP daemon * 
 # ****************
 #
-# $Id: Makefile.am,v 1.48.2.3 2010/11/05 13:28:44 mezzadri Exp $ 
+# $Id: Makefile.am,v 1.57.2.3 2012/03/20 13:38:43 mezzadri Exp $ 
 #
 # File:           Makefile.am
 #
@@ -31,7 +31,12 @@
 #    limitations under the License.
 #
 
-INCLUDES = -I. $(CLASSAD_CFLAGS) $(GLOBUS_NOTHR_CFLAGS)
+INCLUDES = -I. $(CLASSAD_CFLAGS) \
+           $(GLOBUS_GSI_CRED_CFLAGS) \
+           $(GLOBUS_GSI_PROXY_CFLAGS) \
+           $(GLOBUS_GSI_UTILS_CFLAGS) \
+           $(GLOBUS_GSS_ASSIST_CFLAGS) \
+           $(GLOBUS_GSI_SYSCFG_CFLAGS) 
 
 SUBDIRS = scripts
 
@@ -41,30 +46,40 @@
 GLOBUS_EXECS =
 endif
 
-bin_PROGRAMS = batch_gahp batch_gahp_daemon BLClient BLParserLSF BLParserPBS test_condor_logger blah_job_registry_add blah_job_registry_lkup blah_job_registry_scan_by_subject BUpdaterCondor BNotifier BUpdaterLSF BUpdaterPBS BUpdaterSGE $(GLOBUS_EXECS)  blparser_master blah_check_config blah_job_registry_dump
-noinst_PROGRAMS = test_job_registry_create test_job_registry_purge test_job_registry_update test_job_registry_access
+sbin_PROGRAMS = blahpd_daemon blah_job_registry_add blah_job_registry_lkup blah_job_registry_scan_by_subject blah_check_config blah_job_registry_dump blah_job_registry_purge
+bin_PROGRAMS = blahpd
+libexec_PROGRAMS = BLClient BLParserLSF BLParserPBS BUpdaterCondor BNotifier BUpdaterLSF BUpdaterPBS BUpdaterSGE $(GLOBUS_EXECS)  blparser_master
+noinst_PROGRAMS = test_job_registry_create test_job_registry_purge test_job_registry_update test_job_registry_access test_job_registry_update_from_network test_cmdbuffer
 
-common_sources = console.c job_status.c resbuffer.c server.c commands.c classad_binary_op_unwind.C classad_c_helper.C proxy_hashcontainer.c config.c job_registry.c blah_utils.c env_helper.c mapped_exec.c md5.c 
+common_sources = console.c job_status.c resbuffer.c server.c commands.c classad_binary_op_unwind.C classad_c_helper.C proxy_hashcontainer.c config.c job_registry.c blah_utils.c env_helper.c mapped_exec.c md5.c cmdbuffer.c
 
-batch_gahp_SOURCES = main.c $(common_sources)
+blahpd_SOURCES = main.c $(common_sources)
 
-batch_gahp_daemon_SOURCES = main_daemon.c $(common_sources)
+blahpd_daemon_SOURCES = main_daemon.c $(common_sources)
 
-batch_gahp_LDADD = $(CLASSAD_LIBS) $(GLOBUS_GSS_NOTHR_LIBS) $(GLOBUS_SSL_NOTHR_LIBS)
+blahpd_LDADD = $(CLASSAD_LIBS) $(GLOBUS_GSSSAPI_GSI_LIBS) $(GLOBUS_GSS_ASSIST_LIBS)
 
-batch_gahp_daemon_LDADD = $(batch_gahp_LDADD)
+blahpd_daemon_LDADD = $(blahpd_LDADD)
 
 BPRclient_SOURCES = BPRclient.c BPRcomm.c tokens.c
 
 BPRclient_LDADD = \
-$(GLOBUS_GSS_NOTHR_LIBS) $(GLOBUS_SSL_NOTHR_LIBS)
+		$(GLOBUS_GSI_CRED_LIBS) \
+		$(GLOBUS_GSI_PROXY_LIBS) \
+		$(GLOBUS_GSI_UTILS_LIBS) \
+		$(GLOBUS_GSS_ASSIST_LIBS) \
+		$(GLOBUS_GSI_SYSCFG_LIBS)
 
 BPRserver_SOURCES = BPRserver.c BPRcomm.c tokens.c
 
 BPRserver_LDFLAGS = -static
 
 BPRserver_LDADD = \
-$(GLOBUS_GSS_NOTHR_LIBS) $(GLOBUS_SSL_NOTHR_LIBS)
+		$(GLOBUS_GSI_CRED_LIBS) \
+		$(GLOBUS_GSI_PROXY_LIBS) \
+		$(GLOBUS_GSI_UTILS_LIBS) \
+		$(GLOBUS_GSS_ASSIST_LIBS) \
+		$(GLOBUS_GSI_SYSCFG_LIBS)
 
 BLClient_SOURCES = BLClient.c blah_utils.c BLfunctions.c
 
@@ -78,10 +93,7 @@
 
 BLParserPBS_LDADD =
 
-test_condor_logger_SOURCES = test_condor_create_log.c condor_create_log.c config.c blah_utils.c
-test_condor_logger_CFLAGS = $(AM_CFLAGS)
-
-blah_job_registry_add_SOURCES = blah_job_registry_add.c job_registry.c md5.c config.c
+blah_job_registry_add_SOURCES = blah_job_registry_add.c job_registry.c job_registry_updater.c md5.c config.c
 blah_job_registry_add_CFLAGS = $(AM_CFLAGS)
 
 blah_job_registry_lkup_SOURCES = blah_job_registry_lkup.c job_registry.c md5.c config.c
@@ -91,6 +103,9 @@
 blah_job_registry_scan_by_subject_LDADD = $(CLASSAD_LIBS)
 blah_job_registry_scan_by_subject_CFLAGS = $(AM_CFLAGS)
 
+blah_job_registry_purge_SOURCES = blah_job_registry_purge.c job_registry.c md5.c
+blah_job_registry_purge_CFLAGS = $(AM_CFLAGS)
+
 test_job_registry_purge_SOURCES = test_job_registry_purge.c job_registry.c md5.c
 test_job_registry_purge_CFLAGS = $(AM_CFLAGS)
 
@@ -103,16 +118,19 @@
 test_job_registry_access_SOURCES = test_job_registry_access.c job_registry.c md5.c
 test_job_registry_access_CFLAGS = $(AM_CFLAGS)
 
-BUpdaterCondor_SOURCES = BUpdaterCondor.c Bfunctions.c job_registry.c md5.c config.c blah_utils.c
+test_job_registry_update_from_network_SOURCES = test_job_registry_update_from_network.c job_registry.c job_registry_updater.c md5.c config.c
+test_job_registry_update_from_network_CFLAGS = $(AM_CFLAGS)
+
+BUpdaterCondor_SOURCES = BUpdaterCondor.c Bfunctions.c job_registry.c md5.c config.c blah_utils.c job_registry_updater.c
 BUpdaterCondor_LDADD = -lpthread
 
 BNotifier_SOURCES = BNotifier.c Bfunctions.c job_registry.c md5.c config.c blah_utils.c
 BNotifier_LDADD = -lpthread
 
-BUpdaterLSF_SOURCES = BUpdaterLSF.c Bfunctions.c job_registry.c md5.c config.c blah_utils.c
+BUpdaterLSF_SOURCES = BUpdaterLSF.c Bfunctions.c job_registry.c md5.c config.c blah_utils.c job_registry_updater.c
 BUpdaterLSF_LDADD = -lpthread -lm
 
-BUpdaterPBS_SOURCES = BUpdaterPBS.c Bfunctions.c job_registry.c md5.c config.c blah_utils.c
+BUpdaterPBS_SOURCES = BUpdaterPBS.c Bfunctions.c job_registry.c md5.c config.c blah_utils.c job_registry_updater.c
 BUpdaterPBS_LDADD = -lpthread -lm
 
 BUpdaterSGE_SOURCES = BUpdaterSGE.c Bfunctions.c job_registry.c md5.c config.c blah_utils.c
@@ -127,8 +145,8 @@
 blah_job_registry_dump_SOURCES = blah_job_registry_dump.c job_registry.c md5.c config.c
 blah_job_registry_dump_CFLAGS = $(AM_CFLAGS)
 
-noinst_HEADERS = blahpd.h classad_binary_op_unwind.h classad_c_helper.h commands.h job_status.h resbuffer.h server.h console.h BPRcomm.h tokens.h BLParserPBS.h BLParserLSF.h condor_create_log.h proxy_hashcontainer.h job_registry.h md5.h config.h BUpdaterCondor.h Bfunctions.h BNotifier.h BUpdaterLSF.h BUpdaterPBS.h BUpdaterSGE.h blah_utils.h env_helper.h mapped_exec.h blah_check_config.h BLfunctions.h
+test_cmdbuffer_SOURCES = cmdbuffer.c
+test_cmdbuffer_CFLAGS = $(AM_CFLAGS) -DCMDBUF_DEBUG
 
-#bin_SCRIPTS = pbs_cancel.sh pbs_status.sh pbs_submit.sh lsf_cancel.sh lsf_status.sh lsf_submit.sh
+noinst_HEADERS = blahpd.h classad_binary_op_unwind.h classad_c_helper.h commands.h job_status.h resbuffer.h server.h console.h BPRcomm.h tokens.h BLParserPBS.h BLParserLSF.h proxy_hashcontainer.h job_registry.h md5.h config.h BUpdaterCondor.h Bfunctions.h BNotifier.h BUpdaterLSF.h BUpdaterPBS.h BUpdaterSGE.h blah_utils.h env_helper.h mapped_exec.h blah_check_config.h BLfunctions.h cmdbuffer.h job_registry_updater.h
 
-#EXTRA_DIST = $(bin_SCRIPTS)
Only in blahp-condor/src: Makefile.in
diff -ur blahp-condor/src/scripts/blah_common_submit_functions.sh blahp-osg/src/scripts/blah_common_submit_functions.sh
--- blahp-condor/src/scripts/blah_common_submit_functions.sh	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/scripts/blah_common_submit_functions.sh	2016-04-26 11:19:29.487397711 -0500
@@ -140,11 +140,9 @@
 #
   local container_name
   local subst_template
-  local filename
 
   container_name=${1:?"Missing container name argument to bls_fl_subst_and_dump"}
   subst_template=${2:?"Missing template argument to bls_fl_subst_and_dump"}
-  filename=${3:?"Missing filename argument to bls_fl_subst_and_dump"}
 
   local last_argument
 
@@ -156,7 +154,7 @@
   for (( ind=0 ; ind < $last_argument ; ind++ )) ; do
       bls_fl_subst $container_name $ind "$subst_template"
       if [ ! -z "$bls_fl_subst_result" ] ; then
-          echo $bls_fl_subst_result >> $filename
+          echo $bls_fl_subst_result 
       fi
   done
 }
@@ -172,13 +170,11 @@
 #
   local container_name
   local subst_template
-  local filename
   local destination_root
 
   container_name=${1:?"Missing container name argument to bls_fl_subst_relative_paths_and_dump"}
   subst_template=${2:?"Missing template argument to bls_fl_subst_relative_paths_and_dump"}
-  filename=${3:?"Missing filename argument to bls_fl_subst_relative_paths_and_dump"}
-  destination_root=$4
+  destination_root=$3
 
   local last_argument
 
@@ -206,7 +202,7 @@
       if [ "${f_workname:0:1}" != "/" ]; then
           bls_fl_subst $container_name $ind "$subst_template"
           if [ ! -z "$bls_fl_subst_result" ] ; then
-              echo $bls_fl_subst_result >> $filename
+              echo $bls_fl_subst_result 
           fi
       fi
   done
@@ -246,7 +242,7 @@
   
   if [ "x$blah_wn_proxy_renewal_daemon" == "x" ]
   then
-    bls_proxyrenewald="${blah_bin_directory}/BPRserver"
+    bls_proxyrenewald="${blah_libexec_directory}/BPRserver"
   else
     bls_proxyrenewald="$blah_wn_proxy_renewal_daemon"
   fi
@@ -267,7 +263,7 @@
   bls_opt_prnpoll=30
   bls_opt_prnlifetime=0
   
-  bls_BLClient="${blah_bin_directory}/BLClient"
+  bls_BLClient="${blah_libexec_directory}/BLClient"
   
   ###############################################################
   # Parse parameters
@@ -599,25 +595,31 @@
   fi
 } 
 
-function bls_add_job_wrapper ()
+function bls_start_job_wrapper ()
 {
   # Set the required environment variables (escape values with double quotes)
   if [ "x$bls_opt_environment" != "x" ] ; then
-          echo "" >> $bls_tmp_file
-          echo "# Setting the environment:" >> $bls_tmp_file
+          echo ""
+          echo "# Setting the environment:"
   	eval "env_array=($bls_opt_environment)"
           for  env_var in "${env_array[@]}"; do
-                   echo export \"$env_var\" >> $bls_tmp_file
+                   echo export \"$env_var\"
           done
   else
           if [ "x$bls_opt_envir" != "x" ] ; then
-                  echo "" >> $bls_tmp_file
-                  echo "# Setting the environment:" >> $bls_tmp_file
-                  echo "`echo ';'$bls_opt_envir | sed -e 's/;[^=]*;/;/g' -e 's/;[^=]*$//g' | sed -e 's/;\([^=]*\)=\([^;]*\)/;export \1=\"\2\"/g' | awk 'BEGIN { RS = ";" } ; { print $0 }'`" >> $bls_tmp_file
+                  echo ""
+                  echo "# Setting the environment:"
+                  echo "`echo ';'$bls_opt_envir | sed -e 's/;[^=]*;/;/g' -e 's/;[^=]*$//g' | sed -e 's/;\([^=]*\)=\([^;]*\)/;export \1=\"\2\"/g' | awk 'BEGIN { RS = ";" } ; { print $0 }'`"
           fi
   fi
   
-  echo "old_home=\`pwd\`">>$bls_tmp_file
+  JOB_ENV="/var/lib/osg/osg-job-environment.conf"
+  LOCAL_JOB_ENV="/var/lib/osg/osg-local-job-environment.conf"
+  for fname in $JOB_ENV $LOCAL_JOB_ENV; do
+    test -r $fname && echo "`grep -G \"^[^# ]\" $fname`"
+  done
+
+  echo "old_home=\`pwd\`"
   # Set the temporary home (including cd'ing into it)
   if [ "x$bls_opt_run_dir" != "x" ] ; then
     run_dir="$bls_opt_run_dir"
@@ -625,110 +627,120 @@
     run_dir="home_$bls_tmp_name"
   fi
   if [ -n "$blah_wn_temporary_home_dir" ] ; then
-    echo "new_home=${blah_wn_temporary_home_dir}/$run_dir">>$bls_tmp_file
+    echo "new_home=${blah_wn_temporary_home_dir}/$run_dir"
   else
-    echo "new_home=\${old_home}/$run_dir">>$bls_tmp_file
+    echo "new_home=\${old_home}/$run_dir"
   fi
 
-  echo "mkdir \$new_home">>$bls_tmp_file
-  echo "trap 'cd \$old_home; rm -rf \$new_home; exit 255' 1 2 3 15 24" >> $bls_tmp_file
-  echo "trap 'cd \$old_home; rm -rf \$new_home' 0" >> $bls_tmp_file
+  echo "mkdir \$new_home"
+  echo "trap 'wait \$job_pid; cd \$old_home; rm -rf \$new_home; exit 255' 1 2 3 15 24"
+  echo "trap 'wait \$job_pid; cd \$old_home; rm -rf \$new_home' 0"
 
-  echo "# Copy into new home any shared input sandbox file" >> $bls_tmp_file
-  bls_fl_subst_and_dump inputcopy "cp \"@@F_LOCAL\" \"\$new_home/@@F_REMOTE\" &> /dev/null" $bls_tmp_file
-  echo "# Move into new home any relative input sandbox file" >> $bls_tmp_file
-  bls_fl_subst_relative_paths_and_dump inputsand "mv \"@@F_REMOTE\" \"\$new_home/@@F_WORKNAME\" &> /dev/null" $bls_tmp_file
+  echo "# Copy into new home any shared input sandbox file"
+  bls_fl_subst_and_dump inputcopy "cp \"@@F_LOCAL\" \"\$new_home/@@F_REMOTE\" &> /dev/null" 
+  echo "# Move into new home any relative input sandbox file"
+  bls_fl_subst_relative_paths_and_dump inputsand "mv \"@@F_REMOTE\" \"\$new_home/@@F_WORKNAME\" &> /dev/null" 
 
-  echo "export HOME=\$new_home">>$bls_tmp_file
-  echo "cd \$new_home">>$bls_tmp_file
+  echo "export HOME=\$new_home"
+  echo "cd \$new_home"
   
   # Set the path to the user proxy
   if [ "x$bls_need_to_reset_proxy" == "xyes" ] ; then
-      echo "# Resetting proxy to local position" >> $bls_tmp_file
-      echo "export X509_USER_PROXY=\$new_home/${bls_proxy_remote_file}" >> $bls_tmp_file
+      echo "# Resetting proxy to local position"
+      echo "export X509_USER_PROXY=\$new_home/${bls_proxy_remote_file}"
   fi
   
   # Add the command (with full path if not staged)
-  echo "" >> $bls_tmp_file
-  echo "# Command to execute:" >> $bls_tmp_file
+  echo "" 
+  echo "# Command to execute:" 
   if [ "x$bls_opt_stgcmd" == "xyes" ] 
   then
       bls_opt_the_command="./`basename $bls_opt_the_command`"
-      echo "if [ ! -x $bls_opt_the_command ]; then chmod u+x $bls_opt_the_command; fi" >> $bls_tmp_file
-      echo "if [ -x \${GLITE_LOCATION:-/opt/glite}/libexec/jobwrapper ]" >> $bls_tmp_file
-      echo "then" >> $bls_tmp_file
-      echo "\${GLITE_LOCATION:-/opt/glite}/libexec/jobwrapper $bls_opt_the_command $bls_arguments &" >> $bls_tmp_file
-      echo "elif [ -x /opt/lcg/libexec/jobwrapper ]" >> $bls_tmp_file
-      echo "then" >> $bls_tmp_file
-      echo "/opt/lcg/libexec/jobwrapper $bls_opt_the_command $bls_arguments &" >>$bls_tmp_file
-      echo "elif [ -x \$BLAH_AUX_JOBWRAPPER ]" >> $bls_tmp_file
-      echo "then" >> $bls_tmp_file
-      echo "\$BLAH_AUX_JOBWRAPPER $bls_opt_the_command $bls_arguments &" >>$bls_tmp_file
-      echo "else" >>$bls_tmp_file
-      echo "\$new_home/`basename $bls_opt_the_command` $bls_arguments &" >> $bls_tmp_file
-      echo "fi" >>$bls_tmp_file
+      echo "if [ ! -x $bls_opt_the_command ]; then chmod u+x $bls_opt_the_command; fi" 
+      echo "if [ -x \${GLITE_LOCATION:-/opt/glite}/libexec/jobwrapper ]"
+      echo "then"
+      echo "\${GLITE_LOCATION:-/opt/glite}/libexec/jobwrapper $bls_opt_the_command $bls_arguments &" 
+      echo "elif [ -x /opt/lcg/libexec/jobwrapper ]" 
+      echo "then" 
+      echo "/opt/lcg/libexec/jobwrapper $bls_opt_the_command $bls_arguments &" 
+      echo "elif [ -x \$BLAH_AUX_JOBWRAPPER ]" 
+      echo "then" 
+      echo "\$BLAH_AUX_JOBWRAPPER $bls_opt_the_command $bls_arguments &" 
+      echo "else" 
+      echo "\$new_home/`basename $bls_opt_the_command` $bls_arguments &"
+      echo "fi" 
   else
-      echo "$bls_opt_the_command $bls_arguments &" >> $bls_tmp_file
+      echo "$bls_opt_the_command $bls_arguments &" 
   fi
   
-  echo "job_pid=\$!" >> $bls_tmp_file
+  echo "job_pid=\$!" 
   
   if [ "x$bls_opt_proxyrenew" == "xyes" ]
   then
-      echo "" >> $bls_tmp_file
-      echo "# Start the proxy renewal server" >> $bls_tmp_file
-      echo "if [ ! -x \"$remote_BPRserver\" ]; then chmod u+x \"$remote_BPRserver\"; fi" >> $bls_tmp_file
-      echo "\"$remote_BPRserver\" \$job_pid $bls_opt_prnpoll $bls_opt_prnlifetime \${$bls_job_id_for_renewal} &" >> $bls_tmp_file
-      echo "server_pid=\$!" >> $bls_tmp_file
+      echo "" 
+      echo "# Start the proxy renewal server" 
+      echo "if [ ! -x \"$remote_BPRserver\" ]; then chmod u+x \"$remote_BPRserver\"; fi" 
+      echo "\"$remote_BPRserver\" \$job_pid $bls_opt_prnpoll $bls_opt_prnlifetime \${$bls_job_id_for_renewal} &" 
+      echo "server_pid=\$!"
   fi
   
-  echo "" >> $bls_tmp_file
-  echo "# Wait for the user job to finish" >> $bls_tmp_file
-  echo "wait \$job_pid" >> $bls_tmp_file
-  echo "user_retcode=\$?" >> $bls_tmp_file
+  echo ""
+  echo "# Wait for the user job to finish"
+  echo "wait \$job_pid" 
+  echo "user_retcode=\$?"
 
   if [ "x$blah_debug_save_wn_files" != "x" ]; then
-      echo "if [ -d $blah_debug_save_wn_files ]; then" >> $bls_tmp_file
-      echo "  blw_save_dir=\"$blah_debug_save_wn_files/\`basename \$new_home\`.debug\"" >> $bls_tmp_file
-      echo "  mkdir \$blw_save_dir" >> $bls_tmp_file
-      echo "  # Saving files for debug"  >> $bls_tmp_file
-      echo "  cp \$X509_USER_PROXY \$blw_save_dir" >> $bls_tmp_file
-      [ -z ${bls_unique_stdout_name} ] || echo "  cp $bls_unique_stdout_name \$blw_save_dir" >> $bls_tmp_file
-      [ -z ${bls_unique_stderr_name} ] || echo "  cp $bls_unique_stderr_name \$blw_save_dir" >> $bls_tmp_file
-      echo "fi" >> $bls_tmp_file
+      echo "if [ -d $blah_debug_save_wn_files ]; then"
+      echo "  blw_save_dir=\"$blah_debug_save_wn_files/\`basename \$new_home\`.debug\""
+      echo "  mkdir \$blw_save_dir"
+      echo "  # Saving files for debug"
+      echo "  cp \$X509_USER_PROXY \$blw_save_dir"
+      [ -z ${bls_unique_stdout_name} ] || echo "  cp $bls_unique_stdout_name \$blw_save_dir"
+      [ -z ${bls_unique_stderr_name} ] || echo "  cp $bls_unique_stderr_name \$blw_save_dir"
+      echo "fi"
   fi
 
   if [ "x$bls_opt_proxyrenew" == "xyes" ]
   then
-      echo "# Kill the watchdog when done" >> $bls_tmp_file
-      echo "sleep 1" >> $bls_tmp_file
-      echo "kill \$server_pid 2> /dev/null" >> $bls_tmp_file
+      echo "# Kill the watchdog when done"
+      echo "sleep 1"
+      echo "kill \$server_pid 2> /dev/null"
+  fi
+  
+  echo "" 
+  echo "# Move all relative outputsand paths out of temp home"
+  echo "cd \$new_home"
+  bls_fl_subst_relative_paths_and_dump outputsand "mv \"@@F_WORKNAME\" \"@@F_REMOTE\" 2> /dev/null" "\\\$old_home" 
+  echo "# Move any remapped outputsand file to shared directories"
+  bls_fl_subst_relative_paths_and_dump outputmove "mv \"@@F_REMOTE\" \"@@F_LOCAL\" 2> /dev/null"
+  
+  echo ""
+  echo "# Remove the staged files, if any"
+  bls_fl_subst_and_dump inputcopy "rm \"@@F_REMOTE\" 2> /dev/null"
+  bls_fl_subst_relative_paths_and_dump inputsand "rm \"@@F_WORKNAME\" 2> /dev/null"
+}
+
+function bls_finish_job_wrapper ()
+{
+  echo "cd \$old_home"
+  if [ "x$bls_opt_proxy_string" != "x" ]
+  then
+    echo "rm -f $bls_opt_proxy_string"
   fi
-  
-  echo ""  >> $bls_tmp_file
-  echo "# Move all relative outputsand paths out of temp home" >> $bls_tmp_file
-  echo "cd \$new_home" >> $bls_tmp_file
-  bls_fl_subst_relative_paths_and_dump outputsand "mv \"@@F_WORKNAME\" \"@@F_REMOTE\" 2> /dev/null" $bls_tmp_file "\\\$old_home" 
-  echo "# Move any remapped outputsand file to shared directories" >> $bls_tmp_file
-  bls_fl_subst_relative_paths_and_dump outputmove "mv \"@@F_REMOTE\" \"@@F_LOCAL\" 2> /dev/null" $bls_tmp_file
-  
-  echo ""  >> $bls_tmp_file
-  echo "# Remove the staged files, if any" >> $bls_tmp_file
-  bls_fl_subst_and_dump inputcopy "rm \"@@F_REMOTE\" 2> /dev/null" $bls_tmp_file
-  bls_fl_subst_relative_paths_and_dump inputsand "rm \"@@F_WORKNAME\" 2> /dev/null" $bls_tmp_file
 
-  echo "cd \$old_home" >> $bls_tmp_file
-  
-  echo "" >> $bls_tmp_file
+  echo ""
   
-  echo "exit \$user_retcode" >> $bls_tmp_file
+  echo "exit \$user_retcode"
 
   # Exit if it was just a test
   if [ "x$debug" == "xyes" ]
   then
       exit 255
   fi
+}
 
+function bls_test_working_dir ()
+{
   if [ "x$bls_opt_workdir" != "x" ]; then
       cd $bls_opt_workdir
   elif [ "x$blah_set_default_workdir_to_home" == "xyes" ]; then
@@ -743,6 +755,13 @@
   fi
 }
 
+function bls_add_job_wrapper ()
+{
+  bls_start_job_wrapper >> $bls_tmp_file
+  bls_finish_job_wrapper >> $bls_tmp_file
+  bls_test_working_dir
+}
+
 function bls_set_up_local_and_extra_args ()
 {
   if [ -r $bls_local_submit_attributes_file ] ; then
Only in blahp-condor/src/scripts: blah_common_submit_functions.sh.orig
diff -ur blahp-condor/src/scripts/blah_load_config.sh blahp-osg/src/scripts/blah_load_config.sh
--- blahp-condor/src/scripts/blah_load_config.sh	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/scripts/blah_load_config.sh	2016-04-26 11:19:29.488397981 -0500
@@ -31,15 +31,29 @@
 else
   blah_bin_directory="/usr/bin"
 fi
+if [ "x$BLAHPD_LOCATION" != "x" -a -d "${BLAHPD_LOCATION}/sbin" ]; then
+  blah_sbin_directory="${BLAHPD_LOCATION}/sbin"
+elif [ -d "${GLITE_LOCATION:-/opt/glite}/sbin" ]; then
+  blah_sbin_directory="${GLITE_LOCATION:-/opt/glite}/sbin"
+else
+  blah_sbin_directory="/usr/sbin"
+fi
+if [ "x$BLAHPD_LOCATION" != "x" -a -d "${BLAHPD_LOCATION}/libexec" ]; then
+  blah_libexec_directory="${BLAHPD_LOCATION}/libexec"
+elif [ -d "${GLITE_LOCATION:-/opt/glite}/libexec" ]; then
+  blah_libexec_directory="${GLITE_LOCATION:-/opt/glite}/libexec"
+else
+  blah_libexec_directory="/usr/libexec"
+fi
 
 # Let blah_bin_directory be overridden in the config file.
 
 if [ -r "$BLAHPD_CONFIG_LOCATION" ]; then
   . $BLAHPD_CONFIG_LOCATION
-elif [ -r "${GLITE_LOCATION:-/opt/glite}/etc/batch_gahp.config" ]; then
-  . ${GLITE_LOCATION:-/opt/glite}/etc/batch_gahp.config
-elif [ -r "${BLAHPD_LOCATION}/etc/batch_gahp.config" ]; then
-#   This will default to /etc/batch_gahp.config if BLAHPD_LOCATION is unset.
-  . ${BLAHPD_LOCATION}/etc/batch_gahp.config
+elif [ -r "${GLITE_LOCATION:-/opt/glite}/etc/blah.config" ]; then
+  . ${GLITE_LOCATION:-/opt/glite}/etc/blah.config
+elif [ -r "${BLAHPD_LOCATION}/etc/blah.config" ]; then
+#   This will default to /etc/blah.config if BLAHPD_LOCATION is unset.
+  . ${BLAHPD_LOCATION}/etc/blah.config
 fi
 
diff -ur blahp-condor/src/scripts/condor_status.sh blahp-osg/src/scripts/condor_status.sh
--- blahp-condor/src/scripts/condor_status.sh	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/scripts/condor_status.sh	2016-04-26 11:19:29.492396772 -0500
@@ -23,11 +23,15 @@
 # limitations under the License.
 #
 
-
 proxy_dir=~/.blah_jobproxy_dir
 
 . `dirname $0`/blah_load_config.sh
 
+if [ "x$job_registry" != "x" ] ; then
+   ${blah_sbin_directory}/blah_job_registry_lkup $@
+   exit 0
+fi
+
 FORMAT='-format "%d" ClusterId -format "," ALWAYS -format "%d" JobStatus -format "," ALWAYS -format "%f" RemoteSysCpu -format "," ALWAYS -format "%f" RemoteUserCpu -format "," ALWAYS -format "%f" BytesSent -format "," ALWAYS -format "%f" BytesRecvd -format "," ALWAYS -format "%f" RemoteWallClockTime -format "," ALWAYS -format "%d" ExitBySignal -format "," ALWAYS -format "%d" ExitCode -format "%d" ExitSignal -format "\n" ALWAYS'
 
 # The "main" for this script is way at the bottom of the file.
@@ -268,7 +272,7 @@
     #   instead of using -f.
     history_file=$($condor_binpath/condor_config_val $target -schedd history)
     if [ "$?" == "0" ]; then
-	line=$(echo $FORMAT | _condor_HISTORY="$history_file" xargs $condor_binpath/condor_history -backwards -match 1 $id)
+	line=$(echo $FORMAT | _condor_HISTORY="$history_file" xargs $condor_binpath/condor_history -f $history_file -backwards -match 1 $id)
 	if  [ ! -z "$line" ] ; then
 	    echo "0$(make_ad $job "$line")"
 	    exit 0
diff -ur blahp-condor/src/scripts/condor_submit.sh blahp-osg/src/scripts/condor_submit.sh
--- blahp-condor/src/scripts/condor_submit.sh	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/scripts/condor_submit.sh	2016-04-26 11:19:29.493398123 -0500
@@ -47,13 +47,13 @@
 # script debug flag: currently unused
 debug=no
 
-# number of MPI nodes: interpretted as a core count for vanilla universe
-mpinodes=1
+# number of MPI nodes: currently unused
+mpinodes=0
 
 # Name of local requirements file: currently unused
 req_file=""
 
-while getopts "a:i:o:de:j:n:N:z:h:S:v:V:c:w:x:u:q:r:s:T:I:O:R:C:D:m:" arg 
+while getopts "a:i:o:de:j:n:v:V:c:w:x:u:q:r:s:T:I:O:R:C:D:m:" arg 
 do
     case "$arg" in
     a) xtra_args="$OPTARG" ;;
@@ -66,10 +66,6 @@
     V) environment="$OPTARG";;
     c) command="$OPTARG" ;;
     n) mpinodes="$OPTARG" ;;
-    N) hostsmpsize="$OPTARG";;
-    z) wholenodes="$OPTARG";;
-    h) hostnumber="$OPTARG";;
-    S) smpgranularity="$OPTARG";;
     w) workdir="$OPTARG";;
     x) proxy_file="$OPTARG" ;;
     u) proxy_subject="$OPTARG" ;;
@@ -187,7 +183,7 @@
 	if [ ! -z "${remap_files[0]}" ] ; then
 	    map=${remap_files[$i]}
 	else
-	    map=${output_files$i]}
+	    map=${output_files[$i]}
 	fi
 	transfer_output_remaps="$transfer_output_remaps;${output_files[$i]}=$map"
     done
@@ -245,13 +241,12 @@
   echo -e $xtra_args >> $submit_file
 fi
 
-if [ "x$req_mem" != "x" ]
+if [ "x$req_mem" != "x"]
 then
   echo "request_memory = $req_mem" >> $submit_file
 fi
 
 cat >> $submit_file << EOF
-request_cpus = $mpinodes
 # We insist on new style quoting in Condor
 arguments = $arguments
 input = $stdin
@@ -277,7 +272,7 @@
 fi
 
 #local batch system-specific file output must be added to the submit file
-local_submit_attributes_file=${blah_bin_directory}/condor_local_submit_attributes.sh
+local_submit_attributes_file=${blah_libexec_directory}/condor_local_submit_attributes.sh
 if [ -r $local_submit_attributes_file ] ; then
     echo \#\!/bin/sh > $tmp_req_file
     if [ ! -z $req_file ] ; then
@@ -330,7 +325,7 @@
     blahp_jobID="condor/$jobID/$queue/$pool"
 
     if [ "x$job_registry" != "x" ]; then
-      `dirname $0`/blah_job_registry_add "$blahp_jobID" "$jobID" 1 $now "$creamjobid" "$proxy_file" 0 "$proxy_subject"
+      ${blah_sbin_directory}/blah_job_registry_add "$blahp_jobID" "$jobID" 1 $now "$creamjobid" "$proxy_file" 0 "$proxy_subject"
     fi
 
     echo "BLAHP_JOBID_PREFIX$blahp_jobID"
diff -ur blahp-condor/src/scripts/lsf_status.sh blahp-osg/src/scripts/lsf_status.sh
--- blahp-condor/src/scripts/lsf_status.sh	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/scripts/lsf_status.sh	2016-04-26 11:19:29.499397845 -0500
@@ -35,7 +35,7 @@
 . `dirname $0`/blah_load_config.sh
 
 if [ "x$job_registry" != "x" ] ; then
-   ${blah_bin_directory}/blah_job_registry_lkup $@
+   ${blah_sbin_directory}/blah_job_registry_lkup $@
    exit 0
 fi
 
@@ -55,7 +55,7 @@
    
 srvfound=""
 
-BLClient="${blah_bin_directory}/BLClient"
+BLClient="${blah_libexec_directory}/BLClient"
 
 ###############################################################
 # Parse parameters
@@ -319,15 +319,15 @@
 }
 
 $0 ~ rex_uhold {
-	jobstatus = 5
+	jobstatus = 7
 }
 
 $0 ~ rex_phold {
-	jobstatus = 5
+	jobstatus = 1
 }
 
 $0 ~ rex_shold {
-	jobstatus = 5
+	jobstatus = 7
 }
 
 END {
diff -ur blahp-condor/src/scripts/lsf_submit.sh blahp-osg/src/scripts/lsf_submit.sh
--- blahp-condor/src/scripts/lsf_submit.sh	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/scripts/lsf_submit.sh	2016-04-26 11:19:29.500398014 -0500
@@ -143,15 +143,15 @@
 # --- End of MPI directives
 
 #local batch system-specific file output must be added to the submit file
-bls_local_submit_attributes_file=${blah_bin_directory}/lsf_local_submit_attributes.sh
+bls_local_submit_attributes_file=${blah_libexec_directory}/lsf_local_submit_attributes.sh
 
 bls_set_up_local_and_extra_args
 
 # Write LSF directives according to command line options
 
 # File transfer directives. Input and output sandbox
-bls_fl_subst_and_dump inputsand "#BSUB -f \"@@F_LOCAL > @@F_REMOTE\"" $bls_tmp_file
-bls_fl_subst_and_dump outputsand "#BSUB -f \"@@F_LOCAL < @@F_REMOTE\"" $bls_tmp_file
+bls_fl_subst_and_dump inputsand "#BSUB -f \"@@F_LOCAL > @@F_REMOTE\"" >> $bls_tmp_file
+bls_fl_subst_and_dump outputsand "#BSUB -f \"@@F_LOCAL < @@F_REMOTE\"" >> $bls_tmp_file
 
 # Accommodate for CERN-specific job subdirectory creation.
 echo "" >> $bls_tmp_file
@@ -264,7 +264,7 @@
 if [ "x$job_registry" != "x" ]; then
   now=`date +%s`
   let now=$now-1
-  `dirname $0`/blah_job_registry_add "$blahp_jobID" "$jobID" 1 $now "$bls_opt_creamjobid" "$bls_proxy_local_file" "$bls_opt_proxyrenew_numeric" "$bls_opt_proxy_subject"
+  ${blah_sbin_directory}/blah_job_registry_add "$blahp_jobID" "$jobID" 1 $now "$bls_opt_creamjobid" "$bls_proxy_local_file" "$bls_opt_proxyrenew_numeric" "$bls_opt_proxy_subject"
 fi
 
 echo ""
Only in blahp-condor/src/scripts: Makefile
diff -ur blahp-condor/src/scripts/Makefile.am blahp-osg/src/scripts/Makefile.am
--- blahp-condor/src/scripts/Makefile.am	2011-09-09 04:58:16.000000000 -0500
+++ blahp-osg/src/scripts/Makefile.am	2016-04-26 11:19:29.486396426 -0500
@@ -2,7 +2,7 @@
 # * BLAHP scripts * 
 # *****************
 #
-# $Id: Makefile.am,v 1.5.2.3 2011/09/09 09:58:16 mezzadri Exp $ 
+# $Id: Makefile.am,v 1.10 2012/01/13 11:23:44 mezzadri Exp $ 
 #
 # File:           Makefile.am
 #
@@ -31,11 +31,14 @@
 #
 
 
-bin_SCRIPTS = blah_load_config.sh blah_common_submit_functions.sh \
+libexec_SCRIPTS = blah_load_config.sh blah_common_submit_functions.sh \
   pbs_cancel.sh pbs_status.sh pbs_submit.sh pbs_hold.sh pbs_resume.sh \
   lsf_cancel.sh lsf_status.sh lsf_submit.sh lsf_hold.sh lsf_resume.sh \
   condor_cancel.sh condor_status.sh condor_submit.sh condor_hold.sh condor_resume.sh \
   sge_cancel.sh sge_helper sge_resume.sh sge_submit.sh sge_filestaging \
-  sge_hold.sh sge_status.sh runcmd.pl.template sge_local_submit_attributes.sh 
+  sge_hold.sh sge_status.sh runcmd.pl.template sge_local_submit_attributes.sh \
+  slurm_cancel.sh slurm_resume.sh slurm_status.sh \
+  slurm_submit.sh \
+  pbs_status.py
 
 EXTRA_DIST = $(bin_SCRIPTS)
Only in blahp-condor/src/scripts: Makefile.in
diff -ur blahp-condor/src/scripts/pbs_cancel.sh blahp-osg/src/scripts/pbs_cancel.sh
--- blahp-condor/src/scripts/pbs_cancel.sh	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/scripts/pbs_cancel.sh	2016-04-26 11:19:29.501396300 -0500
@@ -35,13 +35,6 @@
         requested=`echo $job | sed 's/^.*\///'`
         cmdout=`${pbs_binpath}/qdel $requested 2>&1`
         retcode=$?
-        # If the job is already completed or no longer in the queue,
-        # treat it as successfully deleted.
-        if echo "$cmdout" | grep -q 'Unknown Job' ; then
-                retcode=0
-        elif echo "$cmdout" | grep -q 'Request invalid for state of job MSG=invalid state for job - COMPLETE' ; then
-                retcode=0
-        fi
         if [ "$retcode" == "0" ] ; then
                 if [ "$jnr" == "1" ]; then
                         echo " 0 No\\ error"
Only in blahp-osg/src/scripts: pbs_status.py
diff -ur blahp-condor/src/scripts/pbs_status.sh blahp-osg/src/scripts/pbs_status.sh
--- blahp-condor/src/scripts/pbs_status.sh	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/scripts/pbs_status.sh	2016-04-26 11:19:29.506397885 -0500
@@ -34,7 +34,7 @@
 . `dirname $0`/blah_load_config.sh
 
 if [ "x$job_registry" != "x" ] ; then
-   ${blah_bin_directory}/blah_job_registry_lkup $@
+   ${blah_sbin_directory}/blah_job_registry_lkup $@
    exit 0
 fi
 
@@ -56,7 +56,7 @@
 
 srvfound=""
 
-BLClient="${blah_bin_directory}/BLClient"
+BLClient="${blah_libexec_directory}/BLClient"
 
 qstatuser=`whoami`
 qstatcache=/tmp/qstatcache_${qstatuser}.txt
@@ -82,6 +82,9 @@
 
 /Job Id:/ {
     current_job = substr($0, index($0, ":") + 2)
+    end = index(current_job, ".")
+    if ( end == 0 ) { end = length(current_job) + 1 }
+    current_job = substr(current_job, 1, end)
 }
 /exec_host =/ {
     current_wn = substr($0, index($0, "=")+2)
@@ -201,9 +204,6 @@
 
 END {
         if (current_js ~ "Q")  {jobstatus = 1}
-        if (current_js ~ "W")  {jobstatus = 1}
-        if (current_js ~ "S")  {jobstatus = 1}
-        if (current_js ~ "T")  {jobstatus = 1}
         if (current_js ~ "R")  {jobstatus = 2}
         if (current_js ~ "E")  {jobstatus = 2}
         if (current_js ~ "C")  {jobstatus = 4}
@@ -231,14 +231,14 @@
         errout=`cat $staterr`
 	rm -f $staterr 2>/dev/null
 	
-        if [ "$qstat_exit_code" -eq "153" ] ; then
-                # If the job has disappeared, assume it's completed
+        if [ -z "$errout" ] ; then
+                echo "0"$result
+                retcode=0
+        elif [ "$qstat_exit_code" -eq "153" ] ; then
+                # If the job has disappeared, assume it's completed 
                 # (same as globus)
                 echo "0[BatchJobId=\"$reqjob\";JobStatus=4;ExitCode=0]"
                 retcode=0
-        elif [ -z "$errout" ] ; then
-                echo "0"$result
-                retcode=0
         else
                 echo "1ERROR: Job not found"
                 retcode=1
Only in blahp-condor/src/scripts: pbs_status.sh.orig
diff -ur blahp-condor/src/scripts/pbs_submit.sh blahp-osg/src/scripts/pbs_submit.sh
--- blahp-condor/src/scripts/pbs_submit.sh	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/scripts/pbs_submit.sh	2016-04-26 11:19:29.507397268 -0500
@@ -46,8 +46,14 @@
 
 logpath=${pbs_spoolpath}/server_logs
 if [ ! -d $logpath -o ! -x $logpath ]; then
- pbs_spoolpath=`${pbs_binpath}/tracejob | grep 'default prefix path'|awk -F" " '{ print $5 }'`
- logpath=${pbs_spoolpath}/server_logs
+  if [ -x "${pbs_binpath}/tracejob" ]; then
+    pbs_spoolpath=`${pbs_binpath}/tracejob | grep 'default prefix path'|awk -F" " '{ print $5 }'`
+    logpath=${pbs_spoolpath}/server_logs
+  else
+    # EPEL defaults for torque
+    pbs_spoolpath=/var/lib/torque/spool
+    logpath=/var/lib/torque/server_logs
+  fi
 fi
 
 bls_job_id_for_renewal=PBS_JOBID
@@ -109,14 +115,31 @@
 fi
 
 #local batch system-specific file output must be added to the submit file
-bls_local_submit_attributes_file=${blah_bin_directory}/pbs_local_submit_attributes.sh
+bls_local_submit_attributes_file=${blah_libexec_directory}/pbs_local_submit_attributes.sh
 
-if [ "x$bls_opt_req_mem" != "x" ]
-then
-  # Different schedulers require different memory checks
-  echo "#PBS -l mem=${bls_opt_req_mem}mb" >> $bls_tmp_file
-  echo "#PBS -l pmem=${bls_opt_req_mem}mb" >> $bls_tmp_file
-  echo "#PBS -l pvmem=${bls_opt_req_mem}mb" >> $bls_tmp_file
+${pbs_binpath}/qstat --version 2>&1 | grep PBSPro > /dev/null 2>&1
+is_pbs_pro=$?
+# Begin building the select statement: select=x where x is the number of 'chunks'
+# to request. Chunk requests should precede any resource requests (resource
+# requests are order independent). An example from the PBS Pro manual:
+# #PBS -l  select=2:ncpus=8:mpiprocs=8:mem=6gb:interconnect=10g,walltime=16:00:00
+# Only one chunk is required for OSG needs at this time.
+pbs_select="#PBS -l select=1"
+
+if [ "x$bls_opt_req_mem" != "x" ]; then
+    # Max amount of virtual memory allocated to a single process
+    if [[ "x$pbs_set_pvmem" == "xyes" ]]; then
+        echo "#PBS -l pvmem=${bls_opt_req_mem}mb" >> $bls_tmp_file
+    fi
+    # Max amount of physical memory allocated to a single process
+    if [[ "$bls_opt_smpgranularity" == 1 ]]; then
+        echo "#PBS -l pmem=${bls_opt_req_mem}mb" >> $bls_tmp_file
+    fi
+    # Total amount of memory allocated to the job
+    pbs_select="$pbs_select:mem=${bls_opt_req_mem}mb"
+    if [ "$is_pbs_pro" != 0 ]; then
+        echo "#PBS -l mem=${bls_opt_req_mem}mb" >> $bls_tmp_file
+    fi
 fi
 
 bls_set_up_local_and_extra_args
@@ -126,48 +149,50 @@
 [ -z "$bls_opt_queue" ] || grep -q "^#PBS -q" $bls_tmp_file || echo "#PBS -q $bls_opt_queue" >> $bls_tmp_file
 
 # Extended support for MPI attributes
-if [ "x$bls_opt_wholenodes" == "xyes" ] ; then
-  bls_opt_hostsmpsize=${bls_opt_hostsmpsize:-1}
-  if [[ ! -z "$bls_opt_smpgranularity" ]] ; then
-    if [[ -z "$bls_opt_hostnumber" ]] ; then
-      echo "#PBS -l nodes=1:ppn=$bls_opt_hostsmpsize" >> $bls_tmp_file
-    else
-      echo "#PBS -l nodes=$bls_opt_hostnumber:ppn=$bls_opt_hostsmpsize" >> $bls_tmp_file
-    fi
-    echo "#PBS -W x=NACCESSPOLICY:SINGLEJOB" >> $bls_tmp_file
-  else
-    if [[ ! -z "$bls_opt_hostnumber" ]] ; then
-      if [[ $bls_opt_mpinodes -gt 0 ]] ; then
-        r=$((bls_opt_mpinodes % bls_opt_hostnumber))
-        (( r )) && mpireminder="+$r:ppn=$bls_opt_hostsmpsize"
-        echo "#PBS -l nodes=$((bls_opt_hostnumber-r)):ppn=${bls_opt_hostsmpsize}${mpireminder}" >> $bls_tmp_file
-      else
-        echo "#PBS -l nodes=$bls_opt_hostnumber:ppn=$bls_opt_hostsmpsize" >> $bls_tmp_file
-      fi
-      echo "#PBS -W x=NACCESSPOLICY:SINGLEJOB" >> $bls_tmp_file
-    fi
-  fi
+if [ "$is_pbs_pro" == 0 ]; then
+    pbs_select="$pbs_select:ncpus=1"
 else
-  if [[ ! -z "$bls_opt_smpgranularity" ]] ; then
-    n=$((bls_opt_mpinodes / bls_opt_smpgranularity))
-    r=$((bls_opt_mpinodes % bls_opt_smpgranularity))
-    (( r )) && mpireminder="+1:ppn=$r"
-    echo "#PBS -l nodes=$n:ppn=${bls_opt_smpgranularity}${mpireminder}" >> $bls_tmp_file
-  else
-    if [[ ! -z "$bls_opt_hostnumber" ]] ; then
-      n=$((bls_opt_mpinodes / bls_opt_hostnumber))
-      r=$((bls_opt_mpinodes % bls_opt_hostnumber))
-      (( r )) && mpireminder="+$r:ppn=$((n+1))"
-      echo "#PBS -l nodes=$((bls_opt_hostnumber-r)):ppn=$n$mpireminder" >> $bls_tmp_file
-    elif [[ $bls_opt_mpinodes -gt 0 ]] ; then
-      echo "#PBS -l nodes=$bls_opt_mpinodes" >> $bls_tmp_file
+    if [ "x$bls_opt_wholenodes" == "xyes" ]; then
+        bls_opt_hostsmpsize=${bls_opt_hostsmpsize:-1}
+        if [[ ! -z "$bls_opt_smpgranularity" ]] ; then
+            if [[ -z "$bls_opt_hostnumber" ]] ; then
+                echo "#PBS -l nodes=1:ppn=$bls_opt_hostsmpsize" >> $bls_tmp_file
+            else
+                echo "#PBS -l nodes=$bls_opt_hostnumber:ppn=$bls_opt_hostsmpsize" >> $bls_tmp_file
+            fi
+            echo "#PBS -W x=NACCESSPOLICY:SINGLEJOB" >> $bls_tmp_file
+        else
+            if [[ ! -z "$bls_opt_hostnumber" ]] ; then
+                if [[ $bls_opt_mpinodes -gt 0 ]] ; then
+                    r=$((bls_opt_mpinodes % bls_opt_hostnumber))
+                    (( r )) && mpireminder="+$r:ppn=$bls_opt_hostsmpsize"
+                    echo "#PBS -l nodes=$((bls_opt_hostnumber-r)):ppn=${bls_opt_hostsmpsize}${mpireminder}" >> $bls_tmp_file
+                else
+                    echo "#PBS -l nodes=$bls_opt_hostnumber:ppn=$bls_opt_hostsmpsize" >> $bls_tmp_file
+                fi
+                echo "#PBS -W x=NACCESSPOLICY:SINGLEJOB" >> $bls_tmp_file
+            fi
+        fi
+    else
+        if [[ ! -z "$bls_opt_smpgranularity" ]] ; then
+            n=$((bls_opt_mpinodes / bls_opt_smpgranularity))
+            r=$((bls_opt_mpinodes % bls_opt_smpgranularity))
+            (( r )) && mpireminder="+1:ppn=$r"
+            echo "#PBS -l nodes=$n:ppn=${bls_opt_smpgranularity}${mpireminder}" >> $bls_tmp_file
+        else
+            if [[ ! -z "$bls_opt_hostnumber" ]] ; then
+                n=$((bls_opt_mpinodes / bls_opt_hostnumber))
+                r=$((bls_opt_mpinodes % bls_opt_hostnumber))
+                (( r )) && mpireminder="+$r:ppn=$((n+1))"
+                echo "#PBS -l nodes=$((bls_opt_hostnumber-r)):ppn=$n$mpireminder" >> $bls_tmp_file
+            elif [[ $bls_opt_mpinodes -gt 0 ]] ; then
+                echo "#PBS -l nodes=$bls_opt_mpinodes" >> $bls_tmp_file
+            fi
+        fi
     fi
-  fi
 fi
 # --- End of MPI directives
 
-
-
 # Input and output sandbox setup.
 if [ "x$blah_torque_multiple_staging_directive_bug" == "xyes" ]; then
   bls_fl_subst_and_accumulate inputsand "stagein=@@F_REMOTE@`hostname -f`:@@F_LOCAL" ","
@@ -175,8 +200,8 @@
   bls_fl_subst_and_accumulate outputsand "stageout=@@F_REMOTE@`hostname -f`:@@F_LOCAL" ","
   [ -z "$bls_fl_subst_and_accumulate_result" ] || echo "#PBS -W $bls_fl_subst_and_accumulate_result" >> $bls_tmp_file
 elif [ "x$blah_torque_multiple_staging_directive_bug" == "xmultiline" ]; then
-  bls_fl_subst_and_dump inputsand "#PBS -W stagein=@@F_REMOTE@`hostname -f`:@@F_LOCAL" $bls_tmp_file
-  bls_fl_subst_and_dump outputsand "#PBS -W stageout=@@F_REMOTE@`hostname -f`:@@F_LOCAL" $bls_tmp_file
+  bls_fl_subst_and_dump inputsand "#PBS -W stagein=@@F_REMOTE@`hostname -f`:@@F_LOCAL" >> $bls_tmp_file
+  bls_fl_subst_and_dump outputsand "#PBS -W stageout=@@F_REMOTE@`hostname -f`:@@F_LOCAL" >> $bls_tmp_file
 else
   bls_fl_subst_and_accumulate inputsand "@@F_REMOTE@`hostname -f`:@@F_LOCAL" ","
   [ -z "$bls_fl_subst_and_accumulate_result" ] || echo "#PBS -W stagein=\\'$bls_fl_subst_and_accumulate_result\\'" >> $bls_tmp_file
@@ -184,6 +209,10 @@
   [ -z "$bls_fl_subst_and_accumulate_result" ] || echo "#PBS -W stageout=\\'$bls_fl_subst_and_accumulate_result\\'" >> $bls_tmp_file
 fi
 
+if [ "$is_pbs_pro" == 0 ]; then
+    echo $pbs_select >> $bls_tmp_file
+fi
+
 echo "#PBS -m n"  >> $bls_tmp_file
 
 bls_add_job_wrapper
@@ -202,6 +231,8 @@
 retcode=$?
 if [ "$retcode" != "0" ] ; then
 	rm -f $bls_tmp_file
+	# Echo the output from qsub onto stderr, which is captured by HTCondor
+	echo "Error from qsub: $jobID" >&2
 	exit 1
 fi
 
@@ -209,7 +240,7 @@
 jobID=`echo $jobID | awk 'match($0,/[0-9]+/){print substr($0, RSTART, RLENGTH)}'`
 if [ "X$jobID" == "X" ]; then
 	rm -f $bls_tmp_file
-	echo "Error: job id missing" >&2
+	echo "Error from qsub: $jobID" >&2
 	echo Error # for the sake of waiting fgets in blahpd
 	exit 1
 fi
@@ -292,7 +323,7 @@
 if [ "x$job_registry" != "x" ]; then
   now=`date +%s`
   let now=$now-1
-  `dirname $0`/blah_job_registry_add "$blahp_jobID" "$jobID" 1 $now "$bls_opt_creamjobid" "$bls_proxy_local_file" "$bls_opt_proxyrenew_numeric" "$bls_opt_proxy_subject"
+  ${blah_sbin_directory}/blah_job_registry_add "$blahp_jobID" "$jobID" 1 $now "$bls_opt_creamjobid" "$bls_proxy_local_file" "$bls_opt_proxyrenew_numeric" "$bls_opt_proxy_subject"
 fi
 
 echo "BLAHP_JOBID_PREFIX$blahp_jobID"
diff -ur blahp-condor/src/scripts/sge_cancel.sh blahp-osg/src/scripts/sge_cancel.sh
--- blahp-condor/src/scripts/sge_cancel.sh	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/scripts/sge_cancel.sh	2016-04-26 11:19:29.509396878 -0500
@@ -20,7 +20,7 @@
 #
 
 
-[ -f ${GLITE_LOCATION:-/opt/glite}/etc/batch_gahp.config ] && . ${GLITE_LOCATION:-/opt/glite}/etc/batch_gahp.config
+. `dirname $0`/blah_load_config.sh
 
 if [ -z "$sge_rootpath" ]; then sge_rootpath="/usr/local/sge/pro"; fi
 if [ -r "$sge_rootpath/${sge_cellname:-default}/common/settings.sh" ]
diff -ur blahp-condor/src/scripts/sge_hold.sh blahp-osg/src/scripts/sge_hold.sh
--- blahp-condor/src/scripts/sge_hold.sh	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/scripts/sge_hold.sh	2016-04-26 11:19:29.512397167 -0500
@@ -20,7 +20,7 @@
 #
 
 
-[ -f ${GLITE_LOCATION:-/opt/glite}/etc/batch_gahp.config ] && . ${GLITE_LOCATION:-/opt/glite}/etc/batch_gahp.config
+. `dirname $0`/blah_load_config.sh
 
 if [ -z "$sge_rootpath" ]; then sge_rootpath="/usr/local/sge/pro"; fi
 if [ -r "$sge_rootpath/${sge_cellname:-default}/common/settings.sh" ]
diff -ur blahp-condor/src/scripts/sge_local_submit_attributes.sh blahp-osg/src/scripts/sge_local_submit_attributes.sh
--- blahp-condor/src/scripts/sge_local_submit_attributes.sh	2011-07-20 01:19:25.000000000 -0500
+++ blahp-osg/src/scripts/sge_local_submit_attributes.sh	2016-04-26 11:19:29.513397929 -0500
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-# $Id: sge_local_submit_attributes.sh,v 1.1.4.2 2011/07/20 06:19:25 rrosende Exp $
+# $Id: sge_local_submit_attributes.sh,v 1.1 2011/07/20 06:15:34 rrosende Exp $
 
 # The memory and wall time requirements as passed from the job
 # description file (JDL) need to be passed on to the local batch
diff -ur blahp-condor/src/scripts/sge_resume.sh blahp-osg/src/scripts/sge_resume.sh
--- blahp-condor/src/scripts/sge_resume.sh	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/scripts/sge_resume.sh	2016-04-26 11:19:29.514397792 -0500
@@ -20,7 +20,7 @@
 #
 
 
-[ -f ${GLITE_LOCATION:-/opt/glite}/etc/batch_gahp.config ] && . ${GLITE_LOCATION:-/opt/glite}/etc/batch_gahp.config
+. `dirname $0`/blah_load_config.sh
 
 if [ -z "$sge_rootpath" ]; then sge_rootpath="/usr/local/sge/pro"; fi
 if [ -r "$sge_rootpath/${sge_cellname:-default}/common/settings.sh" ]
diff -ur blahp-condor/src/scripts/sge_status.sh blahp-osg/src/scripts/sge_status.sh
--- blahp-condor/src/scripts/sge_status.sh	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/scripts/sge_status.sh	2016-04-26 11:19:29.515398234 -0500
@@ -20,9 +20,9 @@
 #
 
 
-[ -f ${GLITE_LOCATION:-/opt/glite}/etc/batch_gahp.config ] && . ${GLITE_LOCATION:-/opt/glite}/etc/batch_gahp.config
+. `dirname $0`/blah_load_config.sh
 
-sge_helper_path=${GLITE_LOCATION:-/opt/glite}/bin
+sge_helper_path=${blah_libexec_directory}
 
 usage_string="Usage: $0 [-w] [-n]"
 
@@ -52,7 +52,7 @@
 
 if [ "x$getcreamport" == "xyes" ]
 then
-    exec `dirname $0`/blah_job_registry_lkup -n
+    exec ${blah_sbin_directory}/blah_job_registry_lkup -n
 fi
 
 if [ -z "$sge_rootpath" ]; then sge_rootpath="/usr/local/sge/pro"; fi
@@ -67,7 +67,7 @@
 jobid=${tmpid}.${sge_cellname:-default}
 
 
-blahp_status=`exec ${sge_helper_path:-/opt/glite/bin}/sge_helper --status $getwn $jobid`
+blahp_status=`exec ${sge_helper_path}/sge_helper --status $getwn $jobid`
 retcode=$?
 
 # Now see if we need to run qstat 'manually'
Only in blahp-condor/src/scripts: sge_status.sh.orig
diff -ur blahp-condor/src/scripts/sge_submit.sh blahp-osg/src/scripts/sge_submit.sh
--- blahp-condor/src/scripts/sge_submit.sh	2011-09-02 04:05:50.000000000 -0500
+++ blahp-osg/src/scripts/sge_submit.sh	2016-04-26 11:19:29.516396673 -0500
@@ -64,7 +64,7 @@
 end_of_preamble
 
 #local batch system-specific file output must be added to the submit file
-local_submit_attributes_file=${GLITE_LOCATION:-/opt/glite}/bin/sge_local_submit_attributes.sh
+local_submit_attributes_file=${blah_libexec_directory}/sge_local_submit_attributes.sh
 if [ -r $local_submit_attributes_file ] ; then
     echo \#\!/bin/sh > $bls_opt_tmp_req_file
     if [ ! -z $bls_opt_req_file ] ; then
@@ -83,7 +83,7 @@
 # Write SGE directives according to command line options
 # handle queue overriding
 [ -z "$bls_opt_queue" ] || grep -q "^#\$ -q" $bls_tmp_file || echo "#\$ -q $bls_opt_queue" >> $bls_tmp_file
-[ -z "$bls_opt_mpinodes" -o "x${bls_opt_mpinodes}" = "x1" ] || grep -q"^#\$ -pe *\\*" $bls_tmp_file || echo "#\$ -pe * $bls_opt_mpinodes" >>$bls_tmp_file
+[ -z "$bls_opt_mpinodes" -o "x${bls_opt_mpinodes}" = "x1" ] || grep -q "^#\$ -pe *\\*" $bls_tmp_file || echo "#\$ -pe * $bls_opt_mpinodes" >>$bls_tmp_file
 
 # Input and output sandbox setup.
 bls_fl_subst_and_accumulate inputsand "@@F_REMOTE@`hostname -f`:@@F_LOCAL" "@@@"
@@ -114,7 +114,7 @@
 if [ "x$job_registry" != "x" ]; then
   now=`date +%s`
   let now=$now-1
-  `dirname $0`/blah_job_registry_add "$blahp_jobID" "$jobID" 1 $now "$bls_opt_creamjobid" "$bls_proxy_local_file" "$bls_opt_proxyrenew_numeric" "$bls_opt_proxy_subject"
+  ${blah_sbin_directory}/blah_job_registry_add "$blahp_jobID" "$jobID" 1 $now "$bls_opt_creamjobid" "$bls_proxy_local_file" "$bls_opt_proxyrenew_numeric" "$bls_opt_proxy_subject"
 fi
 
 echo "BLAHP_JOBID_PREFIX$blahp_jobID"
Only in blahp-osg/src/scripts: slurm_cancel.sh
Only in blahp-osg/src/scripts: slurm_hold.sh
Only in blahp-osg/src/scripts: slurm_resume.sh
Only in blahp-osg/src/scripts: slurm_status.sh
Only in blahp-osg/src/scripts: slurm_submit.sh
diff -ur blahp-condor/src/server.c blahp-osg/src/server.c
--- blahp-condor/src/server.c	2016-04-26 10:38:53.000000000 -0500
+++ blahp-osg/src/server.c	2016-04-26 11:19:29.524396888 -0500
@@ -33,6 +33,8 @@
 #   18 Mar 2009 - (rebatto@mi.infn.it) Glexec references replaced with generic
 #                                      mapping names. Constants' definitions
 #                                      moved to mapped_exec.h.
+#   15 Sep 2011 - (prelz@mi.infn.it). Optionally pass any submit attribute
+#                                     to local configuration script.
 #                                      
 #
 #  Description:
@@ -60,6 +62,8 @@
 #
 */
 
+#include "acconfig.h"
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -93,6 +97,7 @@
 #include "mapped_exec.h"
 #include "proxy_hashcontainer.h"
 #include "blah_utils.h"
+#include "cmdbuffer.h"
 
 #define COMMAND_PREFIX "-c"
 #define JOBID_REGEXP            "(^|\n)BLAHP_JOBID_PREFIX([^\n]*)"
@@ -116,6 +121,10 @@
 #define TRUE  1
 #endif
 
+#ifndef VERSION
+#define VERSION            "1.8.0"
+#endif
+
 const char *opt_format[] = {
 	" %s %s",          /* NO_QUOTE */
 	" %s '%s'",        /* SINGLE_QUOTE */
@@ -137,10 +146,10 @@
 int set_cmd_string_option(char **command, classad_context cad, const char *attribute, const char *option, const int quote_style);
 int set_cmd_int_option(char **command, classad_context cad, const char *attribute, const char *option, const int quote_style);
 int set_cmd_bool_option(char **command, classad_context cad, const char *attribute, const char *option, const int quote_style);
-char *limit_proxy(char* proxy_name, char *requested_name);
+static char *limit_proxy(char* proxy_name, char *requested_name, char **error_message);
 int getProxyInfo(char* proxname, char** subject, char** fqan);
 int logAccInfo(char* jobId, char* server_lrms, classad_context cad, char* fqan, char* userDN, char** environment);
-int CEReq_parse(classad_context cad, char* filename);
+int CEReq_parse(classad_context cad, char* filename, char *proxysubject, char *proxyfqan);
 char* outputfileRemaps(char *sb,char *sbrmp);
 int check_TransferINOUT(classad_context cad, char **command, char *reqId, char **resultLine, char ***files_to_clean_up);
 char *ConvertArgs(char* args, char sep);
@@ -149,6 +158,7 @@
 struct blah_managed_child {
 	char *exefile;
 	char *pidfile;
+	char *sname;
 	time_t lastfork;
 };
 static struct blah_managed_child *blah_children=NULL;
@@ -183,6 +193,8 @@
 
 static char *mapping_parameter[MEXEC_PARAM_COUNT];
 
+static char **submit_attributes_to_pass = NULL;
+static int pass_all_submit_attributes = FALSE;
 
 /* Check on good health of our managed children
  **/
@@ -235,8 +247,8 @@
 			/* Don't attempt to restart too often. */
 			if ((now - children[i].lastfork) < calldiff) 
 			{
-				fprintf(stderr,"Restarting %s too frequently.\n",
-					children[i].exefile);
+				fprintf(stderr,"Restarting %s (%s) too frequently.\n",
+					children[i].exefile, children[i].sname);
 				fprintf(stderr,"Last restart %d seconds ago (<%d).\n",
 					(int)(now - children[i].lastfork), calldiff);
 				continue;
@@ -287,6 +299,7 @@
 serveConnection(int cli_socket, char* cli_ip_addr)
 {
 	char *input_buffer;
+	int get_cmd_res;
 	char *reply;
 	char *result;
 	char *cmd_result;
@@ -315,15 +328,32 @@
 	struct stat tmp_stat;
 	config_entry *jr_mmap;
 	job_registry_index_mode jr_mode;
+	config_entry *check_children_interval_conf;
+	int check_children_interval = -1; /* no timeout by default */
+        config_entry *pass_attr;
+	int virtualorg_found;
+	char **attr;
+	int n_attrs;
 
 	blah_config_handle = config_read(NULL);
 	if (blah_config_handle == NULL)
 	{
-		fprintf(stderr, "Cannot access batch_gahp.config file in default locations ($BLAHPD_CONFIG_LOCATION, or $GLITE_LOCATION/etc or $BLAHPD_LOCATION/etc): ");
+		fprintf(stderr, "Cannot access blah.config file in default locations ($BLAHPD_CONFIG_LOCATION, or $GLITE_LOCATION/etc or $BLAHPD_LOCATION/etc): ");
 		perror("");
 		exit(MALLOC_ERROR);
 	}
 
+	check_children_interval_conf = config_get("blah_check_children_interval",blah_config_handle);
+	if (check_children_interval_conf != NULL)
+		check_children_interval = atoi(check_children_interval_conf->value);
+
+	/* Start with a 4 KB input buffer */
+	if (cmd_buffer_init(cli_socket, 4096, check_children_interval) != CMDBUF_OK)
+	{
+		perror("Cannot allocate input buffer");
+		exit(MALLOC_ERROR);
+	}
+
 	blah_accounting_log_location = config_get("BLAHPD_ACCOUNTING_INFO_LOG",blah_config_handle);
 	blah_accounting_log_umask = config_get("blah_accounting_log_umask",blah_config_handle);
 	max_threaded_conf = config_get("blah_max_threaded_cmds",blah_config_handle);
@@ -349,6 +379,8 @@
 /* In the Condor build of the blahp, we can find all the libraries we need
  * via the RUNPATH. Setting LD_LIBRARY_PATH can muck up the command line
  * tools for the local batch system.
+ *
+ * Similarly, in OSG, all Globus libraries are in the expected location.
  */
 #if 0
 	needed_libs = make_message("%s/lib:%s/externals/lib:%s/lib:/opt/lcg/lib", result, result, getenv("GLOBUS_LOCATION") ? getenv("GLOBUS_LOCATION") : "/opt/globus");
@@ -366,15 +398,47 @@
 	}
 	else
 	 	 setenv("LD_LIBRARY_PATH",needed_libs,1);
-#endif
-	
-	blah_script_location = strdup(blah_config_handle->bin_path);
+#endif	
+	blah_script_location = strdup(blah_config_handle->libexec_path);
 	blah_version = make_message(RCSID_VERSION, VERSION, "poly,new_esc_format");
 	require_proxy_on_submit = config_test_boolean(config_get("blah_require_proxy_on_submit",blah_config_handle));
 	enable_condor_glexec = config_test_boolean(config_get("blah_enable_glexec_from_condor",blah_config_handle));
 	disable_wn_proxy_renewal = config_test_boolean(config_get("blah_disable_wn_proxy_renewal",blah_config_handle));
 	disable_proxy_user_copy = config_test_boolean(config_get("blah_disable_proxy_user_copy",blah_config_handle));
         disable_limited_proxy = config_test_boolean(config_get("blah_disable_limited_proxy",blah_config_handle));
+
+	/* Scan configuration for submit attributes to pass to local script */
+	pass_all_submit_attributes = config_test_boolean(config_get("blah_pass_all_submit_attributes",blah_config_handle));
+	if (!pass_all_submit_attributes)
+	{
+		pass_attr = config_get("blah_pass_submit_attributes",blah_config_handle);
+		if (pass_attr != NULL)
+		{
+			submit_attributes_to_pass = pass_attr->values;
+		}
+		virtualorg_found = FALSE;
+		n_attrs = 0;
+		for (attr = submit_attributes_to_pass; (attr != NULL) && ((*attr) != NULL); attr++)
+		{
+			if (strcmp(*attr, "VirtualOrganisation") == 0) virtualorg_found = TRUE;
+			n_attrs++;
+		}
+		/* Make sure we have VirtualOrganisation here */
+		if (!virtualorg_found)
+		{
+			submit_attributes_to_pass = realloc(submit_attributes_to_pass, n_attrs+2);
+			if (submit_attributes_to_pass != NULL)
+			{
+				submit_attributes_to_pass[n_attrs] = strdup("VirtualOrganisation");
+				submit_attributes_to_pass[n_attrs+1] = NULL;
+				if (pass_attr != NULL)
+				{
+					pass_attr->values = submit_attributes_to_pass;
+				}
+			}
+		}
+		
+	}
 				
 	if (enable_condor_glexec)
 	{
@@ -480,8 +544,10 @@
 			}
 			blah_children[blah_children_count].exefile = strdup(child_config_exe->value);
 			blah_children[blah_children_count].pidfile = strdup(child_config_pid->value);
+			blah_children[blah_children_count].sname = strdup(*child_prefix);
 			if (blah_children[blah_children_count].exefile == NULL ||
-			    blah_children[blah_children_count].pidfile == NULL)
+			    blah_children[blah_children_count].pidfile == NULL ||
+                            blah_children[blah_children_count].sname == NULL )
 			{
 				fprintf(stderr, "Out of memory\n");
 				exit(MALLOC_ERROR);
@@ -505,8 +571,12 @@
 	write(server_socket, "\r\n", 2);
 	while(!exit_program)
 	{
-		input_buffer = get_command(cli_socket);
-		if (input_buffer)
+		get_cmd_res = cmd_buffer_get_command(&input_buffer);
+		if (get_cmd_res == CMDBUF_TIMEOUT)
+		{
+			if (blah_children_count>0) check_on_children(blah_children, blah_children_count);
+		}
+		else if (get_cmd_res == CMDBUF_OK)
 		{
 			if (parse_command(input_buffer, &argc, &argv) == 0)
 				command = find_command(argv[0]);
@@ -537,7 +607,13 @@
 
 						if (sem_trywait(&sem_total_commands))
 						{
-							reply = make_message("F Threads\\ limit\\ reached\r\n");
+							if (errno == EAGAIN)
+								reply = make_message("F Threads\\ limit\\ reached\r\n");
+							else
+							{
+								perror("sem_trywait()");
+								exit(1);
+							}
 						}
 						else if (pthread_create(&task_tid, &cmd_threads_attr, command->cmd_handler, (void *)argv))
 						{
@@ -577,7 +653,7 @@
 			
 			free(input_buffer);
 		}
-		else /* command was NULL */
+		else /* cmd_buffer_get_command() returned an error */
 		{
 			if (synchronous_termination)
 			{
@@ -612,6 +688,7 @@
 		}
 
 	}
+
 	if (cli_socket != 0) 
 	{
 		shutdown(cli_socket, SHUT_RDWR);
@@ -620,6 +697,7 @@
 
 	free(blah_script_location);
 	free(blah_version);
+	cmd_buffer_free();
 
 	exit(exitcode);
 }
@@ -888,11 +966,12 @@
 		/* proxt4 must be limited for subsequent submission */		
 		if(argv[3][0]=='0')
 		{
-			if((proxynameNew = limit_proxy(proxt4, NULL)) == NULL)
+                  if (((proxynameNew = limit_proxy(proxt4, NULL, NULL)) == NULL) ||
+                      (disable_limited_proxy))
 			{
 				free(mapping_parameter[MEXEC_PARAM_DELEGCRED]);
 				mapping_parameter[MEXEC_PARAM_DELEGCRED] = NULL;
-				result = strdup("F Cannot\\ limit\\ proxy\\ file");
+				result = strdup("F Not\\ limiting\\ proxy\\ file");
 			}
 			else
 				mapping_parameter[MEXEC_PARAM_SRCPROXY] = proxynameNew;
@@ -958,6 +1037,7 @@
 	char *error_string;
 	int res = 1;
 	char *proxyname = NULL;
+	char *iwd = NULL;
 	char *proxysubject = NULL;
 	char *proxyfqan = NULL;
 	char *proxynameNew   = NULL;
@@ -1018,6 +1098,30 @@
 			proxyname = NULL;
 		}
 	}
+	/* If the proxy is a relative path, we must prepend the Iwd to make it absolute */
+	if (proxyname && proxyname[0] != '/') {
+		if (classad_get_dstring_attribute(cad, "Iwd", &iwd) == C_CLASSAD_NO_ERROR) {
+			size_t iwdlen = strlen(iwd);
+			size_t proxylen = iwdlen + strlen(proxyname) + 1;
+			char *proxynameTmp;
+			proxynameTmp = malloc(proxylen + 1);
+			if (!proxynameTmp) {
+				resultLine = make_message("%s 1 Malloc\\ failure N/A", reqId);
+				goto cleanup_lrms;
+			}
+			memcpy(proxynameTmp, iwd, iwdlen);
+			proxynameTmp[iwdlen] = '/';
+			strcpy(proxynameTmp+iwdlen+1, proxyname);
+			free(proxyname);
+			free(iwd);
+			iwd = NULL;
+			proxyname = proxynameTmp;
+			proxynameTmp = NULL;
+		} else {
+			resultLine = make_message("%s 1 Relative\\ x509UserProxy\\ specified\\ without\\ Iwd N/A", reqId);
+			goto cleanup_lrms;
+		}
+	}
 
 	/* If there are additional arguments, we have to map on a different id */
 	if(argv[CMD_SUBMIT_JOB_ARGS + 1] != NULL)
@@ -1055,10 +1159,14 @@
 	else if ((proxyname) != NULL && (!disable_limited_proxy))
 	{
 		/* not in glexec mode: need to limit the proxy */
-		if((proxynameNew = limit_proxy(proxyname, NULL)) == NULL)
+		char *errmsg;
+		if((proxynameNew = limit_proxy(proxyname, NULL, &errmsg)) == NULL)
 		{
 			/* PUSH A FAILURE */
-			resultLine = make_message("%s 1 Unable\\ to\\ limit\\ the\\ proxy N/A", reqId);
+			char * escaped_errmsg = (errmsg) ? escape_spaces(errmsg) : NULL;
+			if (escaped_errmsg) resultLine = make_message("%s 1 Unable\\ to\\ limit\\ the\\ proxy\\ (%s) N/A", reqId, escaped_errmsg);
+			else resultLine = make_message("%s 1 Unable\\ to\\ limit\\ the\\ proxy N/A", reqId);
+			if (errmsg) free(errmsg);
 			goto cleanup_proxyname;
 		}
 		free(proxyname);
@@ -1172,7 +1280,7 @@
 	/* Set the CE requirements */
 	gettimeofday(&ts, NULL);
 	req_file = make_message("%s/ce-req-file-%d%d",tmp_dir, ts.tv_sec, ts.tv_usec);
-	if(CEReq_parse(cad, req_file) >= 0)
+	if(CEReq_parse(cad, req_file, proxysubject, proxyfqan) >= 0)
 	{
 		command_ext = make_message("%s -C %s", command, req_file);
 		if (command_ext == NULL)
@@ -1661,7 +1769,7 @@
 }
 
 int
-get_status_and_old_proxy(int use_glexec, char *jobDescr, 
+get_status_and_old_proxy(int use_glexec, char *jobDescr, const char *proxyFileName,
 			char **status_argv, char **old_proxy,
 			char **workernode, char **error_string)
 {
@@ -1753,6 +1861,21 @@
 				job_registry_free_split_id(spid);
 				return 1; /* 'local' state */
 			}
+			// Look for the limited proxy next to the new proxy - this is a common case for HTCondor-based submission.
+			free(proxy_link);
+			if ((proxy_link = make_message("%s.lmt", proxyFileName)) == NULL)
+			{
+				fprintf(stderr, "Out of memory.\n");
+				exit(MALLOC_ERROR);
+			}
+			if (access(proxy_link, R_OK) == 0)
+			{
+				*old_proxy = proxy_link;
+				// do not free proxy_link in this case.
+				free(r_old_proxy);
+				job_registry_free_split_id(spid);
+				return 1;
+			}
 			free(proxy_link);
 			free(r_old_proxy);
 			job_registry_free_split_id(spid);
@@ -1873,7 +1996,7 @@
 
 	if (blah_children_count>0) check_on_children(blah_children, blah_children_count);
 
-	jobStatus=get_status_and_old_proxy(use_mapping, jobDescr, argv + CMD_RENEW_PROXY_ARGS + 1, &old_proxy, &workernode, &error_string);
+	jobStatus=get_status_and_old_proxy(use_mapping, jobDescr, proxyFileName, argv + CMD_RENEW_PROXY_ARGS + 1, &old_proxy, &workernode, &error_string);
 	old_proxy_len = -1;
 	if (old_proxy != NULL) old_proxy_len = strlen(old_proxy);
 	if ((jobStatus < 0) || (old_proxy == NULL) || (old_proxy_len <= 0))
@@ -1889,20 +2012,20 @@
 		switch(jobStatus)
 		{
 			case 1: /* job queued: copy the proxy locally */
-				if ((!use_mapping) && (!disable_limited_proxy))
-				{
-					limit_proxy(proxyFileName, old_proxy); /*FIXME: should check if limited proxies are enabled? */ 
+                               if ((!use_mapping) && (!disable_limited_proxy)
+				){
+					limit_proxy(proxyFileName, old_proxy, NULL);
 					resultLine = make_message("%s 0 Proxy\\ renewed", reqId);
 				}
 				else
 				{
 					exe_command.delegation_type = atoi(argv[CMD_RENEW_PROXY_ARGS + 1 + MEXEC_PARAM_DELEGTYPE]);
 					exe_command.delegation_cred = argv[CMD_RENEW_PROXY_ARGS + 1 + MEXEC_PARAM_DELEGCRED];
-					if (use_glexec)
+					if ((use_glexec) && (disable_limited_proxy))
 					{
 						exe_command.source_proxy = argv[CMD_RENEW_PROXY_ARGS + 1 + MEXEC_PARAM_SRCPROXY];
 					} else {
-						limited_proxy_name = limit_proxy(proxyFileName, NULL);
+						limited_proxy_name = limit_proxy(proxyFileName, NULL, NULL);
 						exe_command.source_proxy = limited_proxy_name;
 					}
 					exe_command.dest_proxy = old_proxy;
@@ -2018,22 +2141,16 @@
 	{
                if((!use_glexec) && (!disable_limited_proxy))
 		{
-			proxyFileNameNew = limit_proxy(proxyFileName, NULL);
+			proxyFileNameNew = limit_proxy(proxyFileName, NULL, NULL);
 		}
 		else
 			proxyFileNameNew = strdup(argv[CMD_SEND_PROXY_TO_WORKER_NODE_ARGS + MEXEC_PARAM_SRCPROXY + 1]);
 
-/* In the Condor build of the blahp, we can find all the libraries we need
- * via the RUNPATH. GLOBUS_LOCATION is unlikely to be set, and /opt/globus
- * is very unlikely to contain anything useful.
- */
-#if 0
 		/* Add the globus library path */
 		ld_path = make_message("LD_LIBRARY_PATH=%s/lib",
 		                           getenv("GLOBUS_LOCATION") ? getenv("GLOBUS_LOCATION") : "/opt/globus");
 		push_env(&exe_command.environment, ld_path);
 		free(ld_path);
-#endif
 
 		delegate_switch = "";
 		if (config_test_boolean(config_get("blah_delegate_renewed_proxies",blah_config_handle)))
@@ -2347,111 +2464,6 @@
 /* Utility functions
  * */
 
-char*
-get_command(int s)
-{
-	static char *cmd_queue = NULL;
-	static char *next_cmd;
-	static char *queue_end;
-	char *message = NULL;
-	char *tmp_realloc;
-	int allocated_size = 0;
-	char buffer[2047];
-	int read_chars = 0; 
-	int recv_chars, i;
-	int done = FALSE;
-	char last_char;
-
-	/* if the queue is empty, read from the socket */
-	if (!cmd_queue)
-	{
-		while (!done)
-		{
-			if ((recv_chars = read(s, buffer, sizeof(buffer))) > 0)
-			{
-				if ((read_chars + recv_chars) > allocated_size)
-				{
-					allocated_size += sizeof(buffer) + 1;
-					tmp_realloc = (char *) realloc (message, allocated_size);
-					if (tmp_realloc == NULL)
-					{
-						allocated_size = 0;
-						perror("Error allocating buffer for incoming message");
-						close(s);
-						if (message) free(message);
-						exit(MALLOC_ERROR);
-					}
-					else
-						message = tmp_realloc;
-				}
-				memcpy(&message[read_chars], buffer, recv_chars);
-				read_chars += recv_chars;
-				message[read_chars] = '\000';
-			} else {
-				/* Error or EOF */
-				break;
-			}
-			if (message != NULL) {
-				/* Require LF terminated messages */
-				last_char = message[read_chars -1];
-				if (last_char == '\n') break;
-			}
-		}
-	
-		if (recv_chars <= 0)
-		{
-			return(NULL);
-		}
-		else if (read_chars > 0)
-		{
-			/* return(message); */
-			cmd_queue = strdup(message);
-			next_cmd = cmd_queue;
-			queue_end = cmd_queue + read_chars;
-			free(message);
-		}
-	}
-
-	/* save the pointer to current command */
-	message = next_cmd;
-
-	/* search for end of current command */
-	while(next_cmd <= queue_end)
-	{
-		if (*next_cmd == '\n' || *next_cmd == '\r' || *next_cmd == '\000') break;
-		next_cmd++;
-	}
-
-	/* mark end of command */
-	*next_cmd = '\000';
-	
-	/* make a copy of the command to be returned */
-	message = strdup(message);
-	if (message == NULL)
-	{
-		fprintf(stderr, "Out of memory.\n");
-		exit(MALLOC_ERROR);
-	}
-
-	/* search for beginning of next command */
-	next_cmd++;
-	while(next_cmd <= queue_end)
-	{
-		if ((*next_cmd != '\n' && *next_cmd != '\r') || *next_cmd == '\000') break;
-		next_cmd++;
-	}
-	
-	/* if we reached end of queue free all */
-	if (next_cmd >= queue_end)
-	{
-		free(cmd_queue);
-		cmd_queue = NULL;
-		next_cmd = NULL;
-	}
-	
-	return(message);
-}
-
 int
 enqueue_result(char *res)
 {
@@ -2601,7 +2613,7 @@
 	if (to_append) free (to_append);
 	return(result);
 }
-
+ 
 const char *grid_proxy_errmsg = NULL;
 
 int activate_globus()
@@ -2756,8 +2768,8 @@
 	return rc;
 }
 
-char *
-limit_proxy(char* proxy_name, char *limited_proxy_name)
+static char *
+limit_proxy(char* proxy_name, char *limited_proxy_name, char **error_message)
 {
 	int seconds_left, hours_left, minutes_left;
 	char *limcommand;
@@ -2778,6 +2790,35 @@
 		limited_proxy_name = limited_proxy_made_up_name;
 	}
 
+	/* Sanity check - make sure the destination is writable and the source exists */
+	tmpfd = open(limited_proxy_name, O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR);
+	if (tmpfd == -1)
+	{
+		char * errmsg = make_message("Unable to create limited proxy file (%s):"
+		    " errno=%d, %s", limited_proxy_name, errno, strerror(errno));
+		if (limited_proxy_made_up_name != NULL) free(limited_proxy_made_up_name);
+		if (!errmsg) return(NULL);
+		if (error_message) *error_message = errmsg; else free(errmsg);
+		return NULL;
+	}
+	else
+	{
+		close(tmpfd);
+	}
+	if ((tmpfd = open(proxy_name, O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR)) == -1)
+	{
+		char * errmsg = make_message("Unable to read proxy file (%s):" 
+		    " errno=%d, %s", proxy_name, errno, strerror(errno));
+		if (limited_proxy_made_up_name != NULL) free(limited_proxy_made_up_name);
+		if (!errmsg) return(NULL);
+		if (error_message) *error_message = errmsg; else if (errmsg) free(errmsg);
+		return NULL;
+	}
+	else
+	{
+		close(tmpfd);
+	}
+
 	seconds_left = grid_proxy_info( proxy_name );
 	if ( seconds_left < 0 ) {
 		perror("blahpd error reading proxy lifetime");
@@ -2816,7 +2857,9 @@
 		if (fpr == NULL)
 		{
 			fprintf(stderr, "blahpd limit_proxy: Cannot open %s in append mode to obtain file lock: %s\n", limited_proxy_name, strerror(errno));
+			char * errmsg = make_message("Cannot open %s in append mode to obtain file lock: %s", limited_proxy_name, strerror(errno));
 			if (limited_proxy_made_up_name != NULL) free(limited_proxy_made_up_name);
+			if (error_message && errmsg) *error_message= errmsg; else if (errmsg) free(errmsg);
 			return(NULL);
 		}
 		/* Acquire lock on limited proxy */
@@ -2828,7 +2871,9 @@
 		{
 			fclose(fpr);
 			fprintf(stderr, "blahpd limit_proxy: Cannot obtain write file lock on %s: %s\n", limited_proxy_name, strerror(errno));
+			char * errmsg = make_message("Cannot obtain write file lock on %s: %s", limited_proxy_name, strerror(errno));
 			if (limited_proxy_made_up_name != NULL) free(limited_proxy_made_up_name);
+			if (error_message && errmsg) *error_message= errmsg; else if (errmsg) free(errmsg);
 			return(NULL);
 		}
 	} 
@@ -2859,8 +2904,10 @@
 			{
 				fprintf(stderr, "blahpd limit_proxy: Cannot open %s in append mode to obtain file lock: %s\n", limited_proxy_name, strerror(errno));
 				unlink(limit_command_output);
+				char * errmsg = make_message("Cannot open %s in append mode to obtain file lock: %s", limited_proxy_name, strerror(errno));
 				free(limit_command_output);
 				if (limited_proxy_made_up_name != NULL) free(limited_proxy_made_up_name);
+				if (error_message && errmsg) *error_message= errmsg; else if (errmsg) free(errmsg);
 				return(NULL);
 			}	
 			/* Acquire lock on limited proxy */
@@ -2872,9 +2919,11 @@
 			{
 				fclose(fpr);
 				fprintf(stderr, "blahpd limit_proxy: Cannot obtain write file lock on %s: %s\n", limited_proxy_name, strerror(errno));
+				char * errmsg = make_message("Cannot obtain write file lock on %s: %s", limited_proxy_name, strerror(errno));
 				unlink(limit_command_output);
 				free(limit_command_output);
 				if (limited_proxy_made_up_name != NULL) free(limited_proxy_made_up_name);
+				if (error_message && errmsg) *error_message= errmsg; else free(errmsg);
 				return(NULL);
 			}
 		}
@@ -3126,30 +3175,53 @@
 	return 0;
 }
 
-int CEReq_parse(classad_context cad, char* filename)
+int CEReq_parse(classad_context cad, char* filename, 
+                char *proxysubject, char *proxyfqan)
 {
 	FILE *req_file=NULL;
 	char **reqstr=NULL;
 	char **creq;
 	int cs=0;
-	char *vo=NULL;
+	char *attr=NULL;
 	int n_written=-1;
 	config_entry *aen;
 	int i;
+	char **reqattr=NULL;
+	int clret;
+
+	if (pass_all_submit_attributes)
+	{
+		classad_get_attribute_names(cad, &reqattr);
+	} else {
+		reqattr = submit_attributes_to_pass;
+	}
 
-	classad_get_dstring_attribute(cad, "VirtualOrganisation", &vo);
-	if(vo)
+	for (creq = reqattr; ((creq != NULL) && ((*creq) != NULL)); creq++)
 	{
-		if (req_file== NULL)
+		clret = classad_get_dstring_attribute(cad, *creq, &attr);
+		if((clret == C_CLASSAD_NO_ERROR) && (attr != NULL))
 		{
-			req_file=fopen(filename,"w");
-			if(req_file==NULL) return -1;
+ 			if (req_file== NULL)
+			{
+				req_file=fopen(filename,"w");
+				if(req_file==NULL) return -1;
+			}
+			if (strcasecmp(*creq, "x509UserProxySubject") == 0)
+			{
+				cs = fprintf(req_file, "%s='%s'\n", *creq, proxysubject);
+			} else if (strcasecmp(*creq, "x509UserProxyFQAN") == 0) {
+				cs = fprintf(req_file, "%s='%s'\n", *creq, proxyfqan);
+			} else {
+				cs = fprintf(req_file, "%s='%s'\n", *creq, attr);
+			}
+			free(attr);
+			n_written++;
 		}
-		cs = fwrite("VirtualOrganisation=", 1, strlen("VirtualOrganisation="), req_file);
-		cs = fwrite(vo, 1, strlen(vo), req_file);
-		cs = fwrite("\n" ,1, strlen("\n"), req_file);
-		free(vo);
-		n_written++;
+	}
+
+	if (pass_all_submit_attributes)
+	{
+		classad_free_results(reqattr);
 	}
 
 	/* Look up any configured attribute */
@@ -3185,14 +3257,7 @@
 	if (req_file != NULL) fclose(req_file);
 
 free_reqstr:
-	if (reqstr != NULL)
-	{
-		for(creq=reqstr; (*creq)!=NULL; creq++)
-		{
-			free(*creq);
-		}
-		free(reqstr);
-	}
+	classad_free_results(reqstr);
 	return n_written;
 }
 
@@ -3206,7 +3271,7 @@
         char *superbufferRemaps = NULL;
         char *superbufferTMP = NULL;
         char *iwd = NULL;
-	int  iwd_alloc = 256;
+	size_t  iwd_alloc = 256;
         struct timeval ts;
         int i=0,cs=0,fc=0,iwdlen=0;
         char *cur, *next_comma;
@@ -3229,13 +3294,15 @@
 	if (result == C_CLASSAD_NO_ERROR)
 	{
 		result = classad_get_dstring_attribute(cad, "Iwd", &iwd);
+		/* very tempting, but it's a linux-only extension to POSIX:
+		if (iwd == NULL) iwd = getcwd(NULL, 0); */
 		if(iwd == NULL)
 		{
 			/* Try to set iwd to the current directory */
 			iwd = (char *)malloc(iwd_alloc);
 			while (iwd != NULL)
 			{
-				if (getcwd(iwd, iwd_alloc) < 0)
+				if (getcwd(iwd, iwd_alloc) == NULL)
 				{
 					if (errno == ERANGE)
 					{
@@ -3524,10 +3591,10 @@
 
 #define SINGLE_QUOTE_CHAR '\''
 #define DOUBLE_QUOTE_CHAR '\"'
-#define CONVARG_OPENING        "'\""
-#define CONVARG_OPENING_LEN    2
-#define CONVARG_CLOSING        "\"'\000"
-#define CONVARG_CLOSING_LEN    3
+#define CONVARG_OPENING        "\"\\\""
+#define CONVARG_OPENING_LEN    3
+#define CONVARG_CLOSING        "\\\"\"\000"
+#define CONVARG_CLOSING_LEN    4
 #define CONVARG_QUOTSEP        "\\\"%c\\\""
 #define CONVARG_QUOTSEP_LEN    5
 #define CONVARG_DBLQUOTESC     "\\\\\\\""
@@ -3593,9 +3660,8 @@
 			memcpy(result + j, CONVARG_DBLQUOTESC, CONVARG_DBLQUOTESC_LEN);
 			j += CONVARG_DBLQUOTESC_LEN;
 		}
-		/* Must escape a few meta-characters for wordexp */
 		else if ((original[i] == '(') || (original[i] == ')') || (original[i] == '&'))
-		{
+		{	/* Must escape a few meta-characters for wordexp */
 			result[j++] = '\\';
 			result[j++] = original[i];
 		}
Only in blahp-condor/src: server.c.orig
Only in blahp-condor/src: test_condor_create_log.c
Only in blahp-osg/src: test_job_registry_update_from_network.c
