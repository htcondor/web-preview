diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7a431ff..c63d455 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -29,7 +29,7 @@ set(PACKAGE "condor")
 #   Condor and other systems parse this number. Keep it simple:
 #   Number.Number.Number. Do nothing else.  If you need to add
 #   more information, PRE_RELEASE is usually the right location.
-set(VERSION "8.2.3")
+set(VERSION "8.3.0")
 
 # Set PRE_RELEASE to either a string (i.e. "PRE-RELEASE-UWCS") or OFF
 #   This shuld be "PRE-RELEASE-UWCS most of the time, and OFF when
@@ -37,8 +37,8 @@ set(VERSION "8.2.3")
 #   perhaps because you are working on a feature branch and need to
 #   ship test binaries to a user, change this to identify your work.
 #   Avoid whitespace.
-set(PRE_RELEASE "PRE-RELEASE-UWCS")
-#set(PRE_RELEASE OFF)
+#set(PRE_RELEASE "PRE-RELEASE-UWCS")
+set(PRE_RELEASE OFF)
 
 # If set via the cmake command line, FORCE_PRE_RELEASE allows for
 #   PRE_RELEASE to be forced into a build.
diff --git a/build/cmake/CondorConfigure.cmake b/build/cmake/CondorConfigure.cmake
index 9057f45..45cc131 100644
--- a/build/cmake/CondorConfigure.cmake
+++ b/build/cmake/CondorConfigure.cmake
@@ -188,6 +188,7 @@ if( NOT WINDOWS)
 	check_symbol_exists(MS_SHARED  "sys/mount.h" HAVE_MS_SHARED)
 	check_symbol_exists(MS_SLAVE  "sys/mount.h" HAVE_MS_SLAVE)
 	check_symbol_exists(MS_REC  "sys/mount.h" HAVE_MS_REC)
+	check_symbol_exists(fdatasync "unistd.h" HAVE_FDATASYNC)
 
 	check_function_exists("access" HAVE_ACCESS)
 	check_function_exists("clone" HAVE_CLONE)
diff --git a/doc/admin-man/configure.tex b/doc/admin-man/configure.tex
index 01030ab..5310f56 100644
--- a/doc/admin-man/configure.tex
+++ b/doc/admin-man/configure.tex
@@ -8445,6 +8445,22 @@ These macros affect the \Condor{negotiator}.
   where X equals number of consecutive jobs in the queue 
   within the same auto cluster.
 
+\label{param:NegotiatorResourceRequestListSize}
+\item[\Macro{NEGOTIATOR\_RESOURCE\_REQUEST\_LIST\_SIZE}]
+  An integer tuning parameter used by the \Condor{negotiator} to control 
+  the number of resource requests fetched from a \Condor{schedd} per 
+  network round-trip.
+  With higher values, 
+  the latency of negotiation can be significantly be reduced
+  when negotiating with a \Condor{schedd} running 
+  HTCondor version 8.3.0 or more recent,
+  especially over a wide-area network.
+  Setting this value too high, however,
+  could cause the \Condor{schedd} to unnecessarily block on network I/O.  
+  The default value is 20.  If \MacroNI{USE\_RESOURCE\_REQUEST\_COUNTS}
+  is set to \Expr{False}, then this variable will be unconditionally set
+  to a value of 1.
+
 \label{param:NegotiatorMatchExprs}
 \item[\Macro{NEGOTIATOR\_MATCH\_EXPRS}]
   A comma-separated list of macro names that are inserted as
@@ -10561,6 +10577,18 @@ section~\ref{sec:Security} on Security.
   variable \Env{GSI\_AUTHZ\_CONF} when this variable is not defined.
   Setting this variable to \Expr{/dev/null} disables callouts.
 
+\label{param:GSSAssistGridmapCacheExpiration}
+\item[\Macro{GSS\_ASSIST\_GRIDMAP\_CACHE\_EXPIRATION}]
+  The length of time, in seconds, to cache the result of the Globus mapping
+  lookup result when using Globus to map certificates to HTCondor user names.
+  The lookup only occurs when the canonical name \Expr{GSS\_ASSIST\_GRIDMAP}
+  is present in the HTCondor map file.  
+  The default value is 0 seconds, 
+  which is a special value that disables caching.  
+  The cache uses the DN and VOMS FQAN as a key;
+  very rare Globus configurations that utilize other certificate attributes
+  for the mapping may cause the cache to return a different user than Globus.
+
 \label{param:DelegateJobGSICredentials} 
 \item[\Macro{DELEGATE\_JOB\_GSI\_CREDENTIALS}]
   A boolean value that defaults to \Expr{True} for HTCondor version 6.7.19
diff --git a/doc/admin-man/group-tracking.tex b/doc/admin-man/group-tracking.tex
index 8e0c48e..5ad4bd7 100644
--- a/doc/admin-man/group-tracking.tex
+++ b/doc/admin-man/group-tracking.tex
@@ -28,7 +28,7 @@ tracking. This method of tracking requires that a range of dedicated
 that must be set aside for an execute machine is equal to its number
 of execution slots. 
 GID-based tracking is only available on Linux, 
-and it requires that HTCondor runs as \Login{root}.
+and it requires that HTCondor daemons run as \Login{root}.
 
 GID-based tracking works by placing a dedicated GID in the
 supplementary group list of a job's initial process. Since modifying
@@ -82,18 +82,18 @@ On RPM-based systems, these can be installed with the command
 yum install libcgroup\*
 \end{verbatim}
 
-After these tools are installed, the cgconfig service needs to be
+After these tools are installed, the \Prog{cgconfig} service needs to be
 running.  It parses the \File{/etc/cgconfig.conf} file, and makes
-appropriate mounts under \File{/cgroup}.  Before starting the cgconfig
+appropriate mounts under \File{/cgroup}.  Before starting the \Prog{cgconfig}
 service, you will need to edit the file \File{/etc/cgconfig.conf} to
 add a group specific to HTCondor.
 
 Here is an example of the contents of file \File{/etc/cgconfig.conf} with
-appropriate values for the HTCondor group:
+appropriate values for the \texttt{htcondor} group:
 
 \begin{verbatim}
 mount {
-        cpu		= /cgroup/cpu;
+        cpu	= /cgroup/cpu;
         cpuset	= /cgroup/cpuset;
         cpuacct = /cgroup/cpuacct;
         memory  = /cgroup/memory;
@@ -102,7 +102,7 @@ mount {
 }
 
 group htcondor {
-		cpu {}
+	cpu {}
         cpuacct {}
         memory {}
         freezer {}
@@ -110,41 +110,66 @@ group htcondor {
 }
 \end{verbatim}
 
-After the \File{/etc/cgconfig.conf} file has had the htcondor group
-added to it, add and start the cgconfig service by running
+On Debian based systems, the memory cgroup controller is often not 
+on by default, and needs to be enabled with a boot time option.
+This setting needs to be inherited
+down to the per-job cgroup with the following commands in \File{rc.local}:
+
+\begin{verbatim}
+/usr/sbin/cgconfigparser -l /etc/cgconfig.conf
+/bin/echo 1 > /sys/fs/cgroup/htcondor/cgroup.clone_children
+\end{verbatim}
+
+Also for Debian, add the following field to group \texttt{htcondor}:
+
+\begin{verbatim}
+cpuset {
+	cpusets.mems = 0;
+}
+\end{verbatim}
+
+After the \File{/etc/cgconfig.conf} file has had the \texttt{htcondor} group
+added to it, add and start the \Prog{cgconfig} service by running
 
 \begin{verbatim}
 chkconfig --add cgconfig
 service cgconfig start
 \end{verbatim}
 
-When the cgconfig service is correctly running, the virtual file system
-mounted on \File{/cgroup} should have several subdirectories under it, and
-there should a an htcondor subdirectory under the directory \File{/cgroup/cpu}
+When the \Prog{cgconfig} service is correctly running, 
+the virtual file system
+mounted on \File{/cgroup} should have several subdirectories under it, 
+and there should an \File{htcondor} subdirectory under the directory 
+\File{/cgroup/cpu}.
 
-Starting with HTCondor version 7.7.0, 
-the \Condor{starter} daemon can optionally use cgroups
+The \Condor{starter} daemon can optionally use cgroups
 to accurately track all the processes started by a job, 
 even when quickly-exiting parent processes spawn many child processes.
 As with the GID-based tracking, this is only implemented when a 
 \Condor{procd} daemon is running.  The HTCondor team recommends enabling 
-this feature on Linux platforms that support it.  When cgroup tracking is enabled, 
+this feature on Linux platforms that support it.  
+When cgroup tracking is enabled, 
 HTCondor is able to report a much more accurate
 measurement of the physical memory used by a set of processes.
 
 To enable cgroup tracking in HTCondor, once cgroups have been enabled
 in the operating system, set the \Macro{BASE\_CGROUP} configuration
-variable to the string that matches the group name specified in the \File{/etc/cgconfig.conf}
-In the example above, "htcondor" is a good choice.  There is no default value
-for \Macro{BASE\_CGROUP}, and if left unset, cgroup tracking will not be used.
+variable to the string that matches the group name specified in 
+the \File{/etc/cgconfig.conf}.
+In the example above, \texttt{htcondor} is the choice.  
+There is no default value for \Macro{BASE\_CGROUP}, 
+and if left unset, cgroup tracking will not be used.
 
 Kernel cgroups are named in a virtual file system hierarchy. 
 HTCondor will put each running job on the execute node in a distinct cgroup.
-The name of this cgroup is the name of the execute directory for that \Condor{starter}, with
-slashes replaced by underscores, followed by the name and number of the slot.  So, for the
-memory controller, a job running on slot1 would have its cgroup located at
-\File{/cgroup/memory/htcondor/condor\_var\_lib\_condor\_execute\_slot1/}.  The \File{tasks}
-file in this directory will contain a list of all the processes in this cgroup, and
+The name of this cgroup is the name of the execute directory for 
+that \Condor{starter}, with slashes replaced by underscores, 
+followed by the name and number of the slot.  
+So, for the memory controller, 
+a job running on slot1 would have its cgroup located at
+\File{/cgroup/memory/htcondor/condor\_var\_lib\_condor\_execute\_slot1/}.  
+The \File{tasks} file in this directory will contain a list 
+of all the processes in this cgroup, and
 many other files in this directory have useful information about resource usage
 of this cgroup.  See the kernel documentation for full details.
 
diff --git a/doc/admin-man/security.tex b/doc/admin-man/security.tex
index 0a403f0..057cd35 100644
--- a/doc/admin-man/security.tex
+++ b/doc/admin-man/security.tex
@@ -961,6 +961,7 @@ GSI_DAEMON_NAME = /X.509/name/of/server/1,/X.509/name/of/server/2,...
 \end{verbatim}
 \normalsize
 
+\index{authentication!unified map file}
 HTCondor will also need a way to map an X.509 distinguished
 name to an HTCondor user id.
 There are two ways to accomplish this mapping.
@@ -1463,6 +1464,7 @@ for testing purposes only.
 \subsection{\label{sec:Security-Unified-Map-File}The Unified Map File for Authentication}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \index{security!unified map file}
+\index{authentication!unified map file}
 
 HTCondor's unified map file allows the mappings
 from authenticated names to an HTCondor canonical user name
diff --git a/doc/condor-macros.tex b/doc/condor-macros.tex
index e859e93..a8d0828 100644
--- a/doc/condor-macros.tex
+++ b/doc/condor-macros.tex
@@ -6,7 +6,7 @@
 %  Set up version, author and copyright notices
 %
 \newcommand{\AuthorNotice}{Center for High Throughput Computing, University of Wisconsin--Madison}
-\newcommand{\VersionNotice}{Version 8.2.3}
+\newcommand{\VersionNotice}{Version 8.3.0}
 %\newcommand{\CondorR}{\Reg{Condor}}
 \newcommand{\CondorTM}{\TM{HTCondor}}
 
diff --git a/doc/man-pages/condor_dagman.tex b/doc/man-pages/condor_dagman.tex
index 530e426..64c32d0 100644
--- a/doc/man-pages/condor_dagman.tex
+++ b/doc/man-pages/condor_dagman.tex
@@ -13,6 +13,7 @@
 \SynProg{\Condor{dagman}}
 \Arg{-f}
 \Arg{-l .}
+\OptArg{-csdversion}{version\_string}
 \oOptArg{-debug}{level}
 \oOptArg{-maxidle}{numberOfJobs}
 \oOptArg{-maxjobs}{numberOfJobs}
@@ -25,7 +26,6 @@
 \oOpt{-waitfordebug}
 \oOptArg{-autorescue}{0|1}
 \oOptArg{-dorescuefrom}{number}
-\OptArg{-csdversion}{version\_string}
 \oOpt{-allowversionmismatch}
 \oOpt{-DumpRescue}
 \oOpt{-verbose}
@@ -37,7 +37,9 @@
 \oOptArg{-outfile\_dir}{directory}
 \oOpt{-update\_submit}
 \oOpt{-import\_env}
+\oOptArg{-priority}{number}
 \oOpt{-DontAlwaysRunPost}
+\oOpt{-DoRecovery}
 \OptArg{-dag}{dag\_file}
 \oArg{\OptArg{-dag}{dag\_file\_2} \Dots \OptArg{-dag}{dag\_file\_n} }
 
@@ -60,6 +62,10 @@ work for \Condor{dagman}.
 When invoked from the command line, \Condor{dagman} requires
 the arguments \Arg{-f -l .} to appear first on the command line,
 to be processed by \Prog{DaemonCore}.
+The \Opt{csdversion} must also be specified;
+at start up,
+\Condor{dagman} checks for a version mismatch with the
+\Condor{submit\_dag} version in this argument.
 The \Arg{-t} argument must also be present for the \Opt{-help}
 option, such that output is sent to the terminal.
 
@@ -94,6 +100,8 @@ output DAG input file lines as they are parsed
 
 
 \begin{Options}
+    \OptItem{\Opt{-help}}{Display usage information and exit.}
+    \OptItem{\Opt{-version}}{Display version information and exit.}
     \OptItem{\OptArg{-debug}{level}}{An integer level of debugging output.
        \Arg{level} is an integer, with values of 0-7 inclusive,
        where 7 is the most verbose output.
@@ -169,10 +177,6 @@ output DAG input file lines as they are parsed
        run the specified rescue DAG number for the given DAG.  A value
        of 0 is the same as not specifying this option.  Specifying a
        nonexistent rescue DAG is a fatal error.}
-    \OptItem{\OptArg{-csdversion}{version\_string}}{\Arg{version\_string}
-       is the version of the \Condor{submit\_dag} program.  At startup,
-       \Condor{dagman} checks for a version mismatch with the
-       \Condor{submit\_dag} version in this argument.}
     \OptItem{\Opt{-allowversionmismatch}}{This optional argument causes
        \Condor{dagman} to allow a version mismatch between
        \Condor{dagman} itself and the \File{.condor.sub} file produced
@@ -213,6 +217,28 @@ output DAG input file lines as they are parsed
        submit description file for DAGMan. This file is produced by
        \Condor{submit\_dag}. The \Opt{notification} option is described
        in the \Condor{submit} manual page. }
+    \OptItem{\Opt{-suppress\_notification}}{Causes jobs submitted
+       by \Condor{dagman} to not send email notification for events. 
+       The same effect
+       can be achieved by setting the configuration variable
+       \Macro{DAGMAN\_SUPPRESS\_NOTIFICATION} to \Expr{True}.
+       This command line option is independent of the
+       \Opt{-notification} command line option, 
+       which controls notification for the \Condor{dagman} job itself.
+       This flag is generally superfluous, as
+       \MacroNI{DAGMAN\_SUPPRESS\_NOTIFICATION} defaults to \Expr{True}.}
+    \OptItem{\Opt{-dont\_suppress\_notification}}{Causes jobs
+       submitted by \Condor{dagman} to defer to content within 
+       the submit description file when deciding to send
+       email notification for events. 
+       The same effect can be achieved by setting the configuration variable
+       \Macro{DAGMAN\_SUPPRESS\_NOTIFICATION} to \Expr{False}.
+       This command line flag is independent of the \Opt{-notification} 
+       command line option, 
+       which controls notification for the \Condor{dagman} job itself. 
+       If both \Opt{-dont\_suppress\_notification} and 
+       \Opt{-suppress\_notification} are specified within the same command line,
+       the last argument is used.}
     \OptItem{\OptArg{-dagman}{DagmanExecutable}}{(This argument is
        included only to be passed to \Condor{submit\_dag} if lazy submit
        file generation is used for nested DAGs.)  Allows the
@@ -241,9 +267,8 @@ output DAG input file lines as they are parsed
        \Condor{submit\_dag} to import the current environment into
        the \Opt {environment} command of the \File{.condor.sub} file it
        generates.}
-    \OptItem{\OptArg{-dag}{filename}}{\Arg{filename} is the name of the
-       DAG input file that is set as an argument to \Condor{submit\_dag},
-       and passed to \Condor{dagman}.}
+    \OptItem{\OptArg{-priority}{number}}{Sets the minimum job priority
+       of node jobs submitted and running under this \Condor{dagman} job.}
     \OptItem{\Opt{-DontAlwaysRunPost}}{This option causes \Condor{dagman} to
        observe the exit status of the PRE script when deciding whether or not
        to run the POST script.  
@@ -255,28 +280,13 @@ output DAG input file lines as they are parsed
        Using this option restores the previous behavior, 
        in which \Condor{dagman} will not run the POST script if the PRE
        script fails.}
-    \OptItem{\Opt{-suppress\_notification}}{Causes jobs submitted
-       by \Condor{dagman} to not send email notification for events. 
-       The same effect
-       can be achieved by setting the configuration variable
-       \Macro{DAGMAN\_SUPPRESS\_NOTIFICATION} to \Expr{True}.
-       This command line option is independent of the
-       \Opt{-notification} command line option, 
-       which controls notification for the \Condor{dagman} job itself.
-       This flag is generally superfluous, as
-       \MacroNI{DAGMAN\_SUPPRESS\_NOTIFICATION} defaults to \Expr{True}.}
-    \OptItem{\Opt{-dont\_suppress\_notification}}{Causes jobs
-       submitted by \Condor{dagman} to defer to content within 
-       the submit description file when deciding to send
-       email notification for events. 
-       The same effect can be achieved by setting the configuration variable
-       \Macro{DAGMAN\_SUPPRESS\_NOTIFICATION} to \Expr{False}.
-       This command line flag is independent of the \Opt{-notification} 
-       command line option, 
-       which controls notification for the \Condor{dagman} job itself. 
-       If both \Opt{-dont\_suppress\_notification} and 
-       \Opt{-suppress\_notification} are specified within the same command line,
-       the last argument is used.}
+    \OptItem{\Opt{-DoRecovery}}{Causes \Condor{dagman} to start in recovery
+      mode.  This means that it reads the relevant job user log(s) and
+      catches up to the given DAG's previous state before submitting
+      any new jobs.}
+    \OptItem{\OptArg{-dag}{filename}}{\Arg{filename} is the name of the
+       DAG input file that is set as an argument to \Condor{submit\_dag},
+       and passed to \Condor{dagman}.}
 
 \end{Options}
 
diff --git a/doc/man-pages/condor_status.tex b/doc/man-pages/condor_status.tex
index 8465ff8..b3775aa 100644
--- a/doc/man-pages/condor_status.tex
+++ b/doc/man-pages/condor_status.tex
@@ -43,6 +43,9 @@ Any number of \Arg{custom options} and \Arg{host options} may be specified.
       performing the query.}
     \OptItem{\Opt{-absent}}{(Query option) Query for and display only 
       absent resources.}
+    \OptItem{\OptArg{-ads}{filename}}{(Query option) Read the set of 
+      ClassAds in the file specified by \Arg{filename},
+      instead of querying the \Condor{collector}.}
     \OptItem{\Opt{-any}}{(Query option) Query all ClassAds and display 
       their type, target type, and name.}
     \OptItem{\Opt{-avail}}{(Query option) Query \Condor{startd} ClassAds 
diff --git a/doc/man-pages/condor_submit_dag.tex b/doc/man-pages/condor_submit_dag.tex
index 50423a0..a68c879 100644
--- a/doc/man-pages/condor_submit_dag.tex
+++ b/doc/man-pages/condor_submit_dag.tex
@@ -39,6 +39,7 @@
 \oOptArg{-schedd-address-file}{FileName}
 \oOpt{-suppress\_notification}
 \oOpt{-dont\_suppress\_notification}
+\oOpt{-DoRecovery}
 \Arg{DAGInputFile1}
 \oArg{{DAGInputFile2} \Dots {DAGInputFileN} }
 
@@ -58,8 +59,8 @@ Extensive documentation is in the HTCondor User Manual
 section on DAGMan.
 
 \begin{Options}
-  \OptItem{\Opt{-help}}{Display usage information.}
-  \OptItem{\Opt{-version}}{Display version information.}
+  \OptItem{\Opt{-help}}{Display usage information and exit.}
+  \OptItem{\Opt{-version}}{Display version information and exit.}
   \OptItem{\Opt{-no\_submit}}{Produce the HTCondor submit description file
      for DAGMan, but do not submit DAGMan as an HTCondor job.}
   \OptItem{\Opt{-verbose}}{Cause \Condor{submit\_dag}
@@ -272,7 +273,7 @@ section on DAGMan.
      value and would not run the POST script if the PRE script failed.
   }
   \OptItem{\OptArg{-priority}{number}}{Sets the minimum job priority
-    of jobs submitted and running under the \Condor{dagman} job
+    of node jobs submitted and running under the \Condor{dagman} job
     submitted by this \Condor{submit\_dag} command.
   }
   \OptItem{\Opt{-dont\_use\_default\_node\_log}}{ Tells \Condor{dagman}
@@ -325,6 +326,11 @@ section on DAGMan.
     \Opt{-suppress\_notification} are specified with the same command line,
     the last argument is used.
   }
+  \OptItem{\Opt{-DoRecovery}}{Causes \Condor{dagman} to start in recovery
+    mode.  (This means that it reads the relevant job user log(s) and
+    "catches up" to the given DAG's previous state before submitting
+    any new jobs.)
+  }
   \end{Options}
 
 \ExitStatus
diff --git a/doc/misc/hooks.tex b/doc/misc/hooks.tex
index e4098fb..d702105 100644
--- a/doc/misc/hooks.tex
+++ b/doc/misc/hooks.tex
@@ -222,11 +222,23 @@ Policy expressions may then reference the dynamic attributes.
 Configuration variables related to Daemon ClassAd Hooks are defined
 within section ~\ref{sec:Config-hooks}.
 
-The output of the job is incorporated into the ClassAd when
-the job exits,
-or when the job outputs a specialized line containing a 
-dash as the first character.
-The remainder of the line is discarded.
+The output of the job is incorporated into one or more ClassAds when
+the job exits.
+When the job outputs the specialized line:
+\begin{verbatim}
+  - update:true
+\end{verbatim}
+the output of the job goes is merged into all proper ClassAds,
+and an update goes to the \Condor{collector} daemon.
+
+When the output of the job contains a dash as the first character,
+following the dash may be a tag composed of alphanumeric characters,
+which uniquely identifies a buffer corresponding to a specific ClassAd.
+The contents of the output attributes from the job specify which ClassAd.
+The use of the tag intends to permit output with different attributes 
+and values for different slots of the same machine.
+An output line from the job with a dash and optionally a tag
+causes the associated buffer to be merged with appropriate ClassAd.
 
 Here is a complete configuration example.
 It defines all three of the available types of jobs:
diff --git a/doc/misc/scheddad.tex b/doc/misc/scheddad.tex
index ff47da4..9610d42 100644
--- a/doc/misc/scheddad.tex
+++ b/doc/misc/scheddad.tex
@@ -45,6 +45,12 @@ number, the release date, and the build identification number.
   the sum of the all of the time jobs which did not complete successfully 
   have spent running over the lifetime of this \Condor{schedd}.
 
+\index{ClassAd Scheduler attribute!JobsAccumExceptionalBadputTime}
+\item[\AdAttr{JobsAccumExceptionalBadputTime}:] A Statistics attribute 
+  defining the sum of the all of the time jobs which did not complete 
+  successfully due to \Condor{shadow} exceptions 
+  have spent running over the lifetime of this \Condor{schedd}.
+
 \index{ClassAd Scheduler attribute!JobsAccumRunningTime}
 \item[\AdAttr{JobsAccumRunningTime}:]  A Statistics attribute defining
   the sum of the all of the time jobs have spent running
@@ -170,6 +176,10 @@ number, the release date, and the build identification number.
   \Expr{JOB\_NOT\_STARTED}
   in the time interval defined by attribute \AdAttr{StatsLifetime}.
 
+\index{ClassAd Scheduler attribute!JobsRunning}
+\item[\AdAttr{JobsRunning}:]  A Statistics attribute representing the number
+  of jobs currently running.
+
 % histogram statistic
 \index{ClassAd Scheduler attribute!JobsRunningRuntimes}
 \item[\AdAttr{JobsRunningRuntimes}:] A Statistics attribute defining
diff --git a/doc/user-man/dagman.tex b/doc/user-man/dagman.tex
index 5068cc6..02cc555 100644
--- a/doc/user-man/dagman.tex
+++ b/doc/user-man/dagman.tex
@@ -837,7 +837,7 @@ condor_submit_dag -usedagdir dag1/one.dag dag2/two.dag
 \end{verbatim}
 The directory will be correct for each of the two DAGs,
 and output files will be placed in the correct directory.
-The File{.dagman.out} file will also be in the correct directory.
+The \File{.dagman.out} file will also be in the correct directory.
 
 If all paths in the DAG input file(s) and the relevant submit
 description files are absolute,
@@ -860,7 +860,7 @@ The Rescue DAG includes all the path information necessary to
 run each node job in the proper directory.
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-\subsection{Job Monitoring, Job Failure, and Job Removal}
+\subsection{\label{sec:DAGMonitoring}Job Monitoring, Job Failure, and Job Removal}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
 After submission, the progress of the DAG can be monitored
@@ -3168,6 +3168,9 @@ The attributes are
 \item \Attr{DAG\_InRecovery}
 \end{itemize}
 
+Note that most of this information is also available in the
+\File{dagman.out} file as described in section~\ref{sec:DAGMonitoring}.
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \subsection{\label{sec:DAGLotsaJobs}Utilizing the Power of DAGMan for Large Numbers of Jobs}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
diff --git a/doc/version-history/8-3.history.tex b/doc/version-history/8-3.history.tex
new file mode 100644
index 0000000..d81c108
--- /dev/null
+++ b/doc/version-history/8-3.history.tex
@@ -0,0 +1,112 @@
+%%%      PLEASE RUN A SPELL CHECKER BEFORE COMMITTING YOUR CHANGES!
+%%%      PLEASE RUN A SPELL CHECKER BEFORE COMMITTING YOUR CHANGES!
+%%%      PLEASE RUN A SPELL CHECKER BEFORE COMMITTING YOUR CHANGES!
+%%%      PLEASE RUN A SPELL CHECKER BEFORE COMMITTING YOUR CHANGES!
+%%%      PLEASE RUN A SPELL CHECKER BEFORE COMMITTING YOUR CHANGES!
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\section{\label{sec:History-8-3}Development Release Series 8.3}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+This is the development release series of HTCondor.
+The details of each version are described below.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+\subsection*{\label{sec:New-8-3-0}Version 8.3.0}
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+\noindent Release Notes:
+
+\begin{itemize}
+
+\item HTCondor version 8.3.0 released on August 12, 2014.
+This release contains all improvements and bug fixes from 
+HTCondor version 8.2.2.
+
+\end{itemize}
+
+
+\noindent New Features:
+
+\begin{itemize}
+
+\item When a daemon creates a child daemon process, it also creates a
+security session shared with the child daemon.
+This makes the initial communication between the daemons more efficient.
+\Ticket{4405}
+
+\item Negotiation cycle performance has been improved, especially
+over a wide-area network, by reducing network traffic and latency
+between a submit machine and a central manager.
+The new configuration variable 
+\Macro{NEGOTIATOR\_RESOURCE\_REQUEST\_LIST\_SIZE}
+does performance tuning, as defined 
+in section~\ref{param:NegotiatorResourceRequestListSize}.
+\Ticket{4460}
+
+\item The synchronization of the job event log was improved by only
+using \Procedure{fsync} where necessary and 
+\Procedure{fdatasync} where sufficient.  
+This should provide a small reduction in disk I/O to 
+the \Condor{schedd} daemon.
+\Ticket{4283}
+
+\item CPU usage by the \Condor{collector} has been reduced when
+handling normal queries from \Condor{status},
+and CPU usage by the \Condor{schedd} has been reduced when
+handling normal queries from \Condor{q}.
+\Ticket{4448}
+
+\item HTCondor can now internally cache the result of Globus authorization
+callouts.  
+The caching behavior is enabled by setting configuration variable
+\Macro{GSS\_ASSIST\_GRIDMAP\_CACHE\_EXPIRATION} to a non-zero value.
+This feature will be useful for sites that use the Globus authorization
+callouts based only on DN and VOMS FQAN, and for sites that have 
+performance issues.
+\Ticket{4138}
+
+\item The job ClassAd attribute \Attr{DAG\_Status} is included in 
+the \File{dagman.out} file.
+\Ticket{4381}
+
+\item The new \Opt{-DoRecovery} command line option for \Condor{dagman}
+and \Condor{submit\_dag} causes \Condor{dagman} to run in
+recovery mode.
+\Ticket{2218}
+
+\item The new \Opt{-ads} option to \Condor{status} permits a set of ClassAds
+to be read from a file, processing the ClassAds as if they came from
+the \Condor{collector}.
+\Ticket{4414}
+
+\item Daemon ClassAd hooks implementing Startd Cron functionality  
+can now return multiple ClassAds,
+and the hooks can specify which ClassAds their output should merge into.
+\Ticket{4398}
+
+\item Two new \Condor{schedd} ClassAd statistics attributes are
+available: \Attr{JobsRunning} and \Attr{JobsAccumExceptionalBadputTime}.
+\Ticket{4409}
+
+\end{itemize}
+
+\noindent Bugs Fixed:
+
+\begin{itemize}
+
+\item Fixed a bug that caused \Condor{dagman} to unnecessarily attempt
+to read node job submit description files, 
+which could cause spurious warnings when in recovery mode.
+Strictly speaking, the bug is fixed only for the
+default case in which \MacroNI{DAGMAN\_ALWAYS\_USE\_NODE\_LOG} is set
+to \Expr{True}.
+\Ticket{3843}
+
+\item Fixed a bug in the \Condor{schedd} daemon that caused the values
+of the ClassAd attributes \Attr{JobsRunningSizes} and 
+\Attr{ JobsRunningRuntimes} to be much larger than they should have been.
+\Ticket{4409}
+
+\end{itemize}
+
diff --git a/doc/version-history/history.tex b/doc/version-history/history.tex
index c655634..2f07a52 100644
--- a/doc/version-history/history.tex
+++ b/doc/version-history/history.tex
@@ -104,6 +104,7 @@ development release from there.
 % upgrade instructions are in the Pool Management section
 \input{version-history/upgradingto8-2.tex}
 %\input{version-history/upgradingto8-0.tex}
+\input{version-history/8-3.history.tex}
 \input{version-history/8-2.history.tex}
 \input{version-history/8-1.history.tex}
 \input{version-history/8-0.history.tex}
diff --git a/src/ccb/ccb_client.cpp b/src/ccb/ccb_client.cpp
index f8f4a0f..3ce4bbc 100644
--- a/src/ccb/ccb_client.cpp
+++ b/src/ccb/ccb_client.cpp
@@ -26,7 +26,6 @@
 #include "selector.h"
 #include "CondorError.h"
 #include "ccb_client.h"
-#include "daemon_core_sock_adapter.h"
 #include "condor_sinful.h"
 #include "shared_port_endpoint.h"
 
@@ -75,7 +74,7 @@ CCBClient::~CCBClient()
 		delete m_ccb_sock;
 	}
 	if( m_deadline_timer != -1 ) {
-		daemonCoreSockAdapter.Cancel_Timer(m_deadline_timer);
+		daemonCore->Cancel_Timer(m_deadline_timer);
 		m_deadline_timer = -1;
 	}
 }
@@ -85,6 +84,11 @@ bool
 CCBClient::ReverseConnect( CondorError *error, bool non_blocking )
 {
 	if( non_blocking ) {
+		// Non-blocking mode requires DaemonCore
+		if ( !daemonCore ) {
+			dprintf( D_ALWAYS, "Can't do non-blocking CCB reverse connection without DaemonCore!\n" );
+			return false;
+		}
 		m_target_sock->enter_reverse_connecting_state();
 		// NOTE: now we _must_ call exit_reverse_connecting_state()
 		// before we are done with m_target_sock.  This state
@@ -108,9 +112,9 @@ CCBClient::myName()
 	// It is who we say we are when talking to the CCB server.
 	MyString name;
 	name = get_mySubSystem()->getName();
-	if( daemonCoreSockAdapter.isEnabled() ) {
+	if( daemonCore ) {
 		name += " ";
-		name += daemonCoreSockAdapter.publicNetworkIpAddr();
+		name += daemonCore->publicNetworkIpAddr();
 	}
 	return name;
 }
@@ -503,7 +507,7 @@ CCBClient::try_next_ccb()
 		return try_next_ccb();
 	}
 
-	char const *return_address = daemonCoreSockAdapter.publicNetworkIpAddr();
+	char const *return_address = daemonCore->publicNetworkIpAddr();
 
 	// For now, we require that this daemon has a command port.
 	// If needed, we could add support for opening a listen socket here.
@@ -580,7 +584,7 @@ CCBClient::try_next_ccb()
 
 			// bypass startCommand() and call the command handler directly
 			// this call will take care of deleting server_sock when done
-		daemonCoreSockAdapter.CallCommandHandler(CCB_REQUEST,server_sock);
+		daemonCore->CallCommandHandler(CCB_REQUEST,server_sock);
 	}
 	else {
 		ccb_server->sendMsg(msg.get());
@@ -593,7 +597,7 @@ CCBClient::try_next_ccb()
 void
 CCBClient::CancelReverseConnect()
 {
-	if( m_target_sock ) {
+	if( daemonCore && m_target_sock ) {
 		ReverseConnectCallback( NULL );
 	}
 }
@@ -681,7 +685,7 @@ CCBClient::RegisterReverseConnectCallback()
 		// security session management.  Again, that stuff all happens
 		// later in the reverse direction.
 
-		daemonCoreSockAdapter.Register_Command(
+		daemonCore->Register_Command(
 			CCB_REVERSE_CONNECT,
 			"CCB_REVERSE_CONNECT",
 			CCBClient::ReverseConnectCommandHandler,
@@ -706,7 +710,7 @@ CCBClient::RegisterReverseConnectCallback()
 		if( timeout < 0 ) {
 			timeout = 0;
 		}
-		m_deadline_timer = daemonCoreSockAdapter.Register_Timer (
+		m_deadline_timer = daemonCore->Register_Timer (
 			timeout,
 			(TimerHandlercpp)&CCBClient::DeadlineExpired,
 			"CCBClient::DeadlineExpired",
@@ -732,7 +736,7 @@ void
 CCBClient::UnregisterReverseConnectCallback()
 {
 	if( m_deadline_timer != -1 ) {
-		daemonCoreSockAdapter.Cancel_Timer(m_deadline_timer);
+		daemonCore->Cancel_Timer(m_deadline_timer);
 		m_deadline_timer = -1;
 	}
 
@@ -806,7 +810,7 @@ CCBClient::ReverseConnectCallback(Sock *sock)
 	// We are all done creating the connection (or failing to do so).
 	// Call any function that may have been registered with
 	// DaemonCore::Register_Socket().
-	daemonCoreSockAdapter.CallSocketHandler(m_target_sock,false);
+	daemonCore->CallSocketHandler(m_target_sock,false);
 
 	// No more use of m_target_sock, because it may have been deleted
 	// by now.
diff --git a/src/classad/classad/classad.h b/src/classad/classad/classad.h
index 2f68652..3816922 100644
--- a/src/classad/classad/classad.h
+++ b/src/classad/classad/classad.h
@@ -672,6 +672,10 @@ e		*/
 
 		/**@name Dirty Tracking */
         //@{
+		/** enable or disable dirty tracking for this ClassAd
+		 *  and return whether dirty track was previously enabled or disabled.
+		 */
+		bool       SetDirtyTracking(bool enable) { bool was_enabled = do_dirty_tracking; do_dirty_tracking = enable; return was_enabled; }
         /** Turn on dirty tracking for this ClassAd. 
          *  If tracking is on, every insert will label the attribute that was inserted
          *  as dirty. Dirty tracking is always turned off during Copy() and
diff --git a/src/condor_collector.V6/collector.cpp b/src/condor_collector.V6/collector.cpp
index b2450b4..2edd18b 100644
--- a/src/condor_collector.V6/collector.cpp
+++ b/src/condor_collector.V6/collector.cpp
@@ -372,24 +372,32 @@ int CollectorDaemon::receive_query_cedar(Service* /*s*/,
 
 		// See if query ad asks for server-side projection
 	string projection = "";
+		// turn projection string into a set of attributes
+	classad::References proj;
+	bool evaluate_projection = false;
+	if (cad.LookupString(ATTR_PROJECTION, projection) && ! projection.empty()) {
+		StringTokenIterator list(projection);
+		const std::string * attr;
+		while ((attr = list.next_string())) { proj.insert(*attr); }
+	} else if (cad.Lookup(ATTR_PROJECTION)) {
+		// if projection is not a simple string, then assume that evaluating it as a string in the context of the ad will work better
+		// (the negotiator sends this sort of projection)
+		evaluate_projection = true;
+	}
 
 	while ( (curr_ad=results.Next()) )
     {
-		StringList expanded_projection;
-		StringList *attr_whitelist=NULL;
-
-		projection = "";
-		cad.EvalString(ATTR_PROJECTION, curr_ad, projection);
-		SimpleList<MyString> projectionList;
-
-		::split_args(projection.c_str(), &projectionList);
-
-		if (projectionList.Number() > 0) {
-			computeProjection(curr_ad, &projectionList, expanded_projection);
-			attr_whitelist = &expanded_projection;
+		if (evaluate_projection) {
+			proj.clear();
+			projection.clear();
+			if (cad.EvalString(ATTR_PROJECTION, curr_ad, projection) && ! projection.empty()) {
+				StringTokenIterator list(projection);
+				const std::string * attr;
+				while ((attr = list.next_string())) { proj.insert(*attr); }
+			}
 		}
-		
-        if (!sock->code(more) || !putClassAd(sock, *curr_ad, false, attr_whitelist))
+
+        if (!sock->code(more) || !putClassAd(sock, *curr_ad, 0, proj.empty() ? NULL : &proj))
         {
             dprintf (D_ALWAYS,
                     "Error sending query result to client -- aborting\n");
diff --git a/src/condor_daemon_client/daemon.cpp b/src/condor_daemon_client/daemon.cpp
index 3ea7f2b..1f84be6 100644
--- a/src/condor_daemon_client/daemon.cpp
+++ b/src/condor_daemon_client/daemon.cpp
@@ -30,14 +30,12 @@
 #include "condor_adtypes.h"
 #include "condor_query.h"
 #include "get_daemon_name.h"
-#include "get_full_hostname.h"
 #include "internet.h"
 #include "HashTable.h"
 #include "condor_daemon_core.h"
 #include "dc_collector.h"
 #include "time_offset.h"
 #include "condor_netdb.h"
-#include "daemon_core_sock_adapter.h"
 #include "subsystem_info.h"
 #include "condor_sinful.h"
 
diff --git a/src/condor_daemon_client/dc_collector.cpp b/src/condor_daemon_client/dc_collector.cpp
index 577e793..199fbc8 100644
--- a/src/condor_daemon_client/dc_collector.cpp
+++ b/src/condor_daemon_client/dc_collector.cpp
@@ -27,7 +27,6 @@
 #include "daemon.h"
 #include "condor_daemon_core.h"
 #include "dc_collector.h"
-#include "daemon_core_sock_adapter.h"
 
 std::map< std::string, Timeslice > DCCollector::blacklist;
 
@@ -275,10 +274,10 @@ DCCollector::sendUpdate( int cmd, ClassAd* ad1, ClassAd* ad2, bool nonblocking )
 		return true;
 	}
 
-	if(!use_nonblocking_update || !daemonCoreSockAdapter.isEnabled()) {
+	if(!use_nonblocking_update || !daemonCore) {
 			// Either caller OR config may turn off nonblocking updates.
 			// In other words, both must be true to enable nonblocking.
-			// Also, must have daemonCoreSockAdapter enabled.
+			// Also, must have DaemonCore intialized.
 		nonblocking = false;
 	}
 
diff --git a/src/condor_daemon_client/dc_lease_manager_lease.cpp b/src/condor_daemon_client/dc_lease_manager_lease.cpp
index e108d90..7f02f7d 100644
--- a/src/condor_daemon_client/dc_lease_manager_lease.cpp
+++ b/src/condor_daemon_client/dc_lease_manager_lease.cpp
@@ -464,7 +464,6 @@ DCLeaseManagerLease_getConstList(
 	const list<DCLeaseManagerLease *>	&non_const_list
 	)
 {
-	typedef list<DCLeaseManagerLease *>			LeaseList;
 	typedef list<const DCLeaseManagerLease *>	ConstList;
 
 	const ConstList *const_list = (const ConstList *) &non_const_list;
diff --git a/src/condor_daemon_client/dc_message.cpp b/src/condor_daemon_client/dc_message.cpp
index 3919209..b5cc353 100644
--- a/src/condor_daemon_client/dc_message.cpp
+++ b/src/condor_daemon_client/dc_message.cpp
@@ -23,7 +23,6 @@
 #include "condor_daemon_core.h"
 #include "daemon.h"
 #include "dc_message.h"
-#include "daemon_core_sock_adapter.h"
 
 DCMsg::DCMsg(int cmd):
 	m_cmd( cmd ),
@@ -306,7 +305,7 @@ void DCMessenger::startCommand( classy_counted_ptr<DCMsg> msg )
 		// the SafeSock and another for a ReliSock to establish the
 		// security session.
 	Stream::stream_type st = msg->getStreamType();
-	if( daemonCoreSockAdapter.TooManyRegisteredSockets(-1,&error,st==Stream::safe_sock?2:1) ) {
+	if( daemonCore->TooManyRegisteredSockets(-1,&error,st==Stream::safe_sock?2:1) ) {
 			// Try again in a sec
 			// Eventually, it would be better to queue this centrally
 			// (i.e. in DaemonCore) rather than having an independent
@@ -465,7 +464,7 @@ void DCMessenger::startReceiveMsg( classy_counted_ptr<DCMsg> msg, Sock *sock )
 
 	incRefCount();
 
-	int reg_rc = daemonCoreSockAdapter.
+	int reg_rc = daemonCore->
 		Register_Socket( sock, peerDescription(),
 						 (SocketHandlercpp)&DCMessenger::receiveMsgCallback,
 						 name.c_str(), this, ALLOW );
@@ -495,7 +494,7 @@ DCMessenger::receiveMsgCallback(Stream *sock)
 	m_callback_sock = NULL;
 	m_pending_operation = NOTHING_PENDING;
 
-	daemonCoreSockAdapter.Cancel_Socket( sock );
+	daemonCore->Cancel_Socket( sock );
 
 	ASSERT( sock );
 	readMsg( msg, (Sock *)sock );
@@ -569,7 +568,7 @@ DCMessenger::cancelMessage( classy_counted_ptr<DCMsg> msg )
 	else if( m_callback_sock && m_callback_sock->get_file_desc() != INVALID_SOCKET) {
 		m_callback_sock->close();
 			// force callback now so everything gets cleaned up properly
-		daemonCoreSockAdapter.CallSocketHandler( m_callback_sock );
+		daemonCore->CallSocketHandler( m_callback_sock );
 	}
 }
 
@@ -586,18 +585,18 @@ DCMessenger::startCommandAfterDelay( unsigned int delay, classy_counted_ptr<DCMs
 	qc->msg = msg;
 
 	incRefCount();
-	qc->timer_handle = daemonCoreSockAdapter.Register_Timer(
+	qc->timer_handle = daemonCore->Register_Timer(
 		delay,
 		(TimerHandlercpp)&DCMessenger::startCommandAfterDelay_alarm,
 		"DCMessenger::startCommandAfterDelay",
 		this );
 	ASSERT(qc->timer_handle != -1);
-	daemonCoreSockAdapter.Register_DataPtr( qc );
+	daemonCore->Register_DataPtr( qc );
 }
 
 void DCMessenger::startCommandAfterDelay_alarm()
 {
-	QueuedCommand *qc = (QueuedCommand *)daemonCoreSockAdapter.GetDataPtr();
+	QueuedCommand *qc = (QueuedCommand *)daemonCore->GetDataPtr();
 	ASSERT(qc);
 
 	startCommand(qc->msg);
diff --git a/src/condor_daemon_core.V6/condor_daemon_core.h b/src/condor_daemon_core.V6/condor_daemon_core.h
index 89d16b0..55bff83 100644
--- a/src/condor_daemon_core.V6/condor_daemon_core.h
+++ b/src/condor_daemon_core.V6/condor_daemon_core.h
@@ -455,6 +455,10 @@ class DaemonCore : public Service
 		*/
 	const char* privateNetworkName(void);
 
+	void SetInheritParentSinful( const char *sinful ) {
+		m_inherit_parent_sinful = sinful ? sinful : "";
+	}
+
 	/** Returns a pointer to the penvid passed in if successful
 		in determining the environment id for the pid, or NULL if unable
 		to determine.
@@ -736,6 +740,15 @@ class DaemonCore : public Service
 	int CallCommandHandler(int req,Stream *stream,bool delete_stream=true,bool check_payload=true,float time_spent_on_sec=0,float time_spent_waiting_for_payload=0);
 
 
+		// This function is called in order to have
+		// TooManyRegisteredSockets() take into account an extra socket
+		// that is waiting for a timer or other callback to complete.
+	void incrementPendingSockets() { nPendingSockets++; }
+
+		// This function must be called after incrementPendingSockets()
+		// when the socket is being (or about to be) destroyed.
+	void decrementPendingSockets() { nPendingSockets--; }
+
 	/**
 	   @return Number of currently registered sockets.
 	 */
@@ -1669,15 +1682,6 @@ class DaemonCore : public Service
                         int is_cpp,
                         void **prev_entry = NULL);
 
-		// This function is called in order to have
-		// TooManyRegisteredSockets() take into account an extra socket
-		// that is waiting for a timer or other callback to complete.
-	void incrementPendingSockets() { nPendingSockets++; }
-
-		// This function must be called after incrementPendingSockets()
-		// when the socket is being (or about to be) destroyed.
-	void decrementPendingSockets() { nPendingSockets--; }
-
     int Register_Pipe(int pipefd,
                         const char *pipefd_descrip,
                         PipeHandler handler, 
@@ -2064,6 +2068,8 @@ class DaemonCore : public Service
 	bool CommandNumToTableIndex(int cmd,int *cmd_index);
 
 	void InitSharedPort(bool in_init_dc_command_socket=false);
+
+	std::string m_inherit_parent_sinful;
 };
 
 /**
diff --git a/src/condor_daemon_core.V6/daemon_core.cpp b/src/condor_daemon_core.V6/daemon_core.cpp
index 3d59dc9..ff74e08 100644
--- a/src/condor_daemon_core.V6/daemon_core.cpp
+++ b/src/condor_daemon_core.V6/daemon_core.cpp
@@ -90,7 +90,6 @@ CRITICAL_SECTION Big_fat_mutex; // coarse grained mutex for debugging purposes
 #include "directory.h"
 #include "../condor_io/condor_rw.h"
 
-#include "daemon_core_sock_adapter.h"
 #include "HashTable.h"
 #include "selector.h"
 #include "proc_family_interface.h"
@@ -254,33 +253,6 @@ DaemonCore::DaemonCore(int PidSize, int ComSize,int SigSize,
     dc_stats.Init(); // initilize statistics.
     dc_stats.SetWindowSize(20*60);
 
-		// Provide cedar sock with pointers to various daemonCore functions
-		// that cannot be directly referenced in cedar, because it
-		// is sometimes used in an application that is not linked with
-		// DaemonCore.
-	daemonCoreSockAdapter.EnableDaemonCore(
-		this,
-		// Typecast Register_Socket because it is overloaded, and some (all?)
-		// compilers have trouble choosing which one to use.
-		(DaemonCoreSockAdapterClass::Register_Socket_fnptr)&DaemonCore::Register_Socket,
-		&DaemonCore::Cancel_Socket,
-		&DaemonCore::CallSocketHandler,
-		&DaemonCore::CallCommandHandler,
-		&DaemonCore::HandleReqAsync,
-		&DaemonCore::Register_DataPtr,
-		&DaemonCore::GetDataPtr,
-		(DaemonCoreSockAdapterClass::Register_Timer_fnptr)&DaemonCore::Register_Timer,
-		(DaemonCoreSockAdapterClass::Register_PeriodicTimer_fnptr)&DaemonCore::Register_Timer,
-		&DaemonCore::Cancel_Timer,
-		&DaemonCore::TooManyRegisteredSockets,
-		&DaemonCore::incrementPendingSockets,
-		&DaemonCore::decrementPendingSockets,
-		&DaemonCore::publicNetworkIpAddr,
-		&DaemonCore::Register_Command,
-		&DaemonCore::daemonContactInfoChanged,
-		&DaemonCore::Register_Timer_TS,
-		&DaemonCore::SocketIsRegistered);
-
 	if ( PidSize == 0 )
 		PidSize = DEFAULT_PIDBUCKETS;
 	pidTable = new PidHashTable(PidSize, compute_pid_hash);
@@ -944,7 +916,9 @@ int DaemonCore::Register_Command(int command, const char* command_descrip,
 			i = j;
 		}
 		if ( comTable[j].num == command ) {
-			EXCEPT("DaemonCore: Same command registered twice");
+			MyString msg;
+			msg.formatstr("DaemonCore: Same command registered twice (id=%d)", command);
+			EXCEPT(msg.c_str());
 		}
 	}
 	if ( i == -1 ) {
@@ -6452,10 +6426,14 @@ int DaemonCore::Create_Process(
 		//  CCB's trickery if present.  As this address is
 		//  intended for my own children on the same machine,
 		//  this should be safe.
-	{
+		// If m_inherit_parent_sinful is set, then the daemon wants
+		//   this child to use an alternate sinful to contact it.
+	if ( m_inherit_parent_sinful.empty() ) {
 		MyString mysin = InfoCommandSinfulStringMyself(true);
 		ASSERT(mysin.Length() > 0); // Empty entry means unparsable string.
 		inheritbuf += mysin;
+	} else {
+		inheritbuf += m_inherit_parent_sinful;
 	}
 
 	if ( sock_inherit_list ) {
@@ -6604,11 +6582,16 @@ int DaemonCore::Create_Process(
 		char const *session_id_c_str = session_id.c_str();
 		char const *session_key_c_str = session_key.c_str();
 
+		// we need to include the list of valid commands with the session
+		// so the child knows it can use this session to contact the parent.
+		std::string valid_coms;
+		formatstr( valid_coms, "[%s=\"%s\"]", ATTR_SEC_VALID_COMMANDS,
+				   GetCommandsInAuthLevel(DAEMON,true).Value() );
 		bool rc = getSecMan()->CreateNonNegotiatedSecuritySession(
 			DAEMON,
 			session_id_c_str,
 			session_key_c_str,
-			NULL,
+			valid_coms.c_str(),
 			CONDOR_CHILD_FQU,
 			NULL,
 			0);
@@ -6618,6 +6601,10 @@ int DaemonCore::Create_Process(
 			dprintf(D_ALWAYS, "ERROR: Create_Process failed to create security session for child daemon.\n");
 			goto wrapup;
 		}
+		IpVerify* ipv = getSecMan()->getIpVerify();
+		MyString id = CONDOR_CHILD_FQU;
+		ipv->PunchHole(DAEMON, id);
+
 		privateinheritbuf += " SessionKey:";
 
 		MyString session_info;
@@ -8153,6 +8140,7 @@ DaemonCore::Inherit( void )
 	int numInheritedSocks = 0;
 	char *ptmp;
 	static bool already_inherited = false;
+	std::string saved_sinful_string;
 
 	if( already_inherited ) {
 		return;
@@ -8197,6 +8185,7 @@ DaemonCore::Inherit( void )
 		pidtmp->pid = ppid;
 		ptmp=inherit_list.next();
 		dprintf(D_DAEMONCORE,"Parent Command Sock = %s\n",ptmp);
+		saved_sinful_string = ptmp;
 		pidtmp->sinful_string = ptmp;
 		pidtmp->is_local = TRUE;
 		pidtmp->parent_is_local = TRUE;
@@ -8371,7 +8360,7 @@ DaemonCore::Inherit( void )
 				claimid.secSessionKey(),
 				claimid.secSessionInfo(),
 				CONDOR_PARENT_FQU,
-				NULL,
+				saved_sinful_string.c_str(),
 				0);
 			if(!rc)
 			{
diff --git a/src/condor_dagman/condor_submit_dag.cpp b/src/condor_dagman/condor_submit_dag.cpp
index 603d695..d6be1ad 100644
--- a/src/condor_dagman/condor_submit_dag.cpp
+++ b/src/condor_dagman/condor_submit_dag.cpp
@@ -167,20 +167,19 @@ doRecursion( SubmitDagDeepOptions &deepOpts,
 	while ( (dagFile = shallowOpts.dagFiles.next()) ) {
 
 			// Get logical lines from this DAG file.
-		StringList logicalLines;
-		MyString error = MultiLogFiles::fileNameToLogicalLines(
-					dagFile, logicalLines );
-		if ( error != "" ) {
+		MultiLogFiles::FileReader reader;
+		MyString errMsg = reader.Open( dagFile );
+		if ( errMsg != "" ) {
 			fprintf( stderr, "Error reading DAG file: %s\n",
-						error.Value() );
+						errMsg.Value() );
 			return 1;
 		}
 
+
 			// Find and parse JOB and SUBDAG lines.
-		logicalLines.rewind();
-		const char *dagLine;
-		while ( (dagLine = logicalLines.next()) ) {
-			StringList tokens( dagLine, " \t" );
+		MyString dagLine;
+		while ( reader.NextLogicalLine( dagLine ) ) {
+			StringList tokens( dagLine.Value(), " \t" );
 			tokens.rewind();
 			const char *first = tokens.next();
 
@@ -190,7 +189,7 @@ doRecursion( SubmitDagDeepOptions &deepOpts,
 					// file line.
 				const char *subFile;
 				const char *directory;
-				if ( parseJobOrDagLine( dagLine, tokens, "submit",
+				if ( parseJobOrDagLine( dagLine.Value(), tokens, "submit",
 							subFile, directory ) != 0 ) {
 					return 1;
 				}
@@ -220,7 +219,7 @@ doRecursion( SubmitDagDeepOptions &deepOpts,
 				const char *inlineOrExt = tokens.next();
 				if ( strcasecmp( inlineOrExt, "EXTERNAL" ) ) {
 					fprintf( stderr, "ERROR: only SUBDAG EXTERNAL is supported "
-								"at this time (line: <%s>)\n", dagLine );
+								"at this time (line: <%s>)\n", dagLine.Value() );
 					return 1;
 				}
 
@@ -228,7 +227,7 @@ doRecursion( SubmitDagDeepOptions &deepOpts,
 					// file line.
 				const char *nestedDagFile;
 				const char *directory;
-				if ( parseJobOrDagLine( dagLine, tokens, "DAG",
+				if ( parseJobOrDagLine( dagLine.Value(), tokens, "DAG",
 							nestedDagFile, directory ) != 0 ) {
 					return 1;
 				}
@@ -240,6 +239,8 @@ doRecursion( SubmitDagDeepOptions &deepOpts,
 				}
 			}
 		}
+
+		reader.Close();
 	}
 
 	return result;
@@ -655,19 +656,17 @@ getOldSubmitFlags(SubmitDagShallowOptions &shallowOpts)
 {
 		// It's not an error for the submit file to not exist.
 	if ( fileExists( shallowOpts.strSubFile ) ) {
-		StringList logicalLines;
-		MyString error = MultiLogFiles::fileNameToLogicalLines(
-					shallowOpts.strSubFile, logicalLines );
+		MultiLogFiles::FileReader reader;
+		MyString error = reader.Open( shallowOpts.strSubFile );
 		if ( error != "" ) {
 			fprintf( stderr, "Error reading submit file: %s\n",
 						error.Value() );
 			return 1;
 		}
 
-		logicalLines.rewind();
-		const char *subLine;
-		while ( (subLine = logicalLines.next()) ) {
-			StringList tokens( subLine, " \t" );
+		MyString subLine;
+		while ( reader.NextLogicalLine( subLine ) ) {
+			StringList tokens( subLine.Value(), " \t" );
 			tokens.rewind();
 			const char *first = tokens.next();
 			if ( first && !strcasecmp( first, "arguments" ) ) {
@@ -676,6 +675,8 @@ getOldSubmitFlags(SubmitDagShallowOptions &shallowOpts)
 				}
 			}
 		}
+
+		reader.Close();
 	}
 
 	return 0;
@@ -852,39 +853,47 @@ void writeSubmitFile(/* const */ SubmitDagDeepOptions &deepOpts,
 		args.AppendArg("-MaxIdle");
 		args.AppendArg(shallowOpts.iMaxIdle);
     }
+
     if(shallowOpts.iMaxJobs != 0) 
 	{
 		args.AppendArg("-MaxJobs");
 		args.AppendArg(shallowOpts.iMaxJobs);
     }
+
     if(shallowOpts.iMaxPre != 0) 
 	{
 		args.AppendArg("-MaxPre");
 		args.AppendArg(shallowOpts.iMaxPre);
     }
+
     if(shallowOpts.iMaxPost != 0) 
 	{
 		args.AppendArg("-MaxPost");
 		args.AppendArg(shallowOpts.iMaxPost);
     }
+
 	if(shallowOpts.bNoEventChecks)
 	{
 		// strArgs += " -NoEventChecks";
 		printf( "Warning: -NoEventChecks is ignored; please use "
 					"the DAGMAN_ALLOW_EVENTS config parameter instead\n");
 	}
+
 	if(!shallowOpts.bPostRun)
 	{
 		args.AppendArg("-DontAlwaysRunPost");
 	}
+
 	if(deepOpts.bAllowLogError)
 	{
 		args.AppendArg("-AllowLogError");
 	}
+
 	if(deepOpts.useDagDir)
 	{
 		args.AppendArg("-UseDagDir");
 	}
+
 	if(deepOpts.suppress_notification)
 	{
 		args.AppendArg("-Suppress_notification");
@@ -894,11 +903,17 @@ void writeSubmitFile(/* const */ SubmitDagDeepOptions &deepOpts,
 		args.AppendArg("-Dont_Suppress_notification");
 	}
 
+	if ( shallowOpts.doRecovery ) {
+		args.AppendArg( "-DoRecov" );
+	}
+
 	args.AppendArg("-CsdVersion");
 	args.AppendArg(CondorVersion());
+
 	if(deepOpts.allowVerMismatch) {
 		args.AppendArg("-AllowVersionMismatch");
 	}
+
 	if(shallowOpts.dumpRescueDag) {
 		args.AppendArg("-DumpRescue");
 	}
@@ -1242,11 +1257,6 @@ parseCommandLine(SubmitDagDeepOptions &deepOpts,
 			{
 				deepOpts.suppress_notification = false;
 			}
-			else if ( parsePreservedArgs( strArg, iArg, argc, argv,
-						shallowOpts) )
-			{
-				// No-op here
-			}
 			else if( (strArg.find("-prio") != -1) ) // -priority
 			{
 				if(iArg + 1 >= argc) {
@@ -1255,6 +1265,15 @@ parseCommandLine(SubmitDagDeepOptions &deepOpts,
 				}
 				deepOpts.priority = atoi(argv[++iArg]);
 			}
+			else if ( (strArg.find("-dorecov") != -1) )
+			{
+				shallowOpts.doRecovery = true;
+			}
+			else if ( parsePreservedArgs( strArg, iArg, argc, argv,
+						shallowOpts) )
+			{
+				// No-op here
+			}
 			else
 			{
 				fprintf( stderr, "ERROR: unknown option %s\n", strArg.Value() );
@@ -1358,6 +1377,7 @@ int printUsage(int iExitCode)
     printf("    -notification <value> (Determines how much email you get from Condor.\n");
     printf("        See the condor_submit man page for values.)\n");
     printf("    -NoEventChecks      (Now ignored -- use DAGMAN_ALLOW_EVENTS)\n"); 
+    printf("    -DontAlwaysRunPost  (Don't run POST script if PRE script fails)\n");
     printf("    -AllowLogError      (Allows the DAG to attempt execution even if the log\n");
     printf("        reading code finds errors when parsing the submit files)\n"); 
 	printf("    -UseDagDir          (Run DAGs in directories specified in DAG file paths)\n");
@@ -1384,5 +1404,6 @@ int printUsage(int iExitCode)
 	printf("    -dont_use_default_node_log (Restore pre-7.9.0 behavior of using UserLog only)\n");
 	printf("    -suppress_notification (Set \"notification = never\" in all jobs submitted by this DAGMan)\n");
 	printf("    -dont_suppress_notification (Allow jobs to specify notification)\n");
+	printf("    -DoRecov            (run in recovery mode)\n");
 	exit(iExitCode);
 }
diff --git a/src/condor_dagman/dag.cpp b/src/condor_dagman/dag.cpp
index d1fb2e8..d59d99c 100644
--- a/src/condor_dagman/dag.cpp
+++ b/src/condor_dagman/dag.cpp
@@ -59,6 +59,17 @@ const int Dag::DAG_ERROR_CONDOR_JOB_ABORTED = -1002;
 const int Dag::DAG_ERROR_LOG_MONITOR_ERROR = -1003;
 const int Dag::DAG_ERROR_JOB_SKIPPED = -1004;
 
+// NOTE: this must be kept in sync with the dag_status enum
+const char * Dag::_dag_status_names[] = {
+    "DAG_STATUS_OK",
+    "DAG_STATUS_ERROR",
+    "DAG_STATUS_NODE_FAILED",
+    "DAG_STATUS_ABORT",
+    "DAG_STATUS_RM",
+    "DAG_STATUS_CYCLE",
+    "DAG_STATUS_HALTED"
+};
+
 //---------------------------------------------------------------------------
 void touch (const char * filename) {
     int fd = safe_open_wrapper_follow(filename, O_RDWR | O_CREAT, 0600);
@@ -219,7 +230,8 @@ Dag::Dag( /* const */ StringList &dagFiles,
 }
 
 //-------------------------------------------------------------------------
-Dag::~Dag() {
+Dag::~Dag()
+{
 		// remember kids, delete is safe *even* if ptr == NULL...
 
     // delete all jobs in _jobs
@@ -4015,16 +4027,12 @@ Dag::SubmitNodeJob( const Dagman &dm, Job *node, CondorID &condorID )
 		return SUBMIT_RESULT_NO_SUBMIT;
 	}
 
-		// Note: we're checking for a missing log file spec here instead of
-		// inside the submit code because we don't want to re-try the submit
-		// if the log file spec is missing in the submit file.  wenger
-
 		// We now only check for missing log files for Stork jobs because
 		// of the default log file feature; that doesn't work for Stork
 		// jobs because we can't specify the log file on the command
 		// line.  wenger 2009-08-14
 	if ( !_allowLogError && node->JobType() == Job::TYPE_STORK &&
-				!node->CheckForLogFile( _use_default_node_log ) ) {
+				!node->CheckForLogFile( false ) ) {
 		debug_printf( DEBUG_NORMAL, "ERROR: No 'log =' value found in "
 					"submit file %s for node %s\n", node->GetCmdFile(),
 					node->GetJobName() );
@@ -4043,7 +4051,6 @@ Dag::SubmitNodeJob( const Dagman &dm, Job *node, CondorID &condorID )
 		debug_printf( DEBUG_NORMAL, "Submitting %s Node %s job(s)...\n",
 				  	node->JobTypeString(), node->GetJobName() );
 
-    	MyString cmd_file = node->GetCmdFile();
 		bool submit_success = false;
 
     	if( node->JobType() == Job::TYPE_CONDOR ) {
@@ -4051,37 +4058,34 @@ Dag::SubmitNodeJob( const Dagman &dm, Job *node, CondorID &condorID )
 			if ( node->GetNoop() ) {
       			submit_success = fake_condor_submit( condorID, 0,
 							node->GetJobName(), node->GetDirectory(),
-							_use_default_node_log ? DefaultNodeLog():
-								node->GetLogFile() ,
-							!_use_default_node_log && node->GetLogFileIsXml() );
+							node->GetLogFile() ,
+							node->GetLogFileIsXml() );
 			} else {
 				const char *logFile = node->UsingDefaultLog() ?
-							DefaultNodeLog() : NULL;
+							node->GetLogFile() : NULL;
 					// Note: assigning the ParentListString() return value
 					// to a variable here, instead of just passing it directly
 					// to condor_submit(), fixes a memory leak(!).
 					// wenger 2008-12-18
 				MyString parents = ParentListString( node );
-      			submit_success = condor_submit( dm, cmd_file.Value(), condorID,
+      			submit_success = condor_submit( dm, node->GetCmdFile(), condorID,
 							node->GetJobName(), parents,
 							node->varsFromDag, node->GetRetries(),
-							node->GetDirectory(), DefaultNodeLog(),
-							_use_default_node_log && node->UseDefaultLog(),
-							logFile, ProhibitMultiJobs(),
-							node->NumChildren() > 0 && dm._claim_hold_time > 0);
+							node->GetDirectory(), logFile,
+							ProhibitMultiJobs(),
+							node->NumChildren() > 0 && dm._claim_hold_time > 0 );
 			}
     	} else if( node->JobType() == Job::TYPE_STORK ) {
 	  		node->_submitTries++;
 			if ( node->GetNoop() ) {
       			submit_success = fake_condor_submit( condorID, 0,
 							node->GetJobName(), node->GetDirectory(),
-							_use_default_node_log ? DefaultNodeLog() :
-								node->GetLogFile(),
-							!_use_default_node_log && node->GetLogFileIsXml() );
+							node->GetLogFile(),
+							node->GetLogFileIsXml() );
 
 			} else {
-      			submit_success = stork_submit( dm, cmd_file.Value(), condorID,
-				   		node->GetJobName(), node->GetDirectory() );
+      			submit_success = stork_submit( dm, node->GetCmdFile(),
+						condorID, node->GetJobName(), node->GetDirectory() );
 			}
     	} else {
 	    	debug_printf( DEBUG_QUIET, "Illegal job type: %d\n",
diff --git a/src/condor_dagman/dag.h b/src/condor_dagman/dag.h
index d860a9c..7644cfb 100644
--- a/src/condor_dagman/dag.h
+++ b/src/condor_dagman/dag.h
@@ -741,6 +741,12 @@ class Dag {
 
 	dag_status _dagStatus;
 
+	// WARNING!  dag_status and dag_status_names just be kept in sync!
+	static const char *_dag_status_names[];
+
+	const char *GetStatusName() const {
+				return _dag_status_names[_dagStatus]; }
+
 	/** Determine whether this DAG has a final node.
 		@return true iff the DAG has a final node.
 	*/
diff --git a/src/condor_dagman/dagman_main.cpp b/src/condor_dagman/dagman_main.cpp
index b8eb811..f05233c 100644
--- a/src/condor_dagman/dagman_main.cpp
+++ b/src/condor_dagman/dagman_main.cpp
@@ -61,30 +61,34 @@ static void Usage() {
             "\t\t-Lockfile <NAME.dag.lock>\n"
             "\t\t-Dag <NAME.dag>\n"
             "\t\t-CsdVersion <version string>\n"
-            "\t\t[-Debug <level>]\n"
+            "\t\t[-Help]\n"
+            "\t\t[-Version]\n"
+	    "\t\t[-Debug <level>]\n"
             "\t\t[-MaxIdle <int N>]\n"
             "\t\t[-MaxJobs <int N>]\n"
             "\t\t[-MaxPre <int N>]\n"
             "\t\t[-MaxPost <int N>]\n"
-            "\t\t[-DontAlwaysRunPost]\n"
-            "\t\t[-WaitForDebug]\n"
             "\t\t[-NoEventChecks]\n"
             "\t\t[-AllowLogError]\n"
+            "\t\t[-DontAlwaysRunPost]\n"
+            "\t\t[-WaitForDebug]\n"
             "\t\t[-UseDagDir]\n"
             "\t\t[-AutoRescue <0|1>]\n"
             "\t\t[-DoRescueFrom <int N>]\n"
-            "\t\t[-Priority <int N>]\n"
 			"\t\t[-AllowVersionMismatch]\n"
 			"\t\t[-DumpRescue]\n"
 			"\t\t[-Verbose]\n"
 			"\t\t[-Force]\n"
 			"\t\t[-Notification <never|always|complete|error>]\n"
+			"\t\t[-Suppress_notification]\n"
+			"\t\t[-Dont_Suppress_notification]\n"
 			"\t\t[-Dagman <dagman_executable>]\n"
 			"\t\t[-Outfile_dir <directory>]\n"
 			"\t\t[-Update_submit]\n"
 			"\t\t[-Import_env]\n"
-			"\t\t[-Suppress_notification]\n"
-			"\t\t[-Dont_Suppress_notification]\n"
+            "\t\t[-Priority <int N>]\n"
+			"\t\t[-dont_use_default_node_log]\n"
+			"\t\t[-DoRecov]\n"
             "\twhere NAME is the name of your DAG.\n"
             "\tdefault -Debug is -Debug %d\n", DEBUG_NORMAL);
 	DC_Exit( EXIT_ERROR );
@@ -135,6 +139,7 @@ Dagman::Dagman() :
 	_runPost(true),
 	_defaultPriority(0),
 	_claim_hold_time(20),
+	_doRecovery(false),
 	_dagmanClassad(NULL)
 {
     debug_level = DEBUG_VERBOSE;  // Default debug level is verbose output
@@ -795,14 +800,19 @@ void main_init (int argc, char ** const argv) {
 			dagman._submitDagDeepOpts.importEnv = true;
 
         } else if( !strcasecmp( "-priority", argv[i] ) ) {
-		++i;
-		if( i >= argc || strcmp( argv[i], "" ) == 0 ) {
-			debug_printf( DEBUG_NORMAL, "No priority value specified\n");
-			Usage();
-		}
-		dagman._submitDagDeepOpts.priority = atoi(argv[i]);
+			++i;
+			if( i >= argc || strcmp( argv[i], "" ) == 0 ) {
+				debug_printf( DEBUG_NORMAL, "No priority value specified\n");
+				Usage();
+			}
+			dagman._submitDagDeepOpts.priority = atoi(argv[i]);
+
 		} else if( !strcasecmp( "-dont_use_default_node_log", argv[i] ) ) {
 			dagman._submitDagDeepOpts.always_use_node_log = false;
+
+		} else if ( !strcasecmp( "-dorecov", argv[i] ) ) {
+			dagman._doRecovery = true;
+
         } else {
     		debug_printf( DEBUG_SILENT, "\nUnrecognized argument: %s\n",
 						argv[i] );
@@ -1195,6 +1205,12 @@ void main_init (int argc, char ** const argv) {
 				}
 			}
 
+        } else if ( dagman._doRecovery ) {
+            debug_printf( DEBUG_VERBOSE, "Running in recovery mode because -DoRecovery flag was specified\n" );
+			recovery = true;
+		}
+
+        if ( recovery ) {
 				// Not using the default node log is the backward
 				// compatible thing to do, so if using the default
 				// log file is already disabled, we don't have to
@@ -1202,7 +1218,7 @@ void main_init (int argc, char ** const argv) {
 			if ( dagman._submitDagDeepOpts.always_use_node_log ) { 
 				dagman.CheckLogFileMode( submitFileVersion );
 			}
-        }
+		}
 
 			//
 			// If this DAGMan continues, it should overwrite the lock
@@ -1337,6 +1353,10 @@ Dagman::ResolveDefaultLog()
 
 void
 print_status() {
+	debug_printf( DEBUG_VERBOSE, "DAG status: %d (%s)\n",
+				dagman.dag->_dagStatus,
+				dagman.dag->GetStatusName() );
+
 	int total = dagman.dag->NumNodes( true );
 	int done = dagman.dag->NumNodesDone( true );
 	int pre = dagman.dag->PreRunNodeCount();
diff --git a/src/condor_dagman/dagman_main.h b/src/condor_dagman/dagman_main.h
index 01c29a0..e0b8c9f 100644
--- a/src/condor_dagman/dagman_main.h
+++ b/src/condor_dagman/dagman_main.h
@@ -218,10 +218,15 @@ class Dagman {
 		// If _runPost is true, we run a POST script even if the PRE
 		// script for the node fails.
 	bool _runPost;
+
 		// Default priority that DAGman uses for nodes.
 	int _defaultPriority;
+
 	int _claim_hold_time;
 
+		// True iff -DoRecov is specified on the command line.
+	bool _doRecovery;
+
 	DagmanClassad *_dagmanClassad;
 };
 
diff --git a/src/condor_dagman/dagman_recursive_submit.h b/src/condor_dagman/dagman_recursive_submit.h
index badfb84..1a3fa66 100644
--- a/src/condor_dagman/dagman_recursive_submit.h
+++ b/src/condor_dagman/dagman_recursive_submit.h
@@ -52,6 +52,7 @@ struct SubmitDagShallowOptions
 	bool runValgrind;
 	MyString primaryDagFile;
 	StringList	dagFiles;
+	bool doRecovery;
 
 	// non-command line options
 	MyString strLibOut;
@@ -82,6 +83,7 @@ struct SubmitDagShallowOptions
 		dumpRescueDag = false;
 		runValgrind = false;
 		primaryDagFile = "";
+		doRecovery = false;
 		copyToSpool = param_boolean( "DAGMAN_COPY_TO_SPOOL", false );
 		iDebugLevel = DEBUG_UNSET;
 	}
diff --git a/src/condor_dagman/dagman_submit.cpp b/src/condor_dagman/dagman_submit.cpp
index 6b16e71..d395c51 100644
--- a/src/condor_dagman/dagman_submit.cpp
+++ b/src/condor_dagman/dagman_submit.cpp
@@ -38,6 +38,9 @@
 typedef bool (* parse_submit_fnc)( const char *buffer, int &jobProcCount,
 			int &cluster );
 
+	// Get the event mask for the workflow/default log file.
+const char *getEventMask();
+
 //-------------------------------------------------------------------------
 /** Parse output from condor_submit, determine the number of job procs
     and the cluster.
@@ -244,8 +247,8 @@ bool
 condor_submit( const Dagman &dm, const char* cmdFile, CondorID& condorID,
 			   const char* DAGNodeName, MyString &DAGParentNodeNames,
 			   List<Job::NodeVar> *vars, int retry,
-			   const char* directory, const char *defaultLog, bool appendDefaultLog,
-			   const char *logFile, bool prohibitMultiJobs, bool hold_claim )
+			   const char* directory, const char *workflowLogFile,
+			   bool prohibitMultiJobs, bool hold_claim )
 {
 	TmpDir		tmpDir;
 	MyString	errMsg;
@@ -321,70 +324,30 @@ condor_submit( const Dagman &dm, const char* cmdFile, CondorID& condorID,
 				"submit_event_notes = DAG Node: " ) + DAGNodeName;
 	args.AppendArg( submitEventNotes.Value() );
 
-		// logFile is null here if there was a log specified
-		// in the submit file
-	if ( !logFile ) {
-		if( appendDefaultLog ) {
-				// We need to append the DAGman default log file to
-				// the log file list
-			args.AppendArg( "-a" );
-			std::string dlog("dagman_log = ");
-			dlog += defaultLog;
-			args.AppendArg(dlog.c_str());
-			debug_printf( DEBUG_VERBOSE, "Adding a DAGMan auxiliary log %s\n", defaultLog );
-				// Now append the mask
-			args.AppendArg( "-a" );
-			std::string dmask("+");
-			dmask += ATTR_DAGMAN_WORKFLOW_MASK;
-			dmask += " = \"";
-			debug_printf( DEBUG_VERBOSE, "Masking the events recorded in the DAGMAN auxiliary log\n" );
-			std::stringstream dmaskstrm;
-			//
-			// IMPORTANT NOTE:  see all events that we deal with in
-			// Dag::ProcessOneEvent() -- all of those need to be in the
-			// event mask!! (wenger 2012-11-16)
-			//
-			int mask[] = {
-				ULOG_SUBMIT,
-				ULOG_EXECUTE,
-				ULOG_EXECUTABLE_ERROR,
-				ULOG_JOB_EVICTED,
-				ULOG_JOB_TERMINATED,
-				ULOG_SHADOW_EXCEPTION,
-				ULOG_JOB_ABORTED,
-				ULOG_JOB_SUSPENDED,
-				ULOG_JOB_UNSUSPENDED,
-				ULOG_JOB_HELD,
-				ULOG_JOB_RELEASED,
-				ULOG_POST_SCRIPT_TERMINATED,
-				ULOG_GLOBUS_SUBMIT,			// For Pegasus
-				ULOG_JOB_RECONNECT_FAILED,
-				ULOG_GRID_SUBMIT,			// For Pegasus
-				-1
-			};
-			for(const int*p = &mask[0]; *p != -1; ++p) {
-				if(p != &mask[0]) {
-					dmaskstrm << ",";
-				}
-				dmaskstrm << *p;
-			}
-			dmask += dmaskstrm.str();
-			debug_printf( DEBUG_VERBOSE, "Mask for auxiliary log is %s\n", dmaskstrm.str().c_str() );
-			dmask += "\"";
-			args.AppendArg(dmask.c_str());
-		}
-	} else {
-			// Log was not specified in the submit file
-			// There is a single user log file for this job;
-			// That is, the default
+		// workflowLogFile is non-null here if we need to tell the schedd to
+		// use that file as the default/workflow log for this node.
+	if ( workflowLogFile ) {
+			// We need to append the DAGman default log file to
+			// the log file list
 		args.AppendArg( "-a" );
-		std::string dlog("log = ");
-		dlog += logFile;
-		args.AppendArg(dlog.c_str());
-			// We are using the default log
-			// Never let it be XML
+		std::string dlog( "dagman_log = " );
+		dlog += workflowLogFile;
+		args.AppendArg( dlog.c_str() );
+		debug_printf( DEBUG_VERBOSE, "Adding a DAGMan workflow log %s\n",
+					workflowLogFile );
+
+			// Now append the mask
+		debug_printf( DEBUG_VERBOSE, "Masking the events recorded in the DAGMAN workflow log\n" );
 		args.AppendArg( "-a" );
-		args.AppendArg( "log_xml = False");
+		std::string dmask("+");
+		dmask += ATTR_DAGMAN_WORKFLOW_MASK;
+		dmask += " = \"";
+		const char *eventMask = getEventMask();
+		debug_printf( DEBUG_VERBOSE, "Mask for workflow log is %s\n",
+					eventMask );
+		dmask += eventMask;
+		dmask += "\"";
+		args.AppendArg( dmask.c_str() );
 	}
 
 	ArgList parentNameArgs;
@@ -646,3 +609,47 @@ bool writePreSkipEvent( CondorID& condorID, Job* job, const char* DAGNodeName,
 	}
 	return true;
 }
+
+const char *
+getEventMask()
+{
+	static std::string result("");
+	static std::stringstream dmaskstrm("");
+
+	if ( result == "" ) {
+		//
+		// IMPORTANT NOTE:  see all events that we deal with in
+		// Dag::ProcessOneEvent() -- all of those need to be in the
+		// event mask!! (wenger 2012-11-16)
+		//
+		int mask[] = {
+			ULOG_SUBMIT,
+			ULOG_EXECUTE,
+			ULOG_EXECUTABLE_ERROR,
+			ULOG_JOB_EVICTED,
+			ULOG_JOB_TERMINATED,
+			ULOG_SHADOW_EXCEPTION,
+			ULOG_JOB_ABORTED,
+			ULOG_JOB_SUSPENDED,
+			ULOG_JOB_UNSUSPENDED,
+			ULOG_JOB_HELD,
+			ULOG_JOB_RELEASED,
+			ULOG_POST_SCRIPT_TERMINATED,
+			ULOG_GLOBUS_SUBMIT,			// For Pegasus
+			ULOG_JOB_RECONNECT_FAILED,
+			ULOG_GRID_SUBMIT,			// For Pegasus
+			-1
+		};
+
+		for ( const int *p = &mask[0]; *p != -1; ++p ) {
+			if ( p != &mask[0] ) {
+				dmaskstrm << ",";
+			}
+			dmaskstrm << *p;
+		}
+
+		result = dmaskstrm.str();
+	}
+
+	return result.c_str();
+}
diff --git a/src/condor_dagman/job.cpp b/src/condor_dagman/job.cpp
index eb177a6..2c9f1fe 100644
--- a/src/condor_dagman/job.cpp
+++ b/src/condor_dagman/job.cpp
@@ -94,8 +94,7 @@ Job::~Job() {
 //---------------------------------------------------------------------------
 Job::Job( const job_type_t jobType, const char* jobName,
 			const char *directory, const char* cmdFile ) :
-	_jobType( jobType ), _preskip( PRE_SKIP_INVALID ),
-			_final( false ), append_default_log(true)
+	_jobType( jobType ), _preskip( PRE_SKIP_INVALID ), _final( false )
 {
 	ASSERT( jobName != NULL );
 	ASSERT( cmdFile != NULL );
@@ -197,7 +196,7 @@ bool Job::Remove (const queue_t queue, const JobID_t jobID)
 
 //---------------------------------------------------------------------------
 bool
-Job::CheckForLogFile(bool usingDefault ) const
+Job::CheckForLogFile( bool usingDefault ) const
 {
 	bool tmpLogFileIsXml;
 	MyString logFile = MultiLogFiles::loadLogFileNameFromSubFile( _cmdFile,
@@ -783,8 +782,8 @@ Job::MonitorLogFile( ReadMultipleUserLogs &condorLogReader,
 			bool recovery, const char *defaultNodeLog, bool usingDefault )
 {
 	debug_printf( DEBUG_DEBUG_2,
-				"Attempting to monitor log file for node %s\n",
-				GetJobName() );
+				"Attempting to monitor log file for node %s; using default?: %d\n",
+				GetJobName(), usingDefault );
 
 	if ( _logIsMonitored ) {
 		debug_printf( DEBUG_DEBUG_1, "Warning: log file for node "
@@ -795,78 +794,46 @@ Job::MonitorLogFile( ReadMultipleUserLogs &condorLogReader,
 	ReadMultipleUserLogs &logReader = (_jobType == TYPE_CONDOR) ?
 				condorLogReader : storkLogReader;
 
-    std::string logFileStr;
-	if ( _jobType == TYPE_CONDOR ) {
-			// We check to see if the user has specified a log file
-			// If not, we give him a default
-    	MyString templogFileStr = MultiLogFiles::loadLogFileNameFromSubFile( _cmdFile,
-					_directory, _logFileIsXml, usingDefault);
-		logFileStr = templogFileStr.Value();
-	} else {
-		StringList logFiles;
-		MyString tmpResult = MultiLogFiles::loadLogFileNamesFromStorkSubFile(
-					_cmdFile, _directory, logFiles );
-		if ( tmpResult != "" ) {
-			debug_printf( DEBUG_QUIET, "Error getting Stork log file: %s\n",
-						tmpResult.Value() );
-			LogMonitorFailed();
-			return false;
-		} else if ( logFiles.number() != 1 ) {
-			debug_printf( DEBUG_QUIET, "Error: %d Stork log files found "
-						"in submit file %s; we want 1\n",
-						logFiles.number(), _cmdFile );
-			LogMonitorFailed();
-			return false;
-		} else {
-			logFiles.rewind();
-			logFileStr = logFiles.next();
-		}
+	MyString logFile;
+	if ( !FindLogFile( usingDefault, logFile ) ) {
+		LogMonitorFailed();
+		return false;
 	}
+	// Note:  logFile is "" here if usingDefault is true and this node
+	// is an HTCondor node (not Stork).
 
 		// Warn the user if the node's log file is in /tmp.
-	if ( logFileStr.find( "/tmp" ) == 0 ) {
+	if ( logFile.find( "/tmp" ) == 0 ) {
 		debug_printf( DEBUG_QUIET, "Warning: "
 					"Log file %s for node %s is in /tmp\n",
-					logFileStr.c_str(), GetJobName() );
-        check_warning_strictness( usingDefault ? DAG_STRICT_2 : DAG_STRICT_1 );
+					logFile.Value(), GetJobName() );
+			// If we're using the workflow log, we'll only ever get here
+			// for Stork nodes, because they can't use the workflow log.
+        check_warning_strictness( DAG_STRICT_1 );
 	}
 
-	if ( logFileStr == "" ) {
-		logFileStr = defaultNodeLog;
+	if ( logFile == "" ) {
+			// Using the workflow/default log file for this node.
+		logFile = defaultNodeLog;
 		_useDefaultLog = true;
 			// Default User log is never XML
-			// This could be specified in the submit file and should be
-			// ignored.
 		_logFileIsXml = false;
-		debug_printf( DEBUG_NORMAL, "Unable to get log file from "
-					"submit file %s (node %s); using default (%s)\n",
-					_cmdFile, GetJobName(), logFileStr.c_str() );
-		append_default_log = false;
-	} else {
-		append_default_log = usingDefault;
-		if( append_default_log ) {
-				// DAGman is not going to look at the user-specified log.
-				// It will look at the defaultNode log.
-			logFileStr = defaultNodeLog;
-			_useDefaultLog = false;
-			_logFileIsXml = false;
-		}
 	}
 
 		// This function returns true if the log file is on NFS and
 		// that is an error.  If the log file is on NFS, but nfsIsError
 		// is false, it prints a warning but returns false.
-	if ( MultiLogFiles::logFileNFSError( logFileStr.c_str(),
+	if ( MultiLogFiles::logFileNFSError( logFile.Value(),
 				nfsIsError ) ) {
 		debug_printf( DEBUG_QUIET, "Error: log file %s on NFS\n",
-					logFileStr.c_str() );
+					logFile.Value() );
 		LogMonitorFailed();
 		return false;
 	}
 
 	delete [] _logFile;
 		// Saving log file here in case submit file gets changed.
-	_logFile = strnewp( logFileStr.c_str() );
+	_logFile = strnewp( logFile.Value() );
 	debug_printf( DEBUG_DEBUG_2, "Monitoring log file <%s> for node %s\n",
 				GetLogFile(), GetJobName() );
 	CondorError errstack;
@@ -1033,7 +1000,9 @@ Job::FixPriority(Dag& dag)
 	}
 }
 
-bool Job::SetCondorID(const CondorID& cid)
+//---------------------------------------------------------------------------
+bool
+Job::SetCondorID(const CondorID& cid)
 {
 	bool ret = true;
 	if(GetCluster() != -1) {
@@ -1046,7 +1015,9 @@ bool Job::SetCondorID(const CondorID& cid)
 	return ret;	
 }
 
-bool Job::Hold(int proc) 
+//---------------------------------------------------------------------------
+bool
+Job::Hold(int proc) 
 {
 	if( proc >= static_cast<int>( _onHold.size() ) ) {
 		_onHold.resize( proc+1, 0 );
@@ -1063,7 +1034,9 @@ bool Job::Hold(int proc)
 	return false;
 }
 
-bool Job::Release(int proc)
+//---------------------------------------------------------------------------
+bool
+Job::Release(int proc)
 {
 	if( proc >= static_cast<int>( _onHold.size() ) ) {
 		dprintf( D_FULLDEBUG, "Received release event for node %s, but job %d.%d "
@@ -1139,5 +1112,56 @@ Job::Cleanup()
 
 	std::vector<unsigned char> s2;
 	_gotEvents.swap(s2); // Free memory in _gotEvents
+}
+
+//---------------------------------------------------------------------------
+bool
+Job::FindLogFile( bool usingWorkflowLog, MyString &logFile )
+{
+	if ( _jobType == TYPE_CONDOR ) {
+		if ( usingWorkflowLog ) {
+				// Now, if we're using the workflow log file, we don't
+				// even look at the node's submit file.  (See gittrac
+				// #3843.)
+			logFile = "";
+
+		} else {
+				// We're not in workflow/default log mode, so get the
+				// log file (if any) from the submit file.
+    		logFile = MultiLogFiles::loadLogFileNameFromSubFile(
+						_cmdFile, _directory, _logFileIsXml, false );
+			if ( logFile == "" ) {
+				debug_printf( DEBUG_NORMAL, "Unable to get log file from "
+							"submit file %s (node %s); using default/workflow log\n",
+							_cmdFile, GetJobName() );
+				// Don't return false here, because not specifying the
+				// log file is not an error.
+			}
+		}
 
+	} else {
+			// Workflow/default log file mode is not supported for Stork
+			// nodes, so we always have to get the log file for a Stork
+			// node.
+		StringList logFiles;
+		MyString tmpResult = MultiLogFiles::loadLogFileNamesFromStorkSubFile(
+					_cmdFile, _directory, logFiles );
+		if ( tmpResult != "" ) {
+			debug_printf( DEBUG_QUIET, "Error getting Stork log file: %s\n",
+						tmpResult.Value() );
+			return false;
+
+		} else if ( logFiles.number() != 1 ) {
+			debug_printf( DEBUG_QUIET, "Error: %d Stork log files found "
+						"in submit file %s; we want 1\n",
+						logFiles.number(), _cmdFile );
+			return false;
+
+		} else {
+			logFiles.rewind();
+			logFile = logFiles.next();
+		}
+	}
+
+	return true;
 }
diff --git a/src/condor_dagman/job.h b/src/condor_dagman/job.h
index e1f786e..4bbf9e5 100644
--- a/src/condor_dagman/job.h
+++ b/src/condor_dagman/job.h
@@ -227,7 +227,7 @@ class Job {
 			default node log
 		@return true iff the submit file defines a log file
 	*/
-	bool CheckForLogFile(bool usingDefault) const;
+	bool CheckForLogFile( bool usingDefault ) const;
 
     /** Returns true if a queue is empty (has no jobs)
         @param queue Selects which queue to look at
@@ -356,6 +356,8 @@ class Job {
 		@param recovery: whether we're in recovery mode
 		@param defaultNodeLog: the default log file to be used if the
 			node's submit file doesn't define a log file
+		@param usingDefault: whether we're using the default/workflow
+			log at the DAG level
 		@return true if successful, false if failed
 	*/
 	bool MonitorLogFile( ReadMultipleUserLogs &condorLogReader,
@@ -518,7 +520,6 @@ public:
 		// (Note: we may need to track the hold state of each proc in a
 		// cluster separately to correctly deal with multi-proc clusters.)
 	int _jobProcsOnHold;
-	bool UseDefaultLog() const { return append_default_log; }
 
 		/** Mark a job with ProcId == proc as being on hold
  			Returns false if the job is already on hold
@@ -540,6 +541,17 @@ private:
 		*/
 	void Cleanup();
 
+		/** Get the log file specified in the given submit file, if
+			any.  Note that if the job is an HTCondor job and
+			usingWorkflowLog is true, this method will return "" for
+			the log file name.
+			@param usingWorkflowLog: true iff we're using the workflow
+				log file to monitor jobs
+			@param logFile: a MyString to hold the log file name
+			@return true on success, false otherwise
+		*/
+	bool FindLogFile( bool usingWorkflowLog, MyString &logFile );
+
 		/** _onHold[proc] is nonzero if the condor job 
  			with ProcId == proc is on hold, and zero
 			otherwise
@@ -655,7 +667,6 @@ private:
 
 	// whether this is a final job
 	bool _final;
-	bool append_default_log;
 
 		//
 		// For metrics reporting.
diff --git a/src/condor_dagman/submit.h b/src/condor_dagman/submit.h
index d27cf78..df8b79a 100644
--- a/src/condor_dagman/submit.h
+++ b/src/condor_dagman/submit.h
@@ -55,9 +55,8 @@
 bool condor_submit( const Dagman &dm, const char* cmdFile, CondorID& condorID,
 					const char* DAGNodeName, MyString &DAGParentNodeNames,
 					List<Job::NodeVar> *vars, int retry,
-					const char* directory, const char *defLog, bool useDefLog,
-					const char *logFile, bool prohibitMultiJobs,
-					bool hold_claim );
+					const char* directory, const char *worflowLogFile,
+					bool prohibitMultiJobs, bool hold_claim );
 
 bool stork_submit( const Dagman &dm, const char* cmdFile, CondorID& condorID,
 				   const char* DAGNodeName, const char* directory );
diff --git a/src/condor_includes/classad_cron_job.h b/src/condor_includes/classad_cron_job.h
index b4932da..232e36e 100644
--- a/src/condor_includes/classad_cron_job.h
+++ b/src/condor_includes/classad_cron_job.h
@@ -58,7 +58,8 @@ class ClassAdCronJob : public CronJob
 
   private:
 	virtual int ProcessOutput( const char *line );
-	virtual int Publish( const char *name, ClassAd *ad ) = 0;
+	virtual int ProcessOutputSep( const char *args );
+	virtual int Publish( const char *name, const char *sep_args, ClassAd *ad ) = 0;
 	virtual const ClassAdCronJobParams & Params( void ) const {
 		return static_cast<ClassAdCronJobParams &>(*m_params);
 	};
@@ -67,7 +68,8 @@ class ClassAdCronJob : public CronJob
 	};
 
 	ClassAd		*m_output_ad;
-	int			 m_output_ad_count;
+	int 		 m_output_ad_count; // number of attributes inserted in to m_output_ad
+	MyString	 m_output_ad_args;  // optional arguments from after the '-' that separates ads in the script output
 
 	Env          m_classad_env;
 };
diff --git a/src/condor_includes/condor_attributes.h b/src/condor_includes/condor_attributes.h
index aa23ca8..f092ded 100644
--- a/src/condor_includes/condor_attributes.h
+++ b/src/condor_includes/condor_attributes.h
@@ -536,6 +536,8 @@
 #define ATTR_REQUEUE_REASON  "RequeueReason"
 #define ATTR_REQUIREMENTS  "Requirements"
 #define ATTR_RESOURCE_REQUEST_COUNT "_condor_RESOURCE_COUNT"  // used in resource request ad
+#define ATTR_RESOURCE_REQUEST_CLUSTER "_condor_RESOURCE_CLUSTER"
+#define ATTR_RESOURCE_REQUEST_PROC "_condor_RESOURCE_PROC"
 #define ATTR_SLOT_TYPE  "SlotType"
 #define ATTR_SLOT_TYPE_ID  "SlotTypeID"
 #define ATTR_SLOT_WEIGHT  "SlotWeight"
diff --git a/src/condor_includes/condor_auth_x509.h b/src/condor_includes/condor_auth_x509.h
index 9bb0e94..3bfdf40 100644
--- a/src/condor_includes/condor_auth_x509.h
+++ b/src/condor_includes/condor_auth_x509.h
@@ -31,6 +31,8 @@
 #undef IOV_MAX 
 #include "globus_gss_assist.h"
 
+#include "classad/classad_stl.h"
+
 const char STR_GSI_DAEMON_DIRECTORY[] = "GSI_DAEMON_DIRECTORY";
 const char STR_GSI_DAEMON_PROXY[]     = "GSI_DAEMON_PROXY";
 const char STR_GSI_DAEMON_CERT[]      = "GSI_DAEMON_CERT";
@@ -152,6 +154,15 @@ class Condor_Auth_X509 : public Condor_Auth_Base {
     static Grid_Map_t * GridMap;
 #endif
 	static bool m_globusActivated;
+
+	typedef struct globus_mapping_entry_s {
+		std::string name;
+		time_t expiry_time;
+	} globus_mapping_entry_t;
+	typedef classad_shared_ptr<globus_mapping_entry_t> globus_mapping_entry_ptr;
+	typedef HashTable<std::string, globus_mapping_entry_ptr> GlobusMappingTable;
+	static GlobusMappingTable *m_mapping;
+
 };
 
 #endif
diff --git a/src/condor_includes/condor_commands.h b/src/condor_includes/condor_commands.h
index 2c83558..82a76ae 100644
--- a/src/condor_includes/condor_commands.h
+++ b/src/condor_includes/condor_commands.h
@@ -69,7 +69,7 @@ NAMETABLE_DIRECTIVE:TABLE:DCTranslation
 //#define STARTD_INFO			(SCHED_VERS+14)		/* Not used */
 //#define SCHEDD_INFO			(SCHED_VERS+15)		/* Not used */
 #define NEGOTIATE			(SCHED_VERS+16) // 7.5.4+ negotiation command
-#define SEND_JOB_INFO		(SCHED_VERS+17)
+#define SEND_JOB_INFO		(SCHED_VERS+17)     // used in negotiation protocol
 #define NO_MORE_JOBS		(SCHED_VERS+18)		// used in negotiation protocol
 #define JOB_INFO			(SCHED_VERS+19)		// used in negotiation protocol
 //#define GIVE_STATUS			(SCHED_VERS+20)		/* Not used */
@@ -176,6 +176,7 @@ NAMETABLE_DIRECTIVE:TABLE:DCTranslation
 #define QUERY_SCHEDD_HISTORY (SCHED_VERS+115)
 #define QUERY_JOB_ADS (SCHED_VERS+116)
 #define SWAP_CLAIM_AND_ACTIVATION (SCHED_VERS+117) // swap claim & activation between two STARTD resources, for moving a job into a 'transfer' slot.
+#define SEND_RESOURCE_REQUEST_LIST	(SCHED_VERS+118)     // used in negotiation protocol
 
 // values used for "HowFast" in the draining request
 #define DRAIN_GRACEFUL 0
diff --git a/src/condor_includes/condor_cron_job.h b/src/condor_includes/condor_cron_job.h
index e42eddd..7dc1ff9 100644
--- a/src/condor_includes/condor_cron_job.h
+++ b/src/condor_includes/condor_cron_job.h
@@ -60,6 +60,7 @@ class CronJob : public Service
 
 	int ProcessOutputQueue( void );
 	virtual int ProcessOutput( const char * /*line*/ ) { return 0; };
+	virtual int ProcessOutputSep( const char * /*args*/ ) { return 0; };
 
 	// State information
 	CronJobState GetState( void ) const { return m_state; };
diff --git a/src/condor_includes/condor_cron_job_io.h b/src/condor_includes/condor_cron_job_io.h
index e9bc98c..6b933c6 100644
--- a/src/condor_includes/condor_cron_job_io.h
+++ b/src/condor_includes/condor_cron_job_io.h
@@ -46,10 +46,12 @@ class CronJobOut : public CronJobIO
 	virtual ~CronJobOut( void ) {};
 	virtual int Output( const char *buf, int len );
 	int GetQueueSize( void );
+	const char * GetQueueSep( void ) { return m_q_sep.c_str(); }
 	char *GetLineFromQueue( void );
 	int FlushQueue( void );
   private:
 	Queue<char *>	 m_lineq;
+	MyString m_q_sep; // when record separator '-' is read from the stream, this holds that line with the '-'
 };
 
 // Cron's StdErr Line Buffer
diff --git a/src/condor_includes/config.h.cmake b/src/condor_includes/config.h.cmake
index 610d811..b8a26dc 100644
--- a/src/condor_includes/config.h.cmake
+++ b/src/condor_includes/config.h.cmake
@@ -555,6 +555,9 @@
 /* Define to 1 if you have the '_stati64' function. (USED)*/
 #cmakedefine HAVE__STATI64 1
 
+/* Define to 1 if you have the fdatasync function (Linux) */
+#cmakedefine HAVE_FDATASYNC 1
+
 /* Define to 1 if the system has the type '__int64'. (USED)*/
 #cmakedefine HAVE___INT64 1
 
diff --git a/src/condor_includes/daemon_core_sock_adapter.h b/src/condor_includes/daemon_core_sock_adapter.h
deleted file mode 100644
index b35e534..0000000
--- a/src/condor_includes/daemon_core_sock_adapter.h
+++ /dev/null
@@ -1,289 +0,0 @@
-/***************************************************************
- *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
- * University of Wisconsin-Madison, WI.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you
- * may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ***************************************************************/
-
-#ifndef DAEMON_CORE_SOCK_ADAPTER_H
-#define DAEMON_CORE_SOCK_ADAPTER_H
-
-/**
-   This class is used as an indirect way to call daemonCore functions
-   from cedar sock code.  Not all applications that use cedar
-   are linked with DaemonCore (or use the DaemonCore event loop).
-   In such applications, this daemonCore interface class will not
-   be initialized and it is an error if these functions are ever
-   used in such cases.  (They will EXCEPT.)
- */
-
-#include "condor_daemon_core.h"
-
-class DaemonCoreSockAdapterClass {
- public:
-	typedef int (DaemonCore::*Register_Socket_fnptr)(Stream*,const char*,SocketHandlercpp,const char*,Service*,DCpermission,HandlerType,void**);
-	typedef int (DaemonCore::*Cancel_Socket_fnptr)( Stream *sock, void* );
-	typedef void (DaemonCore::*CallSocketHandler_fnptr)( Stream *sock, bool default_to_HandleCommand );
-	typedef int (DaemonCore::*CallCommandHandler_fnptr)( int cmd, Stream *stream, bool delete_stream, bool check_payload, float time_spent_on_sec, float time_spent_waiting_for_payload);
-	typedef void (DaemonCore::*HandleReqAsync_fnptr)(Stream *stream);
-    typedef int (DaemonCore::*Register_DataPtr_fnptr)( void *data );
-    typedef void *(DaemonCore::*GetDataPtr_fnptr)();
-	typedef int (DaemonCore::*Register_Timer_fnptr)(unsigned deltawhen,TimerHandlercpp handler,const char * event_descrip,Service* s);
-	typedef int (DaemonCore::*Register_Timer_TS_fnptr)(unsigned deltawhen,TimerHandlercpp handler,const char * event_descrip,Service* s);
-	typedef int (DaemonCore::*Register_PeriodicTimer_fnptr)(unsigned deltawhen,unsigned period,TimerHandlercpp handler,const char * event_descrip,Service* s);
-	typedef int (DaemonCore::*Cancel_Timer_fnptr)(int id);
-	typedef bool (DaemonCore::*TooManyRegisteredSockets_fnptr)(int fd,MyString *msg,int num_fds);
-	typedef void (DaemonCore::*incrementPendingSockets_fnptr)();
-	typedef void (DaemonCore::*decrementPendingSockets_fnptr)();
-	typedef const char* (DaemonCore::*publicNetworkIpAddr_fnptr)();
-    typedef int (DaemonCore::*Register_Command_fnptr) (
-		int             command,
-		char const*     com_descrip,
-		CommandHandler  handler, 
-		char const*     handler_descrip,
-		Service *       s,
-		DCpermission    perm,
-		int             dprintf_flag,
-		bool            force_authentication,
-		int             wait_for_payload);
-	typedef void (DaemonCore::*daemonContactInfoChanged_fnptr)();
-	typedef bool (DaemonCore::*SocketIsRegistered_fnptr)(Stream*);
-
-
-	DaemonCoreSockAdapterClass(): m_daemonCore(0),
-	m_Register_Socket_fnptr(0),
-	m_Cancel_Socket_fnptr(0),
-	m_CallSocketHandler_fnptr(0),
-	m_CallCommandHandler_fnptr(0),
-	m_HandleReqAsync_fnptr(0),
-	m_Register_DataPtr_fnptr(0),
-	m_GetDataPtr_fnptr(0),
-	m_Register_Timer_fnptr(0),
-	m_Register_PeriodicTimer_fnptr(0),
-	m_Cancel_Timer_fnptr(0),
-	m_TooManyRegisteredSockets_fnptr(0),
-	m_incrementPendingSockets_fnptr(0),
-	m_decrementPendingSockets_fnptr(0),
-	m_publicNetworkIpAddr_fnptr(0),
-	m_Register_Command_fnptr(0),
-	m_daemonContactInfoChanged_fnptr(0),
-	m_Register_Timer_TS_fnptr(0),
-	m_SocketIsRegistered_fnptr(0) {}
-
-	void EnableDaemonCore(
-		DaemonCore *dC,
-		Register_Socket_fnptr in_Register_Socket_fnptr,
-		Cancel_Socket_fnptr in_Cancel_Socket_fnptr,
-		CallSocketHandler_fnptr in_CallSocketHandler_fnptr,
-		CallCommandHandler_fnptr in_CallCommandHandler_fnptr,
-		HandleReqAsync_fnptr in_HandleReqAsync_fnptr,
-		Register_DataPtr_fnptr in_Register_DataPtr_fnptr,
-		GetDataPtr_fnptr in_GetDataPtrFun_fnptr,
-		Register_Timer_fnptr in_Register_Timer_fnptr,
-		Register_PeriodicTimer_fnptr in_Register_PeriodicTimer_fnptr,
-		Cancel_Timer_fnptr in_Cancel_Timer_fnptr,
-		TooManyRegisteredSockets_fnptr in_TooManyRegisteredSockets_fnptr,
-		incrementPendingSockets_fnptr in_incrementPendingSockets_fnptr,
-		decrementPendingSockets_fnptr in_decrementPendingSockets_fnptr,
-		publicNetworkIpAddr_fnptr in_publicNetworkIpAddr_fnptr,
-		Register_Command_fnptr in_Register_Command_fnptr,
-		daemonContactInfoChanged_fnptr in_daemonContactInfoChanged_fnptr,
-		Register_Timer_TS_fnptr in_Register_Timer_TS_fnptr,
-		SocketIsRegistered_fnptr in_SocketIsRegistered_fnptr)
-	{
-		m_daemonCore = dC;
-		m_Register_Socket_fnptr = in_Register_Socket_fnptr;
-		m_Cancel_Socket_fnptr = in_Cancel_Socket_fnptr;
-		m_CallSocketHandler_fnptr = in_CallSocketHandler_fnptr;
-		m_CallCommandHandler_fnptr = in_CallCommandHandler_fnptr;
-		m_HandleReqAsync_fnptr = in_HandleReqAsync_fnptr;
-		m_Register_DataPtr_fnptr = in_Register_DataPtr_fnptr;
-		m_GetDataPtr_fnptr = in_GetDataPtrFun_fnptr;
-		m_Register_Timer_fnptr = in_Register_Timer_fnptr;
-		m_Register_PeriodicTimer_fnptr = in_Register_PeriodicTimer_fnptr;
-		m_Cancel_Timer_fnptr = in_Cancel_Timer_fnptr;
-		m_TooManyRegisteredSockets_fnptr = in_TooManyRegisteredSockets_fnptr;
-		m_incrementPendingSockets_fnptr = in_incrementPendingSockets_fnptr;
-		m_decrementPendingSockets_fnptr = in_decrementPendingSockets_fnptr;
-		m_publicNetworkIpAddr_fnptr = in_publicNetworkIpAddr_fnptr;
-		m_Register_Command_fnptr = in_Register_Command_fnptr;
-		m_daemonContactInfoChanged_fnptr = in_daemonContactInfoChanged_fnptr;
-		m_Register_Timer_TS_fnptr = in_Register_Timer_TS_fnptr;
-		m_SocketIsRegistered_fnptr = in_SocketIsRegistered_fnptr;
-	}
-
-		// These functions all have the same interface as the corresponding
-		// daemonCore functions.
-
-	DaemonCore *m_daemonCore;
-	Register_Socket_fnptr m_Register_Socket_fnptr;
-	Cancel_Socket_fnptr m_Cancel_Socket_fnptr;
-	CallSocketHandler_fnptr m_CallSocketHandler_fnptr;
-	CallCommandHandler_fnptr m_CallCommandHandler_fnptr;
-	HandleReqAsync_fnptr m_HandleReqAsync_fnptr;
-	Register_DataPtr_fnptr m_Register_DataPtr_fnptr;
-	GetDataPtr_fnptr m_GetDataPtr_fnptr;
-	Register_Timer_fnptr m_Register_Timer_fnptr;
-	Register_PeriodicTimer_fnptr m_Register_PeriodicTimer_fnptr;
-	Cancel_Timer_fnptr m_Cancel_Timer_fnptr;
-	TooManyRegisteredSockets_fnptr m_TooManyRegisteredSockets_fnptr;
-	incrementPendingSockets_fnptr m_incrementPendingSockets_fnptr;
-	decrementPendingSockets_fnptr m_decrementPendingSockets_fnptr;
-	publicNetworkIpAddr_fnptr m_publicNetworkIpAddr_fnptr;
-	Register_Command_fnptr m_Register_Command_fnptr;
-	daemonContactInfoChanged_fnptr m_daemonContactInfoChanged_fnptr;
-	Register_Timer_TS_fnptr m_Register_Timer_TS_fnptr;
-	SocketIsRegistered_fnptr m_SocketIsRegistered_fnptr;
-
-    int Register_Socket (Stream*              iosock,
-                         const char *         iosock_descrip,
-                         SocketHandlercpp     handlercpp,
-                         const char *         handler_descrip,
-                         Service*             s,
-                         DCpermission         perm = ALLOW,
-			 HandlerType          handler_type = HANDLE_READ)
-	{
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_Register_Socket_fnptr)(iosock,iosock_descrip,handlercpp,handler_descrip,s,perm, handler_type,NULL);
-	}
-
-	int Cancel_Socket( Stream *stream )
-	{
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_Cancel_Socket_fnptr)(stream, NULL);
-	}
-
-	void CallSocketHandler( Stream *stream, bool default_to_HandleCommand=false )
-	{
-		ASSERT(m_daemonCore);
-		(m_daemonCore->*m_CallSocketHandler_fnptr)(stream,default_to_HandleCommand);
-	}
-
-	int CallCommandHandler( int cmd, Stream *stream, bool delete_stream=true, bool check_payload=true, float time_spent_on_sec=0, float time_spent_waiting_for_payload=0 )
-	{
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_CallCommandHandler_fnptr)(cmd,stream,delete_stream,check_payload,time_spent_on_sec,time_spent_waiting_for_payload);
-	}
-
-	void HandleReqAsync(Stream *stream)
-	{
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_HandleReqAsync_fnptr)(stream);
-	}
-
-
-    int Register_DataPtr( void *data )
-	{
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_Register_DataPtr_fnptr)(data);
-	}
-    void *GetDataPtr()
-	{
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_GetDataPtr_fnptr)();
-	}
-    int Register_Timer (unsigned     deltawhen,
-                        TimerHandlercpp handler,
-                        const char * event_descrip, 
-                        Service*     s = NULL)
-	{
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_Register_Timer_fnptr)(
-			deltawhen,
-			handler,
-			event_descrip,
-			s);
-	}
-    int Register_Timer (unsigned     deltawhen,
-						unsigned     period,
-                        TimerHandlercpp handler,
-                        const char * event_descrip, 
-                        Service*     s = NULL)
-	{
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_Register_PeriodicTimer_fnptr)(
-			deltawhen,
-			period,
-			handler,
-			event_descrip,
-			s);
-	}
-    int Cancel_Timer (int id)
-	{
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_Cancel_Timer_fnptr)( id );
-	}
-	bool TooManyRegisteredSockets(int fd=-1,MyString *msg=NULL,int num_fds=1)
-	{
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_TooManyRegisteredSockets_fnptr)(fd,msg,num_fds);
-	}
-
-	bool isEnabled()
-	{
-		return m_daemonCore != NULL;
-	}
-
-	void incrementPendingSockets() {
-		ASSERT(m_daemonCore);
-		(m_daemonCore->*m_incrementPendingSockets_fnptr)();
-	}
-
-	void decrementPendingSockets() {
-		ASSERT(m_daemonCore);
-		(m_daemonCore->*m_decrementPendingSockets_fnptr)();
-	}
-
-	const char* publicNetworkIpAddr(void) {
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_publicNetworkIpAddr_fnptr)();
-	}
-
-    int Register_Command (int             command,
-                          char const*     com_descrip,
-                          CommandHandler  handler, 
-                          char const*     handler_descrip,
-                          Service *       s                = NULL,
-                          DCpermission    perm             = ALLOW,
-                          int             dprintf_flag     = D_COMMAND,
-						  bool            force_authentication = false,
-						  int             wait_for_payload = 0)
-	{
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_Register_Command_fnptr)(command,com_descrip,handler,handler_descrip,s,perm,dprintf_flag,force_authentication,wait_for_payload);
-	}
-
-	void daemonContactInfoChanged() {
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_daemonContactInfoChanged_fnptr)();
-	}
-
-	int Register_Timer_TS(unsigned deltawhen, TimerHandlercpp handler,
-				const char *event_descrip, Service* s)
-	{
-		ASSERT(m_daemonCore);
-		return (m_daemonCore->*m_Register_Timer_TS_fnptr)(deltawhen, handler, event_descrip, s);
-	}
-
-	bool SocketIsRegistered (Stream* s)
-	{
-		ASSERT(m_SocketIsRegistered_fnptr);
-		return (m_daemonCore->*m_SocketIsRegistered_fnptr)(s);
-	}
-};
-
-extern DaemonCoreSockAdapterClass daemonCoreSockAdapter;
-
-#endif
diff --git a/src/condor_includes/named_classad_list.h b/src/condor_includes/named_classad_list.h
index 46e94cb..72a63d1 100644
--- a/src/condor_includes/named_classad_list.h
+++ b/src/condor_includes/named_classad_list.h
@@ -45,6 +45,7 @@ class NamedClassAdList
 	int	Publish( ClassAd *ad );
 
   protected:
+	virtual NamedClassAd * New( const char *name, ClassAd *ad = NULL ) { return new NamedClassAd(name, ad); }
 	std::list<NamedClassAd*>		m_ads;
 
 };
diff --git a/src/condor_io/cedar_no_ckpt.cpp b/src/condor_io/cedar_no_ckpt.cpp
index c855dd5..0511339 100644
--- a/src/condor_io/cedar_no_ckpt.cpp
+++ b/src/condor_io/cedar_no_ckpt.cpp
@@ -40,7 +40,6 @@
 #include "ccb_client.h"
 #include "condor_sinful.h"
 #include "shared_port_client.h"
-#include "daemon_core_sock_adapter.h"
 #include "condor_netdb.h"
 #include "internet.h"
 #include "ipv6_hostname.h"
@@ -273,7 +272,7 @@ ReliSock::get_file( filesize_t *size, int fd,
 	}
 
 	if (flush_buffers && fd != GET_FILE_NULL_FD ) {
-		if (condor_fsync(fd) < 0) {
+		if (condor_fdatasync(fd) < 0) {
 			dprintf(D_ALWAYS, "get_file(): ERROR on fsync: %d\n", errno);
 			return -1;
 		}
@@ -714,7 +713,7 @@ ReliSock::get_x509_delegation( filesize_t *size, const char *destination,
 		if ( fd < 0 ) {
 			rc = fd;
 		} else {
-			rc = condor_fsync( fd, destination );
+			rc = condor_fdatasync( fd, destination );
 			::close( fd );
 		}
 		if ( rc < 0 ) {
@@ -886,8 +885,8 @@ int Sock::special_connect(char const *host,int /*port*/,bool nonblocking)
 		}
 
 		bool i_am_shared_port_server = false;
-		if( daemonCoreSockAdapter.isEnabled() ) {
-			char const *daemon_addr = daemonCoreSockAdapter.publicNetworkIpAddr();
+		if( daemonCore ) {
+			char const *daemon_addr = daemonCore->publicNetworkIpAddr();
 			if( daemon_addr ) {
 				Sinful my_sinful(daemon_addr);
 				if( my_sinful.getHost() && sinful.getHost() &&
diff --git a/src/condor_io/condor_auth_ssl.cpp b/src/condor_io/condor_auth_ssl.cpp
index 50c0220..46e502d 100644
--- a/src/condor_io/condor_auth_ssl.cpp
+++ b/src/condor_io/condor_auth_ssl.cpp
@@ -27,7 +27,6 @@
 #include "condor_string.h"
 #include "condor_environ.h"
 #include "CondorError.h"
-#include "get_full_hostname.h"
 #include "openssl/rand.h"
 #include "condor_netdb.h"
 
diff --git a/src/condor_io/condor_auth_x509.cpp b/src/condor_io/condor_auth_x509.cpp
index 3eb74c1..8cbbdf3 100644
--- a/src/condor_io/condor_auth_x509.cpp
+++ b/src/condor_io/condor_auth_x509.cpp
@@ -51,6 +51,13 @@ HashTable<MyString, MyString> * Condor_Auth_X509::GridMap = 0;
 
 bool Condor_Auth_X509::m_globusActivated = false;
 
+unsigned int hashFuncString( const std::string &key )
+{
+	return hashFuncChars(key.c_str());
+}
+
+Condor_Auth_X509::GlobusMappingTable *Condor_Auth_X509::m_mapping = NULL;
+
 //----------------------------------------------------------------------
 // Implementation
 //----------------------------------------------------------------------
@@ -469,7 +476,7 @@ int Condor_Auth_X509::nameGssToLocal(const char * GSSClientname)
 {
 	//this might need to change with SSLK5 stuff
 	//just extract username from /CN=<username>@<domain,etc>
-	OM_uint32 major_status;
+	OM_uint32 major_status = GSS_S_COMPLETE;
 	char *tmp_user = NULL;
 	char local_user[USER_NAME_MAX];
 
@@ -480,32 +487,73 @@ int Condor_Auth_X509::nameGssToLocal(const char * GSSClientname)
 #else
 // Switched the unix map function to _map_and_authorize, which allows access
 // to the Globus callout infrastructure.
-        char condor_str[] = "condor";
-	major_status = globus_gss_assist_map_and_authorize(
-            context_handle,
-            condor_str, // Requested service name
-            NULL, // Requested user name; NULL for non-specified
-            local_user,
-            USER_NAME_MAX-1); // Leave one space at end of buffer, just-in-case
-        // Defensive programming: to protect against buffer overruns in the
-        // unknown globus mapping module, make sure we are at least nul-term'd
-        local_user[USER_NAME_MAX-1] = '\0';
-
-	// More defensive programming: There is a bug in LCMAPS, (which is possibly
-	// called by a globus callout) that sometimes returns with the euid set to
-	// root (!?!).  As a safeguard, We check for that here and return to the
-	// condor euid.  This is done "outside" of the condor priv stack since this
-	// is essentially undoing a side effect of the library call, not
-	// intentionally changing priv state.
-	if (geteuid() == 0) {
-		dprintf(D_ALWAYS, "WARNING: globus returned with euid 0\n");
-		// attempt to undo
-		if (seteuid(get_condor_uid())) {
-			// complain loudly, but continue
-			dprintf(D_ALWAYS, "ERROR: something has gone terribly wrong: errno %i\n", errno);
+
+	if (m_mapping == NULL) {
+		// Size of hash table is purposely initialized small to prevent this
+		// from hogging memory.  This will, of course, grow at large sites.
+		m_mapping = new GlobusMappingTable(53, hashFuncString, updateDuplicateKeys);
+	}
+	const char *auth_name_to_map;
+	const char *fqan = getFQAN();
+	if (fqan && fqan[0]) {
+		auth_name_to_map = fqan;
+	}
+	else {
+		auth_name_to_map = GSSClientname;
+	}
+
+	globus_mapping_entry_ptr value;
+	time_t now = 0;
+	time_t gsi_cache_expiry = param_integer("GSS_ASSIST_GRIDMAP_CACHE_EXPIRATION", 0);
+	if (gsi_cache_expiry && (m_mapping->lookup(auth_name_to_map, value) == 0)) {
+		now = time(NULL);
+		if (now < value->expiry_time) {
+			dprintf(D_SECURITY, "Using Globus mapping result from the cache.\n");
+			if (value->name.size()) {
+				tmp_user = strdup(value->name.c_str());
+			}
+			else {
+				major_status = GSS_S_FAILURE;
+			}
 		}
 	}
 
+	if ((tmp_user == NULL) && (major_status == GSS_S_COMPLETE)) {
+		char condor_str[] = "condor";
+		major_status = globus_gss_assist_map_and_authorize(
+			context_handle,
+			condor_str, // Requested service name
+			NULL, // Requested user name; NULL for non-specified
+			local_user,
+			USER_NAME_MAX-1); // Leave one space at end of buffer, just-in-case
+		// Defensive programming: to protect against buffer overruns in the
+		// unknown globus mapping module, make sure we are at least nul-term'd
+		local_user[USER_NAME_MAX-1] = '\0';
+
+		// More defensive programming: There is a bug in LCMAPS, (which is possibly
+		// called by a globus callout) that sometimes returns with the euid set to
+		// root (!?!).  As a safeguard, We check for that here and return to the
+		// condor euid.  This is done "outside" of the condor priv stack since this
+		// is essentially undoing a side effect of the library call, not
+		// intentionally changing priv state.
+		if (geteuid() == 0) {
+			dprintf(D_ALWAYS, "WARNING: globus returned with euid 0\n");
+			// attempt to undo
+			if (seteuid(get_condor_uid())) {
+				// complain loudly, but continue
+				dprintf(D_ALWAYS, "ERROR: something has gone terribly wrong: errno %i\n", errno);
+			}
+		}
+
+		if (now == 0) { now = time(NULL); }
+		value.reset(new globus_mapping_entry_t);
+		value->expiry_time = now + gsi_cache_expiry;
+		// The special name of "" indicates failed mapping.
+		if (major_status == GSS_S_COMPLETE) {
+			value->name = local_user;
+		}
+		m_mapping->insert(auth_name_to_map, value);
+	}
 #endif
 
 	if (tmp_user) {
diff --git a/src/condor_io/condor_secman.cpp b/src/condor_io/condor_secman.cpp
index 75eb6fa..82b0c88 100644
--- a/src/condor_io/condor_secman.cpp
+++ b/src/condor_io/condor_secman.cpp
@@ -38,7 +38,6 @@
 #include "condor_secman.h"
 #include "classad_merge.h"
 #include "daemon.h"
-#include "daemon_core_sock_adapter.h"
 #include "subsystem_info.h"
 #include "setenv.h"
 #include "ipv6_hostname.h"
@@ -904,7 +903,7 @@ class SecManStartCommand: Service, public ClassyCountedPtr {
 	~SecManStartCommand() {
 		if( m_pending_socket_registered ) {
 			m_pending_socket_registered = false;
-			daemonCoreSockAdapter.decrementPendingSockets();
+			daemonCore->decrementPendingSockets();
 		}
 		if( m_private_key ) {
 			delete m_private_key;
@@ -928,7 +927,7 @@ class SecManStartCommand: Service, public ClassyCountedPtr {
 			// case automatically.
 		if( !m_pending_socket_registered ) {
 			m_pending_socket_registered = true;
-			daemonCoreSockAdapter.incrementPendingSockets();
+			daemonCore->incrementPendingSockets();
 		}
 	}
 
@@ -2302,7 +2301,7 @@ SecManStartCommand::WaitForSocketCallback()
 	MyString req_description;
 	req_description.formatstr("SecManStartCommand::WaitForSocketCallback %s",
 							m_cmd_description.Value());
-	int reg_rc = daemonCoreSockAdapter.Register_Socket(
+	int reg_rc = daemonCore->Register_Socket(
 		m_sock,
 		m_sock->peer_description(),
 		(SocketHandlercpp)&SecManStartCommand::SocketCallback,
@@ -2333,7 +2332,7 @@ SecManStartCommand::WaitForSocketCallback()
 int
 SecManStartCommand::SocketCallback( Stream *stream )
 {
-	daemonCoreSockAdapter.Cancel_Socket( stream );
+	daemonCore->Cancel_Socket( stream );
 
 		// NOTE: startCommand_inner() is responsible for checking
 		// if our deadline had expired.
@@ -2981,6 +2980,31 @@ SecMan::CreateNonNegotiatedSecuritySession(DCpermission auth_level, char const *
 	dprintf(D_SECURITY, "SECMAN: created non-negotiated security session %s for %d %sseconds."
 			"\n", sesid, duration, expiration_time == 0 ? "(inf) " : "");
 
+	// now add entrys which map all the {<sinful_string>,<command>} pairs
+	// to the same key id (which is in the variable sesid)
+	dprintf(D_SECURITY, "SECMAN: now creating non-negotiated command mappings\n");
+
+	MyString valid_coms;
+	policy.LookupString(ATTR_SEC_VALID_COMMANDS, valid_coms);
+	StringList coms(valid_coms.Value());
+	char *p;
+
+	coms.rewind();
+	while ( (p = coms.next()) ) {
+		MyString keybuf;
+		keybuf.formatstr ("{%s,<%s>}", peer_sinful, p);
+
+		// NOTE: HashTable returns ZERO on SUCCESS!!!
+		if (command_map->insert(keybuf, sesid) == 0) {
+			// success
+			if (IsDebugVerbose(D_SECURITY)) {
+				dprintf (D_SECURITY, "SECMAN: command %s mapped to session %s.\n", keybuf.Value(), sesid);
+			}
+		} else {
+			dprintf (D_ALWAYS, "SECMAN: command %s NOT mapped (insert failed!)\n", keybuf.Value());
+		}
+	}
+
 	if( IsDebugVerbose(D_SECURITY) ) {
 		if( exported_session_info ) {
 			dprintf(D_SECURITY,"Imported session attributes: %s\n",
@@ -3037,6 +3061,7 @@ SecMan::ImportSecSessionInfo(char const *session_info,ClassAd &policy) {
 	sec_copy_attribute(policy,imp_policy,ATTR_SEC_ENCRYPTION);
 	sec_copy_attribute(policy,imp_policy,ATTR_SEC_CRYPTO_METHODS);
 	sec_copy_attribute(policy,imp_policy,ATTR_SEC_SESSION_EXPIRES);
+	sec_copy_attribute(policy,imp_policy,ATTR_SEC_VALID_COMMANDS);
 
 	return true;
 }
@@ -3059,6 +3084,7 @@ SecMan::ExportSecSessionInfo(char const *session_id,MyString &session_info) {
 	sec_copy_attribute(exp_policy,*policy,ATTR_SEC_ENCRYPTION);
 	sec_copy_attribute(exp_policy,*policy,ATTR_SEC_CRYPTO_METHODS);
 	sec_copy_attribute(exp_policy,*policy,ATTR_SEC_SESSION_EXPIRES);
+	sec_copy_attribute(exp_policy,*policy,ATTR_SEC_VALID_COMMANDS);
 
 	session_info += "[";
 	exp_policy.ResetExpr();
diff --git a/src/condor_io/shared_port_client.cpp b/src/condor_io/shared_port_client.cpp
index 2b2bde7..f5bfbb6 100644
--- a/src/condor_io/shared_port_client.cpp
+++ b/src/condor_io/shared_port_client.cpp
@@ -20,7 +20,6 @@
 #include "condor_common.h"
 #include "condor_config.h"
 #include "../condor_daemon_core.V6/condor_daemon_core.h"
-#include "daemon_core_sock_adapter.h"
 #include "subsystem_info.h"
 #include "shared_port_client.h"
 #include "shared_port_endpoint.h"
@@ -151,9 +150,9 @@ SharedPortClient::myName()
 	// It is who we say we are when talking to the shared port server.
 	MyString name;
 	name = get_mySubSystem()->getName();
-	if( daemonCoreSockAdapter.isEnabled() ) {
+	if( daemonCore ) {
 		name += " ";
-		name += daemonCoreSockAdapter.publicNetworkIpAddr();
+		name += daemonCore->publicNetworkIpAddr();
 	}
 	return name;
 }
@@ -379,8 +378,8 @@ SharedPortState::Handle(Stream *s)
 			result = FAILED;
 		}
 	}
-	if (result == WAIT && !daemonCoreSockAdapter.SocketIsRegistered(s)) {
-		int reg_rc = daemonCoreSockAdapter.Register_Socket(
+	if (result == WAIT && !daemonCore->SocketIsRegistered(s)) {
+		int reg_rc = daemonCore->Register_Socket(
 			s,
 			m_requested_by.c_str(),
 			(SocketHandlercpp)&SharedPortState::Handle,
@@ -407,7 +406,7 @@ SharedPortState::Handle(Stream *s)
 
 	// If we are done, clean up and dellocate
 	if (result == DONE || result == FAILED) {
-		if ((s) && (m_state != RECV_RESP || !m_non_blocking || !daemonCoreSockAdapter.SocketIsRegistered(s))) {
+		if ((s) && (m_state != RECV_RESP || !m_non_blocking || !daemonCore->SocketIsRegistered(s))) {
 			delete s;
 		}
 		delete this;
diff --git a/src/condor_io/shared_port_endpoint.cpp b/src/condor_io/shared_port_endpoint.cpp
index 5b19178..87a0109 100644
--- a/src/condor_io/shared_port_endpoint.cpp
+++ b/src/condor_io/shared_port_endpoint.cpp
@@ -22,7 +22,6 @@
 #include "shared_port_endpoint.h"
 #include "subsystem_info.h"
 #include "../condor_daemon_core.V6/condor_daemon_core.h"
-#include "daemon_core_sock_adapter.h"
 #include "counted_ptr.h"
 #include "basename.h"
 
@@ -213,8 +212,8 @@ SharedPortEndpoint::StopListener()
 		DeleteCriticalSection(&received_lock);
 	}
 #else
-	if( m_registered_listener && daemonCoreSockAdapter.isEnabled() ) {
-		daemonCoreSockAdapter.Cancel_Socket( &m_listener_sock );
+	if( m_registered_listener && daemonCore ) {
+		daemonCore->Cancel_Socket( &m_listener_sock );
 	}
 	m_listener_sock.close();
 	if( !m_full_name.IsEmpty() ) {
@@ -222,7 +221,7 @@ SharedPortEndpoint::StopListener()
 	}
 
 	if( m_retry_remote_addr_timer != -1 ) {
-		daemonCoreSockAdapter.Cancel_Timer( m_retry_remote_addr_timer );
+		daemonCore->Cancel_Timer( m_retry_remote_addr_timer );
 		m_retry_remote_addr_timer = -1;
 	}
 #endif
@@ -378,10 +377,10 @@ SharedPortEndpoint::StartListener()
 
 	return StartListenerWin32();
 #else
-	ASSERT( daemonCoreSockAdapter.isEnabled() );
+	ASSERT( daemonCore );
 
 	int rc;
-	rc = daemonCoreSockAdapter.Register_Socket(
+	rc = daemonCore->Register_Socket(
 		&m_listener_sock,
 		m_full_name.Value(),
 		(SocketHandlercpp)&SharedPortEndpoint::HandleListenerAccept,
@@ -395,7 +394,7 @@ SharedPortEndpoint::StartListener()
 			// from removing it (and to prevent tmpwatch accidents).
 		const int socket_check_interval = TouchSocketInterval();
 		int fuzz = timer_fuzz(socket_check_interval);
-		m_socket_check_timer = daemonCoreSockAdapter.Register_Timer(
+		m_socket_check_timer = daemonCore->Register_Timer(
 			socket_check_interval + fuzz,
 			socket_check_interval + fuzz,
 			(TimerHandlercpp)&SharedPortEndpoint::SocketCheck,
@@ -563,7 +562,7 @@ SharedPortEndpoint::PipeListenerThread()
 			if(!wake_select_dest)
 			{
 //				dprintf(D_ALWAYS, "SharedPortEndpoint: Registering timer.\n");
-				int status = daemonCoreSockAdapter.Register_Timer_TS(0, (TimerHandlercpp)&SharedPortEndpoint::PipeListenerHelper, "Received socket handler", this);
+				int status = daemonCore->Register_Timer_TS(0, (TimerHandlercpp)&SharedPortEndpoint::PipeListenerHelper, "Received socket handler", this);
 //				dprintf(D_ALWAYS, "SharedPortEndpoint: Timer registration status: %d\n", status);
 			}
 			else
@@ -723,12 +722,12 @@ SharedPortEndpoint::RetryInitRemoteAddress()
 			// Now set up a timer to periodically check for changes
 			// in SharedPortServer's address.
 
-		if( daemonCoreSockAdapter.isEnabled() ) {
+		if( daemonCore ) {
 				// Randomize time a bit so many daemons are unlikely to
 				// do it all at once.
 			int fuzz = timer_fuzz(remote_addr_retry_time);
 
-			m_retry_remote_addr_timer = daemonCoreSockAdapter.Register_Timer(
+			m_retry_remote_addr_timer = daemonCore->Register_Timer(
 				remote_addr_refresh_time + fuzz,
 				(TimerHandlercpp)&SharedPortEndpoint::RetryInitRemoteAddress,
 				"SharedPortEndpoint::RetryInitRemoteAddress",
@@ -740,19 +739,19 @@ SharedPortEndpoint::RetryInitRemoteAddress()
 					// for daemonCore's command socket.  If that isn't
 					// true, we may inform daemonCore more frequently
 					// than necessary, which isn't the end of the world.
-				daemonCoreSockAdapter.daemonContactInfoChanged();
+				daemonCore->daemonContactInfoChanged();
 			}
 		}
 
 		return;
 	}
 
-	if( daemonCoreSockAdapter.isEnabled() ) {
+	if( daemonCore ) {
 		dprintf(D_ALWAYS,
 			"SharedPortEndpoint: did not successfully find SharedPortServer address."
 			" Will retry in %ds.\n",remote_addr_retry_time);
 
-		m_retry_remote_addr_timer = daemonCoreSockAdapter.Register_Timer(
+		m_retry_remote_addr_timer = daemonCore->Register_Timer(
 			remote_addr_retry_time,
 			(TimerHandlercpp)&SharedPortEndpoint::RetryInitRemoteAddress,
 			"SharedPortEndpoint::RetryInitRemoteAddress",
@@ -773,9 +772,9 @@ SharedPortEndpoint::ClearSharedPortServerAddr()
 void
 SharedPortEndpoint::ReloadSharedPortServerAddr()
 {
-	if( daemonCoreSockAdapter.isEnabled() ) {
+	if( daemonCore ) {
 		if( m_retry_remote_addr_timer != -1 ) {
-			daemonCoreSockAdapter.Cancel_Timer( m_retry_remote_addr_timer );
+			daemonCore->Cancel_Timer( m_retry_remote_addr_timer );
 			m_retry_remote_addr_timer = -1;
 		}
 	}
@@ -854,7 +853,7 @@ SharedPortEndpoint::DoListenerAccept(ReliSock *return_remote_sock)
 		remote_sock->enter_connected_state();
 		remote_sock->isClient(false);
 		if(!return_remote_sock)
-			daemonCoreSockAdapter.HandleReqAsync(remote_sock);
+			daemonCore->HandleReqAsync(remote_sock);
 		HeapFree(GetProcessHeap(), NULL, received_socket);
 	}
 	else
@@ -1018,8 +1017,8 @@ SharedPortEndpoint::ReceiveSocket( ReliSock *named_sock, ReliSock *return_remote
 
 
 	if( !return_remote_sock ) {
-		ASSERT( daemonCoreSockAdapter.isEnabled() );
-		daemonCoreSockAdapter.HandleReqAsync(remote_sock);
+		ASSERT( daemonCore );
+		daemonCore->HandleReqAsync(remote_sock);
 		remote_sock = NULL; // daemonCore took ownership of remote_sock
 	}
 	free(buf);
@@ -1080,7 +1079,7 @@ SharedPortEndpoint::deserialize(char *inherit_buf)
 	*/
 	sscanf_s(inherit_buf, "%d", (int*)&pipe_end);
 
-	//m_pipe_out = daemonCoreSockAdapter.Inherit_Pipe_Handle(out_pipe, false, true, true, 4096);
+	//m_pipe_out = daemonCore->Inherit_Pipe_Handle(out_pipe, false, true, true, 4096);
 #else
 	inherit_buf = m_listener_sock.serialize(inherit_buf);
 #endif
diff --git a/src/condor_io/sock.cpp b/src/condor_io/sock.cpp
index 6e0be01..9255987 100644
--- a/src/condor_io/sock.cpp
+++ b/src/condor_io/sock.cpp
@@ -34,12 +34,12 @@
 #include "condor_debug.h"
 #include "get_port_range.h"
 #include "condor_netdb.h"
-#include "daemon_core_sock_adapter.h"
 #include "selector.h"
 #include "authentication.h"
 #include "condor_sockfunc.h"
 #include "condor_ipv6.h"
 #include "condor_config.h"
+#include "condor_sinful.h"
 
 #if defined(WIN32)
 // <winsock2.h> already included...
@@ -66,8 +66,6 @@ void dprintf ( int flags, Sock & sock, const char *fmt, ... )
     va_end( args );
 }
 
-DaemonCoreSockAdapterClass daemonCoreSockAdapter;
-
 unsigned int Sock::m_nextUniqueId = 1;
 
 Sock::Sock() : Stream() {
diff --git a/src/condor_master.V6/masterDaemon.cpp b/src/condor_master.V6/masterDaemon.cpp
index 2291477..5e59c01 100644
--- a/src/condor_master.V6/masterDaemon.cpp
+++ b/src/condor_master.V6/masterDaemon.cpp
@@ -2752,9 +2752,11 @@ Daemons::UpdateCollector()
 #endif
 #endif
 
+	if ( FILEObj ) {
 		// log classad into sql log so that it can be updated to DB
-	FILESQL::daemonAdInsert(ad, "MasterAd", FILEObj, prevLHF);
-	
+		FILESQL::daemonAdInsert(ad, "MasterAd", FILEObj, prevLHF);
+	}
+
 		// Reset the timer so we don't do another period update until 
 	daemonCore->Reset_Timer( update_tid, update_interval, update_interval );
 
diff --git a/src/condor_negotiator.V6/matchmaker.cpp b/src/condor_negotiator.V6/matchmaker.cpp
index 5dc0350..8c8d640 100644
--- a/src/condor_negotiator.V6/matchmaker.cpp
+++ b/src/condor_negotiator.V6/matchmaker.cpp
@@ -906,7 +906,7 @@ GET_PRIORITY_commandHandler (int, Stream *strm)
 	dprintf (D_ALWAYS,"Getting state information from the accountant\n");
 	AttrList* ad=accountant.ReportState();
 	
-	if (!putClassAdNoTypes(strm, *ad) ||
+	if (!putClassAd(strm, *ad, PUT_CLASSAD_NO_TYPES) ||
 	    !strm->end_of_message())
 	{
 		dprintf (D_ALWAYS, "Could not send priority information\n");
@@ -932,7 +932,7 @@ GET_PRIORITY_ROLLUP_commandHandler(int, Stream *strm) {
     dprintf(D_ALWAYS, "Getting state information from the accountant\n");
     AttrList* ad = accountant.ReportState(true);
 
-    if (!putClassAdNoTypes(strm, *ad) ||
+    if (!putClassAd(strm, *ad, PUT_CLASSAD_NO_TYPES) ||
         !strm->end_of_message()) {
         dprintf (D_ALWAYS, "Could not send priority information\n");
         delete ad;
@@ -964,7 +964,7 @@ GET_RESLIST_commandHandler (int, Stream *strm)
 	AttrList* ad=accountant.ReportState(submitter);
 	dprintf (D_ALWAYS,"Getting state information from the accountant\n");
 	
-	if (!putClassAdNoTypes(strm, *ad) ||
+	if (!putClassAd(strm, *ad, PUT_CLASSAD_NO_TYPES) ||
 	    !strm->end_of_message())
 	{
 		dprintf (D_ALWAYS, "Could not send resource list\n");
@@ -2607,16 +2607,6 @@ negotiateWithGroup ( int untrimmed_num_startds,
 				dprintf(D_ALWAYS, "%d seconds so far\n", totalTime);
 			}
 
-			// store the verison of the schedd, so we can take advantage of
-			// protocol improvements in newer versions while still being
-			// backwards compatible.
-			char *schedd_ver_string = NULL;
-			schedd->LookupString(ATTR_VERSION, &schedd_ver_string);
-			ASSERT(schedd_ver_string);
-			CondorVersionInfo	scheddVersion(schedd_ver_string);
-			free(schedd_ver_string);
-			schedd_ver_string = NULL;
-
 			double submitterLimit = 0.0;
             double submitterLimitUnclaimed = 0.0;
 			double submitterUsage = 0.0;
@@ -3436,15 +3426,11 @@ negotiate(char const* groupName, char const *scheddName, const ClassAd *scheddAd
 		   int& numMatched, double &pieLeft)
 {
 	ReliSock	*sock;
-	int			reply;
-	int			cluster, proc;
+	int			cluster, proc, autocluster;
 	int			result;
 	time_t		currentTime;
 	time_t		beginTime = time(NULL);
 	ClassAd		request;
-	ClassAd     cached_resource_request;
-	int			resource_request_count = 0;  // how many resources desired in resource request
-	int			resource_request_offers = 0; // how many resources offered on behalf of this request
 	ClassAd*    offer = NULL;
 	bool		only_consider_startd_rank = false;
 	bool		display_overlimit = true;
@@ -3462,6 +3448,22 @@ negotiate(char const* groupName, char const *scheddName, const ClassAd *scheddAd
 		negotiate_cmd = NEGOTIATE_WITH_SIGATTRS;
 	}
 
+	// fetch the verison of the schedd, so we can take advantage of
+	// protocol improvements in newer versions while still being
+	// backwards compatible.  
+	MyString schedd_version_string;
+	scheddAd->LookupString(ATTR_VERSION,schedd_version_string);	
+	// from the version of the schedd, figure out the version of the negotiate 
+	// protocol supported.
+	int schedd_negotiate_protocol_version = 0; 
+	if ( !schedd_version_string.empty() ) {
+		CondorVersionInfo	scheddVersion(schedd_version_string.Value());
+		if ( scheddVersion.built_since_version(8,3,0) ) {
+			// resource request lists supported...
+			schedd_negotiate_protocol_version = 1;
+		}
+	}
+
 	// Because of CCB, we may end up contacting a different
 	// address than scheddAddr!  This is used for logging (to identify
 	// the schedd) and to uniquely identify the host in the socketCache.
@@ -3574,9 +3576,9 @@ negotiate(char const* groupName, char const *scheddName, const ClassAd *scheddAd
 		sockCache->invalidateSock(scheddAddr.Value());
 		return MM_ERROR;
 	}
-
 	
 	// 2.  negotiation loop with schedd
+	ResourceRequestList request_list(schedd_negotiate_protocol_version);  
 	for (numMatched=0;true;numMatched++)
 	{
 		// Service any interactive commands on our command socket.
@@ -3621,102 +3623,32 @@ negotiate(char const* groupName, char const *scheddName, const ClassAd *scheddAd
 
 
 		// 2a.  ask for job information
-		if ( resource_request_count > ++resource_request_offers ) {
-			// no need to go to the schedd to ask for another resource request,
-			// since we have not yet handed out the number of requested matches
-			// for the request we already have cached.
-			request = cached_resource_request;
-		} else {
-			// need to go over the wire and ask the schedd for the request
-			int sleepy = param_integer("NEG_SLEEP", 0);
-				//  This sleep is useful for any testing that calls for a
-				//  long negotiation cycle, please do not remove
-				//  it. Examples of such testing are the async negotiation
-				//  protocol w/ schedds and reconfig delaying until after
-				//  a negotiation cycle. -matt 21 mar 2012
-			if ( sleepy ) {
-				dprintf(D_ALWAYS, "begin sleep: %d seconds\n", sleepy);
-				sleep(sleepy); // TODD DEBUG - allow schedd to do other things
-				dprintf(D_ALWAYS, "end sleep: %d seconds\n", sleepy);
-			}
-			dprintf (D_FULLDEBUG, "    Sending SEND_JOB_INFO/eom\n");
-			sock->encode();
-			if (!sock->put(SEND_JOB_INFO) || !sock->end_of_message())
-			{
-				dprintf (D_ALWAYS, "    Failed to send SEND_JOB_INFO/eom\n");
-				sockCache->invalidateSock(scheddAddr.Value());
-				return MM_ERROR;
-			}
-
-			// 2b.  the schedd may either reply with JOB_INFO or NO_MORE_JOBS
-			dprintf (D_FULLDEBUG, "    Getting reply from schedd ...\n");
-			sock->decode();
-			if (!sock->get (reply))
-			{
-				dprintf (D_ALWAYS, "    Failed to get reply from schedd\n");
-				sock->end_of_message ();
-				sockCache->invalidateSock(scheddAddr.Value());
-				return MM_ERROR;
-			}
-
-			// 2c.  if the schedd replied with NO_MORE_JOBS, cleanup and quit
-			if (reply == NO_MORE_JOBS)
-			{
-				dprintf (D_ALWAYS, "    Got NO_MORE_JOBS;  done negotiating\n");
-				sock->end_of_message ();
-					// If we have negotiated above our submitterLimit, we have only
-					// considered matching if the offer strictly prefers the request.
-					// So in this case, return MM_RESUME since there still may be
-					// jobs which the schedd wants scheduled but have not been considered
-					// as candidates for no preemption or user priority preemption.
-					// Also, if we were limited by submitterLimit, resume
-					// in the next spin of the pie, because our limit might
-					// increase.
-				if( limitUsed >= submitterLimit || limited_by_submitterLimit ) {
-					return MM_RESUME;
-				} else {
-					return MM_DONE;
-				}
-			}
-			else
-			if (reply != JOB_INFO)
-			{
-				// something goofy
-				dprintf(D_ALWAYS,"    Got illegal command %d from schedd\n",reply);
-				sock->end_of_message ();
-				sockCache->invalidateSock(scheddAddr.Value());
-				return MM_ERROR;
-			}
-
-			// 2d.  get the request
-			dprintf (D_FULLDEBUG,"    Got JOB_INFO command; getting classad/eom\n");
-			if (!getClassAd(sock, request) || !sock->end_of_message())
-			{
-				dprintf(D_ALWAYS, "    JOB_INFO command not followed by ad/eom\n");
-				sock->end_of_message();
+		if ( !request_list.getRequest(request,cluster,proc,autocluster,sock) ) {
+			// Failed to get a request.  Check to see if it is because
+			// of an error talking to the schedd.
+			if ( request_list.hadError() ) {
+				// note: error message already dprintf-ed 
 				sockCache->invalidateSock(scheddAddr.Value());
 				return MM_ERROR;
+			} 
+			// Failed to get a request, and no error occured.  
+			// If we have negotiated above our submitterLimit, we have only
+			// considered matching if the offer strictly prefers the request.
+			// So in this case, return MM_RESUME since there still may be
+			// jobs which the schedd wants scheduled but have not been considered
+			// as candidates for no preemption or user priority preemption.
+			// Also, if we were limited by submitterLimit, resume
+			// in the next spin of the pie, because our limit might
+			// increase.
+			if( limitUsed >= submitterLimit || limited_by_submitterLimit ) {
+				return MM_RESUME;
+			} else {
+				return MM_DONE;
 			}
-			if (!request.LookupInteger (ATTR_CLUSTER_ID, cluster) ||
-				!request.LookupInteger (ATTR_PROC_ID, proc))
-			{
-				dprintf (D_ALWAYS, "    Could not get %s and %s from request\n",
-						ATTR_CLUSTER_ID, ATTR_PROC_ID);
-				sockCache->invalidateSock( scheddAddr.Value() );
-				return MM_ERROR;
-			}
-			resource_request_offers = 0;
-			resource_request_count = 0;
-			if ( param_boolean("USE_RESOURCE_REQUEST_COUNTS",true) ) {
-				request.LookupInteger(ATTR_RESOURCE_REQUEST_COUNT,resource_request_count);
-				if (resource_request_count > 0) {
-					cached_resource_request = request;
-				}
-			}
-		}	// end of going over wire to ask schedd for request
+		}
+		// end of asking for job information - we now have a request
+	
 
-		dprintf(D_ALWAYS, "    Request %05d.%05d:  (request count %d of %d)\n", cluster, proc,
-			resource_request_offers+1,resource_request_count);
         negotiation_cycle_stats[0]->num_jobs_considered += 1;
 
 #if defined(ADD_TARGET_SCOPING)
@@ -3776,9 +3708,12 @@ negotiate(char const* groupName, char const *scheddName, const ClassAd *scheddAd
 
 			if( !offer )
 			{
+				// lookup want_match_diagnostics in request
+				// 0 = no match diagnostics
+				// 1 = match diagnostics string
+				// 2 = match diagnostics string w/ autocluster + jobid
 				int want_match_diagnostics = 0;
-				request.LookupBool (ATTR_WANT_MATCH_DIAGNOSTICS,
-									want_match_diagnostics);
+				request.LookupInteger(ATTR_WANT_MATCH_DIAGNOSTICS,want_match_diagnostics);
 				string diagnostic_message;
 				// no match found
 				dprintf(D_ALWAYS|D_MATCH, "      Rejected %d.%d %s %s: ",
@@ -3812,6 +3747,12 @@ negotiate(char const* groupName, char const *scheddName, const ClassAd *scheddAd
 					dprintf(D_ALWAYS|D_MATCH|D_NOHEADER, "%s\n",
 							diagnostic_message.c_str());
 				}
+				// add in autocluster and job id info if requested
+				if ( want_match_diagnostics == 2 ) {
+					string diagnostic_jobinfo;
+					formatstr(diagnostic_jobinfo," |%d|%d.%d|",autocluster,cluster,proc);
+					diagnostic_message += diagnostic_jobinfo;
+				}
 				sock->encode();
 				if ((want_match_diagnostics) ? 
 					(!sock->put(REJECTED_WITH_REASON) ||
@@ -3880,7 +3821,7 @@ negotiate(char const* groupName, char const *scheddName, const ClassAd *scheddAd
 		{
 			numMatched--;		// haven't used any resources this cycle
 
-			resource_request_count = 0;	// do not reuse any cached request
+			request_list.noMatchFound(); // do not reuse any cached requests
 
             if (rejForSubmitterLimit && !ConsiderPreemption && !accountant.UsingWeightedSlots()) {
                 // If we aren't considering preemption and slots are unweighted, then we can
@@ -4596,7 +4537,8 @@ matchmakingProtocol (ClassAd &request, ClassAd *offer,
 						ClaimIdHash &claimIds, Sock *sock,
 					    const char* scheddName, const char* scheddAddr)
 {
-	int  cluster, proc;
+	int  cluster = 0;
+	int proc = 0;
 	MyString startdAddr;
 	string remoteUser;
 	char accountingGroup[256];
@@ -4703,6 +4645,11 @@ matchmakingProtocol (ClassAd &request, ClassAd *offer,
     offer->CopyAttribute(ATTR_REMOTE_NEGOTIATING_GROUP, ATTR_SUBMITTER_NEGOTIATING_GROUP, &request);
     offer->CopyAttribute(ATTR_REMOTE_AUTOREGROUP, ATTR_SUBMITTER_AUTOREGROUP, &request);
 
+	// insert cluster and proc from the request into the offer; this is
+	// used by schedd_negotiate.cpp when resource request lists are being used
+	offer->Assign(ATTR_RESOURCE_REQUEST_CLUSTER,cluster);
+	offer->Assign(ATTR_RESOURCE_REQUEST_PROC,proc);
+
 	// ---- real matchmaking protocol begins ----
 	// 1.  contact the startd 
 	if (want_claiming && want_inform_startd) {
@@ -5426,8 +5373,10 @@ Matchmaker::updateCollector() {
         daemonCore->dc_stats.Publish(*publicAd);
 		daemonCore->monitor_data.ExportData(publicAd);
 
-		// log classad into sql log so that it can be updated to DB
-		FILESQL::daemonAdInsert(publicAd, "NegotiatorAd", FILEObj, prevLHF);	
+		if ( FILEObj ) {
+			// log classad into sql log so that it can be updated to DB
+			FILESQL::daemonAdInsert(publicAd, "NegotiatorAd", FILEObj, prevLHF);
+		}
 
 #if defined(WANT_CONTRIB) && defined(WITH_MANAGEMENT)
 #if defined(HAVE_DLOPEN)
@@ -5470,6 +5419,9 @@ Matchmaker::invalidateNegotiatorAd( void )
 /* CONDORDB functions */
 void Matchmaker::insert_into_rejects(char const *userName, ClassAd& job)
 {
+	if ( !FILEObj ) {
+		return;
+	}
 	int cluster, proc;
 //	char startdname[80];
 	char globaljobid[200];
@@ -5509,6 +5461,9 @@ void Matchmaker::insert_into_rejects(char const *userName, ClassAd& job)
 }
 void Matchmaker::insert_into_matches(char const * userName,ClassAd& request, ClassAd& offer)
 {
+	if ( !FILEObj ) {
+		return;
+	}
 	char startdname[80],remote_user[80];
 	char globaljobid[200];
 	float remote_prio;
diff --git a/src/condor_negotiator.V6/matchmaker.h b/src/condor_negotiator.V6/matchmaker.h
index b0aa879..98243cf 100644
--- a/src/condor_negotiator.V6/matchmaker.h
+++ b/src/condor_negotiator.V6/matchmaker.h
@@ -27,6 +27,7 @@
 #include "string_list.h"
 #include "dc_collector.h"
 #include "condor_ver_info.h"
+#include "matchmaker_negotiate.h"
 
 #include <vector>
 #include <string>
@@ -155,7 +156,7 @@ class Matchmaker : public Service
 
 		int update_collector_tid;
 		void updateCollector();
-
+		
 		// auxillary functions
 		bool obtainAdsFromCollector (ClassAdList&, ClassAdListDoesNotDeleteAds&, ClassAdListDoesNotDeleteAds&, ClaimIdHash& );	
 		char * compute_significant_attrs(ClassAdListDoesNotDeleteAds & startdAds);
@@ -449,7 +450,7 @@ class Matchmaker : public Service
 
 
 		private:
-
+			
 			// AdListEntry* peek_candidate();
 			static int sort_compare(const void*, const void*);
 			AdListEntry* AdListArray;			
diff --git a/src/condor_negotiator.V6/matchmaker_negotiate.cpp b/src/condor_negotiator.V6/matchmaker_negotiate.cpp
new file mode 100644
index 0000000..5427a4d
--- /dev/null
+++ b/src/condor_negotiator.V6/matchmaker_negotiate.cpp
@@ -0,0 +1,297 @@
+/***************************************************************
+ *
+ * Copyright (C) 1990-2014, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#include "condor_common.h"
+#include "condor_io.h"
+#include "condor_debug.h"
+#include "condor_config.h"
+#include "condor_attributes.h"
+#include "condor_commands.h"
+#include "matchmaker_negotiate.h"
+
+ResourceRequestList::ResourceRequestList(int protocol_version)
+{
+	m_protocol_version = protocol_version;
+	m_clear_rejected_autoclusters = false;
+	m_use_resource_request_counts = param_boolean("USE_RESOURCE_REQUEST_COUNTS",true);
+	if ( protocol_version == 0 || m_use_resource_request_counts == false ) {
+		// Protocol version is 0, and schedd resource request lists were introduced
+		// in protocol version 1.  so set m_num_to_fetch to 1 so we use the old
+		// protocol of getting one request at a time with this old schedd.
+		// Also we must use the old protocol if admin disabled USE_RESOURCE_REQUEST_COUNTS,
+		// since the new protocol relies on that.
+		m_num_to_fetch = 1;
+	} else {
+		m_num_to_fetch = param_integer("NEGOTIATOR_RESOURCE_REQUEST_LIST_SIZE");
+	}
+	errcode = 0;
+	current_autocluster = -1;
+	resource_request_count = 0;
+	resource_request_offers = 0;
+}
+
+ResourceRequestList::~ResourceRequestList()
+{
+	ClassAd *front;
+
+	while( !m_ads.empty() ) {
+		front = m_ads.front();
+		m_ads.pop_front();
+		delete front;
+	}
+}
+
+bool
+ResourceRequestList::getRequest(ClassAd &request, int &cluster, int &proc, int &autocluster,
+								ReliSock* const sock)
+{
+	errcode = 0;	// clear errcode
+	cluster = -1;
+	proc = -1;
+	autocluster = -1;
+
+	// 2a.  ask for job information
+	if ( resource_request_count > ++resource_request_offers ) {
+		// No need to go to the schedd to ask for another resource request,
+		// since we have not yet handed out the number of requested matches
+		// for the request we already have cached.
+		request = cached_resource_request;
+	} else {
+		// We used up our cached_resource_request, so no we need to grab the
+		// next request from our list m_ads.
+		
+		resource_request_offers = 0;
+		resource_request_count = 0;
+
+		// Pull off front of m_ads list into *front, skipping any
+		// requests associated with rejected autoclusters, and going
+		// back over the wire to the schedd for more ads as needed.  
+		// If there are no more requests, return false.
+		ClassAd *front = NULL;		
+		while ( front == NULL ) {
+			if ( m_ads.empty() ) {
+				// No more requests stashed in our list, so go over the wire
+				// to the schedd and ask for more.
+				if ( m_clear_rejected_autoclusters ) {
+					m_rejected_auto_clusters.clear();
+					m_clear_rejected_autoclusters = false;
+				}
+				if (!fetchRequestsFromSchedd(sock))
+				{
+					// note: Do not set errcode here, it had better be set
+					// appropriately by fetchRequestFromSchedd()
+					ASSERT(errcode > 0);
+					return false;
+				}
+				if ( m_ads.empty() ) {
+					// if m_ads is still empty, schedd must have nothing
+					// more to give.  
+					return false;
+				}
+			}
+			ASSERT( !m_ads.empty() );
+			front = m_ads.front();
+			m_ads.pop_front();
+			front->LookupInteger(ATTR_AUTO_CLUSTER_ID,current_autocluster);
+			if ( m_rejected_auto_clusters.find(current_autocluster) != 
+					m_rejected_auto_clusters.end() ) 
+			{
+				// this request has an autocluster that has been rejected.
+				// skip it.
+				delete front;
+				front = NULL;
+			}
+		}
+		// we have a result in *front; copy it into request and deallocate front
+		request = *front;
+		delete front;
+		front = NULL;
+
+		if ( m_use_resource_request_counts ) {
+			request.LookupInteger(ATTR_RESOURCE_REQUEST_COUNT,resource_request_count);
+			if (resource_request_count > 0) {
+				cached_resource_request = request;
+			}
+		}
+	}	// end of going over wire to ask schedd for request
+
+	//
+	// If we made it here, "request" has a copy of the next request ad.
+	//
+
+	// fill in cluster, proc, and autocluster function parameters
+	if (!request.LookupInteger (ATTR_CLUSTER_ID, cluster) ||
+		!request.LookupInteger (ATTR_PROC_ID, proc))
+	{
+		dprintf (D_ALWAYS, "    Could not get %s and %s from request\n",
+				ATTR_CLUSTER_ID, ATTR_PROC_ID);
+		errcode = __LINE__;
+		return false;
+	}
+	autocluster = current_autocluster;
+
+	dprintf(D_ALWAYS, "    Request %05d.%05d:  (request count %d of %d)\n", cluster, proc,
+		resource_request_offers+1,resource_request_count);
+
+	return true;
+}
+
+void
+ResourceRequestList::noMatchFound()
+{
+	// No match was found for the current request, so we want to stop using
+	// this autocluster.
+	
+	// Stop re-using current autocluster
+	resource_request_count = 0;
+
+	if ( current_autocluster < 0 ) {
+		// This shouldn't really happen, but just in case...
+		return;
+	}
+	
+	// Don't use any other instances of current autocluster in the list.
+	// However, if we are always only fetching one request at a time (i.e.
+	// because we are talking to an older schedd), no need to waste time
+	// collecting up a set of rejected autoclusters as the schedd will keep
+	// track of this.
+	if ( m_num_to_fetch > 1 ) {
+		m_rejected_auto_clusters.insert( current_autocluster );
+	}
+}
+
+bool
+ResourceRequestList::fetchRequestsFromSchedd(ReliSock* const sock)
+{
+	int reply;
+	ClassAd *request_ad;
+
+	// go over the wire and ask the schedd for the request
+	int sleepy = param_integer("NEG_SLEEP", 0);
+		//  This sleep is useful for any testing that calls for a
+		//  long negotiation cycle, please do not remove
+		//  it. Examples of such testing are the async negotiation
+		//  protocol w/ schedds and reconfig delaying until after
+		//  a negotiation cycle. -matt 21 mar 2012
+	if ( sleepy ) {
+		dprintf(D_ALWAYS, "begin sleep: %d seconds\n", sleepy);
+		sleep(sleepy); // TODD DEBUG - allow schedd to do other things
+		dprintf(D_ALWAYS, "end sleep: %d seconds\n", sleepy);
+	}
+
+
+	ASSERT(m_num_to_fetch > 0);	
+
+	if ( m_num_to_fetch == 1 ) {
+		dprintf (D_FULLDEBUG, 
+			"    Sending SEND_JOB_INFO/eom\n");
+		sock->encode();
+		if (!sock->put(SEND_JOB_INFO) || !sock->end_of_message())
+		{
+			dprintf (D_ALWAYS, 
+				"    Failed to send SEND_JOB_INFO/eom\n");
+			errcode = __LINE__;
+			return false;
+		}
+	} else {
+		dprintf (D_FULLDEBUG, 
+			"    Sending SEND_RESOURCE_REQUEST_LIST/%d/eom\n",m_num_to_fetch);
+		sock->encode();
+		if (!sock->put(SEND_RESOURCE_REQUEST_LIST) || !sock->put(m_num_to_fetch) || 
+			!sock->end_of_message())
+		{
+			dprintf (D_ALWAYS, 
+				"    Failed to send SEND_RESOURCE_REQUEST_LIST/%d/eom\n",m_num_to_fetch);
+			errcode = __LINE__;
+			return false;
+		}
+	}
+
+	for (int i=0; i<m_num_to_fetch; i++) {
+		// 2b.  the schedd may either reply with JOB_INFO or NO_MORE_JOBS
+		dprintf (D_FULLDEBUG, "    Getting reply from schedd ...\n");
+		sock->decode();
+		if (!sock->get (reply))
+		{
+			dprintf (D_ALWAYS, "    Failed to get reply from schedd\n");
+			sock->end_of_message ();
+			errcode = __LINE__;
+			return false;
+		}
+
+		// 2c.  if the schedd replied with NO_MORE_JOBS, cleanup and quit
+		if (reply == NO_MORE_JOBS)
+		{
+			dprintf (D_ALWAYS, "    Got NO_MORE_JOBS;  schedd has no more requests\n");
+			sock->end_of_message ();
+			// Note: do NOT set errcode here, as this is not an error condition
+			return true;
+		}
+		else
+		if (reply != JOB_INFO)
+		{
+			// something goofy
+			dprintf(D_ALWAYS,"    Got illegal command %d from schedd\n",reply);
+			sock->end_of_message ();
+			errcode = __LINE__;
+			return false;
+		}
+
+		// 2d.  get the request
+		dprintf (D_FULLDEBUG,"    Got JOB_INFO command; getting classad/eom\n");
+		request_ad = getClassAd(sock);	// allocates a new ClassAd on success, NULL on fail
+		if ( request_ad==NULL || !sock->end_of_message() )
+		{
+			dprintf(D_ALWAYS, "    JOB_INFO command not followed by ad/eom\n");
+			sock->end_of_message();
+			errcode = __LINE__;
+			return false;
+		}
+		m_ads.push_back(request_ad);
+	}
+
+	return true;
+}
+
+#if 0
+	RequestListManager::~RequestListManager()
+	{
+		clear();
+	}
+
+	void
+	RequestListManager::clear()
+	{
+		m_request_lists_map.clear();	
+	}
+
+	ResourceRequestList*
+	RequestListManager::getRequestList(const MyString &key)
+	{
+		if ( m_request_lists_map.find(key) == m_request_lists_map.end() ) {
+			// key is not in the map, create a new object on the heap
+			ResourceRequestList *entry;
+			entry = new ResourceRequestList(0);
+			m_request_lists_map[key] = entry;
+			return entry;
+		} else {
+			return m_request_lists_map[key].get();
+		}
+	}
+#endif
diff --git a/src/condor_negotiator.V6/matchmaker_negotiate.h b/src/condor_negotiator.V6/matchmaker_negotiate.h
new file mode 100644
index 0000000..75d6dac
--- /dev/null
+++ b/src/condor_negotiator.V6/matchmaker_negotiate.h
@@ -0,0 +1,84 @@
+/***************************************************************
+ *
+ * Copyright (C) 1990-2014, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef _MATCHMAKER_NEGOTIATE_H
+#define _MATCHMAKER_NEGOTIATE_H
+
+#include <deque>
+
+class ResourceRequestList : public ClassyCountedPtr {
+
+ public:
+	ResourceRequestList(int protocol_version);
+	~ResourceRequestList();
+
+		// returns true if a request was found, else false.
+		// pass in a sock to use, function then returns request,
+		// cluster, proc, and autocluster.
+	bool getRequest(ClassAd &request, int &cluster, int &proc, 
+			int &autocluster, ReliSock* const sock);
+
+		//
+	bool hadError() { return errcode > 0; }
+
+		//
+	int getErrorCode() { return errcode; }
+
+		// 
+	void noMatchFound();
+
+		//
+	void clearRejectedAutoclusters() { m_clear_rejected_autoclusters = true; }
+
+ private:
+
+	bool fetchRequestsFromSchedd(ReliSock* const sock);
+
+	int m_protocol_version;
+	bool m_use_resource_request_counts;
+	bool m_clear_rejected_autoclusters;
+	int m_num_to_fetch;
+	int errcode;
+	int current_autocluster;
+	ClassAd cached_resource_request;
+	int resource_request_count;
+	int resource_request_offers;
+	std::deque<ClassAd *> m_ads;
+	std::set<int> m_rejected_auto_clusters;
+};
+
+#if 0
+	class RequestListManager {
+
+	 public:
+
+		 RequestListManager() { }
+		 ~RequestListManager();
+
+		 ResourceRequestList *getRequestList(const MyString& schedd_and_submitter);
+		 void clear();
+
+	 private:
+		typedef std::map< MyString,classy_counted_ptr<ResourceRequestList> > RequestListMap;
+		RequestListMap m_request_lists_map;
+
+	};
+#endif 
+
+#endif
diff --git a/src/condor_q.V6/queue.cpp b/src/condor_q.V6/queue.cpp
index 4f7eea3..1db3582 100644
--- a/src/condor_q.V6/queue.cpp
+++ b/src/condor_q.V6/queue.cpp
@@ -3066,13 +3066,12 @@ static void init_output_mask()
 		mask.SetAutoSep(NULL," ",NULL,"\n");
 		mask.registerFormat ("%4d.", 5, FormatOptionAutoWidth | FormatOptionNoSuffix, ATTR_CLUSTER_ID);
 		mask.registerFormat ("%-3d", 3, FormatOptionAutoWidth | FormatOptionNoPrefix, ATTR_PROC_ID);
-		mask.registerFormat (NULL, -14, 0, format_owner_wide, ATTR_OWNER, "[????????????]" );
+		mask.registerFormat (NULL, -14, AltQuestion | AltWide, format_owner_wide, ATTR_OWNER /*, "[????????????]"*/ );
 		//mask.registerFormat(" ", "*bogus*", " ");  // force space
-		mask.registerFormat (NULL,  11, 0, format_q_date, ATTR_Q_DATE, "[????????????]");
+		mask.registerFormat (NULL,  11, AltQuestion | AltWide, format_q_date, ATTR_Q_DATE /*, "[????????????]"*/ );
 		//mask.registerFormat(" ", "*bogus*", " ");  // force space
-		mask.registerFormat (NULL,  12, 0, format_cpu_time,
-							  ATTR_JOB_REMOTE_USER_CPU,
-							  "[??????????]");
+		mask.registerFormat (NULL,  12, AltQuestion | AltWide, format_cpu_time,
+							 ATTR_JOB_REMOTE_USER_CPU /*, "[??????????]"*/);
 		if (dash_run && ! dash_goodput) {
 			mask_headings = (cputime) ? " ID\0 \0OWNER\0  SUBMITTED\0    CPU_TIME\0HOST(S)\0"
 			                          : " ID\0 \0OWNER\0  SUBMITTED\0    RUN_TIME\0HOST(S)\0";
@@ -3082,20 +3081,17 @@ static void init_output_mask()
 			// format_remote_host() is always called. We are
 			// actually displaying ATTR_REMOTE_HOST if defined,
 			// but we play some tricks if it isn't defined.
-			mask.registerFormat ( NULL, 0, 0, format_remote_host,
-								  ATTR_OWNER, "[????????????????]");
+			mask.registerFormat ( NULL, 0, AltQuestion | AltWide, format_remote_host,
+								  ATTR_OWNER /*, "[????????????????]"*/);
 		} else {			// goodput
 			mask_headings = (cputime) ? " ID\0 \0OWNER\0  SUBMITTED\0    CPU_TIME\0GOODPUT\0CPU_UTIL\0Mb/s\0"
 			                          : " ID\0 \0OWNER\0  SUBMITTED\0    RUN_TIME\0GOODPUT\0CPU_UTIL\0Mb/s\0";
-			mask.registerFormat (NULL, 8, 0, format_goodput,
-								  ATTR_JOB_STATUS,
-								  "[?????]");
-			mask.registerFormat (NULL, 9, 0, format_cpu_util,
-								  ATTR_JOB_REMOTE_USER_CPU,
-								  "[??????]");
-			mask.registerFormat (NULL, 7, 0, format_mbps,
-								  ATTR_BYTES_SENT,
-								  "[????]");
+			mask.registerFormat (NULL, 8, AltQuestion | AltWide, format_goodput,
+								 ATTR_JOB_STATUS /*, "[?????]"*/);
+			mask.registerFormat (NULL, 9, AltQuestion | AltWide, format_cpu_util,
+								 ATTR_JOB_REMOTE_USER_CPU /*, "[??????]"*/);
+			mask.registerFormat (NULL, 7, AltQuestion | AltWide, format_mbps,
+								 ATTR_BYTES_SENT /*, "[????]"*/);
 		}
 		//mask.registerFormat("\n", "*bogus*", "\n");  // force newline
 		usingPrintMask = true;
@@ -3104,15 +3100,15 @@ static void init_output_mask()
 		mask.SetAutoSep(NULL," ",NULL,"\n");
 		mask.registerFormat ("%4d.", 5, FormatOptionAutoWidth | FormatOptionNoSuffix, ATTR_CLUSTER_ID);
 		mask.registerFormat ("%-3d", 3, FormatOptionAutoWidth | FormatOptionNoPrefix,  ATTR_PROC_ID);
-		mask.registerFormat (NULL, -14, 0, format_owner_wide, ATTR_OWNER, "[?]" );
-		mask.registerFormat(NULL, -8, 0, format_globusStatus, ATTR_GLOBUS_STATUS, "[?]" );
+		mask.registerFormat (NULL, -14, AltQuestion | AltWide, format_owner_wide, ATTR_OWNER /*, "[?]"*/ );
+		mask.registerFormat(NULL, -8, AltQuestion | AltWide, format_globusStatus, ATTR_GLOBUS_STATUS /*, "[?]"*/ );
 		if (widescreen) {
-			mask.registerFormat(NULL, -30, FormatOptionAutoWidth | FormatOptionNoTruncate, 
-				format_globusHostAndJM, ATTR_GRID_RESOURCE, "fork    [?????]" );
+			mask.registerFormat(NULL, -30,  FormatOptionAlwaysCall | FormatOptionAutoWidth | FormatOptionNoTruncate,
+				format_globusHostAndJM, ATTR_GRID_RESOURCE);
 			mask.registerFormat("%v", -18, FormatOptionAutoWidth | FormatOptionNoTruncate, ATTR_JOB_CMD );
 		} else {
-			mask.registerFormat(NULL, 30, 0, 
-				format_globusHostAndJM, ATTR_JOB_CMD, "fork    [?????]" );
+			mask.registerFormat(NULL, 30, FormatOptionAlwaysCall,
+				format_globusHostAndJM, ATTR_JOB_CMD);
 			mask.registerFormat("%-18.18s", ATTR_JOB_CMD);
 		}
 		usingPrintMask = true;
@@ -3141,11 +3137,9 @@ static void init_output_mask()
 		mask.SetAutoSep(NULL," ",NULL,"\n");
 		mask.registerFormat ("%4d.", 5, FormatOptionAutoWidth | FormatOptionNoSuffix, ATTR_CLUSTER_ID);
 		mask.registerFormat ("%-3d", 3, FormatOptionAutoWidth | FormatOptionNoPrefix, ATTR_PROC_ID);
-		mask.registerFormat (NULL, -14, 0, format_owner_wide, ATTR_OWNER, "[????????????]" );
-		//mask.registerFormat(" ", "*bogus*", " ");  // force space
-		mask.registerFormat (NULL, 11, 0, format_q_date,
-							  ATTR_ENTERED_CURRENT_STATUS, "[????????????]");
-		//mask.registerFormat(" ", "*bogus*", " ");  // force space
+		mask.registerFormat (NULL, -14, AltQuestion | AltWide, format_owner_wide, ATTR_OWNER /*, "[????????????]"*/ );
+		mask.registerFormat (NULL, 11, AltQuestion | AltWide, format_q_date,
+							  ATTR_ENTERED_CURRENT_STATUS /*, "[????????????]"*/);
 		if (widescreen) {
 			mask.registerFormat("%v", -43, FormatOptionAutoWidth | FormatOptionNoTruncate, ATTR_HOLD_REASON );
 		} else {
diff --git a/src/condor_schedd.V6/qmgmt.cpp b/src/condor_schedd.V6/qmgmt.cpp
index d796178..41115d6 100644
--- a/src/condor_schedd.V6/qmgmt.cpp
+++ b/src/condor_schedd.V6/qmgmt.cpp
@@ -1946,8 +1946,10 @@ int DestroyProc(int cluster_id, int proc_id)
   ScheddPluginManager::Archive(ad);
 #endif
 
-  if (FILEObj->file_newEvent("History", ad) == QUILL_FAILURE) {
-	  dprintf(D_ALWAYS, "AppendHistory Logging History Event --- Error\n");
+  if ( FILEObj ) {
+	  if (FILEObj->file_newEvent("History", ad) == QUILL_FAILURE) {
+		  dprintf(D_ALWAYS, "AppendHistory Logging History Event --- Error\n");
+	  }
   }
 
   // save job ad to the log
@@ -2087,8 +2089,10 @@ int DestroyCluster(int cluster_id, const char* reason)
 				ScheddPluginManager::Archive(ad);
 #endif
 
-				if (FILEObj->file_newEvent("History", ad) == QUILL_FAILURE) {
-			  		dprintf(D_ALWAYS, "AppendHistory Logging History Event --- Error\n");
+				if ( FILEObj ) {
+					if (FILEObj->file_newEvent("History", ad) == QUILL_FAILURE) {
+						dprintf(D_ALWAYS, "AppendHistory Logging History Event --- Error\n");
+					}
 		  		}
 
   // save job ad to the log
diff --git a/src/condor_schedd.V6/qmgmt_receivers.cpp b/src/condor_schedd.V6/qmgmt_receivers.cpp
index 58d3fb6..f867eb8 100644
--- a/src/condor_schedd.V6/qmgmt_receivers.cpp
+++ b/src/condor_schedd.V6/qmgmt_receivers.cpp
@@ -820,7 +820,7 @@ do_Q_request(ReliSock *syscall_sock,bool &may_fork)
 			assert( syscall_sock->code(terrno) );
 		}
 		if( rval >= 0 ) {
-			assert( putClassAd(syscall_sock, *ad, true) );
+			assert( putClassAd(syscall_sock, *ad, PUT_CLASSAD_NO_PRIVATE) );
 		}
 		// Here we must really, truely delete the ad.  Why? Because
 		// when GetJobAd is called with the third bool argument set
@@ -853,7 +853,7 @@ do_Q_request(ReliSock *syscall_sock,bool &may_fork)
 			assert( syscall_sock->code(terrno) );
 		}
 		if( rval >= 0 ) {
-			assert( putClassAd(syscall_sock, *ad, true) );
+			assert( putClassAd(syscall_sock, *ad, PUT_CLASSAD_NO_PRIVATE) );
 		}
 		FreeJobAd(ad);
 		free( (char *)constraint );
@@ -883,7 +883,7 @@ do_Q_request(ReliSock *syscall_sock,bool &may_fork)
 			assert( syscall_sock->code(terrno) );
 		}
 		if( rval >= 0 ) {
-			assert( putClassAd(syscall_sock, *ad, true) );
+			assert( putClassAd(syscall_sock, *ad, PUT_CLASSAD_NO_PRIVATE) );
 		}
 		FreeJobAd(ad);
 		assert( syscall_sock->end_of_message() );;
@@ -920,7 +920,7 @@ do_Q_request(ReliSock *syscall_sock,bool &may_fork)
 			assert( syscall_sock->code(terrno) );
 		}
 		if( rval >= 0 ) {
-			assert( putClassAd(syscall_sock, *ad, true) );
+			assert( putClassAd(syscall_sock, *ad, PUT_CLASSAD_NO_PRIVATE) );
 		}
 		FreeJobAd(ad);
 		free( (char *)constraint );
@@ -957,7 +957,7 @@ do_Q_request(ReliSock *syscall_sock,bool &may_fork)
 			assert( syscall_sock->code(terrno) );
 		}
 		if( rval >= 0 ) {
-			assert( putClassAd(syscall_sock, *ad, true) );
+			assert( putClassAd(syscall_sock, *ad, PUT_CLASSAD_NO_PRIVATE) );
 		}
 		FreeJobAd(ad);
 		free( (char *)constraint );
@@ -1012,6 +1012,7 @@ do_Q_request(ReliSock *syscall_sock,bool &may_fork)
 		ClassAd *ad;
 		int terrno;
 		int initScan = 1;
+		classad::References proj;
 
 		if ( !(syscall_sock->code(constraint)) ) {
 			if (constraint != NULL) {
@@ -1033,7 +1034,12 @@ do_Q_request(ReliSock *syscall_sock,bool &may_fork)
 
 		assert( syscall_sock->end_of_message() );;
 
-		StringList sl(projection, "\n");
+		// if there is a projection, convert it into a set of attribute names
+		if (projection) {
+			StringTokenIterator list(projection);
+			const std::string * attr;
+			while ((attr = list.next_string())) { proj.insert(*attr); }
+		}
 
 		syscall_sock->encode();
 
@@ -1054,23 +1060,7 @@ do_Q_request(ReliSock *syscall_sock,bool &may_fork)
 			}
 
 			if( rval >= 0 ) {
-				if (sl.number() != 0) {
-					sl.rewind();
-					StringList internals;
-					StringList externals; // shouldn't have any
-					while (char *attr = sl.next()) {
-
-						if( !ad->GetExprReferences(attr, internals, externals) ) {
-							dprintf(D_FULLDEBUG,
-									"GetAllJobsByConstraint failed to parse "
-									"requested ClassAd expression: %s\n",attr);
-						}
-					}
-
-					assert( putClassAd(syscall_sock, *ad, true, &internals) );
-				} else {
-					assert( putClassAd(syscall_sock, *ad, true) );
-				}
+				assert( putClassAd(syscall_sock, *ad, PUT_CLASSAD_NO_PRIVATE, proj.empty() ? NULL : &proj) );
 				FreeJobAd(ad);
 			}
 		} while (rval >= 0);
diff --git a/src/condor_schedd.V6/schedd.cpp b/src/condor_schedd.V6/schedd.cpp
index 42c9917..81365d4 100644
--- a/src/condor_schedd.V6/schedd.cpp
+++ b/src/condor_schedd.V6/schedd.cpp
@@ -168,7 +168,7 @@ bool jobPrepNeedsThread( int cluster, int proc );
 bool jobCleanupNeedsThread( int cluster, int proc );
 bool jobExternallyManaged(ClassAd * ad);
 bool jobManagedDone(ClassAd * ad);
-int  count( ClassAd *job );
+int  count_a_job( ClassAd *job );
 static void WriteCompletionVisa(ClassAd* ad);
 
 
@@ -1128,8 +1128,10 @@ Scheduler::count_jobs()
 	SchedUniverseJobsRunning = 0;
 	LocalUniverseJobsIdle = 0;
 	LocalUniverseJobsRunning = 0;
+	stats.JobsRunning = 0;
 	stats.JobsRunningRuntimes = 0;
 	stats.JobsRunningSizes = 0;
+	scheduler.OtherPoolStats.ResetJobsRunning();
 
 	// clear owner table contents
 	time_t current_time = time(0);
@@ -1153,7 +1155,7 @@ Scheduler::count_jobs()
 		// job cluster ids, since we're about to re-create it.
 	dedicated_scheduler.clearDedicatedClusters();
 
-	WalkJobQueue((int(*)(ClassAd *)) count );
+	WalkJobQueue( count_a_job );
 
 	if( dedicated_scheduler.hasDedicatedClusters() ) {
 			// We found some dedicated clusters to service.  Wake up
@@ -1328,7 +1330,9 @@ Scheduler::count_jobs()
 
 		// log classad into sql log so that it can be updated to DB
 #ifdef HAVE_EXT_POSTGRESQL
-	FILESQL::daemonAdInsert(cad, "ScheddAd", FILEObj, prevLHF);
+	if ( FILEObj ) {
+		FILESQL::daemonAdInsert(cad, "ScheddAd", FILEObj, prevLHF);
+	}
 #endif
 
 #if defined(HAVE_DLOPEN)
@@ -1859,7 +1863,7 @@ sendDone(Stream *stream)
 struct QueryJobAdsContinuation : Service {
 
 	classad_shared_ptr<classad::ExprTree> requirements;
-	StringList projection;
+	classad::References projection;
 	ClassAdLog::filter_iterator it;
 	bool unfinished_eom;
 	bool registered_socket;
@@ -1906,18 +1910,9 @@ QueryJobAdsContinuation::finish(Stream *stream) {
 		//	tmp_ad->EvaluateAttrInt(ATTR_PROC_ID, proc);
 		//	dprintf(D_FULLDEBUG, "Writing job %d.%d to wire\n", cluster,proc);
 		//}
-		StringList expanded_projection;
-		StringList * attr_whitelist = NULL;
-		if ( ! projection.isEmpty()) {
-			StringList externals; // don't need this, but must pass it.
-			const char * attr;
-			projection.rewind();
-			while ((attr = projection.next())) {
-				tmp_ad->GetExprReferences(attr, expanded_projection, externals);
-			}
-			attr_whitelist = &expanded_projection;
-		}
-		int retval = putClassAdNonblocking(sock, *tmp_ad, true, attr_whitelist);
+		int retval = putClassAd(sock, *tmp_ad,
+					PUT_CLASSAD_NON_BLOCKING | PUT_CLASSAD_NO_PRIVATE,
+					projection.empty() ? NULL : &projection);
 		if (retval == 2) {
 			//dprintf(D_FULLDEBUG, "Detecting backlog.\n");
                         has_backlog = true;
@@ -1968,34 +1963,14 @@ int Scheduler::command_query_job_ads(int, Stream* stream)
 	}
 	classad_shared_ptr<classad::ExprTree> requirements_ptr(requirements->Copy());
 
-	classad::Value value;
-	classad::ExprList *list = NULL;
-	if ((queryAd.find(ATTR_PROJECTION) != queryAd.end()) &&
-		!queryAd.EvaluateAttr(ATTR_PROJECTION, value))
-	{
-		return sendJobErrorAd(stream, 2, "Unable to evaluate projection list");
-	}
 	QueryJobAdsContinuation *continuation = new QueryJobAdsContinuation(requirements_ptr, 1000);
-	StringList &projection = continuation->projection;
-	if (!value.IsListValue(list)) {
-		list = NULL;
-		std::string slist;
-		// a string of comma and/or space separated attributes is the usual form for projection
-		if (value.IsStringValue(slist)) {
-			projection.initializeFromString(slist.c_str());
-		} else {
-			delete continuation;
-			return sendJobErrorAd(stream, 3, "Unable to convert projection list to string list");
+	int proj_err = mergeProjectionFromQueryAd(queryAd, ATTR_PROJECTION, continuation->projection, true);
+	if (proj_err < 0) {
+		delete continuation;
+		if (proj_err == -1) {
+			return sendJobErrorAd(stream, 2, "Unable to evaluate projection list");
 		}
-	}
-	if (list) for (classad::ExprList::const_iterator it = list->begin(); it != list->end(); it++) {
-		std::string attr;
-		if (!(*it)->Evaluate(value) || !value.IsStringValue(attr))
-		{
-			delete continuation;
-			return sendJobErrorAd(stream, 3, "Unable to convert projection list to string list");
-		}
-		projection.insert(attr.c_str());
+		return sendJobErrorAd(stream, 3, "Unable to convert projection list to string list");
 	}
 
 	return continuation->finish(stream);
@@ -2009,7 +1984,7 @@ clear_autocluster_id( ClassAd *job )
 }
 
 int
-count( ClassAd *job )
+count_a_job( ClassAd *job )
 {
 	int		status;
 	int		niceUser;
@@ -2265,17 +2240,23 @@ count( ClassAd *job )
 			// Don't update scheduler.Owners[OwnerNum].JobsRunning here.
 			// We do it in Scheduler::count_jobs().
 
-		int job_image_size = 0;
-		job->LookupInteger("ImageSize_RAW", job_image_size);
-		scheduler.stats.JobsRunningSizes += (int64_t)job_image_size * 1024;
-		OTHER.JobsRunningSizes += (int64_t)job_image_size * 1024;
-
-		int job_start_date = 0;
-		int job_running_time = 0;
-		if (job->LookupInteger(ATTR_JOB_START_DATE, job_start_date))
-			job_running_time = (now - job_start_date);
-		scheduler.stats.JobsRunningRuntimes += job_running_time;
-		OTHER.JobsRunningRuntimes += job_running_time;
+			// if job is not idle, then update statistics for running jobs
+		if (status == RUNNING || status == TRANSFERRING_OUTPUT) {
+			scheduler.stats.JobsRunning += 1;
+			OTHER.JobsRunning += 1;
+
+			int job_image_size = 0;
+			job->LookupInteger("ImageSize_RAW", job_image_size);
+			scheduler.stats.JobsRunningSizes += (int64_t)job_image_size * 1024;
+			OTHER.JobsRunningSizes += (int64_t)job_image_size * 1024;
+
+			int job_start_date = 0;
+			int job_running_time = 0;
+			if (job->LookupInteger(ATTR_JOB_START_DATE, job_start_date))
+				job_running_time = (now - job_start_date);
+			scheduler.stats.JobsRunningRuntimes += job_running_time;
+			OTHER.JobsRunningRuntimes += job_running_time;
+		}
 	} else if (status == HELD) {
 		scheduler.JobsHeld++;
 		scheduler.Owners[OwnerNum].JobsHeld++;
@@ -8674,14 +8655,18 @@ Scheduler::start_sched_universe_job(PROC_ID* job_id)
 		core_size = (size_t)core_size_truncated;
 		core_size_ptr = &core_size;
 	}
-	
+
+		// Scheduler universe jobs should not be told about the shadow
+		// command socket in the inherit buffer.
+	daemonCore->SetInheritParentSinful( NULL );
 	pid = daemonCore->Create_Process( a_out_name.Value(), args, PRIV_USER_FINAL, 
 	                                  shadowReaperId, FALSE,
 	                                  &envobject, iwd.Value(), NULL, NULL, inouterr,
 	                                  NULL, niceness, NULL,
 	                                  DCJOBOPT_NO_ENV_INHERIT,
 	                                  core_size_ptr );
-	
+	daemonCore->SetInheritParentSinful( MyShadowSockName );
+
 	// now close those open fds - we don't want them here.
 	for ( i=0 ; i<3 ; i++ ) {
 		if ( close( inouterr[i] ) == -1 ) {
@@ -10189,7 +10174,7 @@ Scheduler::child_exit(int pid, int status)
 		//
 	if ( srec_was_local_universe == true ) {
 		ClassAd *job_ad = GetJobAd( job_id.cluster, job_id.proc );
-		count( job_ad );
+		count_a_job( job_ad );
 	}
 
 		// If we're not trying to shutdown, now that either an agent
@@ -10583,6 +10568,7 @@ Scheduler::jobExitCode( PROC_ID job_id, int exit_code )
 			stats.JobsCompletedRuntimes += job_running_time;
 		} else if (is_badput) {
 			stats.JobsAccumBadputTime += job_running_time;
+			if (reportException) { stats.JobsAccumExceptionalBadputTime += job_running_time; }
 			stats.JobsBadputSizes += (int64_t)job_image_size * 1024;
 			stats.JobsBadputRuntimes += job_running_time;
 		}
@@ -10597,6 +10583,7 @@ Scheduler::jobExitCode( PROC_ID job_id, int exit_code )
 				OTHER.JobsCompletedRuntimes += job_running_time;
 			} else if (is_badput) {
 				OTHER.JobsAccumBadputTime += job_running_time;
+				if (reportException) { OTHER.JobsAccumExceptionalBadputTime += job_running_time; }
 				OTHER.JobsBadputSizes += (int64_t)job_image_size * 1024;
 				OTHER.JobsBadputRuntimes += job_running_time;
 			}
@@ -11641,6 +11628,10 @@ Scheduler::Init()
 		MyShadowSockName = strdup( shadowCommandrsock->get_sinful() );
 
 		sent_shadow_failure_email = FALSE;
+
+		// In the inherit buffer we pass to our children, tell them to use
+		// the shadow command socket.
+		daemonCore->SetInheritParentSinful( MyShadowSockName );
 	}
 		
 		// initialize our ShadowMgr, too.
@@ -12665,7 +12656,10 @@ Scheduler::AlreadyMatched(PROC_ID* id)
 
 	if (GetAttributeInt(id->cluster, id->proc,
 						ATTR_JOB_UNIVERSE, &universe) < 0) {
-		dprintf(D_FULLDEBUG, "GetAttributeInt() failed\n");
+		// Failing to get the JOB_UNIVERSE is common 
+		// because the job may have left the queue.
+		// So in this case, just return FALSE, since a job
+		// not in the queue is most certainly not matched :)
 		return FALSE;
 	}
 
diff --git a/src/condor_schedd.V6/schedd_cron_job.cpp b/src/condor_schedd.V6/schedd_cron_job.cpp
index 8d5f846..33492f7 100644
--- a/src/condor_schedd.V6/schedd_cron_job.cpp
+++ b/src/condor_schedd.V6/schedd_cron_job.cpp
@@ -42,7 +42,7 @@ ScheddCronJob::~ScheddCronJob( )
 }
 
 int
-ScheddCronJob::Publish( const char *a_name, ClassAd *ad )
+ScheddCronJob::Publish( const char *a_name, const char * /*args*/, ClassAd *ad )
 {
 	return scheduler.adlist_replace( a_name, ad );
 }
diff --git a/src/condor_schedd.V6/schedd_cron_job.h b/src/condor_schedd.V6/schedd_cron_job.h
index b7a1ec1..09018ac 100644
--- a/src/condor_schedd.V6/schedd_cron_job.h
+++ b/src/condor_schedd.V6/schedd_cron_job.h
@@ -31,7 +31,7 @@ class ScheddCronJob: public ClassAdCronJob
 	virtual ~ScheddCronJob( );
 
   private:
-	int Publish( const char *name, ClassAd *ad );
+	int Publish( const char *name, const char *args, ClassAd *ad );
 };
 
 #endif /* _SCHEDD_CRON_JOB_H */
diff --git a/src/condor_schedd.V6/schedd_files.cpp b/src/condor_schedd.V6/schedd_files.cpp
index 2d0217f..d752e2d 100644
--- a/src/condor_schedd.V6/schedd_files.cpp
+++ b/src/condor_schedd.V6/schedd_files.cpp
@@ -177,6 +177,9 @@ void schedd_files_ins(
 void schedd_files(ClassAd *procad)
 
 {
+	if ( !FILEObj ) {
+		return;
+	}
 	FILEObj->file_lock();
 	schedd_files_ins(procad, ATTR_JOB_CMD);	
 	schedd_files_ins(procad, ATTR_JOB_INPUT);
diff --git a/src/condor_schedd.V6/schedd_negotiate.cpp b/src/condor_schedd.V6/schedd_negotiate.cpp
index 133e9f6..87fee68 100644
--- a/src/condor_schedd.V6/schedd_negotiate.cpp
+++ b/src/condor_schedd.V6/schedd_negotiate.cpp
@@ -70,6 +70,8 @@ ScheddNegotiate::ScheddNegotiate
 	m_current_auto_cluster_id(-1),
 	m_jobs_rejected(0),
 	m_jobs_matched(0),
+	m_num_resource_reqs_sent(0),
+	m_num_resource_reqs_to_send(0),
 	m_negotiation_finished(false),
 	m_operation(0)
 {
@@ -115,6 +117,19 @@ ScheddNegotiate::getRemotePool()
 bool
 ScheddNegotiate::nextJob()
 {
+	if ( m_num_resource_reqs_sent > 0 && m_num_resource_reqs_to_send == 0 ) {
+		// If we have already sent off a list of resource requests via
+		// sendResourceRequestList(), and we are not currently being asked
+		// by the negotiator to send more requests (or jobs), then
+		// we want nextJob() to essentially be a no-op here.
+		// In other words, when doing resource request lists, we want
+		// all the calls to nextJob() to be ignored unless we are
+		// in the process of sending a resource request list.
+		// Note that if we are talking to anything earlier than a v8.3.0
+		// negotiator, m_num_resource_reqs_sent will always be 0.
+		return true;
+	}
+
 	while( !m_jobs->empty() ) {
 		ResourceRequestCluster *cluster = m_jobs->front();
 		ASSERT( cluster );
@@ -259,7 +274,51 @@ ScheddNegotiate::fixupPartitionableSlot(ClassAd *job_ad, ClassAd *match_ad)
 }
 
 bool
-ScheddNegotiate::sendJobInfo(Sock *sock)
+ScheddNegotiate::sendResourceRequestList(Sock *sock)
+{
+	while (m_num_resource_reqs_to_send > 0) {
+
+		nextJob();
+
+		if ( !sendJobInfo(sock, true) ) {
+			return false;
+		}
+
+		// If m_negotiation_finished==true, then no more jobs to send. But
+		// if we already sent some jobs in response to this request, we
+		// don't want to consider the negotitation finished since we still want
+		// to receive responses (e.g. matches) back from the negotiator.
+		if ( m_negotiation_finished ) {
+			if (m_num_resource_reqs_sent > 0 ) {
+				m_negotiation_finished = false;
+			}
+			break;
+		}
+
+		// When we call sendJobInfo next at the top of the loop,
+		// we don't want it to send all the individual jobs in the current cluster since
+		// we already sent an ad with a resource_request_count.  So we want
+		// to skip ahead to the next cluster.
+		if ( !m_jobs->empty() ) {
+			ResourceRequestCluster *cluster = m_jobs->front();
+			m_jobs->pop_front();
+			delete cluster;
+		}
+
+		m_num_resource_reqs_sent++;
+		m_num_resource_reqs_to_send--;
+	}
+
+	// Set m_num_resource_reqs_to_send to zero, as we are not sending
+	// any more reqs now, and this counter is inspected in nextJob()
+	m_num_resource_reqs_to_send = 0; 
+
+	return true;
+}
+
+
+bool
+ScheddNegotiate::sendJobInfo(Sock *sock, bool just_sig_attrs)
 {
 		// The Negotiator wants us to send it a job. 
 
@@ -280,10 +339,43 @@ ScheddNegotiate::sendJobInfo(Sock *sock)
 	}
 
 		// request match diagnostics
-	m_current_job_ad.Assign(ATTR_WANT_MATCH_DIAGNOSTICS, true);
+		// 0 = no match diagnostics
+		// 1 = match diagnostics string
+		// 2 = match diagnostics string decorated w/ autocluster + jobid
+	m_current_job_ad.Assign(ATTR_WANT_MATCH_DIAGNOSTICS, (int) 2);
 
 		// Send the ad to the negotiator
-	if( !putClassAd(sock, m_current_job_ad) ) {
+	int putad_result = 0;
+	std::string auto_cluster_attrs;
+	if ( just_sig_attrs &&
+		 m_current_job_ad.LookupString(ATTR_AUTO_CLUSTER_ATTRS, auto_cluster_attrs) )
+	{
+		// don't send the entire job ad; just send significant attrs
+		classad::References sig_attrs;
+
+		StringTokenIterator list(auto_cluster_attrs);
+		const std::string *attr;
+		while ((attr = list.next_string())) { sig_attrs.insert(*attr); }
+
+		// besides significant attrs, we also always want to send these attrs cuz
+		// the matchmaker explicitly looks for them (for dprintfs or whatever).
+		sig_attrs.insert(ATTR_OWNER);
+		sig_attrs.insert(ATTR_CLUSTER_ID);
+		sig_attrs.insert(ATTR_PROC_ID);
+		sig_attrs.insert(ATTR_RESOURCE_REQUEST_COUNT);
+		sig_attrs.insert(ATTR_GLOBAL_JOB_ID);
+		sig_attrs.insert(ATTR_AUTO_CLUSTER_ID);
+		sig_attrs.insert(ATTR_WANT_MATCH_DIAGNOSTICS);
+		sig_attrs.insert(ATTR_WANT_CLAIMING);  // used for Condor-G matchmaking
+		// ship it!
+		putad_result = putClassAd(sock, m_current_job_ad, 0, &sig_attrs);
+	} else {
+		// send the entire classad.  perhaps we are doing this because the
+		// ad does not have ATTR_AUTO_CLUSTER_ATTRS defined for some reason,
+		// or perhaps we are doing this because we were explicitly told to do so.
+		putad_result = putClassAd(sock, m_current_job_ad);
+	}
+	if( !putad_result ) {
 		dprintf( D_ALWAYS,
 				 "Can't send job ad to mgr\n" );
 		sock->end_of_message();
@@ -313,33 +405,76 @@ ScheddNegotiate::messageReceived( DCMessenger *messenger, Sock *sock )
 		// Now carry out the negotiator's request that we just read.
 
 	switch( m_operation ) {
+
 	case REJECTED:
 		m_reject_reason = "Unknown reason";
-	case REJECTED_WITH_REASON:
+
+	case REJECTED_WITH_REASON: {
+		// To support resource request lists, the
+		// reject reason may end with "...|autocluster|cluster.proc|"
+		// if so, reset m_current_auto_cluster_id and m_current_job_id
+		// with the values contained in the reject reason, and truncate
+		// this information out of m_reject_reason.
+		int pos = m_reject_reason.FindChar('|');
+		if ( pos >= 0 ) {
+			m_reject_reason.Tokenize();
+			/*const char *reason =*/ m_reject_reason.GetNextToken("|",false);
+			const char *ac = m_reject_reason.GetNextToken("|",false);
+			const char *jobid = m_reject_reason.GetNextToken("|",false);
+			if (ac && jobid) {
+				int rr_cluster, rr_proc;
+				m_current_auto_cluster_id = atoi(ac);
+				StrToProcId(jobid,rr_cluster,rr_proc);
+				if (rr_cluster != m_current_job_id.cluster || rr_proc != m_current_job_id.proc) {
+					m_current_resources_delivered = 0;
+				}
+				m_current_job_id.cluster = rr_cluster;
+				m_current_job_id.proc = rr_proc;
+			}
+			m_reject_reason.setChar(pos,'\0');	// will truncate string at pos
+		}
 		scheduler_handleJobRejected( m_current_job_id, m_reject_reason.c_str() );
 		m_jobs_rejected++;
 		setAutoClusterRejected( m_current_auto_cluster_id );
 		nextJob();
 		break;
+	}
 
 	case SEND_JOB_INFO:
+		m_num_resource_reqs_sent = 0;  // clear counter of reqs sent this round
 		if( !sendJobInfo(sock) ) {
 				// We failed to talk to the negotiator, so close the socket.
 			return MESSAGE_FINISHED;
 		}
 		break;
 
+	case SEND_RESOURCE_REQUEST_LIST:
+		m_num_resource_reqs_sent = 0; // clear counter of reqs sent this round
+		if( !sendResourceRequestList(sock) ) {
+				// We failed to talk to the negotiator, so close the socket.
+			return MESSAGE_FINISHED;
+		}
+		break;
+
 	case PERMISSION_AND_AD: {
 
-		// If the slot we matched is partitionable, edit it
-		// so it will look like the resulting dynamic slot. 
-		// NOTE: Seems like we no longer need to do this here,
-		// since we also do the fixup at claim time in
-		// contactStartd().  - Todd 1/12 <tannenba@cs.wisc.edu>
-		if( !fixupPartitionableSlot(&m_current_job_ad,&m_match_ad) )
-		{
-			nextJob();
-			break;
+		// When using request lists, one single
+		// "m_current_job_id" is kinda meaningless if we just sent a whole
+		// pile of jobs to the negotiator.  So we want to 
+		// reset m_current_job_id with the job id info embedded in the offer 
+		// that comes back from the negotiator (if it exists).  This will
+		// happen with an 8.3.0+ negotiator, and is needed when using
+		// resource request lists.  
+		int rr_cluster = -1;
+		int rr_proc = -1;
+		m_match_ad.LookupInteger(ATTR_RESOURCE_REQUEST_CLUSTER, rr_cluster);
+		m_match_ad.LookupInteger(ATTR_RESOURCE_REQUEST_PROC, rr_proc);
+		if (rr_cluster != -1 && rr_proc != -1) {
+			if (rr_cluster != m_current_job_id.cluster || rr_proc != m_current_job_id.proc) {
+				m_current_resources_delivered = 0;
+			}
+			m_current_job_id.cluster = rr_cluster;
+			m_current_job_id.proc = rr_proc;
 		}
 
 		m_current_resources_delivered++;
@@ -374,10 +509,11 @@ ScheddNegotiate::messageReceived( DCMessenger *messenger, Sock *sock )
 
 		m_negotiation_finished = true;
 		break;
+
 	default:
 		EXCEPT("should never get here (negotiation op %d)",m_operation);
-	}
 
+	} // end of switch on m_operation
 
 	if( m_negotiation_finished ) {
 			// the following function takes ownership of sock
@@ -424,12 +560,21 @@ ScheddNegotiate::readMsg( DCMessenger * /*messenger*/, Sock *sock )
 			return false;
 		}
 		break;
+
 	case REJECTED:
 		break;
 
 	case SEND_JOB_INFO:
 		break;
 
+	case SEND_RESOURCE_REQUEST_LIST:
+		if( !sock->code(m_num_resource_reqs_to_send) ) {
+			dprintf( D_ALWAYS,
+					 "Can't receive num_resource_reqs_to_send from negotiator\n" );
+			return false;
+		}
+		break;
+
 	case PERMISSION:
 			// No negotiator since 7.1.3 should ever send this
 			// command, and older ones should not send it either,
diff --git a/src/condor_schedd.V6/schedd_negotiate.h b/src/condor_schedd.V6/schedd_negotiate.h
index 81b1a7c..21417cc 100644
--- a/src/condor_schedd.V6/schedd_negotiate.h
+++ b/src/condor_schedd.V6/schedd_negotiate.h
@@ -157,11 +157,14 @@ class ScheddNegotiate: public DCMsg {
 	int m_jobs_rejected;
 	int m_jobs_matched;
 
+	int m_num_resource_reqs_sent; // used when sending a resource request list
+	int m_num_resource_reqs_to_send; // used when sending a resource request list
+
 	bool m_negotiation_finished;
 
 		// data in message received from negotiator
 	int m_operation;             // the negotiation operation
-	std::string m_reject_reason; // why the job was rejected
+	MyString m_reject_reason; // why the job was rejected
 	std::string m_claim_id;      // the string "null" if none
 	ClassAd m_match_ad;          // the machine we matched to
 
@@ -175,7 +178,9 @@ class ScheddNegotiate: public DCMsg {
 		// marks the specified cluster as rejected
 	void setAutoClusterRejected(int auto_cluster_id);
 
-	bool sendJobInfo(Sock *sock);
+	bool sendJobInfo(Sock *sock, bool just_sig_attrs=false);
+
+	bool sendResourceRequestList(Sock *sock);
 
 		/////////////// DCMsg hooks ///////////////
 
diff --git a/src/condor_schedd.V6/schedd_stats.cpp b/src/condor_schedd.V6/schedd_stats.cpp
index 2343ee4..c9afe69 100644
--- a/src/condor_schedd.V6/schedd_stats.cpp
+++ b/src/condor_schedd.V6/schedd_stats.cpp
@@ -120,6 +120,7 @@ void ScheddStatistics::Init(int fOtherPool)
 
    SCHEDD_STATS_ADD_RECENT(Pool, JobsAccumTimeToStart, if_poolbasic);
    SCHEDD_STATS_ADD_RECENT(Pool, JobsAccumBadputTime,  if_poolbasic);
+   SCHEDD_STATS_ADD_RECENT(Pool, JobsAccumExceptionalBadputTime,  if_poolbasic);
    SCHEDD_STATS_ADD_RECENT(Pool, JobsAccumRunningTime, if_poolbasic);
    SCHEDD_STATS_ADD_RECENT(Pool, JobsAccumExecuteTime, if_poolbasic);
    SCHEDD_STATS_ADD_RECENT(Pool, JobsAccumPreExecuteTime,  if_poolbasic);
@@ -149,6 +150,7 @@ void ScheddStatistics::Init(int fOtherPool)
    SCHEDD_STATS_ADD_RECENT(Pool, JobsCompletedRuntimes,     if_poolbasic);
    SCHEDD_STATS_ADD_RECENT(Pool, JobsBadputRuntimes,        if_poolbasic);
 
+   SCHEDD_STATS_ADD_VAL(Pool, JobsRunning,                  if_poolbasic);
    SCHEDD_STATS_ADD_VAL(Pool, JobsRunningSizes,             if_poolbasic);
    SCHEDD_STATS_ADD_VAL(Pool, JobsRunningRuntimes,          if_poolbasic);
 
@@ -451,6 +453,39 @@ void ScheddOtherStatsMgr::CountJobsSubmitted()
 	deferred_jobs_submitted.clear();
 }
 
+// reset jobs-running counters/histograms in preparation for count_jobs
+void ScheddOtherStatsMgr::ResetJobsRunning()
+{
+	ScheddOtherStats* po = NULL;
+	pools.startIterations();
+	while (pools.iterate(po)) {
+
+		// don't bother to reset disabled stats.
+		if ( ! po->enabled)
+			continue;
+
+		po->stats.JobsRunning = 0;
+		po->stats.JobsRunningRuntimes = 0;
+		po->stats.JobsRunningSizes = 0;
+
+		if (po->sets.empty())
+			continue;
+
+		for (std::map<std::string, ScheddOtherStats*>::iterator it = po->sets.begin();
+				it != po->sets.end();
+				++it) {
+
+			ScheddOtherStats* po2 = it->second;
+			if (po2->enabled) {
+				po2->stats.JobsRunning = 0;
+				po2->stats.JobsRunningRuntimes = 0;
+				po2->stats.JobsRunningSizes = 0;
+			}
+		}
+	}
+}
+
+
 
 /* don't use these.
 void ScheddOtherStatsMgr::SetWindowSize(int window)
diff --git a/src/condor_schedd.V6/schedd_stats.h b/src/condor_schedd.V6/schedd_stats.h
index 133742f..3f6b7e8 100644
--- a/src/condor_schedd.V6/schedd_stats.h
+++ b/src/condor_schedd.V6/schedd_stats.h
@@ -46,6 +46,7 @@ typedef struct ScheddStatistics {
    stats_entry_recent<time_t> JobsAccumTimeToStart; // sum of all time jobs spent waiting to start
    stats_entry_recent<time_t> JobsAccumRunningTime; // sum of all time jobs spent running.
    stats_entry_recent<time_t> JobsAccumBadputTime;  // sum of all time jobs spent running badput
+   stats_entry_recent<time_t> JobsAccumExceptionalBadputTime;  // sum of all time jobs spent running badput and the shadow excepted
    stats_entry_recent<time_t> JobsAccumExecuteTime;  // sum of all time jobs spent executing the user code ((reap - start) - (pre + post))
    stats_entry_recent<time_t> JobsAccumPreExecuteTime;  // sum of all time jobs spent transferring input   (max(0, exec - start))
    stats_entry_recent<time_t> JobsAccumPostExecuteTime; // sum of all time jobs spent transferring output  (max(0, reap - post))
@@ -84,6 +85,7 @@ typedef struct ScheddStatistics {
    stats_entry_recent_histogram<time_t> JobsCompletedRuntimes;
    stats_entry_recent_histogram<time_t> JobsBadputRuntimes;
 
+   stats_entry_abs<int> JobsRunning; // number of running jobs, counted so that we can do BY_* and FOR_* counters
    stats_histogram<int64_t> JobsRunningSizes;
    stats_histogram<time_t>  JobsRunningRuntimes;
 
@@ -149,6 +151,7 @@ public:
    bool AnyEnabled();
    void DeferJobsSubmitted(int cluster, int proc);
    void CountJobsSubmitted(); // finish deferred counting of submitted jobs.
+   void ResetJobsRunning(); // reset jobs-running counters/histograms in preparation for count_jobs
 
    // returns a linked list of matches, and sets the last_incr_time of each to updateTime
    ScheddOtherStats * Matches(ClassAd & ad, time_t updateTime);
diff --git a/src/condor_schedd.V6/scheduler.h b/src/condor_schedd.V6/scheduler.h
index b659caa..bebd1dd 100644
--- a/src/condor_schedd.V6/scheduler.h
+++ b/src/condor_schedd.V6/scheduler.h
@@ -338,7 +338,7 @@ class Scheduler : public Service
 	void			send_all_jobs_prioritized(ReliSock*, struct sockaddr_in*);
 
 	friend	int		NewProc(int cluster_id);
-	friend	int		count(ClassAd *);
+	friend	int		count_a_job(ClassAd *);
 	friend	void	job_prio(ClassAd *);
 	friend  int		find_idle_local_jobs(ClassAd *);
 	friend	int		updateSchedDInterval( ClassAd* );
diff --git a/src/condor_shadow.std/pseudo_ops.cpp b/src/condor_shadow.std/pseudo_ops.cpp
index ae8056b..42a7633 100644
--- a/src/condor_shadow.std/pseudo_ops.cpp
+++ b/src/condor_shadow.std/pseudo_ops.cpp
@@ -1041,9 +1041,6 @@ int
 create_tcp_port( unsigned int *ip, u_short *port, int *fd )
 {
     struct sockaddr_in  sin;
-    SOCKET_LENGTH_TYPE  addr_len;
-   
-    addr_len = sizeof(sin);
 
         /* create a tcp socket */
     if( (*fd=socket(AF_INET,SOCK_STREAM,0)) < 0 ) {
diff --git a/src/condor_startd.V6/ResMgr.cpp b/src/condor_startd.V6/ResMgr.cpp
index 8715967..c71d148 100644
--- a/src/condor_startd.V6/ResMgr.cpp
+++ b/src/condor_startd.V6/ResMgr.cpp
@@ -736,8 +736,15 @@ ResMgr::adlist_register( StartdNamedClassAd *ad )
 	return extra_ads.Register( ad );
 }
 
+StartdNamedClassAd *
+ResMgr::adlist_find( const char * name )
+{
+	NamedClassAd * nad = extra_ads.Find(name);
+	return dynamic_cast<StartdNamedClassAd*>(nad);
+}
+
 int
-ResMgr::adlist_replace( const char *name, const char *prefix, ClassAd *newAd, bool report_diff )
+ResMgr::adlist_replace( const char *name, ClassAd *newAd, bool report_diff, const char *prefix )
 {
 	if( report_diff ) {
 		StringList ignore_list;
@@ -751,11 +758,6 @@ ResMgr::adlist_replace( const char *name, const char *prefix, ClassAd *newAd, bo
 	}
 }
 
-int
-ResMgr::adlist_delete( const char *name )
-{
-	return extra_ads.Delete( name );
-}
 
 int
 ResMgr::adlist_publish( unsigned r_id, ClassAd *resAd, amask_t mask )
diff --git a/src/condor_startd.V6/ResMgr.h b/src/condor_startd.V6/ResMgr.h
index 18ba8ae..daeb310 100644
--- a/src/condor_startd.V6/ResMgr.h
+++ b/src/condor_startd.V6/ResMgr.h
@@ -174,9 +174,12 @@ public:
 
 	// Manipulate the supplemental Class Ad list
 	int		adlist_register( StartdNamedClassAd *ad );
-	int		adlist_replace( const char *name, const char *prefix, ClassAd *ad, 
-							bool report_diff = false );
-	int		adlist_delete( const char *name );
+	StartdNamedClassAd* adlist_find( const char *name );
+	int		adlist_replace( const char *name, ClassAd *ad) { return extra_ads.Replace( name, ad ); }
+	int		adlist_replace( const char *name, ClassAd *ad, bool report_diff, const char *prefix);
+	int		adlist_delete( const char *name ) { return extra_ads.Delete( name ); }
+	int		adlist_delete( StartdCronJob * job ) { return extra_ads.DeleteJob( job ); }
+	int		adlist_clear( StartdCronJob * job )  { return extra_ads.ClearJob( job ); } // delete child ads, and clear the base job ad
 	int		adlist_publish( unsigned r_id, ClassAd *resAd, amask_t mask );
 
 	// Methods to control various timers
diff --git a/src/condor_startd.V6/Starter.cpp b/src/condor_startd.V6/Starter.cpp
index 4f72f81..5bd3762 100644
--- a/src/condor_startd.V6/Starter.cpp
+++ b/src/condor_startd.V6/Starter.cpp
@@ -28,7 +28,6 @@
 #include "condor_common.h"
 #include "startd.h"
 #include "classad_merge.h"
-#include "dynuser.h"
 #include "condor_auth_x509.h"
 #include "setenv.h"
 #include "my_popen.h"
@@ -42,10 +41,6 @@
 #include "glexec_starter.linux.h"
 #endif
 
-#ifdef WIN32
-extern dynuser *myDynuser;
-#endif
-
 Starter::Starter()
 {
 	s_ad = NULL;
diff --git a/src/condor_startd.V6/startd.h b/src/condor_startd.V6/startd.h
index 8c14600..1684a8c 100644
--- a/src/condor_startd.V6/startd.h
+++ b/src/condor_startd.V6/startd.h
@@ -37,7 +37,6 @@
 #include "condor_string.h"
 #include "string_list.h"
 #include "MyString.h"
-#include "get_full_hostname.h"
 #include "condor_random_num.h"
 #include "../condor_procapi/procapi.h"
 //#include "misc_utils.h"
diff --git a/src/condor_startd.V6/startd_bench_job.cpp b/src/condor_startd.V6/startd_bench_job.cpp
index f19d930..c2e6ddf 100644
--- a/src/condor_startd.V6/startd_bench_job.cpp
+++ b/src/condor_startd.V6/startd_bench_job.cpp
@@ -44,8 +44,8 @@ StartdBenchJob::Initialize( void )
 }
 
 int
-StartdBenchJob::Publish( const char *ad_name, ClassAd *ad )
+StartdBenchJob::Publish( const char *ad_name, const char * /*args*/, ClassAd *ad )
 {
-	resmgr->adlist_replace( ad_name, GetPrefix(), ad, false );
+	resmgr->adlist_replace( ad_name, ad );
 	return 0;
 }
diff --git a/src/condor_startd.V6/startd_bench_job.h b/src/condor_startd.V6/startd_bench_job.h
index a6dab8e..306eefa 100644
--- a/src/condor_startd.V6/startd_bench_job.h
+++ b/src/condor_startd.V6/startd_bench_job.h
@@ -32,7 +32,7 @@ class StartdBenchJob: public StartdCronJob
 	int Initialize( void );
 
   private:
-	int Publish( const char *name, ClassAd *ad );
+	int Publish( const char *name, const char *args, ClassAd *ad );
 };
 
 #endif /* _STARTD_BENCH_JOB_H */
diff --git a/src/condor_startd.V6/startd_cron_job.cpp b/src/condor_startd.V6/startd_cron_job.cpp
index 80de36b..e249ec9 100644
--- a/src/condor_startd.V6/startd_cron_job.cpp
+++ b/src/condor_startd.V6/startd_cron_job.cpp
@@ -24,22 +24,22 @@
 #include "startd_named_classad.h"
 #include "startd_named_classad_list.h"
 #include "startd_cron_job.h"
+#include "match_prefix.h"
 
 StartdCronJob::StartdCronJob( ClassAdCronJobParams *params,
 							  CronJobMgr &mgr )
-		: ClassAdCronJob( params, mgr ),
-		  m_named_ad( NULL )
+		: ClassAdCronJob( params, mgr )
 {
 	// Register it with the Resource Manager
-	m_named_ad = new StartdNamedClassAd( GetName(), *this );
-	resmgr->adlist_register( m_named_ad );
+	StartdNamedClassAd * ad = new StartdNamedClassAd( GetName(), *this );
+	resmgr->adlist_register( ad );
 }
 
 // StartdCronJob destructor
 StartdCronJob::~StartdCronJob( void )
 {
 	// Delete myself from the resource manager
-	resmgr->adlist_delete( GetName() );
+	resmgr->adlist_delete( this );
 }
 
 int
@@ -50,24 +50,76 @@ StartdCronJob::Initialize( void )
 }
 
 int
-StartdCronJob::Publish( const char *ad_name, ClassAd *ad )
+StartdCronJob::Publish( const char *ad_name, const char *args, ClassAd *ad )
 {
 		// first, update the ad in the ResMgr, so we have the new
 		// values.  we only want to do the (somewhat expensive)
 		// operation of reportind a diff if we care about that.
-	bool report_diff = false;
 	CronAutoPublish_t auto_publish = cron_job_mgr->getAutoPublishValue();
-	if( auto_publish == CAP_IF_CHANGED ) { 
-		report_diff = true;
+	bool wants_update = false;
+
+		// if args isn't NULL, then we may have a uniqueness tag for the ad and/or publication arguments
+	MyString tagged_name;
+	if (args) {
+		StringList arglist(args);
+		arglist.rewind();
+		const char * arg = arglist.next();
+		// the first token may be a uniqueness tag for the ad, but not if it contains a :
+		if (arg && ! strchr(arg, ':')) {
+			tagged_name.formatstr("%s.%s", ad_name, arg);
+			ad_name = tagged_name.c_str();
+		} else {
+			// if first arg had a : it's not a tag, so we want to re-parse it as an argument.
+			arglist.rewind();
+		}
+		while ((arg = arglist.next())) {
+			const char * pcolon = NULL;
+			if (is_arg_colon_prefix(arg, "update", &pcolon, -1)) {
+				wants_update = true; // update without arg means true
+				if ( ! pcolon || string_is_boolean_param(pcolon+1, wants_update, ad)) {
+					auto_publish = CAP_NEVER; // No point in checking for differences
+				}
+			}
+		}
+	}
+
+		// can't use adlist_replace here because it can't easily insert
+		// new ads that point back to this class
+		// so we replicate the relevent bits of adlist_replace here.
+	int rval = 0; // set to 1 to indicate the ad has changed.
+	StartdNamedClassAd * sad = resmgr->adlist_find( ad_name );
+	if ( ! sad ) {
+		sad = new StartdNamedClassAd( ad_name, *this, ad );
+		// maybe we should be inserting this after the base ad for this cron job?
+		dprintf( D_FULLDEBUG, "Adding '%s' to the 'extra' ClassAd list\n", ad_name );
+		resmgr->adlist_register( sad );
+		rval = 1; // a new ad is a changed ad
+	} else {
+		// found the ad, now we want to update it, and possbly check for changes in the update
+		dprintf( D_FULLDEBUG, "Replacing ClassAd for '%s'\n", ad_name );
+		if (CAP_IF_CHANGED == auto_publish) {
+			ClassAd* oldAd = sad->GetAd();
+			if ( ! oldAd) {
+				rval = 1; // a new ad is a changed ad
+			} else {
+				MyString ignore(GetPrefix()); ignore += "LastUpdate";
+				StringList ignore_list(ignore.c_str());
+				rval =  ! ClassAdsAreSame(ad, oldAd, &ignore_list);
+			}
+		}
+		sad->ReplaceAd(ad);
 	}
-	int rval = resmgr->adlist_replace( ad_name, GetPrefix(), ad, report_diff );
 
 		// now, figure out if we need to update the collector based on
 		// the startd_cron_autopublish stuff and if the ad changed...
-	bool wants_update = false;
+
 	switch( auto_publish ) {
 	case CAP_NEVER:
-		return rval;
+		//  wants_update will be already be set to false unless set to true by the script itself.
+		if (wants_update) {
+			dprintf( D_FULLDEBUG, "StartdCronJob::Publish() updating collector "
+					 "[script '%s' requested update]\n", ad_name );
+		}
 		break;
 
 	case CAP_ALWAYS:
diff --git a/src/condor_startd.V6/startd_cron_job.h b/src/condor_startd.V6/startd_cron_job.h
index 2e4f71d..ce104e1 100644
--- a/src/condor_startd.V6/startd_cron_job.h
+++ b/src/condor_startd.V6/startd_cron_job.h
@@ -37,8 +37,7 @@ class StartdCronJob: public ClassAdCronJob
 	};
 
   private:
-	StartdNamedClassAd	*m_named_ad;
-	int Publish( const char *name, ClassAd *ad );
+	int Publish( const char *name, const char * sep_args, ClassAd *ad );
 };
 
 #endif /* _STARTD_CRON_JOB_H */
diff --git a/src/condor_startd.V6/startd_named_classad.cpp b/src/condor_startd.V6/startd_named_classad.cpp
index 3a9e3d9..66b6b58 100644
--- a/src/condor_startd.V6/startd_named_classad.cpp
+++ b/src/condor_startd.V6/startd_named_classad.cpp
@@ -26,13 +26,93 @@
 
 // Named classAds
 StartdNamedClassAd::StartdNamedClassAd( const char *name,
-										StartdCronJob &job)
-		: NamedClassAd( name, NULL ), m_job( job )
+										StartdCronJob &job,
+										ClassAd * ad /*=NULL*/)
+		: NamedClassAd( name, ad ), m_job( job )
 {
 }
 
+// attributes that are defined only for StartdNamedClassAds (i.e STARTD_CRON ads)
+//
+#define ATTR_SLOT_NAME "SlotName"
+#define ATTR_SLOT_MERGE_CONSTRAINT "SlotMergeConstraint"
+
+// initialize the list of attributes that should never be merged from a STARTD_CRON script output
+// into the slot ad.  It's more efficient if these are sorted.
+static const char * const dont_merge_these[] = {
+	ATTR_NAME,
+	ATTR_SLOT_ID,
+	ATTR_SLOT_MERGE_CONSTRAINT,
+	ATTR_SLOT_NAME,
+	ATTR_SLOT_TYPE_ID,
+};
+AttrNameSet StartdNamedClassAd::dont_merge_attrs(dont_merge_these, dont_merge_these+(sizeof(dont_merge_these)/sizeof(const char *)));
+
 bool
 StartdNamedClassAd::InSlotList( unsigned slot_id ) const
 {
 	return m_job.Params().InSlotList( slot_id );
 }
+
+
+bool
+StartdNamedClassAd::ShouldMergeInto(ClassAd * merge_into, const char ** pattr_used)
+{
+	if (pattr_used) *pattr_used = NULL;
+
+	ClassAd * merge_from = this->GetAd();
+	if ( ! merge_from || ! merge_into)
+		return false;
+
+	// if there is a SlotMergeContraint in the source, then merge into slots for which the
+	// constraint evaluates to true
+	if (merge_from->Lookup(ATTR_SLOT_MERGE_CONSTRAINT)) {
+		int matches = false;
+		if (merge_from->EvalBool(ATTR_SLOT_MERGE_CONSTRAINT, merge_into, matches)) {
+			if (pattr_used) *pattr_used = ATTR_SLOT_MERGE_CONSTRAINT;
+			return matches;
+		}
+	}
+
+	// if there is a "Name" or "SlotName" attribute in the source, then merge into slots
+	// whose name matches it as a prefix.  (i.e. if merge_from("Name") is "xfer", the merge into all slots
+	// whose name starts with "xfer".  this is most useful if you use SLOT_TYPE_n_NAME_PREFIX to name slots.
+	std::string from_str, to_str;
+	if ( ( merge_from->LookupString(ATTR_SLOT_NAME, from_str) ||
+		   merge_from->LookupString(ATTR_NAME, from_str))
+		&& merge_into->LookupString(ATTR_NAME, to_str))
+	{
+		if (from_str.length() > 0) {
+			if (pattr_used) *pattr_used = merge_from->Lookup(ATTR_SLOT_NAME) ? ATTR_SLOT_NAME : ATTR_NAME;
+			return starts_with(to_str, from_str);
+		}
+	}
+
+	// if there is a "SlotTypeId" attribute, merge into slots with the same type id.
+	int from_id, to_id;
+	if (merge_from->LookupInteger(ATTR_SLOT_TYPE_ID, from_id) &&
+		merge_into->LookupInteger(ATTR_SLOT_TYPE_ID, to_id)) {
+		if (pattr_used) *pattr_used = ATTR_SLOT_TYPE_ID;
+		return from_id == to_id;
+	}
+
+	// if there is a "SlotId" attribute, merge into slots with the same type id.
+	if (merge_from->LookupInteger(ATTR_SLOT_ID, from_id) &&
+		merge_into->LookupInteger(ATTR_SLOT_ID, to_id)) {
+		if (pattr_used) *pattr_used = ATTR_SLOT_ID;
+		return from_id == to_id;
+	}
+
+	return true;
+}
+
+bool
+StartdNamedClassAd::MergeInto(ClassAd *merge_into)
+{
+	ClassAd * merge_from = this->GetAd();
+	if ( ! merge_into || ! merge_from)
+		return false;
+
+	int cMerged = MergeClassAdsIgnoring(merge_into, merge_from, this->dont_merge_attrs);
+	return cMerged > 0;
+}
diff --git a/src/condor_startd.V6/startd_named_classad.h b/src/condor_startd.V6/startd_named_classad.h
index 37996c3..be9816d 100644
--- a/src/condor_startd.V6/startd_named_classad.h
+++ b/src/condor_startd.V6/startd_named_classad.h
@@ -28,11 +28,16 @@ class StartdCronJob;
 class StartdNamedClassAd : public NamedClassAd
 {
   public:
-	StartdNamedClassAd( const char *name, StartdCronJob &job );
+	StartdNamedClassAd( const char *name, StartdCronJob &job, ClassAd * ad = NULL );
 	~StartdNamedClassAd( void ) { };
 	bool InSlotList( unsigned slot ) const;
+	StartdNamedClassAd * NewPeer( const char * name, ClassAd * ad = NULL ) { return new StartdNamedClassAd(name, m_job, ad); }
+	bool IsJob(StartdCronJob * job) const { return &m_job == job; }
+	bool ShouldMergeInto(ClassAd * merge_into, const char ** pattr_used);
+	bool MergeInto(ClassAd *merge_to);
 
   private:
+	static AttrNameSet dont_merge_attrs;
 	StartdCronJob	&m_job;
 };
 
diff --git a/src/condor_startd.V6/startd_named_classad_list.cpp b/src/condor_startd.V6/startd_named_classad_list.cpp
index 6b105e1..2445b9e 100644
--- a/src/condor_startd.V6/startd_named_classad_list.cpp
+++ b/src/condor_startd.V6/startd_named_classad_list.cpp
@@ -32,6 +32,84 @@ StartdNamedClassAdList::StartdNamedClassAdList( void )
 {
 }
 
+// virtual method so that NamedClassAdList can create a new StartdNamedClassAd if needed.
+//
+NamedClassAd * StartdNamedClassAdList::New( const char * name, ClassAd * ad)
+{
+	StartdNamedClassAd * sad = NULL;
+	const char * pdot = strchr(name, '.');
+	if (pdot) {
+		// tj: its a bit of a hack, but for now, we look for an existing named ad
+		// that matches the new ad's basename (i.e. everthing before the first '.')
+		// then we ask the existing ad to create a new ad that shares it's job object.
+		// this works because the CronJob will always register the basename in this list.
+		//
+		std::string pre(name);
+		pre[pdot-name] = 0;
+		NamedClassAd * nad = Find(pre.c_str());
+		sad = dynamic_cast<StartdNamedClassAd*>(nad);
+		if (sad) {
+			sad = sad->NewPeer(name, ad);
+		}
+	}
+	ASSERT(sad);
+	return sad;
+}
+
+int
+StartdNamedClassAdList::DeleteJob( StartdCronJob * job )
+{
+	bool no_match = 1;
+
+	std::list<NamedClassAd *>::iterator iter = m_ads.begin();
+	while (iter != m_ads.end())
+	{
+		NamedClassAd * nad = *iter;
+		StartdNamedClassAd *sad = dynamic_cast<StartdNamedClassAd *>(nad);
+		if ( sad && sad->IsJob (job) )
+		{
+			no_match = 0;
+			iter = m_ads.erase(iter);
+			delete nad;
+		} else {
+			++iter;
+		}
+	}
+
+	// No match found; done
+	return no_match;
+}
+
+int
+StartdNamedClassAdList::ClearJob ( StartdCronJob * job )
+{
+	bool no_match = 1;
+
+	std::list<NamedClassAd *>::iterator iter = m_ads.begin();
+	while (iter != m_ads.end())
+	{
+		NamedClassAd * nad = *iter;
+		StartdNamedClassAd *sad = dynamic_cast<StartdNamedClassAd *>(nad);
+		if ( sad && sad->IsJob (job) )
+		{
+			no_match = 0;
+			if (  ! strcmp(sad->GetName(), job->GetName()) ) {
+				sad->ReplaceAd(NULL);
+				++iter;
+			} else {
+				iter = m_ads.erase(iter);
+				delete nad;
+			}
+		} else {
+			++iter;
+		}
+	}
+
+	// No match found; done
+	return no_match;
+}
+
+
 bool
 StartdNamedClassAdList::Register( StartdNamedClassAd *ad )
 {
@@ -47,15 +125,21 @@ StartdNamedClassAdList::Publish( ClassAd *merged_ad, unsigned r_id )
 		NamedClassAd		*nad = *iter;
 		StartdNamedClassAd	*sad = dynamic_cast<StartdNamedClassAd*>(nad);
 		ASSERT( sad );
-		if ( sad->InSlotList(r_id) ) {
+		const char * match_attr = NULL;
+		if ( sad->InSlotList(r_id) && sad->ShouldMergeInto(merged_ad, &match_attr) ) {
 			ClassAd	*ad = nad->GetAd( );
 			if ( NULL != ad ) {
 				dprintf( D_FULLDEBUG,
-						 "Publishing ClassAd for '%s' to slot %d\n",
-						 nad->GetName(), r_id );
-				MergeClassAds( merged_ad, ad, true );
+						 "Publishing ClassAd '%s' to slot %d [%s matches]\n",
+						 nad->GetName(), r_id, match_attr ? match_attr : "InSlotList" );
+				sad->MergeInto(merged_ad);
 			}
 		}
+		else if (match_attr) {
+			dprintf( D_FULLDEBUG,
+						"Rejecting ClassAd '%s' for slot %d [%s does not match]\n",
+						nad->GetName(), r_id, match_attr );
+		}
 	}
 
 	// Done
diff --git a/src/condor_startd.V6/startd_named_classad_list.h b/src/condor_startd.V6/startd_named_classad_list.h
index 90ae143..3e5c96f 100644
--- a/src/condor_startd.V6/startd_named_classad_list.h
+++ b/src/condor_startd.V6/startd_named_classad_list.h
@@ -33,6 +33,9 @@ class StartdNamedClassAdList : public NamedClassAdList
 
 	bool Register( StartdNamedClassAd *ad );
 	int	Publish( ClassAd *ad, unsigned r_id );
+	int DeleteJob ( StartdCronJob * job );
+	int ClearJob ( StartdCronJob * job );
+	virtual NamedClassAd * New( const char *name, ClassAd *ad = NULL );
 };
 
 #endif
diff --git a/src/condor_starter.V6.1/vanilla_proc.cpp b/src/condor_starter.V6.1/vanilla_proc.cpp
index 628772c..dd5c330 100644
--- a/src/condor_starter.V6.1/vanilla_proc.cpp
+++ b/src/condor_starter.V6.1/vanilla_proc.cpp
@@ -28,7 +28,6 @@
 #include "vanilla_proc.h"
 #include "starter.h"
 #include "syscall_numbers.h"
-#include "dynuser.h"
 #include "condor_config.h"
 #include "domain_tools.h"
 #include "classad_helpers.h"
@@ -40,7 +39,6 @@
 
 #ifdef WIN32
 #include "executable_scripts.WINDOWS.h"
-extern dynuser* myDynuser;
 #endif
 
 #if defined(HAVE_EVENTFD)
diff --git a/src/condor_starter.std/starter_main.cpp b/src/condor_starter.std/starter_main.cpp
index a4e06fc..5671acd 100644
--- a/src/condor_starter.std/starter_main.cpp
+++ b/src/condor_starter.std/starter_main.cpp
@@ -821,20 +821,11 @@ int
 supervise_all()
 {
 	UserProc	*proc;
-	int			periodic_checkpointing = FALSE;
 	static Transition	*tr = 0;
 
 
 	// dprintf( D_ALWAYS, "Entering function supervise_all()\n" );
 
-	UProcList.Rewind();
-	while( (proc = UProcList.Next()) ) {
-		if( proc->ckpt_enabled() ) {
-			periodic_checkpointing = TRUE;
-			break;
-		}
-	}
-
 	if (tr == 0) {
 		tr = condor_starter_ptr->find_transition( ALARM );
 		if ( tr ) {
diff --git a/src/condor_status.V6/prettyPrint.cpp b/src/condor_status.V6/prettyPrint.cpp
index 80c172f..6b9fbce 100644
--- a/src/condor_status.V6/prettyPrint.cpp
+++ b/src/condor_status.V6/prettyPrint.cpp
@@ -79,11 +79,29 @@ static const char *formatLoadAvg (double, AttrList *, Formatter &);
 static void ppInit()
 {
 	pm.SetAutoSep(NULL, " ", NULL, "\n");
-	//pm.SetAutoSep(NULL, " (", ")", "\n");
+	//pm.SetAutoSep(NULL, " (", ")", "\n"); // for debugging, delimit the field data explicitly
 }
 
+#ifdef AD_PRINTMASK_V2
+enum ivfield {
+	BlankInvalidField = 0,
+	WideInvalidField = 1,
+	ShortInvalidField = 2,
+	CallInvalidField = 3,   // call the formatter function to generate invalid fields.  only valid when there is a format function.
+};
+class Lbl {
+public:
+	explicit Lbl(const char * ll) : m_lbl(ll) {};
+	operator const char*() const { return m_lbl; }
+private:
+	const char * m_lbl;
+};
+#else
 const char *StdInvalidField = "[?]"; // fill field with ??? surrounded by [], if 
+#endif
 
+#ifdef AD_PRINTMASK_V2
+#else
 // construct a string if the form "[????]" that is the given width
 // into the supplied buffer, output not to exceed max_buf, and
 // if the buffer or width is < 3, then return "?" instead of "[?]"
@@ -109,9 +127,11 @@ static const char * ppMakeFieldofQuestions(int width, char * buf, int buf_size)
 	return buf;
 }
 
+static const char *MinInvalidField = "[?]"; // fill field with ??? surrounded by [], if 
+
 static const char * ppMakeInvalidField(int width, const char * alt, char * buf, int buf_size)
 {
-	if (alt == StdInvalidField) {
+	if (alt == MinInvalidField) {
 		if (invalid_fields_empty) 
 			return "";
 		// make a field-width string of "[????]" for the alt string.
@@ -121,58 +141,101 @@ static const char * ppMakeInvalidField(int width, const char * alt, char * buf,
 	}
 	return alt;
 }
+#endif
 
-static void ppSetColumn(const char * label, const char * attr, int width, bool truncate, const char * alt)
-{
-	pm_head.Append(label ? label : attr);
+#ifdef AD_PRINTMASK_V2
 
+static int ppWidthOpts(int width, int truncate)
+{
 	int opts = FormatOptionAutoWidth;
 	if (0 == width) opts |= FormatOptionAutoWidth | FormatOptionNoTruncate;
 	else if ( ! truncate) opts |= FormatOptionAutoWidth | FormatOptionNoTruncate;
-
-	char altq[22];
-	alt = ppMakeInvalidField(width, alt, altq, sizeof(altq));
-
-	pm.registerFormat("%v", width, opts, attr, alt);
+	return opts;
 }
 
-static void ppSetColumn(const char * label, const char * attr, const char * fmt, bool truncate = true, const char * alt = NULL)
+static int ppAltOpts(ivfield alt)
 {
-	pm_head.Append(label ? label : attr);
-
-	int width = 0;
-	int opts = FormatOptionAutoWidth;
-	if (0 == width) opts |= FormatOptionAutoWidth | FormatOptionNoTruncate;
-	else if ( ! truncate) opts |= FormatOptionAutoWidth | FormatOptionNoTruncate;
-
-	char altq[22];
-	alt = ppMakeInvalidField(width, alt, altq, sizeof(altq));
-
-	pm.registerFormat(fmt, width, opts, attr, alt);
+	int opts = 0;
+	if (alt == WideInvalidField) {
+		if (!invalid_fields_empty) opts |= AltQuestion | AltWide;
+	} else if (alt == ShortInvalidField) {
+		if (!invalid_fields_empty) opts |= AltQuestion;
+	} else if (alt == CallInvalidField) {
+		opts |= FormatOptionAlwaysCall;
+	} else if (alt != BlankInvalidField) {
+		opts |= AltFixMe;
+	}
+	return opts;
 }
 
-#if 1
-
-static void ppSetColumn(const char * label, const char * attr, const CustomFormatFn & fmt, int width, bool truncate = true, const char * alt = NULL)
+static void ppSetColumnFormat(const char * print, int width, bool truncate, ivfield alt, const char * attr)
 {
-	pm_head.Append(label ? label : attr);
-
-	int opts = FormatOptionAutoWidth;
-	if (0 == width) opts |= FormatOptionAutoWidth | FormatOptionNoTruncate;
-	else if ( ! truncate) opts |= FormatOptionAutoWidth | FormatOptionNoTruncate;
+	int opts = ppWidthOpts(width, truncate) | ppAltOpts(alt);
+	pm.registerFormat(print, width, opts, attr);
+}
 
+static void ppSetColumnFormat(const CustomFormatFn & fmt, const char * print, int width, bool truncate, ivfield alt, const char * attr)
+{
+	int opts = ppWidthOpts(width, truncate) | ppAltOpts(alt);
 	if (width == 11 && fmt.IsNumber() && (fmt.Is(formatElapsedTime) || fmt.Is(formatRealTime))) {
 		opts |= FormatOptionNoPrefix;
 		width = 12;
 	}
+	pm.registerFormat(print, width, opts, fmt, attr);
+}
 
-	char altq[22];
-	alt = ppMakeInvalidField(width, alt, altq, sizeof(altq));
+// ------ helpers
+//
+static void ppSetColumn(const char * attr, const Lbl & label, int width, bool truncate, ivfield alt = WideInvalidField)
+{
+	pm_head.Append(label);
+	ppSetColumnFormat("%v", width, truncate, alt, attr);
+}
+static void ppSetColumn(const char * attr, int width, bool truncate, ivfield alt = WideInvalidField)
+{
+	pm_head.Append(attr);
+	ppSetColumnFormat("%v", width, truncate, alt, attr);
+}
 
-	pm.registerFormat(NULL, width, opts, fmt, attr, alt);
+
+static void ppSetColumn(const char * attr, const Lbl & label, const char * print, bool truncate, ivfield alt = WideInvalidField)
+{
+	pm_head.Append(label);
+	ppSetColumnFormat(print, 0, truncate, alt, attr);
+}
+static void ppSetColumn(const char * attr, const char * print, bool truncate, ivfield alt = WideInvalidField)
+{
+	pm_head.Append(attr);
+	ppSetColumnFormat(print, 0, truncate, alt, attr);
 }
 
-static void ppSetColumn(const char * label, const char * attr, const CustomFormatFn & fmt, const char * print, int width, bool truncate = true, const char * alt = NULL)
+
+static void ppSetColumn(const char * attr, const Lbl & label, const CustomFormatFn & fmt, int width, bool truncate, ivfield alt = WideInvalidField)
+{
+	pm_head.Append(label);
+	ppSetColumnFormat(fmt, NULL, width, truncate, alt, attr);
+}
+static void ppSetColumn(const char * attr, const CustomFormatFn & fmt, int width, bool truncate, ivfield alt = WideInvalidField)
+{
+	pm_head.Append(attr);
+	ppSetColumnFormat(fmt, NULL, width, truncate, alt, attr);
+}
+
+static void ppSetColumn(const char * attr, const Lbl & label, const CustomFormatFn & fmt, const char * print, int width, bool truncate = true, ivfield alt = WideInvalidField)
+{
+	pm_head.Append(label);
+	ppSetColumnFormat(fmt, print, width, truncate, alt, attr);
+}
+/* not currently used
+static void ppSetColumn(const char * attr, const CustomFormatFn & fmt, const char * print, int width, bool truncate = true, ivfield alt = WideInvalidField)
+{
+	pm_head.Append(attr);
+	ppSetColumnFormat(fmt, print, width, truncate, alt, attr);
+}
+*/
+#else
+
+static void ppSetColumn(const char * label, const char * attr, int width, bool truncate, const char * alt)
 {
 	pm_head.Append(label ? label : attr);
 
@@ -183,31 +246,26 @@ static void ppSetColumn(const char * label, const char * attr, const CustomForma
 	char altq[22];
 	alt = ppMakeInvalidField(width, alt, altq, sizeof(altq));
 
-	pm.registerFormat(print, width, opts, fmt, attr, alt);
+	pm.registerFormat("%v", width, opts, attr, alt);
 }
 
-#else
 
-static void ppSetColumn(const char * label, const char * attr, IntCustomFmt fmt, int width, bool truncate = true, const char * alt = NULL)
+static void ppSetColumn(const char * label, const char * attr, const char * fmt, bool truncate = true, const char * alt = NULL)
 {
 	pm_head.Append(label ? label : attr);
 
+	int width = 0;
 	int opts = FormatOptionAutoWidth;
 	if (0 == width) opts |= FormatOptionAutoWidth | FormatOptionNoTruncate;
 	else if ( ! truncate) opts |= FormatOptionAutoWidth | FormatOptionNoTruncate;
 
-	if (((fmt == formatElapsedTime) || (fmt == formatRealTime)) && (width == 11)) {
-		opts |= FormatOptionNoPrefix;
-		width = 12;
-	}
-
 	char altq[22];
 	alt = ppMakeInvalidField(width, alt, altq, sizeof(altq));
 
-	pm.registerFormat(NULL, width, opts, fmt, attr, alt);
+	pm.registerFormat(fmt, width, opts, attr, alt);
 }
 
-static void ppSetColumn(const char * label, const char * attr, StringCustomFmt fmt, int width, bool truncate = true, const char * alt = NULL)
+static void ppSetColumn(const char * label, const char * attr, const CustomFormatFn & fmt, int width, bool truncate = true, const char * alt = NULL)
 {
 	pm_head.Append(label ? label : attr);
 
@@ -215,13 +273,18 @@ static void ppSetColumn(const char * label, const char * attr, StringCustomFmt f
 	if (0 == width) opts |= FormatOptionAutoWidth | FormatOptionNoTruncate;
 	else if ( ! truncate) opts |= FormatOptionAutoWidth | FormatOptionNoTruncate;
 
+	if (width == 11 && fmt.IsNumber() && (fmt.Is(formatElapsedTime) || fmt.Is(formatRealTime))) {
+		opts |= FormatOptionNoPrefix;
+		width = 12;
+	}
+
 	char altq[22];
 	alt = ppMakeInvalidField(width, alt, altq, sizeof(altq));
 
 	pm.registerFormat(NULL, width, opts, fmt, attr, alt);
 }
 
-static void ppSetColumn(const char * label, const char * attr, FloatCustomFmt fmt, const char * print, int width, bool truncate = true, const char * alt = NULL)
+static void ppSetColumn(const char * label, const char * attr, const CustomFormatFn & fmt, const char * print, int width, bool truncate = true, const char * alt = NULL)
 {
 	pm_head.Append(label ? label : attr);
 
@@ -234,8 +297,10 @@ static void ppSetColumn(const char * label, const char * attr, FloatCustomFmt fm
 
 	pm.registerFormat(print, width, opts, fmt, attr, alt);
 }
+
 #endif
 
+
 static void ppDisplayHeadings(FILE* file, ClassAd *ad, const char * pszExtra)
 {
 	if (ad) {
@@ -392,406 +457,130 @@ prettyPrint (ClassAdList &adList, TrackTotals *totals)
 void
 printStartdAbsent (ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
-		ppSetColumn(0,ATTR_NAME, -34, ! wide_display, StdInvalidField);
-		ppSetColumn(0,ATTR_OPSYS, -10, true, StdInvalidField);
-		ppSetColumn(0,ATTR_ARCH, -10, true, StdInvalidField);
-		ppSetColumn("Went Absent", ATTR_LAST_HEARD_FROM, formatRealDate, -10, true);
-		ppSetColumn("Will Forget", ATTR_CLASSAD_LIFETIME, formatDueDate, -10, true);
+		ppSetColumn(ATTR_NAME, -34, ! wide_display);
+		ppSetColumn(ATTR_OPSYS, -10, true);
+		ppSetColumn(ATTR_ARCH, -10, true);
+		ppSetColumn(ATTR_LAST_HEARD_FROM, Lbl("Went Absent"), formatRealDate, -10, true);
+		ppSetColumn(ATTR_CLASSAD_LIFETIME, Lbl("Will Forget"), formatDueDate, -10, true);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-	static bool first = true;
-	static AttrListPrintMask alpm;
-	int    now;
-	int	   actvty;
-
-	if( ad ) {
-		if( first ) {
-			printf( "\n%-34.34s %-10.10s %-10.10s %-11.11s %-11.11s\n\n",
-				ATTR_NAME, ATTR_OPSYS, ATTR_ARCH,
-				"Went Absent", "Will Forget" );
-
-			alpm.registerFormat( "%-34.34s ", ATTR_NAME, "[???] " );
-			alpm.registerFormat( "%-10.10s " , ATTR_OPSYS, "[???] " );
-			alpm.registerFormat( "%-10.10s ", ATTR_ARCH, "[???] " );
-
-			first = false;
-			}
-
-		alpm.display( stdout, ad );
-
-		if( ad->LookupInteger( ATTR_LAST_HEARD_FROM, now ) ) {
-			printf( "%-11.11s", format_date( now ) );
-
-			if( ad->LookupInteger( ATTR_CLASSAD_LIFETIME, actvty ) ) {
-				printf( " %-11.11s", format_date( now + actvty ) );
-				}
-			}
-
-		printf( "\n" );
-		}
-	}
-#endif
 	return;
 }
 
 void
 printStartdNormal (ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
-		ppSetColumn(0, ATTR_NAME, wide_display ? -34 : -18, ! wide_display, StdInvalidField);
+		ppSetColumn(ATTR_NAME, wide_display ? -34 : -18, ! wide_display);
 
 		if (javaMode) {
-			ppSetColumn(0, ATTR_JAVA_VENDOR, -10, ! wide_display, StdInvalidField);
-			ppSetColumn("Ver", ATTR_JAVA_VERSION, -6, ! wide_display, StdInvalidField);
+			ppSetColumn(ATTR_JAVA_VENDOR, -10, ! wide_display);
+			ppSetColumn(ATTR_JAVA_VERSION, Lbl("Ver"), -6, ! wide_display);
 		} else if (vmMode) {
-			ppSetColumn("VmType", ATTR_VM_TYPE, -6, true, StdInvalidField);
-			ppSetColumn("Network", ATTR_VM_NETWORKING_TYPES, -9, true, StdInvalidField);
+			ppSetColumn(ATTR_VM_TYPE, Lbl("VmType"), -6, true);
+			ppSetColumn(ATTR_VM_NETWORKING_TYPES, Lbl("Network"), -9, true);
 		}else {
-			ppSetColumn(0, ATTR_OPSYS, -10, true, StdInvalidField);
-			ppSetColumn(0, ATTR_ARCH, -6, true, StdInvalidField);
+			ppSetColumn(ATTR_OPSYS, -10, true);
+			ppSetColumn(ATTR_ARCH, -6, true);
 		}
-		ppSetColumn(0, ATTR_STATE,    -9, true, StdInvalidField);
-		ppSetColumn(0, ATTR_ACTIVITY, -8, true, StdInvalidField);
+		ppSetColumn(ATTR_STATE,    -9, true);
+		ppSetColumn(ATTR_ACTIVITY, -8, true);
 
 		//ppSetColumn(0, ATTR_LOAD_AVG, "%.3f ", false, invalid_fields_empty ? "" : "[???] ");
 		//pm_head.Append(ATTR_LOAD_AVG);
 		//pm_head.Append(wide_display ? ATTR_LOAD_AVG : "LoadAv");
 		//pm.registerFormat("%.3f ", wide_display ? 7 : 6, FormatOptionAutoWidth, ATTR_LOAD_AVG, invalid_fields_empty ? "" : "[???] ");
-		ppSetColumn("LoadAv",ATTR_LOAD_AVG, formatLoadAvg, NULL, 6, true, StdInvalidField);
+		ppSetColumn(ATTR_LOAD_AVG, Lbl("LoadAv"), formatLoadAvg, NULL, 6, true);
 
 		if (vmMode) {
-			ppSetColumn("VMMem", ATTR_VM_MEMORY, "%4d", false, StdInvalidField);
+			ppSetColumn(ATTR_VM_MEMORY, Lbl("VMMem"), "%4d", false);
 		} else {
-			ppSetColumn("Mem", ATTR_MEMORY, "%4d", false, StdInvalidField);
+			ppSetColumn(ATTR_MEMORY, Lbl("Mem"), "%4d", false);
 		}
 		pm_head.Append(wide_display ? "ActivityTime" : "  ActvtyTime");
-		pm.registerFormat(NULL, 12, FormatOptionAutoWidth | (wide_display ? 0 : FormatOptionNoPrefix), formatActivityTime, ATTR_ENTERED_CURRENT_ACTIVITY, "   [Unknown]");
+		pm.registerFormat(NULL, 12, FormatOptionAutoWidth | (wide_display ? 0 : FormatOptionNoPrefix) | AltFixMe,
+			formatActivityTime, ATTR_ENTERED_CURRENT_ACTIVITY /* "   [Unknown]"*/);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-	static bool first = true;
-	static AttrListPrintMask alpm;
-	int    now;
-	int	   actvty;
-
-	const char *opsys_attr, *arch_attr, *mem_attr;
-	const char *opsys_name, *arch_name, *mem_name;
- 
-	mem_name = "Mem";
-	mem_attr = ATTR_MEMORY;
-
-    /* 
-     * The absent mode would share no more than four lines of code with
-     * the other two modes, so just handle it separately.
-     */
-    if( absentMode ) {
-        if( ad ) {
-            if( first ) {
-                printf( "\n%-34.34s %-10.10s %-10.10s %-11.11s %-11.11s\n\n",
-                        ATTR_NAME, ATTR_OPSYS, ATTR_ARCH,
-                        "Went Absent", "Will Forget" );
-
-                alpm.registerFormat( "%-34.34s ", ATTR_NAME, "[???] " );
-                alpm.registerFormat( "%-10.10s " , ATTR_OPSYS, "[???] " );
-                alpm.registerFormat( "%-10.10s ", ATTR_ARCH, "[???] " );
-
-                first = false;
-            }
-
-            alpm.display( stdout, ad );
-
-            if( ad->LookupInteger( ATTR_LAST_HEARD_FROM, now ) ) {
-                printf( "%-11.11s", format_date( now ) );
-
-                if( ad->LookupInteger( ATTR_CLASSAD_LIFETIME, actvty ) ) {
-                    printf( " %-11.11s", format_date( now + actvty ) );
-                }
-            }
-
-            printf( "\n" );
-        }
-
-        return;
-    }
-
-	if(javaMode) {
-		opsys_name = opsys_attr = ATTR_JAVA_VENDOR;
-		arch_name = "Ver";
-		arch_attr = ATTR_JAVA_VERSION;	
-	} else if(vmMode) {
-		// For vm universe, we will print ATTR_VM_MEMORY
-		// instead of ATTR_MEMORY
-		opsys_name = "VMType";
-		opsys_attr = ATTR_VM_TYPE;
-		arch_name = "Network";
-		arch_attr = ATTR_VM_NETWORKING_TYPES;
-		mem_name = "VMMem";
-		mem_attr = ATTR_VM_MEMORY;
-	} else {
-		opsys_name = opsys_attr = ATTR_OPSYS;
-		arch_name = arch_attr = ATTR_ARCH;
-	}
-
-	if (ad)
-	{
-		// print header if necessary
-		if (first)
-		{
-			if( vmMode ) {
-				printf ("\n%-18.18s %-6.6s %-10.10s %-9.9s %-8.8s %-6.6s "
-						"%-4.4s %-12.12s  %s\n\n",
-						ATTR_NAME, opsys_name, arch_name, ATTR_STATE, ATTR_ACTIVITY,
-						ATTR_LOAD_AVG, mem_name, "ActvtyTime", "VMNetworking");
-			}else {
-				printf ("\n%-18.18s %-10.10s %-6.6s %-9.9s %-8.8s %-6.6s "
-						"%-4.4s  %s\n\n",
-						ATTR_NAME, opsys_name, arch_name, ATTR_STATE, ATTR_ACTIVITY,
-						ATTR_LOAD_AVG, mem_name, "ActvtyTime");
-			}
-		
-			alpm.registerFormat("%-18.18s ", ATTR_NAME, "[????????????????] ");
-
-			if( vmMode ) {
-				alpm.registerFormat("%-6.6s " , opsys_attr, "[????] ");
-				alpm.registerFormat("%-10.10s " , arch_attr, "[????????] ");
-			}else {
-				alpm.registerFormat("%-10.10s " , opsys_attr, "[????????] ");
-				alpm.registerFormat("%-6.6s " , arch_attr, "[????] ");
-			}
-
-			alpm.registerFormat("%-9.9s ",  ATTR_STATE, "[???????] ");
-			alpm.registerFormat("%-8.8s ",  ATTR_ACTIVITY, "[??????] ");
-			alpm.registerFormat("%.3f  ",  ATTR_LOAD_AVG, "[???]  ");
-			alpm.registerFormat("%4d",  mem_attr, "[??]");
-
-			first = false;
-		}
-
-		alpm.display(stdout, ad);
-		if (ad->LookupInteger(ATTR_ENTERED_CURRENT_ACTIVITY, actvty)
-			&& (ad->LookupInteger(ATTR_MY_CURRENT_TIME, now) ||
-				ad->LookupInteger(ATTR_LAST_HEARD_FROM, now))) {
-			actvty = now - actvty;
-			printf("%s", format_time(actvty));
-		} else {
-			printf("   [Unknown]");
-		}
-
-		printf("\n");
-	}
-#endif
 }
 
 
 void
 printServer (ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
-		ppSetColumn(0,ATTR_NAME,    wide_display ? -34 : -13, ! wide_display, StdInvalidField);
-		ppSetColumn(0,ATTR_OPSYS,  -11, true, StdInvalidField);
-		ppSetColumn(0,ATTR_ARCH,    -6, true, StdInvalidField);
-		ppSetColumn("LoadAv",ATTR_LOAD_AVG, formatLoadAvg, NULL, 6, true, StdInvalidField);
-		ppSetColumn(0,ATTR_MEMORY, "%8d",  true, StdInvalidField);
-		ppSetColumn(0,ATTR_DISK, "%9d",  true, StdInvalidField);
-		ppSetColumn(0,ATTR_MIPS, "%7d", true, StdInvalidField);
-		ppSetColumn(0,ATTR_KFLOPS, "%9d", true, StdInvalidField);
+		ppSetColumn(ATTR_NAME,    wide_display ? -34 : -13, ! wide_display);
+		ppSetColumn(ATTR_OPSYS,  -11, true);
+		ppSetColumn(ATTR_ARCH,    -6, true);
+		ppSetColumn(ATTR_LOAD_AVG, Lbl("LoadAv"), formatLoadAvg, NULL, 6, true);
+		ppSetColumn(ATTR_MEMORY, "%8d",  true);
+		ppSetColumn(ATTR_DISK, "%9d",  true);
+		ppSetColumn(ATTR_MIPS, "%7d", true);
+		ppSetColumn(ATTR_KFLOPS, "%9d", true);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-	static bool first = true;
-	static AttrListPrintMask alpm;
-
-	if (ad)
-	{
-		// print header if necessary
-		if (first)
-		{
-			printf ("\n%-13.13s %-11.11s %-6.6s %-6.6s %-6.6s  %-7.7s "
-					"%-10.10s %-10.10s\n\n",
-				ATTR_NAME, ATTR_OPSYS, ATTR_ARCH, ATTR_LOAD_AVG, ATTR_MEMORY,
-				ATTR_DISK, ATTR_MIPS, ATTR_KFLOPS);
-		
-			alpm.registerFormat("%-13.13s ", ATTR_NAME, "[???????????] ");
-			alpm.registerFormat("%-11.11s " , ATTR_OPSYS, "[?????????] ");
-			alpm.registerFormat("%-6.6s " , ATTR_ARCH, "[????] ");
-			alpm.registerFormat("%.3f  ",  ATTR_LOAD_AVG, "[???]  ");
-			alpm.registerFormat("%6d  ",  ATTR_MEMORY, "[????]  ");
-			alpm.registerFormat("%7d ",  ATTR_DISK, "[?????] ");
-			alpm.registerFormat("%10d ", ATTR_MIPS, "[????????] ");
-			alpm.registerFormat("%10d\n", ATTR_KFLOPS, "[????????]\n");
-
-			first = false;
-		}
-
-		alpm.display (stdout, ad);
-	}
-#endif
 }
 
 void
 printState (ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
 		int timewid = wide_display ? 12 : 11;
-		ppSetColumn(0,ATTR_NAME,    wide_display ? -34 : -12, ! wide_display, StdInvalidField);
-		ppSetColumn("Cpu",ATTR_CPUS,  3, true, StdInvalidField);
-		ppSetColumn(" Mem",ATTR_MEMORY, 5, true, StdInvalidField);
-		//ppSetColumn("Load ",ATTR_LOAD_AVG, "%.3f", true, StdInvalidField);
-		ppSetColumn("LoadAv",ATTR_LOAD_AVG, formatLoadAvg, NULL, 6, true, StdInvalidField);
-		ppSetColumn("  KbdIdle",ATTR_KEYBOARD_IDLE, formatRealTime, timewid, true, StdInvalidField);
-		ppSetColumn(0,ATTR_STATE, -7,  true, StdInvalidField);
-		ppSetColumn("  StateTime",ATTR_ENTERED_CURRENT_STATE, formatElapsedTime, timewid, true, StdInvalidField);
-		ppSetColumn("Activ",ATTR_ACTIVITY, -5, true, StdInvalidField);
-		ppSetColumn("  ActvtyTime",ATTR_ENTERED_CURRENT_ACTIVITY, formatElapsedTime, timewid, true, StdInvalidField);
+		ppSetColumn(ATTR_NAME,    wide_display ? -34 : -12, ! wide_display);
+		ppSetColumn(ATTR_CPUS, Lbl("Cpu"), 3, true);
+		ppSetColumn(ATTR_MEMORY, Lbl(" Mem"), 5, true);
+		//ppSetColumn(ATTR_LOAD_AVG, Lbl("Load "), "%.3f", true);
+		ppSetColumn(ATTR_LOAD_AVG, Lbl("LoadAv"), formatLoadAvg, NULL, 6, true);
+		ppSetColumn(ATTR_KEYBOARD_IDLE, Lbl("  KbdIdle"), formatRealTime, timewid, true);
+		ppSetColumn(ATTR_STATE, -7,  true);
+		ppSetColumn(ATTR_ENTERED_CURRENT_STATE, Lbl("  StateTime"), formatElapsedTime, timewid, true);
+		ppSetColumn(ATTR_ACTIVITY, Lbl("Activ"), -5, true);
+		ppSetColumn(ATTR_ENTERED_CURRENT_ACTIVITY, Lbl("  ActvtyTime"), formatElapsedTime, timewid, true);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-	static bool first = true;
-	static AttrListPrintMask alpm;
-
-	if (ad)
-	{
-		// print header if necessary
-		if (first)
-		{
-			printf ("\n%-10.10s %-3.3s %5.5s %-6.6s  "
-					"%-10.10s %-7.7s   %-11.11s"
-					"%-4.4s %-12.12s\n\n",
-				ATTR_NAME, ATTR_CPUS, ATTR_MEMORY, "LoadAv",
-				"KbdIdle", ATTR_STATE, "StateTime",
-				ATTR_ACTIVITY, "ActvtyTime");
-		
-			alpm.registerFormat("%-10.10s ", ATTR_NAME, "[????????] ");
-			alpm.registerFormat("%3d " , ATTR_CPUS, "[?] ");
-			alpm.registerFormat("%5d " , ATTR_MEMORY, "[???] ");
-			alpm.registerFormat("%.3f ", ATTR_LOAD_AVG, "[???] ");
-			alpm.registerFormat( (IntCustomFmt) format_time,
-									ATTR_KEYBOARD_IDLE,
-									"[??????????]");
-			alpm.registerFormat(" %-7.7s ",  ATTR_STATE, " [?????] ");
-			alpm.registerFormat( (IntCustomFmt) formatElapsedTime,
-									ATTR_ENTERED_CURRENT_STATE,
-									"[??????????]");
-			alpm.registerFormat(" %-4.4s ",  ATTR_ACTIVITY, " [??] ");
-			alpm.registerFormat( (IntCustomFmt) formatElapsedTime,
-									ATTR_ENTERED_CURRENT_ACTIVITY,
-									"[??????????]");
-			alpm.registerFormat("\n", "*bogus*", "\n");  // force newline
-
-			first = false;
-		}
-
-		alpm.display (stdout, ad);
-	}
-#endif
 }
 
 void
 printRun (ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
-		ppSetColumn(0,ATTR_NAME,    wide_display ? -34 : -15, ! wide_display, StdInvalidField);
+		ppSetColumn(ATTR_NAME,    wide_display ? -34 : -15, ! wide_display);
 		if (javaMode) {
-			ppSetColumn(0,ATTR_JAVA_VENDOR,  -11, ! wide_display, StdInvalidField);
-			ppSetColumn("Ver",ATTR_JAVA_VERSION,  -6, ! wide_display, StdInvalidField);
+			ppSetColumn(ATTR_JAVA_VENDOR,  -11, ! wide_display);
+			ppSetColumn(ATTR_JAVA_VERSION, Lbl("Ver"),  -6, ! wide_display);
 		} else if (vmMode) {
-			ppSetColumn("VMType",ATTR_VM_TYPE,  -6, ! wide_display, StdInvalidField);
-			ppSetColumn("Network",ATTR_VM_NETWORKING_TYPES,  -11, ! wide_display, StdInvalidField);
+			ppSetColumn(ATTR_VM_TYPE, Lbl("VMType"), -6, ! wide_display);
+			ppSetColumn(ATTR_VM_NETWORKING_TYPES, Lbl("Network"),  -11, ! wide_display);
 		} else {
-			ppSetColumn(0,ATTR_OPSYS,  -11, true, StdInvalidField);
-			ppSetColumn(0,ATTR_ARCH,    -6, true, StdInvalidField);
+			ppSetColumn(ATTR_OPSYS,  -11, true);
+			ppSetColumn(ATTR_ARCH,    -6, true);
 		}
-		ppSetColumn("LoadAv",ATTR_LOAD_AVG, formatLoadAvg, NULL, 6, true, StdInvalidField);
-		ppSetColumn(0,ATTR_REMOTE_USER,    -20, ! wide_display, StdInvalidField);
-		ppSetColumn(0,ATTR_CLIENT_MACHINE, -16, ! wide_display, StdInvalidField);
+		ppSetColumn(ATTR_LOAD_AVG, Lbl("LoadAv"), formatLoadAvg, NULL, 6, true);
+		ppSetColumn(ATTR_REMOTE_USER,    -20, ! wide_display);
+		ppSetColumn(ATTR_CLIENT_MACHINE, -16, ! wide_display);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-	static bool first = true;
-	static AttrListPrintMask alpm;
-
-	const char *opsys_attr, *arch_attr;
-	const char *opsys_name, *arch_name;
-
-	if(javaMode) {
-		opsys_name = opsys_attr = ATTR_JAVA_VENDOR;
-		arch_name = "Ver";
-		arch_attr = ATTR_JAVA_VERSION;	
-	} else if(vmMode) {
-		opsys_name = "VMType";
-		opsys_attr = ATTR_VM_TYPE;
-		arch_name = "Network";
-		arch_attr = ATTR_VM_NETWORKING_TYPES;
-	} else {
-		opsys_name = opsys_attr = ATTR_OPSYS;
-		arch_name = arch_attr = ATTR_ARCH;
-	}
-
-	if (ad)
-	{
-		// print header if necessary
-		if (first)
-		{
-			if(vmMode) {
-				printf ("\n%-13.13s %-6.6s %-11.11s %-6.6s %-20.20s %-15.15s\n\n",
-						ATTR_NAME, opsys_name, arch_name, ATTR_LOAD_AVG,
-						ATTR_REMOTE_USER, ATTR_CLIENT_MACHINE);
-			}else {
-				printf ("\n%-13.13s %-11.11s %-6.6s %-6.6s %-20.20s %-15.15s\n\n",
-						ATTR_NAME, opsys_name, arch_name, ATTR_LOAD_AVG,
-						ATTR_REMOTE_USER, ATTR_CLIENT_MACHINE);
-			}
-		
-			alpm.registerFormat("%-13.13s ", ATTR_NAME, "[???????????] ");
-
-
-			if(vmMode) {
-				alpm.registerFormat("%-6.6s " , opsys_attr, "[????] ");
-				alpm.registerFormat("%-11.11s " , arch_attr, "[?????????] ");
-			}else {
-				alpm.registerFormat("%-11.11s " , opsys_attr, "[?????????] ");
-				alpm.registerFormat("%-6.6s " , arch_attr, "[????] ");
-			}
-
-			alpm.registerFormat("%-.3f  ",  ATTR_LOAD_AVG, "[???]  ");
-			alpm.registerFormat("%-20.20s ", ATTR_REMOTE_USER,
-													"[??????????????????] ");
-			alpm.registerFormat("%-15.15s\n", ATTR_CLIENT_MACHINE,
-													"[?????????????]\n");
-
-			first = false;
-		}
-
-		alpm.display (stdout, ad);
-	}
-#endif
 }
 
 
@@ -902,331 +691,130 @@ printQuillNormal (ClassAd *ad) {
 void
 printScheddNormal (ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
-		ppSetColumn(0,ATTR_NAME,    wide_display ? -34 : -20, ! wide_display, StdInvalidField);
-		ppSetColumn(0,ATTR_MACHINE, wide_display ? -34 : -10, ! wide_display, StdInvalidField);
-		ppSetColumn(0,ATTR_TOTAL_RUNNING_JOBS, "%16d", true, StdInvalidField);
-		ppSetColumn(0,ATTR_TOTAL_IDLE_JOBS,    "%13d", true, StdInvalidField);
-		ppSetColumn(0,ATTR_TOTAL_HELD_JOBS,    "%14d", true, StdInvalidField);
+		ppSetColumn(ATTR_NAME,    wide_display ? -34 : -20, ! wide_display);
+		ppSetColumn(ATTR_MACHINE, wide_display ? -34 : -10, ! wide_display);
+		ppSetColumn(ATTR_TOTAL_RUNNING_JOBS, "%16d", true);
+		ppSetColumn(ATTR_TOTAL_IDLE_JOBS,    "%13d", true);
+		ppSetColumn(ATTR_TOTAL_HELD_JOBS,    "%14d", true);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-	static bool first = true;
-	static AttrListPrintMask alpm;
-
-	if (ad)
-	{
-		// print header if necessary
-		if (first)
-		{
-			printf ("\n%-20.20s %-10.10s %-16.16s %-13.13s %-14.14s\n\n",
-				ATTR_NAME, ATTR_MACHINE, ATTR_TOTAL_RUNNING_JOBS,
-				ATTR_TOTAL_IDLE_JOBS, ATTR_TOTAL_HELD_JOBS);
-		
-			alpm.registerFormat("%-20.20s ", ATTR_NAME,
-													"[??????????????????] ");
-			alpm.registerFormat("%-10.10s ", ATTR_MACHINE,
-													"[????????] ");
-			alpm.registerFormat("%16d ",ATTR_TOTAL_RUNNING_JOBS,
-													"[??????????????] ");
-			alpm.registerFormat("%13d ",ATTR_TOTAL_IDLE_JOBS,
-													"[???????????] ");
-			alpm.registerFormat("%14d\n",ATTR_TOTAL_HELD_JOBS,"[????????????]\n");
-
-			first = false;
-		}
-
-		alpm.display (stdout, ad);
-	}
-#endif
 }
 
 
 void
 printScheddSubmittors (ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
-		ppSetColumn(0,ATTR_NAME,    wide_display ? -34 : -28, ! wide_display, StdInvalidField);
-		ppSetColumn(0,ATTR_MACHINE, wide_display ? -34 : -18, ! wide_display, StdInvalidField);
-		ppSetColumn(0,ATTR_RUNNING_JOBS, "%11d", true, StdInvalidField);
-		ppSetColumn(0,ATTR_IDLE_JOBS,    "%8d", true, StdInvalidField);
-		ppSetColumn(0,ATTR_HELD_JOBS,    "%8d", true, StdInvalidField);
+		ppSetColumn(ATTR_NAME,    wide_display ? -34 : -28, ! wide_display);
+		ppSetColumn(ATTR_MACHINE, wide_display ? -34 : -18, ! wide_display);
+		ppSetColumn(ATTR_RUNNING_JOBS, "%11d", true);
+		ppSetColumn(ATTR_IDLE_JOBS,    "%8d", true);
+		ppSetColumn(ATTR_HELD_JOBS,    "%8d", true);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-	static bool first = true;
-	static AttrListPrintMask alpm;
-
-	if (ad)
-	{
-		// print header if necessary
-		if (first)
-		{
-			printf ("\n%-20.20s %-10.10s  %8.8s %-8.8s %-8.8s\n\n",
-				ATTR_NAME, ATTR_MACHINE, "Running", ATTR_IDLE_JOBS,
-				ATTR_HELD_JOBS);
-		
-			alpm.registerFormat("%-20.20s ", ATTR_NAME,
-													"[??????????????????] ");
-			alpm.registerFormat("%-10.10s  ", ATTR_MACHINE,
-													"[????????]  ");
-			alpm.registerFormat("%8d ", ATTR_RUNNING_JOBS, "[??????] ");
-			alpm.registerFormat("%8d ", ATTR_IDLE_JOBS, "[??????] ");
-			alpm.registerFormat("%8d\n", ATTR_HELD_JOBS, "[???????]\n");
-
-			first = false;
-		}
-
-		alpm.display (stdout, ad);
-	}
-#endif
 }
 
 void
 printCollectorNormal(ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
-		ppSetColumn(0,ATTR_NAME,    wide_display ? -34 : -28, ! wide_display, StdInvalidField);
-		ppSetColumn(0,ATTR_MACHINE, wide_display ? -34 : -18, ! wide_display, StdInvalidField);
-		ppSetColumn(0,ATTR_RUNNING_JOBS, "%11d", true, StdInvalidField);
-		ppSetColumn(0,ATTR_IDLE_JOBS,    "%8d", true, StdInvalidField);
-		ppSetColumn(0,ATTR_NUM_HOSTS_TOTAL,    "%10d", true, StdInvalidField);
+		ppSetColumn(ATTR_NAME,    wide_display ? -34 : -28, ! wide_display);
+		ppSetColumn(ATTR_MACHINE, wide_display ? -34 : -18, ! wide_display);
+		ppSetColumn(ATTR_RUNNING_JOBS, "%11d", true);
+		ppSetColumn(ATTR_IDLE_JOBS,    "%8d", true);
+		ppSetColumn(ATTR_NUM_HOSTS_TOTAL,    "%10d", true);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-	static bool first = true;
-	static AttrListPrintMask alpm;
-
-	if (ad)
-	{
-		// print header if necessary
-		if (first)
-		{
-			printf ("\n%-20.20s %-20.20s  %-8.8s %-8.8s  %s\n\n",
-				ATTR_NAME, ATTR_MACHINE, "Running", ATTR_IDLE_JOBS,
-				ATTR_NUM_HOSTS_TOTAL);
-		
-			alpm.registerFormat("%-20.20s ", ATTR_NAME,
-													"[??????????????????] ");
-			alpm.registerFormat("%-20.20s ", ATTR_MACHINE,
-													"[??????????????????] ");
-			alpm.registerFormat("%8d ", ATTR_RUNNING_JOBS, " [?????] ");
-			alpm.registerFormat("%8d  ", ATTR_IDLE_JOBS, " [?????]  ");
-			alpm.registerFormat("%8d\n", ATTR_NUM_HOSTS_TOTAL, "[?????]\n");
-
-			first = false;
-		}
-
-		alpm.display (stdout, ad);
-	}
-#endif
 }
 
 void
 printMasterNormal(ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
-		ppSetColumn(0,ATTR_NAME, -20, false, StdInvalidField);
+		ppSetColumn(ATTR_NAME, -20, false);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-	static bool first = true;
-	static AttrListPrintMask alpm;
-
-	if (ad)
-	{
-		// print header if necessary
-		if (first)
-		{
-			alpm.registerFormat("%s\n",ATTR_NAME,"[??????????????????]");
-			first = false;
-		}
-
-		alpm.display (stdout, ad);
-	}
-#endif
 }
 
 
 void
 printCkptSrvrNormal(ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
-		ppSetColumn(0,ATTR_NAME,    wide_display ? -34 : -28, ! wide_display, StdInvalidField);
-		ppSetColumn("AvailDisk",ATTR_DISK, "%9d", true, StdInvalidField);
-		ppSetColumn(0,ATTR_SUBNET, "%-11s", !wide_display, "[?????]");
+		ppSetColumn(ATTR_NAME,    wide_display ? -34 : -28, ! wide_display);
+		ppSetColumn(ATTR_DISK, Lbl("AvailDisk"), "%9d", true);
+		ppSetColumn(ATTR_SUBNET, "%-11s", !wide_display);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-	static bool first = true;
-	static AttrListPrintMask alpm;
-
-	if (ad)
-	{
-		// print header if necessary
-		if (first)
-		{
-			printf ("\n%-20.20s %-9.9s %-11.11s\n\n", ATTR_NAME,
-					"AvailDisk", ATTR_SUBNET);
-			alpm.registerFormat("%-20.20s ", ATTR_NAME, "[??????????????????] ");
-			alpm.registerFormat("%9d ", ATTR_DISK, "[???????] ");
-			alpm.registerFormat("%-11s\n", ATTR_SUBNET, "[?????]\n");
-			first = false;
-		}
-
-		alpm.display (stdout, ad);
-	}
-#endif
 }
 
 
 void
 printStorageNormal(ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
-		ppSetColumn(0,ATTR_NAME,    wide_display ? -34 : -30, ! wide_display, StdInvalidField);
-		ppSetColumn("AvailDisk",ATTR_DISK, "%9d", true, StdInvalidField);
-		ppSetColumn(0,ATTR_SUBNET, "%-11s", !wide_display, "[?????]");
+		ppSetColumn(ATTR_NAME,    wide_display ? -34 : -30, ! wide_display);
+		ppSetColumn(ATTR_DISK, Lbl("AvailDisk"), "%9d", true);
+		ppSetColumn(ATTR_SUBNET, "%-11s", !wide_display);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-	static bool first = true;
-	static AttrListPrintMask alpm;
-
-	if (ad)
-	{
-		// print header if necessary
-		if (first)
-		{
-			printf ("\n%-30.30s %-9.9s %-11.11s\n\n", ATTR_NAME,
-					"AvailDisk", ATTR_SUBNET);
-			alpm.registerFormat("%-30.30s ", ATTR_NAME, "[????????????????????????????] ");
-			alpm.registerFormat("%9d ", ATTR_DISK, "[???????] ");
-			alpm.registerFormat("%-11s\n", ATTR_SUBNET, "[?????]\n");
-			first = false;
-		}
-
-		alpm.display (stdout, ad);
-	}
-#endif
 }
 
 void
 printGridNormal(ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
-		ppSetColumn(0,ATTR_NAME, -34, ! wide_display, StdInvalidField);
-		ppSetColumn(0,"NumJobs", "%7d", true, StdInvalidField);
-		ppSetColumn("Allowed","SubmitsAllowed", "%7d", true, StdInvalidField);
-		ppSetColumn(" Wanted","SubmitsWanted", "%7d", true, StdInvalidField);
-		ppSetColumn(0,ATTR_RUNNING_JOBS, "%11d", true, StdInvalidField);
-		ppSetColumn(0,ATTR_IDLE_JOBS,    "%8d", true, StdInvalidField);
+		ppSetColumn(ATTR_NAME, -34, ! wide_display);
+		ppSetColumn("NumJobs", "%7d", true);
+		ppSetColumn("SubmitsAllowed", Lbl("Allowed"), "%7d", true);
+		ppSetColumn("SubmitsWanted", Lbl(" Wanted"), "%7d", true);
+		ppSetColumn(ATTR_RUNNING_JOBS, "%11d", true);
+		ppSetColumn(ATTR_IDLE_JOBS,    "%8d", true);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-    static bool first = true;
-	static AttrListPrintMask alpm;
-
-    if (ad)
-    {
-        // print header if necessary
-        if (first)
-        {
-            printf ("\n%-35.35s %-7.7s %-7.7s %-7.7s %-7.7s %-7.7s\n\n",
-				ATTR_NAME, "NumJobs", "Allowed", "Wanted", "Running", "Idle" );
-			
-			alpm.registerFormat("%-35.35s ", ATTR_NAME, 
-				"[?????????????????????????????????] " );
-			alpm.registerFormat ( "%-7d ", "NumJobs",
-				"[?????] " );
-			alpm.registerFormat ( "%-7d ", "SubmitsAllowed",
-				"[?????] " );
-			alpm.registerFormat ( "%-7d ", "SubmitsWanted",
-				"[?????] " );
-			alpm.registerFormat ( "%-7d ", ATTR_RUNNING_JOBS,
-				"[?????] " );
-			alpm.registerFormat ( "%-7d\n", ATTR_IDLE_JOBS,
-				"[?????]\n" );
-
-            first = false;
-        }
-        
-        alpm.display (stdout, ad);
-	}
-#endif
 }
 
 void
 printNegotiatorNormal(ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
-		ppSetColumn(0,ATTR_NAME, wide_display ? -32 : -20, ! wide_display,  StdInvalidField);
-		ppSetColumn(0,ATTR_MACHINE, wide_display ? -32 : -20, ! wide_display,  StdInvalidField);
+		ppSetColumn(ATTR_NAME, wide_display ? -32 : -20, ! wide_display);
+		ppSetColumn(ATTR_MACHINE, wide_display ? -32 : -20, ! wide_display);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-	static bool first = true;
-	static AttrListPrintMask alpm;
-
-	if (ad)
-	{
-		// print header if necessary
-		if (first)
-		{
-			printf ("\n%-20.20s %-20.20s\n\n",
-				ATTR_NAME, ATTR_MACHINE);
-		
-			alpm.registerFormat("%-20.20s ", ATTR_NAME,
-													"[??????????????????] ");
-			alpm.registerFormat("%-20.20s\n", ATTR_MACHINE,
-													"[??????????????????] ");
-
-			first = false;
-		}
-
-		alpm.display (stdout, ad);
-	}
-#endif
 }
 
 /*
@@ -1248,48 +836,16 @@ formatAdType (const char * type, AttrList *, Formatter &)
 void
 printAnyNormal(ClassAd *ad, bool first)
 {
-#if 1
 	if (first) {
 		ppInit();
-		ppSetColumn(0,ATTR_MY_TYPE,     formatAdType, -18, true,  "None");
-		ppSetColumn(0,ATTR_TARGET_TYPE, formatAdType, -18, true,  "None");
-		ppSetColumn(0,ATTR_NAME, wide_display ? "%-41s" : "%-41.41s", ! wide_display, "[???]");
+		ppSetColumn(ATTR_MY_TYPE,     formatAdType, -18, true, CallInvalidField);
+		ppSetColumn(ATTR_TARGET_TYPE, formatAdType, -18, true, CallInvalidField);
+		ppSetColumn(ATTR_NAME, wide_display ? "%-41s" : "%-41.41s", ! wide_display, ShortInvalidField /*"[???]"*/);
 
 		ppDisplayHeadings(stdout, ad, "\n");
 	}
 	if (ad)
 		pm.display (stdout, ad);
-#else
-	static bool first = true;
-	char *name;
-	const char *my_type, *target_type;
-
-	if (ad)
-	{
-		if (first)
-		{		
-			printf ("\n%-20.20s %-20.20s %-30.30s\n\n", ATTR_MY_TYPE, ATTR_TARGET_TYPE, ATTR_NAME );
-			first = false;
-		}
-		name = 0;
-		if(!ad->LookupString(ATTR_NAME,&name)) {
-			name = (char *) malloc(strlen("[???]") + 1);
-			ASSERT( name != NULL );
-			strcpy(name,"[???]");
-		}
-
-		my_type = GetMyTypeName(*ad);
-		if(!my_type[0]) my_type = "None";
-
-		target_type = GetTargetTypeName(*ad);
-		if(!target_type[0]) target_type = "None";
-
-		printf("%-20.20s %-20.20s %-30.30s\n",my_type,target_type,name);
-		free(name);
-
-		pm.display (stdout, ad);
-	}
-#endif
 }
 
 
diff --git a/src/condor_status.V6/status.cpp b/src/condor_status.V6/status.cpp
index 9e2608d..f08c2b4 100644
--- a/src/condor_status.V6/status.cpp
+++ b/src/condor_status.V6/status.cpp
@@ -106,10 +106,12 @@ CondorQuery *query;
 char		buffer[1024];
 char		*myName;
 vector<SortSpec> sortSpecs;
+bool            noSort = false; // set to true to disable sorting entirely
 bool            javaMode = false;
 bool			vmMode = false;
 bool        absentMode = false;
 char 		*target = NULL;
+const char * ads_file = NULL; // read classads from this file instead of querying them from the collector
 ClassAd		*targetAd = NULL;
 ArgList projList;		// Attributes that we want the server to send us
 
@@ -123,6 +125,7 @@ void prettyPrint(ClassAdList &, TrackTotals *);
 int  matchPrefix(const char *, const char *, int min_len);
 int  lessThanFunc(AttrList*,AttrList*,void*);
 int  customLessThanFunc(AttrList*,AttrList*,void*);
+static bool read_classad_file(const char *filename, ClassAdList &classads, const char * constr);
 
 extern "C" int SetSyscalls (int) {return 0;}
 extern	void setPPstyle (ppOption, int, const char *);
@@ -464,7 +467,14 @@ main (int argc, char *argv[])
 
 	ClassAdList result;
 	CondorError errstack;
-	if (NULL != addr) {
+	if (NULL != ads_file) {
+		MyString req; // query requirements
+		q = query->getRequirements(req);
+		const char * constraint = req.empty() ? NULL : req.c_str();
+		if (read_classad_file(ads_file, result, constraint)) {
+			q = Q_OK;
+		}
+	} else if (NULL != addr) {
 			// this case executes if pool was provided, or if in "direct" mode with
 			// subsystem that corresponds to a daemon (above).
 			// Here 'addr' represents either the host:port of requested pool, or
@@ -511,7 +521,9 @@ main (int argc, char *argv[])
 		exit (1);
 	}
 
-	if (sortSpecs.empty()) {
+	if (noSort) {
+		// do nothing 
+	} else if (sortSpecs.empty()) {
         // default classad sorting
 		result.Sort((SortFunctionType)lessThanFunc);
 	} else {
@@ -603,6 +615,55 @@ int set_status_print_mask_from_stream (
 }
 
 
+static bool read_classad_file(const char *filename, ClassAdList &classads, const char * constr)
+{
+	bool success = false;
+
+	FILE* file = safe_fopen_wrapper_follow(filename, "r");
+	if (file == NULL) {
+		fprintf(stderr, "Can't open file of job ads: %s\n", filename);
+		return false;
+	} else {
+		CondorClassAdFileParseHelper parse_helper("\n");
+
+		for (;;) {
+			ClassAd* classad = new ClassAd();
+
+			int error;
+			bool is_eof;
+			int cAttrs = classad->InsertFromFile(file, is_eof, error, &parse_helper);
+
+			bool include_classad = cAttrs > 0 && error >= 0;
+			if (include_classad && constr) {
+				classad::Value val;
+				if (classad->EvaluateExpr(constr,val)) {
+					if ( ! val.IsBooleanValueEquiv(include_classad)) {
+						include_classad = false;
+					}
+				}
+			}
+			if (include_classad) {
+				classads.Insert(classad);
+			} else {
+				delete classad;
+			}
+
+			if (is_eof) {
+				success = true;
+				break;
+			}
+			if (error < 0) {
+				success = false;
+				break;
+			}
+		}
+
+		fclose(file);
+	}
+	return success;
+}
+
+
 void
 usage ()
 {
@@ -627,6 +688,7 @@ usage ()
 		"\t-license\t\tDisplay attributes of licenses\n"
 		"\t-master\t\t\tDisplay daemon master attributes\n"
 		"\t-pool <name>\t\tGet information from collector <name>\n"
+		"\t-ads <file>\t\tGet information from <file>\n"
         "\t-grid\t\t\tDisplay grid resources\n"
 		"\t-run\t\t\tSame as -claimed [deprecated]\n"
 #ifdef HAVE_EXT_POSTGRESQL
@@ -647,7 +709,7 @@ usage ()
 //		"\t-world\t\t\tDisplay all pools reporting to UW collector\n"
 		"    and [display-opt] is one of\n"
 		"\t-long\t\t\tDisplay entire classads\n"
-		"\t-sort <expr>\t\tSort entries by expressions\n"
+		"\t-sort <expr>\t\tSort entries by expressions. 'no' disables sorting\n"
 		"\t-total\t\t\tDisplay totals only\n"
 		"\t-verbose\t\tSame as -long\n"
 		"\t-wide\t\t\tdon't truncate data to fit in 80 columns.\n"
@@ -722,6 +784,16 @@ firstPass (int argc, char *argv[])
 				exit( 1 );
 			}
 		} else
+		if (is_dash_arg_prefix (argv[i], "ads", 2)) {
+			if( !argv[i+1] ) {
+				fprintf( stderr, "%s: -ads requires a filename argument\n",
+						 myName );
+				fprintf( stderr, "Use \"%s -help\" for details\n", myName );
+				exit( 1 );
+			}
+			i += 1;
+			ads_file = argv[i];
+		} else
 		if (matchPrefix (argv[i], "-format", 2)) {
 			setPPstyle (PP_CUSTOM, i, argv[i]);
 			if( !argv[i+1] || !argv[i+2] ) {
@@ -948,6 +1020,15 @@ firstPass (int argc, char *argv[])
 				exit( 1 );
 			}
 
+			if (MATCH == strcasecmp(argv[i], "false") ||
+				MATCH == strcasecmp(argv[i], "0") ||
+				MATCH == strcasecmp(argv[i], "no") ||
+				MATCH == strcasecmp(argv[i], "none"))
+			{
+				noSort = true;
+				continue;
+			}
+
             int jsort = sortSpecs.size();
             SortSpec ss;
 			ExprTree* sortExpr = NULL;
@@ -1167,10 +1248,16 @@ secondPass (int argc, char *argv[])
 			i++;
 			continue;
 		}
+		if (is_dash_arg_prefix(argv[i], "ads", 2)) {
+			++i;
+			continue;
+		}
 		if( matchPrefix(argv[i], "-sort", 3) ) {
 			i++;
-			sprintf( buffer, "%s =!= UNDEFINED", argv[i] );
-			query->addANDConstraint( buffer );
+			if ( ! noSort) {
+				sprintf( buffer, "%s =!= UNDEFINED", argv[i] );
+				query->addANDConstraint( buffer );
+			}
 			continue;
 		}
 		
diff --git a/src/condor_tests/config_if_then_else.run b/src/condor_tests/config_if_then_else.run
index 0aa08d2..3a2dae4 100755
--- a/src/condor_tests/config_if_then_else.run
+++ b/src/condor_tests/config_if_then_else.run
@@ -422,7 +422,7 @@ endif
 my @fuzzytest = ();
 
 push @fuzzytest, "if version == $versionkey\n";
-push @fuzzytest, "iftest37= is 8.2\n";
+push @fuzzytest, "iftest37= is 8.3\n";
 push @fuzzytest, "else\n";
 push @fuzzytest, "iftest37=is not $versionkey\n";
 push @fuzzytest, "endif\n";
diff --git a/src/condor_tests/job_dagman_abnormal_term_recovery_retries.run b/src/condor_tests/job_dagman_abnormal_term_recovery_retries.run
index d0b7aa5..63cf988 100755
--- a/src/condor_tests/job_dagman_abnormal_term_recovery_retries.run
+++ b/src/condor_tests/job_dagman_abnormal_term_recovery_retries.run
@@ -27,7 +27,9 @@ use CondorUtils;
 $cmd = 'job_dagman_abnormal_term_recovery_retries.dag';
 $testdesc =  'Condor submit dag - abnormal termination-recovery-retries test - scheduler U';
 $testname = "job_dagman_abnormal_term_recovery_retries";
-$dagman_args = "-verbose";
+# Force DAGMan to run in recovery mode (so we'll read the log file we
+# copy below).
+$dagman_args = "-verbose -DoRecov";
 
 @logfiles = ("job_dagman_abnormal_term_recovery_retries.dag.dagman.out");
 
@@ -43,10 +45,6 @@ foreach $name (@logfiles) {
 	}
 }
 
-# Force the DAG into recovery mode (so we'll read the log file we
-# copy below).
-runcmd("touch job_dagman_abnormal_term_recovery_retries.dag.lock");
-
 # Copy in dummy log with signal 11 abnormal termination for node A.
 runcmd("cp job_dagman_abnormal_term_recovery_retries-nodeA.dummy_log job_dagman_abnormal_term_recovery_retries-nodeA.log");
 runcmd("cp job_dagman_abnormal_term_recovery_retries-nodeA.dummy_log job_dagman_abnormal_term_recovery_retries.dag.nodes.log");
diff --git a/src/condor_tests/job_dagman_depth_first.config b/src/condor_tests/job_dagman_depth_first.config
index 11bf09b..5d449ff 100644
--- a/src/condor_tests/job_dagman_depth_first.config
+++ b/src/condor_tests/job_dagman_depth_first.config
@@ -1,2 +1,4 @@
 DAGMAN_SUBMIT_DEPTH_FIRST = true
 DAGMAN_MAX_JOBS_SUBMITTED = 1
+# Note: this needs to go away when gittrac #4186 is implemented...
+DAGMAN_USE_OLD_DAG_READER = true
diff --git a/src/condor_tests/job_dagman_dont_use_default_node_log.cfg b/src/condor_tests/job_dagman_dont_use_default_node_log.cfg
index bd5feed..00b81dd 100644
--- a/src/condor_tests/job_dagman_dont_use_default_node_log.cfg
+++ b/src/condor_tests/job_dagman_dont_use_default_node_log.cfg
@@ -1,2 +1,4 @@
 DAGMAN_ALWAYS_USE_NODE_LOG = False
 DAGMAN_USE_STRICT = 0
+# Note: this needs to go away when gittrac #4186 is implemented...
+DAGMAN_USE_OLD_DAG_READER = true
diff --git a/src/condor_tests/job_dagman_dont_use_default_node_log.run b/src/condor_tests/job_dagman_dont_use_default_node_log.run
index 43ea5e5..a4c5355 100755
--- a/src/condor_tests/job_dagman_dont_use_default_node_log.run
+++ b/src/condor_tests/job_dagman_dont_use_default_node_log.run
@@ -76,7 +76,7 @@ $submitted = sub
 $success = sub
 {
 	CondorTest::debug("executed successfully\n",1);
-	die "$dontwatchlog should not have been created\n" if ( -e $dontwatchlog );
+	die "Failed: $dontwatchlog should not have been created\n" if ( -e $dontwatchlog );
 
 	CondorTest::debug("Verifying output\n",1);
 	$diditpass = 1;
diff --git a/src/condor_tests/job_dagman_final-A.dag b/src/condor_tests/job_dagman_final-A.dag
index 94001a3..7648c04 100644
--- a/src/condor_tests/job_dagman_final-A.dag
+++ b/src/condor_tests/job_dagman_final-A.dag
@@ -1,3 +1,6 @@
+#TEMP -- either remove this after merge or add check to test...
+NODE_STATUS_FILE job_dagman_final-A.status
+
 JOBSTATE_LOG job_dagman_final-A.dag.jobstate.log
 NODE_STATUS_FILE job_dagman_final-A.status 600
 
diff --git a/src/condor_tests/job_dagman_final-D.dag b/src/condor_tests/job_dagman_final-D.dag
index 079c80b..1ea4d55 100644
--- a/src/condor_tests/job_dagman_final-D.dag
+++ b/src/condor_tests/job_dagman_final-D.dag
@@ -1,3 +1,6 @@
+#TEMP -- either remove this after merge or add check to test...
+NODE_STATUS_FILE job_dagman_final-D.status
+
 JOB D_A job_dagman_final-D-nodeA.cmd
 
 # This node fails.
diff --git a/src/condor_tests/job_dagman_final-E.dag b/src/condor_tests/job_dagman_final-E.dag
index d83d8a0..c5d2b49 100644
--- a/src/condor_tests/job_dagman_final-E.dag
+++ b/src/condor_tests/job_dagman_final-E.dag
@@ -1,3 +1,6 @@
+#TEMP -- either remove this after merge or add check to test...
+NODE_STATUS_FILE job_dagman_final-E.status
+
 CONFIG job_dagman_final-E.config
 
 NODE_STATUS_FILE job_dagman_final-E.status 600
diff --git a/src/condor_tests/job_dagman_final-F.dag b/src/condor_tests/job_dagman_final-F.dag
index a503ea0..8cb7fcf 100644
--- a/src/condor_tests/job_dagman_final-F.dag
+++ b/src/condor_tests/job_dagman_final-F.dag
@@ -1,3 +1,6 @@
+#TEMP -- either remove this after merge or add check to test...
+NODE_STATUS_FILE job_dagman_final-F.status
+
 CONFIG job_dagman_final-F.config
 
 # This node now uses the 'pre skip' feature.
@@ -11,6 +14,8 @@ JOB F_B1 job_dagman_final-F-nodeB1.cmd
 JOB F_B2 job_dagman_final-F-nodeB2.cmd
 ABORT-DAG-ON F_B2 2
 
+# This job shouldn't actually get submitted because of the throttling
+# in our config file.
 JOB F_B3 job_dagman_final-F-nodeB3.cmd
 # Make sure this runs *after* F_B2
 PRIORITY F_B3 -1
diff --git a/src/condor_tests/job_dagman_jobstate_log.dag b/src/condor_tests/job_dagman_jobstate_log.dag
index f3fde60..293301a 100644
--- a/src/condor_tests/job_dagman_jobstate_log.dag
+++ b/src/condor_tests/job_dagman_jobstate_log.dag
@@ -1,22 +1,29 @@
-JOBSTATE_LOG job_dagman_jobstate_log.dag.jobstate.log
+JOBSTATE_LOG \
+	job_dagman_jobstate_log.dag.jobstate.log
 
-CONFIG job_dagman_jobstate_log.config
+CONFIG \
+	job_dagman_jobstate_log.config
 
 # This job queues two procs that fail, but the post script succeeds.
-Job NodeA job_dagman_jobstate_log-nodeA.cmd
-Script Pre NodeA job_dagman_jobstate_log-pre.pl $JOB
-Script Post NodeA job_dagman_jobstate_log-post.pl $JOB
+Job NodeA \
+	job_dagman_jobstate_log-nodeA.cmd
+Script \
+	Pre NodeA job_dagman_jobstate_log-pre.pl $JOB
+Script Post \
+	NodeA job_dagman_jobstate_log-post.pl $JOB
 
 # The job queues two procs that succeed.
 Job NodeB job_dagman_jobstate_log-nodeB.cmd
 Script Pre NodeB job_dagman_jobstate_log-pre.pl $JOB
-Script Post NodeB job_dagman_jobstate_log-post.pl $JOB
+Script Post NodeB job_dagman_jobstate_log-post.pl \
+	$JOB
 
 # This node's post script fails the first time, but then succeeds.
 Job NodeC job_dagman_jobstate_log-nodeC.cmd
 Script Pre NodeC job_dagman_jobstate_log-pre.pl $JOB
 Script Post NodeC job_dagman_jobstate_log-nodeC-post.pl $JOB $RETRY
-Retry NodeC 1
+Retry \
+	NodeC 1
 
 # This node will hold and release the DAG.
 Job NodeD job_dagman_jobstate_log-nodeD.cmd
@@ -26,7 +33,10 @@ Job NodeD job_dagman_jobstate_log-nodeD.cmd
 Job NodeE job_dagman_jobstate_log-nodeE.cmd
 Script Post NodeE job_dagman_jobstate_log-post.pl $JOB
 
-Parent NodeA Child NodeB
-Parent NodeB Child NodeC
-Parent NodeC Child NodeD
+Parent \
+	NodeA Child NodeB
+Parent NodeB \
+	Child NodeC
+Parent NodeC Child \
+	NodeD
 Parent NodeD Child NodeE
diff --git a/src/condor_tests/job_dagman_jobstate_log.run b/src/condor_tests/job_dagman_jobstate_log.run
index 73a63a4..c31568d 100755
--- a/src/condor_tests/job_dagman_jobstate_log.run
+++ b/src/condor_tests/job_dagman_jobstate_log.run
@@ -121,6 +121,9 @@ foreach $name (@outfiles) {
 	}
 }
 
+# Remove any existing rescue DAGs.
+runcmd("rm -f job_dagman_jobstate_log.dag.rescue*");
+
 $abnormal = sub 
 {
 	die "Want to see only submit, execute and successful completion\n";
diff --git a/src/condor_tests/lib_param_conditionals.run b/src/condor_tests/lib_param_conditionals.run
index ea813ed..549799d 100644
--- a/src/condor_tests/lib_param_conditionals.run
+++ b/src/condor_tests/lib_param_conditionals.run
@@ -56,9 +56,7 @@ if(!(-f "$unit_test")) {
 #
 print("HACK: running $unit_test -memory-shapshot basic_condorutils_mem.smaps\n");
 system("$unit_test -memory-snapshot basic_condorutils_mem.smaps");
-if (-f "basic_condorutils_mem.smaps") { 
-	smap_sum_verbose("basic_condorutils_mem.smaps"); 
-}
+#if (-f "basic_condorutils_mem.smaps") { smap_sum_verbose("basic_condorutils_mem.smaps"); }
 
 my $test_status = 0;
 $test_status = system("$unit_test -v");
diff --git a/src/condor_tests/x_conditional_params.cpp b/src/condor_tests/x_conditional_params.cpp
index ff1ae46..f53e047 100644
--- a/src/condor_tests/x_conditional_params.cpp
+++ b/src/condor_tests/x_conditional_params.cpp
@@ -121,8 +121,8 @@ static const char * const aBoolFalse[] = {
 	"0", "0.0", ".0", "0.", "0e1", "0.0e10", " false ", " 0 ",
 };
 
-#define CONDOR_SERIES_VERSION "8.2"
-#define CONDOR_NEXT_VERSION "8.3"
+#define CONDOR_SERIES_VERSION "8.3"
+#define CONDOR_NEXT_VERSION "8.4"
 static const char * const aVerTrue[] = {
 	"version > 6.0", "!version >" CONDOR_SERIES_VERSION, "version > 8.1.1",
 	"version > 8.1.4", "version > 7.24.29",
diff --git a/src/condor_tools/invalidate_host.cpp b/src/condor_tools/invalidate_host.cpp
index 297c793..f21d8d5 100644
--- a/src/condor_tools/invalidate_host.cpp
+++ b/src/condor_tools/invalidate_host.cpp
@@ -38,7 +38,6 @@
 #include "condor_config.h"
 #include "condor_classad.h"
 #include "condor_io.h"
-#include "get_full_hostname.h"
 #include "daemon.h"
 #include "condor_attributes.h"
 #include "subsystem_info.h"
diff --git a/src/condor_utils/ad_printmask.cpp b/src/condor_utils/ad_printmask.cpp
index c3c9122..fbe1bd4 100644
--- a/src/condor_utils/ad_printmask.cpp
+++ b/src/condor_utils/ad_printmask.cpp
@@ -82,8 +82,14 @@ SetOverallWidth(int wid)
 }
 
 void AttrListPrintMask::
-commonRegisterFormat (int wid, int opts, const char *print, 
-                       const CustomFormatFn & sf, const char *attr, const char *alt)
+commonRegisterFormat (int wid, int opts, const char *print,
+                      const CustomFormatFn & sf,
+#ifdef AD_PRINTMASK_V2
+					  const char *attr
+#else
+					  const char *attr, const char *alt
+#endif
+					 )
 {
 	Formatter *newFmt = new Formatter;
 	memset(newFmt, 0, sizeof(*newFmt));
@@ -92,7 +98,11 @@ commonRegisterFormat (int wid, int opts, const char *print,
 	newFmt->sf = sf;
 	newFmt->width = abs(wid);
 	newFmt->options = opts;
+#ifdef AD_PRINTMASK_V2
+	newFmt->altKind = (char)((opts & (AltQuestion | AltWide | AltFixMe)) / AltQuestion);
+#else
 	newFmt->altText = "";
+#endif
 	if (wid < 0)
 		newFmt->options |= FormatOptionLeftAlign;
 	if (print) {
@@ -116,48 +126,39 @@ commonRegisterFormat (int wid, int opts, const char *print,
 	formats.Append (newFmt);
 
 	attributes.Append(new_strdup (attr));
-#if 1
-	if (alt && alt) {
+#ifdef AD_PRINTMASK_V2
+#else
+	if (alt && alt[0]) {
 		char * tmp = stringpool.consume(strlen(alt)+1, 1);
 		strcpy(tmp, alt);
 		newFmt->altText = collapse_escapes(tmp);
 	}
-#else
-	alternates.Append(collapse_escapes(new_strdup(alt)));
 #endif
 }
 
-
+#ifdef AD_PRINTMASK_V2
 void AttrListPrintMask::
-registerFormat (const char *print, int wid, int opts, const CustomFormatFn & fmt, const char *attr, const char *alternate)
-{
-	commonRegisterFormat(wid, opts, print, fmt, attr, alternate);
-}
-
-void AttrListPrintMask::
-registerFormat (const char *fmt, int wid, int opts, const char *attr, const char *alternate)
+registerFormat (const char *print, int wid, int opts, const CustomFormatFn & fmt, const char *attr)
 {
-	commonRegisterFormat(wid, opts, fmt, CustomFormatFn(), attr, alternate);
+	commonRegisterFormat(wid, opts, print, fmt, attr);
 }
 
-#if 0
 void AttrListPrintMask::
-registerFormat (const char *print, int wid, int opts, IntCustomFmt fmt, const char *attr, const char *alternate)
+registerFormat (const char *fmt, int wid, int opts, const char *attr)
 {
-	commonRegisterFormat(wid, opts, print, fmt, attr, alternate);
+	commonRegisterFormat(wid, opts, fmt, CustomFormatFn(), attr);
 }
-
+#else
 void AttrListPrintMask::
-registerFormat (const char *print, int wid, int opts, FloatCustomFmt fmt, const char *attr, const char *alternate)
+registerFormat (const char *print, int wid, int opts, const CustomFormatFn & fmt, const char *attr, const char *alternate)
 {
 	commonRegisterFormat(wid, opts, print, fmt, attr, alternate);
 }
 
-
 void AttrListPrintMask::
-registerFormat (const char *print, int wid, int opts, StringCustomFmt fmt, const char *attr, const char *alternate)
+registerFormat (const char *fmt, int wid, int opts, const char *attr, const char *alternate)
 {
-	commonRegisterFormat(wid, opts, print, fmt, attr, alternate);
+	commonRegisterFormat(wid, opts, fmt, CustomFormatFn(), attr, alternate);
 }
 #endif
 
@@ -425,6 +426,35 @@ PrintCol(MyString * prow, Formatter & fmt, const char * value)
 		(*prow) += col_suffix;
 }
 
+static void appendFieldofQuestions(MyString & buf, int width)
+{
+	int cq = width;
+	if ( ! cq)
+		return;
+	if (cq < 0) 
+		cq = 0-width;
+
+	if (cq < 3) {
+		buf += "?";
+	} else {
+		buf.reserve_at_least(buf.length() + cq+1);
+		buf += '[';
+		--cq;
+		while (--cq) buf += '?';
+		buf += ']';
+	}
+}
+
+static void append_alt(MyString & buf, Formatter & fmt)
+{
+	int alt = (int)fmt.altKind * AltQuestion;
+	if (alt == AltQuestion) {
+		buf += "?";
+	} else if (alt == (AltQuestion | AltWide)) {
+		appendFieldofQuestions(buf, fmt.width);
+	}
+}
+
 // returns a new char * that is your responsibility to delete.
 char * AttrListPrintMask::
 display (AttrList *al, AttrList *target /* = NULL */)
@@ -459,11 +489,13 @@ display (AttrList *al, AttrList *target /* = NULL */)
 		retval = row_prefix;
 
 	// for each item registered in the print mask
-	while ((fmt=formats.Next()) && (attr=attributes.Next())
-//			&& (alt=alternates.Next())
-			)
+	while ( (fmt = formats.Next()) && (attr = attributes.Next()) )
 	{
+#ifdef AD_PRINTMASK_V2
+		//const char * alt = NULL;
+#else
 		const char * alt = fmt->altText;
+#endif
 		if (icol == 0) {
 			fmt->options |= FormatOptionNoPrefix;
 		}
@@ -549,8 +581,13 @@ display (AttrList *al, AttrList *target /* = NULL */)
 						  there is an alt string defined, we should
 						  print that, instead. -Derek 2004-10-15
 						*/
+#ifdef AD_PRINTMASK_V2
+					if (fmt->altKind) {
+						append_alt(retval, *fmt);
+#else
 					if( alt && alt[0] ) {
 						retval += alt;
+#endif
 					} else { 
 						retval += fmt->printfFmt;
 					}
@@ -566,9 +603,13 @@ display (AttrList *al, AttrList *target /* = NULL */)
 				if ( ! tree) {
 						// drat, there's no data to print if there's an
 						// alt string, use that, otherwise bail.
+#ifdef AD_PRINTMASK_V2
+					if (fmt->altKind) { append_alt(retval, *fmt); }
+#else
 					if ( alt ) {
 						retval += alt;
 					}
+#endif
 					if (fmt->options & FormatOptionAutoWidth) {
 						int col_width = retval.Length() - col_start;
 						fmt->width = MAX(fmt->width, col_width);
@@ -591,9 +632,13 @@ display (AttrList *al, AttrList *target /* = NULL */)
 							retval.formatstr_cat(fmt->printfFmt, buff.c_str());
 						} else {
 							// couldn't eval
+#ifdef AD_PRINTMASK_V2
+							if (fmt->altKind) { append_alt(retval, *fmt); }
+#else
 							if( alt ) {
 								retval += alt;
 							}
+#endif
 						}
 					} else if( al->EvalString( attr, target, &value_from_classad ) ) {
 						stringValue.formatstr( fmt->printfFmt,
@@ -607,9 +652,13 @@ display (AttrList *al, AttrList *target /* = NULL */)
 							stringValue.formatstr(fmt->printfFmt, bool_str);
 							retval += stringValue;
 						} else {
+#ifdef AD_PRINTMASK_V2
+							if (fmt->altKind) { append_alt(retval, *fmt); }
+#else
 							if ( alt ) {
 								retval += alt;
 							}
+#endif
 						}
 					}
 					break;
@@ -617,7 +666,11 @@ display (AttrList *al, AttrList *target /* = NULL */)
 				case PFT_VALUE:
 					{
 #if 1
+#ifdef AD_PRINTMASK_V2
+						const char * pszValue = NULL;
+#else
 						const char * pszValue = alt;
+#endif
 						std::string buff;
 						if( EvalExprTree(tree, al, target, result) ) {
 							// Only strings are formatted differently for
@@ -630,6 +683,12 @@ display (AttrList *al, AttrList *target /* = NULL */)
 							}
 							pszValue = buff.c_str();
 						}
+#ifdef AD_PRINTMASK_V2
+						else if (fmt->altKind) {
+							buff = "?";
+							pszValue = buff.c_str();
+						}
+#endif
 
 						if ((fmt->options & FormatOptionAutoWidth) && strlen(fmt->printfFmt) == 2) {
 							char tfmt[40];
@@ -732,16 +791,24 @@ display (AttrList *al, AttrList *target /* = NULL */)
 								// the thing they want to print
 								// doesn't evaulate to an int or a
 								// float, so just print the alternate
+#ifdef AD_PRINTMASK_V2
+							if (fmt->altKind) { append_alt(retval, *fmt); }
+#else
 							if ( alt ) {
 								retval += alt;
 							}
+#endif
 							break;
 						}
 					} else {
 							// couldn't eval
+#ifdef AD_PRINTMASK_V2
+						if (fmt->altKind) { append_alt(retval, *fmt); }
+#else
 						if( alt ) {
 							retval += alt;
 						}
+#endif
 					}
 					break;
 
@@ -770,7 +837,13 @@ display (AttrList *al, AttrList *target /* = NULL */)
 				if (result_is_valid || (fmt->options & FormatOptionAlwaysCall)) {
 					pszVal = fmt->df(intValue , al, *fmt);
 				} else {
+#ifdef AD_PRINTMASK_V2
+					stringValue = "";
+					if (fmt->altKind) { append_alt(stringValue, *fmt); }
+					pszVal = stringValue.c_str();
+#else
 					pszVal = alt;
+#endif
 				}
 				PrintCol(&retval, *fmt, pszVal);
 				break;
@@ -784,7 +857,13 @@ display (AttrList *al, AttrList *target /* = NULL */)
 				if (result_is_valid || (fmt->options & FormatOptionAlwaysCall)) {
 					pszVal = fmt->ff(realValue , al, *fmt);
 				} else {
+#ifdef AD_PRINTMASK_V2
+					stringValue = "";
+					if (fmt->altKind) { append_alt(stringValue, *fmt); }
+					pszVal = stringValue.c_str();
+#else
 					pszVal = alt;
+#endif
 				}
 				PrintCol(&retval, *fmt, pszVal);
 				break;
@@ -797,7 +876,13 @@ display (AttrList *al, AttrList *target /* = NULL */)
 				if (result_is_valid || (fmt->options & FormatOptionAlwaysCall)) {
 					pszVal = fmt->sf(pszVal, al, *fmt);
 				} else {
+#ifdef AD_PRINTMASK_V2
+					stringValue = "";
+					if (fmt->altKind) { append_alt(stringValue, *fmt); }
+					pszVal = stringValue.c_str();
+#else
 					pszVal = alt;
+#endif
 				}
 				PrintCol(&retval, *fmt, pszVal);
 				break;
@@ -842,7 +927,13 @@ display (AttrList *al, AttrList *target /* = NULL */)
 				break;
 #endif
 			default:
+#ifdef AD_PRINTMASK_V2
+				stringValue = "";
+				if (fmt->altKind) {  append_alt(stringValue, *fmt); }
+				PrintCol(&retval, *fmt, stringValue.c_str());
+#else
 				PrintCol(&retval, *fmt, alt);
+#endif
 				break;
 		}
 	}
diff --git a/src/condor_utils/ad_printmask.h b/src/condor_utils/ad_printmask.h
index 492ab7f..ff92eb8 100644
--- a/src/condor_utils/ad_printmask.h
+++ b/src/condor_utils/ad_printmask.h
@@ -26,6 +26,8 @@
 #include "condor_attributes.h"
 #include "pool_allocator.h"
 
+#define AD_PRINTMASK_V2
+
 enum {
 	FormatOptionNoPrefix = 0x01,
 	FormatOptionNoSuffix = 0x02,
@@ -33,6 +35,10 @@ enum {
 	FormatOptionAutoWidth = 0x08,
 	FormatOptionLeftAlign = 0x10,
 	FormatOptionAlwaysCall = 0x80,
+
+	AltQuestion = 0x10000,     // alt text is single ?
+	AltWide     = 0x20000,     // alt text is the width of the field.
+	AltFixMe    = 0x40000,     // some alt text that needs to be fixed somehow.
 };
 
 typedef const char *(*IntCustomFormat)(int,AttrList*,struct Formatter &);
@@ -77,7 +83,11 @@ struct Formatter
 	char       fmt_letter;   // actual letter in the % escape
 	char       fmt_type;     // one of the the printf_fmt_t enum values.
 	char       fmtKind;      // identifies type type of the union
+#ifdef AD_PRINTMASK_V2
+	char       altKind;      // identifies type of alt text to print when attribute cannot be fetched
+#else
 	const char * altText;      // print this when attribute data is unavailable
+#endif
 	const char * printfFmt;    // may be NULL if fmtKind != PRINTF_FMT
 	union {
 		StringCustomFormat	sf;
@@ -100,10 +110,13 @@ class AttrListPrintMask
 	void SetOverallWidth(int wid);
 
 	// register a format and an attribute
+#ifdef AD_PRINTMASK_V2
+	void registerFormat (const char *print, int wid, int opts, const char *attr);
+	void registerFormat (const char *print, int wid, int opts, const CustomFormatFn & fmt, const char *attr);
+	void registerFormat (const char *print, const char *attr)          { registerFormat(print, 0, 0, attr); }
+	void registerformat (const CustomFormatFn & fmt, const char *attr) { registerFormat(NULL, 0, 0, fmt, attr); }
+#else
 	void registerFormat (const char *fmt, int wid, int opts, const char *attr, const char*alt="");
-	//void registerFormat (const char *print, int wid, int opts, IntCustomFmt fmt, const char *attr, const char *alt="");
-	//void registerFormat (const char *print, int wid, int opts, FloatCustomFmt fmt, const char *attr, const char *alt="");
-	//void registerFormat (const char *print, int wid, int opts, StringCustomFmt fmt, const char *attr, const char *alt="");
 	void registerFormat (const char *print, int wid, int opts, const CustomFormatFn & fmt, const char *attr, const char *alt="");
 
 	void registerFormat (const char *fmt, const char *attr, const char*alt="") {
@@ -112,17 +125,8 @@ class AttrListPrintMask
 	void registerformat (const CustomFormatFn & fmt, const char *attr, const char*alt="") {
 		registerFormat(NULL, 0, 0, fmt, attr, alt);
 	}
-/*
-	void registerFormat (IntCustomFmt fmt, const char *attr, const char *alt="") {
-		registerFormat(NULL, 0, 0, fmt, attr, alt);
-		}
-	void registerFormat (FloatCustomFmt fmt, const char *attr, const char *alt="") {
-		registerFormat(NULL, 0, 0, fmt, attr, alt);
-		}
-	void registerFormat (StringCustomFmt fmt, const char *attr, const char *alt="") {
-		registerFormat(NULL, 0, 0, fmt, attr, alt);
-		}
-*/
+#endif
+
 	// clear all formats
 	void clearFormats (void);
 	bool IsEmpty(void) { return formats.IsEmpty(); }
@@ -162,8 +166,13 @@ class AttrListPrintMask
 	ALLOCATION_POOL stringpool;
 
 	void PrintCol(MyString * pretval, Formatter & fmt, const char * value);
-	void commonRegisterFormat (int wid, int opts, const char *print, 
-		                       const CustomFormatFn & sf, const char *attr, const char *alt);
+	void commonRegisterFormat (int wid, int opts, const char *print, const CustomFormatFn & sf,
+#ifdef AD_PRINTMASK_V2
+							const char *attr
+#else
+							const char *attr, const char *alt
+#endif
+							);
 };
 
 // functions & classes in make_printmask.cpp
diff --git a/src/condor_utils/classad_cron_job.cpp b/src/condor_utils/classad_cron_job.cpp
index 35d92a0..f7bfaf7 100644
--- a/src/condor_utils/classad_cron_job.cpp
+++ b/src/condor_utils/classad_cron_job.cpp
@@ -108,6 +108,22 @@ ClassAdCronJob::Initialize( void )
 	return CronJob::Initialize( );
 }
 
+
+// Process (i.e. store) the separator args between output records. (i.e. everything after the -)
+// so that the Publish method (including a derived one) can fetch and parse it.
+int
+ClassAdCronJob::ProcessOutputSep( const char *args )
+{
+	int status = 0;
+	if ( NULL == args ) {
+		m_output_ad_args.clear();
+	} else {
+		m_output_ad_args = args;
+	}
+	return status;
+}
+
+
 // Process a line of input
 int
 ClassAdCronJob::ProcessOutput( const char *line )
@@ -138,12 +154,17 @@ ClassAdCronJob::ProcessOutput( const char *line )
 				}
 			}
 
+			const char * ad_args = NULL;
+			if ( ! m_output_ad_args.empty())
+				ad_args = m_output_ad_args.c_str();
+
 			// Replace the old ClassAd now
-			Publish( GetName( ), m_output_ad );
+			Publish( GetName( ), ad_args, m_output_ad );
 
 			// I've handed it off; forget about it!
 			m_output_ad = NULL;
 			m_output_ad_count = 0;
+			m_output_ad_args.clear();
 		}
 	} else {
 		// Process this line!
diff --git a/src/condor_utils/classad_log.cpp b/src/condor_utils/classad_log.cpp
index 83ca562..3469b5a 100644
--- a/src/condor_utils/classad_log.cpp
+++ b/src/condor_utils/classad_log.cpp
@@ -22,6 +22,7 @@
 
 #define _POSIX_SOURCE
 
+#include "basename.h"
 #include "condor_common.h"
 #include "classad_log.h"
 #include "condor_debug.h"
@@ -331,7 +332,7 @@ ClassAdLog::ForceLog()
 		FlushLog();
 
 		// Then sync
-		if (condor_fsync(fileno(log_fp)) < 0) {
+		if (condor_fdatasync(fileno(log_fp)) < 0) {
 			EXCEPT("fsync of %s failed, errno = %d", logFilename(), errno);
 		}
 
@@ -445,6 +446,33 @@ ClassAdLog::TruncLog()
 
 		return false;
 	}
+
+#ifndef WIN32
+	// POSIX does not provide any durability guarantees for rename().  Instead, we must
+	// open the parent directory and invoke fsync there.
+	char * parent_dir = condor_dirname( logFilename() );
+	if (parent_dir)
+	{
+		int parent_fd = safe_open_wrapper_follow(parent_dir, O_RDONLY);
+		if (parent_fd >= 0)
+		{
+			if (condor_fsync(parent_fd) == -1)
+			{
+				EXCEPT("Failed to fsync directory %s after rename. (errno=%d, msg=%s)", parent_dir, errno, strerror(errno));
+			}
+			close(parent_fd);
+		}
+		else
+		{
+			EXCEPT("Failed to open parent directory %s for fsync after rename. (errno=%d, msg=%s)", parent_dir, errno, strerror(errno));
+		}
+	}
+	else
+	{
+		dprintf(D_ALWAYS, "Failed to determine log's directory name\n");
+	}
+#endif
+
 	int log_fd = safe_open_wrapper_follow(logFilename(), O_RDWR | O_APPEND | O_LARGEFILE, 0600);
 	if (log_fd < 0) {
 		EXCEPT( "failed to open log in append mode: "
@@ -765,7 +793,7 @@ ClassAdLog::LogState(FILE *fp)
 	if (fflush(fp) !=0){
 	  EXCEPT("fflush of %s failed, errno = %d", logFilename(), errno);
 	}
-	if (condor_fsync(fileno(fp)) < 0) {
+	if (condor_fdatasync(fileno(fp)) < 0) {
 		EXCEPT("fsync of %s failed, errno = %d", logFilename(), errno);
 	} 
 }
diff --git a/src/condor_utils/classad_merge.cpp b/src/condor_utils/classad_merge.cpp
index f0cef18..a2c42ac 100644
--- a/src/condor_utils/classad_merge.cpp
+++ b/src/condor_utils/classad_merge.cpp
@@ -34,6 +34,8 @@ void MergeClassAds(ClassAd *merge_into, ClassAd *merge_from,
 	merge_from->ResetName();
 	merge_from->ResetExpr();
 
+	bool was_dirty_tracking = merge_into->SetDirtyTracking(mark_dirty);
+
 	const char     *name;
 	ExprTree       *expression;
 
@@ -60,16 +62,12 @@ void MergeClassAds(ClassAd *merge_into, ClassAd *merge_from,
 				}
 			}
 
-			ExprTree  *copy_expression;
-
-			copy_expression = expression->Copy();
+			ExprTree *copy_expression = expression->Copy();
 			merge_into->Insert(name, copy_expression,false);
-			if ( !mark_dirty ) {
-				merge_into->SetDirtyFlag(name, false);
-			}
 		}
 	}
 
+	merge_into->SetDirtyTracking(was_dirty_tracking);
 	return;
 }
 
@@ -77,3 +75,34 @@ void MergeClassAdsCleanly(ClassAd *merge_into, ClassAd *merge_from)
 {
 	return MergeClassAds(merge_into,merge_from,true,true,true);
 }
+
+
+int MergeClassAdsIgnoring(ClassAd *merge_into, ClassAd *merge_from, const AttrNameSet & ignore, bool mark_dirty /*=true*/)
+{
+	if (!merge_into || !merge_from) {
+		return 0;
+	}
+
+	merge_from->ResetName();
+	merge_from->ResetExpr();
+
+	bool was_dirty_tracking = merge_into->SetDirtyTracking(mark_dirty);
+
+	int cMerged = 0; // count of merged items
+	const char *name;
+	ExprTree   *expression;
+	while (merge_from->NextExpr(name, expression)) {
+
+		// don't merge attributes if the name is in the ignore list.
+		if (ignore.find(name) != ignore.end())
+			continue;
+
+		ExprTree  *copy_expression = expression->Copy();
+		merge_into->Insert(name, copy_expression,false);
+		++cMerged;
+	}
+
+	merge_into->SetDirtyTracking(was_dirty_tracking);
+	return cMerged;
+}
+
diff --git a/src/condor_utils/classad_merge.h b/src/condor_utils/classad_merge.h
index d722b19..1d32731 100644
--- a/src/condor_utils/classad_merge.h
+++ b/src/condor_utils/classad_merge.h
@@ -46,4 +46,10 @@ void MergeClassAds(ClassAd *merge_into, ClassAd *merge_from,
  */
 void MergeClassAdsCleanly(ClassAd *merge_into, ClassAd *merge_from);
 
+/* Like MergeClassAds() but with a set of attributes that will not be merged
+ *
+ */
+int MergeClassAdsIgnoring(ClassAd *merge_into, ClassAd *merge_from,
+						  const AttrNameSet & ignore, bool mark_dirty = true);
+
 #endif
diff --git a/src/condor_utils/classad_oldnew.cpp b/src/condor_utils/classad_oldnew.cpp
index 9e988be..6c3566e 100644
--- a/src/condor_utils/classad_oldnew.cpp
+++ b/src/condor_utils/classad_oldnew.cpp
@@ -28,10 +28,25 @@
 
 using namespace std;
 
+// undefine this to get rid of the original (slow) _putClassAd function
+//#define ENABLE_V0_PUT_CLASSAD
+
 #include "classad/classad_distribution.h"
 #include "classad_oldnew.h"
 #include "compat_classad.h"
 
+// local helper functions, options are one or more of PUT_CLASSAD_* flags
+int _putClassAd(Stream *sock, classad::ClassAd& ad, int options);
+int _putClassAd(Stream *sock, classad::ClassAd& ad, int options, const classad::References &whitelist);
+int _mergeStringListIntoWhitelist(StringList & list_in, classad::References & whitelist_out);
+#ifdef ENABLE_V0_PUT_CLASSAD
+ // these are the 8.2.0 _putClassAd implementations, available for timing comparison
+ int _putClassAd_v0( Stream *sock, classad::ClassAd& ad, bool excludeTypes, bool exclude_private );
+ int _putClassAd_v0( Stream *sock, classad::ClassAd& ad, bool excludeTypes, bool exclude_private, StringList * whitelist );
+ static bool use_v0_put_classad = false;
+#endif
+
+
 
 static bool publish_server_timeMangled = false;
 void AttrList_setPublishServerTimeMangled( bool publish)
@@ -41,10 +56,10 @@ void AttrList_setPublishServerTimeMangled( bool publish)
 
 static const char *SECRET_MARKER = "ZKM"; // "it's a Zecret Klassad, Mon!"
 
-classad::ClassAd *
+compat_classad::ClassAd *
 getClassAd( Stream *sock )
 {
-	classad::ClassAd *ad = new classad::ClassAd( );
+	compat_classad::ClassAd *ad = new compat_classad::ClassAd( );
 	if( !ad ) { 
 		return NULL;
 	}
@@ -205,6 +220,61 @@ getClassAdNoTypes( Stream *sock, classad::ClassAd& ad )
 	return true;
 }
 
+//
+//
+int _mergeStringListIntoWhitelist(StringList & list_in, classad::References & whitelist_out)
+{
+	const char * attr;
+	list_in.rewind();
+	while ((attr = list_in.next())) {
+		whitelist_out.insert(attr);
+	}
+	return (int)whitelist_out.size();
+}
+
+// read an attribute from a query ad, and turn it into a classad projection (i.e. a set of attributes)
+// the projection attribute can be a string, or (if allow_list is true) a classad list of strings.
+// returns:
+//    -1 if projection does not evaluate
+//    -2 if projection does not convert to string
+//    0  if no projection or projection is valid but empty
+//    1  the projection is non-empty
+//
+int mergeProjectionFromQueryAd(classad::ClassAd & queryAd, const char * attr_projection, classad::References & projection, bool allow_list /*= false*/)
+{
+	if ( ! queryAd.Lookup(attr_projection))
+		return 0; // no projection
+
+	classad::Value value;
+	if ( ! queryAd.EvaluateAttr(attr_projection, value)) {
+		return -1;
+	}
+
+	classad::ExprList *list = NULL;
+	if (allow_list && value.IsListValue(list)) {
+		for (classad::ExprList::const_iterator it = list->begin(); it != list->end(); it++) {
+			std::string attr;
+			if (!(*it)->Evaluate(value) || !value.IsStringValue(attr)) {
+				return -2;
+			}
+			projection.insert(attr);
+		}
+		return projection.empty() ? 0 : 1;
+	}
+
+	std::string proj_list;
+	if (value.IsStringValue(proj_list)) {
+		StringTokenIterator list(proj_list);
+		const std::string * attr;
+		while ((attr = list.next_string())) { projection.insert(*attr); }
+	} else {
+		return -2;
+	}
+
+	return projection.empty() ? 0 : 1;
+}
+
+
 /* 
  * It now prints chained attributes. Or it should.
  * 
@@ -215,15 +285,17 @@ getClassAdNoTypes( Stream *sock, classad::ClassAd& ad )
  *
  * It should also do encryption now.
  */
-
-int putClassAd ( Stream *sock, classad::ClassAd& ad, bool exclude_private, StringList *attr_whitelist )
+int putClassAd ( Stream *sock, classad::ClassAd& ad )
 {
-    bool completion;
-    completion = _putClassAd(sock, ad, false, exclude_private, attr_whitelist);
+	int options = 0;
 
+#ifdef ENABLE_V0_PUT_CLASSAD
+	if (use_v0_put_classad) {
+		return _putClassAd_v0(sock, ad, false, false, NULL);
+	}
+#endif
 
-    //should be true by this point
-	return completion;
+	return _putClassAd(sock, ad, options);
 }
 
 /*
@@ -235,13 +307,28 @@ int putClassAd ( Stream *sock, classad::ClassAd& ad, bool exclude_private, Strin
  * - On success, this returns 1; this indicates that further ClassAds can be sent to this ReliSock.
  * - On permanent failure, this returns 0.
  */
+PRAGMA_REMIND("TJ: kill this off.")
 int putClassAdNonblocking(ReliSock *sock, classad::ClassAd& ad, bool exclude_private, StringList *attr_whitelist )
 {
+	int options = 0;
+	if (exclude_private) { options |= PUT_CLASSAD_NO_PRIVATE; }
+
 	int retval;
 	bool backlog;
 	{
 		BlockingModeGuard guard(sock, true);
-		retval = _putClassAd(sock, ad, false, exclude_private, attr_whitelist);
+	#ifdef ENABLE_V0_PUT_CLASSAD
+		if (use_v0_put_classad) {
+			retval = _putClassAd_v0(sock, ad, false, exclude_private, attr_whitelist);
+		} else
+	#endif
+		if (attr_whitelist) {
+			classad::References attrs;
+			_mergeStringListIntoWhitelist(*attr_whitelist, attrs);
+			retval = _putClassAd(sock, ad, options, attrs);
+		} else {
+			retval = _putClassAd(sock, ad, options);
+		}
 		backlog = sock->clear_backlog_flag();
 	}
 	if (!retval) {
@@ -253,13 +340,19 @@ int putClassAdNonblocking(ReliSock *sock, classad::ClassAd& ad, bool exclude_pri
 }
 
 int
-putClassAdNoTypes ( Stream *sock, classad::ClassAd& ad, bool exclude_private )
+putClassAdNoTypes ( Stream *sock, classad::ClassAd& ad )
 {
-    return _putClassAd(sock, ad, true, exclude_private, NULL);
+#ifdef ENABLE_V0_PUT_CLASSAD
+	if (use_v0_put_classad) {
+		return _putClassAd_v0(sock, ad, true, false);
+	}
+#endif
+    return _putClassAd(sock, ad, PUT_CLASSAD_NO_TYPES);
 }
 
-int _putClassAd( Stream *sock, classad::ClassAd& ad, bool excludeTypes,
-					 bool exclude_private, StringList *attr_whitelist )
+#ifdef ENABLE_V0_PUT_CLASSAD
+// these are here for timing comparison
+int _putClassAd_v0( Stream *sock, classad::ClassAd& ad, bool excludeTypes, bool exclude_private )
 {
 	classad::ClassAdUnParser	unp;
 	std::string					buf;
@@ -280,10 +373,7 @@ int _putClassAd( Stream *sock, classad::ClassAd& ad, bool excludeTypes,
         haveChainedAd = true;
     }
 
-	if( attr_whitelist ) {
-		numExprs += attr_whitelist->number();
-	}
-	else for(int pass = 0; pass < 2; pass++){
+    for(int pass = 0; pass < 2; pass++){
 
         /* 
         * Count the number of chained attributes on the first
@@ -335,35 +425,7 @@ int _putClassAd( Stream *sock, classad::ClassAd& ad, bool excludeTypes,
 		return false;
 	}
     
-	if( attr_whitelist ) {
-		attr_whitelist->rewind();
-		char const *attr;
-		while( (attr=attr_whitelist->next()) ) {
-			classad::ExprTree const *expr = ad.Lookup(attr);
-			buf = attr;
-			buf += " = ";
-            if( !expr || (exclude_private && compat_classad::ClassAdAttributeIsPrivate(attr)) )
-			{
-				buf += "undefined";
-            }
-			else {
-				unp.Unparse( buf, expr );
-			}
-            ConvertDefaultIPToSocketIP(attr,buf,*sock);
-
-            if( ! sock->prepare_crypto_for_secret_is_noop() &&
-				compat_classad::ClassAdAttributeIsPrivate(attr) )
-			{
-                sock->put(SECRET_MARKER);
-
-                sock->put_secret(buf.c_str());
-            }
-            else if (!sock->put(buf.c_str()) ){
-                return false;
-            }
-		}
-	}
-    else for(int pass = 0; pass < 2; pass++){
+    for(int pass = 0; pass < 2; pass++){
         if(pass == 0) {
             /* need to copy the chained attrs first, so if
              *  there are duplicates, the non-chained attrs
@@ -462,6 +524,393 @@ int _putClassAd( Stream *sock, classad::ClassAd& ad, bool excludeTypes,
 	return true;
 }
 
+int _putClassAd_v0( Stream *sock, classad::ClassAd& ad, bool excludeTypes, bool exclude_private, StringList *attr_whitelist )
+{
+	if ( ! attr_whitelist) {
+		return _putClassAd_v0(sock, ad, excludeTypes, exclude_private);
+	}
+
+	classad::ClassAdUnParser	unp;
+	std::string					buf;
+    bool send_server_time = false;
+
+	unp.SetOldClassAd( true, true );
+
+	int numExprs=0;
+
+	numExprs += attr_whitelist->number();
+
+    if( publish_server_timeMangled ){
+        //add one for the ATTR_SERVER_TIME expr
+        numExprs++;
+        send_server_time = true;
+    }
+
+	sock->encode( );
+	if( !sock->code( numExprs ) ) {
+		return false;
+	}
+    
+	if( attr_whitelist ) {
+		attr_whitelist->rewind();
+		char const *attr;
+		while( (attr=attr_whitelist->next()) ) {
+			classad::ExprTree const *expr = ad.Lookup(attr);
+			buf = attr;
+			buf += " = ";
+            if( !expr || (exclude_private && compat_classad::ClassAdAttributeIsPrivate(attr)) )
+			{
+				buf += "undefined";
+            }
+			else {
+				unp.Unparse( buf, expr );
+			}
+            ConvertDefaultIPToSocketIP(attr,buf,*sock);
+
+            if( ! sock->prepare_crypto_for_secret_is_noop() &&
+				compat_classad::ClassAdAttributeIsPrivate(attr) )
+			{
+                sock->put(SECRET_MARKER);
+
+                sock->put_secret(buf.c_str());
+            }
+            else if (!sock->put(buf.c_str()) ){
+                return false;
+            }
+		}
+	}
+
+    if(send_server_time) {
+        //insert in the current time from the server's (Schedd) point of
+        //view. this is used so condor_q can compute some time values 
+        //based upon other attribute values without worrying about 
+        //the clocks being different on the condor_schedd machine
+        // -vs- the condor_q machine
+
+        char* serverTimeStr;
+        serverTimeStr = (char *) malloc(strlen(ATTR_SERVER_TIME)
+                                        + 3     //for " = "
+                                        + 12    // for integer
+                                        +1);    //for null termination
+        ASSERT( serverTimeStr );
+        sprintf(serverTimeStr, "%s = %ld", ATTR_SERVER_TIME, (long)time(NULL) );
+        if(!sock->put(serverTimeStr)){
+            free(serverTimeStr);
+            return 0;
+        }
+        free(serverTimeStr);
+    }
+
+    //ok, so the name of the bool doesn't really work here. It works
+    //  in the other places though.
+    if(!excludeTypes)
+    {
+        // Send the type
+        if (!ad.EvaluateAttrString(ATTR_MY_TYPE,buf)) {
+            buf="";
+        }
+        if (!sock->put(buf.c_str())) {
+            return false;
+        }
+
+        if (!ad.EvaluateAttrString(ATTR_TARGET_TYPE,buf)) {
+            buf="";
+        }
+        if (!sock->put(buf.c_str())) {
+            return false;
+        }
+    }
+
+	return true;
+}
+#endif // ENABLE_V0_PUT_CLASSAD
+
+int putClassAd (Stream *sock, classad::ClassAd& ad, int options, const classad::References * whitelist /*=NULL*/)
+{
+	int retval = 0;
+	classad::References expanded_whitelist; // in case we need to expand the whitelist
+
+	bool expand_whitelist = ! (options & PUT_CLASSAD_NO_EXPAND_WHITELIST);
+	if (whitelist && expand_whitelist) {
+		//PRAGMA_REMIND("need a version of GetInternalReferences that understands that MY is an alias for SELF")
+		ad.InsertAttr("MY","SELF");
+		for (classad::References::const_iterator attr = whitelist->begin(); attr != whitelist->end(); ++attr) {
+			ExprTree * tree = ad.Lookup(*attr);
+			if (tree) {
+				expanded_whitelist.insert(*attr); // the node exists, so add it to the final whitelist
+				if (tree->GetKind() != ExprTree::LITERAL_NODE) {
+					ad.GetInternalReferences(tree, expanded_whitelist, false);
+				}
+			}
+		}
+		ad.Remove("MY");
+		classad::References::iterator my = expanded_whitelist.find("MY");
+		if (my != expanded_whitelist.end()) { expanded_whitelist.erase(my); }
+		whitelist = &expanded_whitelist;
+	}
+
+	bool non_blocking = (options & PUT_CLASSAD_NON_BLOCKING) != 0;
+	ReliSock* rsock = static_cast<ReliSock*>(sock);
+	if (non_blocking && rsock)
+	{
+		BlockingModeGuard(rsock, true);
+		if (whitelist) {
+			retval = _putClassAd(sock, ad, options, *whitelist);
+		} else {
+			retval = _putClassAd(sock, ad, options);
+		}
+		bool backlog = rsock->clear_backlog_flag();
+		if (retval && backlog) { retval = 2; }
+	}
+	else // normal blocking mode put
+	{
+		if (whitelist) {
+			retval = _putClassAd(sock, ad, options, *whitelist);
+		} else {
+			retval = _putClassAd(sock, ad, options);
+		}
+	}
+	return retval;
+}
+
+// helper function for _putClassAd
+static int _putClassAdTrailingInfo(Stream *sock, classad::ClassAd& ad, bool send_server_time, bool excludeTypes)
+{
+    if (send_server_time)
+    {
+        //insert in the current time from the server's (Schedd) point of
+        //view. this is used so condor_q can compute some time values
+        //based upon other attribute values without worrying about
+        //the clocks being different on the condor_schedd machine
+        // -vs- the condor_q machine
+
+        static const char fmt[] = ATTR_SERVER_TIME " = %ld";
+        char buf[sizeof(fmt) + 12]; //+12 for time value
+        sprintf(buf, fmt, (long)time(NULL));
+        if (!sock->put(buf)) {
+            return false;
+        }
+    }
+
+    //ok, so the name of the bool doesn't really work here. It works
+    //  in the other places though.
+    if (!excludeTypes)
+    {
+        std::string buf;
+        // Send the type
+        if (!ad.EvaluateAttrString(ATTR_MY_TYPE,buf)) {
+            buf="";
+        }
+        if (!sock->put(buf.c_str())) {
+            return false;
+        }
+
+        if (!ad.EvaluateAttrString(ATTR_TARGET_TYPE,buf)) {
+            buf="";
+        }
+        if (!sock->put(buf.c_str())) {
+            return false;
+        }
+    }
+
+	return true;
+}
+
+int _putClassAd( Stream *sock, classad::ClassAd& ad, int options)
+{
+	bool excludeTypes = (options & PUT_CLASSAD_NO_TYPES) == PUT_CLASSAD_NO_TYPES;
+	bool exclude_private = (options & PUT_CLASSAD_NO_PRIVATE) == PUT_CLASSAD_NO_PRIVATE;
+
+	classad::ClassAdUnParser	unp;
+	std::string					buf;
+	bool send_server_time = false;
+
+	unp.SetOldClassAd( true, true );
+
+	int numExprs=0;
+
+	classad::AttrList::const_iterator itor;
+	classad::AttrList::const_iterator itor_end;
+
+	bool haveChainedAd = false;
+
+	classad::ClassAd *chainedAd = ad.GetChainedParentAd();
+	if(chainedAd){
+		haveChainedAd = true;
+	}
+
+	for(int pass = 0; pass < 2; pass++){
+
+		/*
+		* Count the number of chained attributes on the first
+		*   pass (if any!), then the number of attrs in this classad on
+		*   pass number 2.
+		*/
+		if(pass == 0){
+			if(!haveChainedAd){
+				continue;
+			}
+			itor = chainedAd->begin();
+			itor_end = chainedAd->end();
+		}
+		else {
+			itor = ad.begin();
+			itor_end = ad.end();
+		}
+
+		for(;itor != itor_end; itor++) {
+			std::string const &attr = itor->first;
+
+			if(!exclude_private ||
+				!compat_classad::ClassAdAttributeIsPrivate(attr.c_str()))
+			{
+				if(excludeTypes)
+				{
+					if(strcasecmp( ATTR_MY_TYPE, attr.c_str() ) != 0 &&
+						strcasecmp( ATTR_TARGET_TYPE, attr.c_str() ) != 0)
+					{
+						numExprs++;
+					}
+				}
+				else { numExprs++; }
+			}
+			if ( strcasecmp( ATTR_CURRENT_TIME, attr.c_str() ) == 0 ) {
+				numExprs--;
+			}
+		}
+	}
+
+	if( publish_server_timeMangled ){
+		//add one for the ATTR_SERVER_TIME expr
+		numExprs++;
+		send_server_time = true;
+	}
+
+	sock->encode( );
+	if( !sock->code( numExprs ) ) {
+		return false;
+	}
+
+	for(int pass = 0; pass < 2; pass++){
+		if(pass == 0) {
+			/* need to copy the chained attrs first, so if
+				*  there are duplicates, the non-chained attrs
+				*  will override them
+				*/
+			if(!haveChainedAd){
+				continue;
+			}
+			itor = chainedAd->begin();
+			itor_end = chainedAd->end();
+		} 
+		else {
+			itor = ad.begin();
+			itor_end = ad.end();
+		}
+
+		for(;itor != itor_end; itor++) {
+			std::string const &attr = itor->first;
+			classad::ExprTree const *expr = itor->second;
+
+			if(strcasecmp(ATTR_CURRENT_TIME,attr.c_str())==0) {
+				continue;
+			}
+			if(exclude_private && compat_classad::ClassAdAttributeIsPrivate(attr.c_str())){
+				continue;
+			}
+
+			if(excludeTypes){
+				if(strcasecmp( ATTR_MY_TYPE, attr.c_str( ) ) == 0 || 
+				   strcasecmp( ATTR_TARGET_TYPE, attr.c_str( ) ) == 0 )
+				{
+					continue;
+				}
+			}
+
+			buf = attr;
+			buf += " = ";
+			unp.Unparse( buf, expr );
+
+			ConvertDefaultIPToSocketIP(attr.c_str(),buf,*sock);
+
+			if( ! sock->prepare_crypto_for_secret_is_noop() &&
+				compat_classad::ClassAdAttributeIsPrivate(attr.c_str()))
+			{
+				sock->put(SECRET_MARKER);
+
+				sock->put_secret(buf.c_str());
+			}
+			else if (!sock->put(buf.c_str()) ){
+				return false;
+			}
+		}
+	}
+
+	return _putClassAdTrailingInfo(sock, ad, send_server_time, excludeTypes);
+}
+
+int _putClassAd( Stream *sock, classad::ClassAd& ad, int options, const classad::References &whitelist)
+{
+	bool excludeTypes = (options & PUT_CLASSAD_NO_TYPES) == PUT_CLASSAD_NO_TYPES;
+	bool exclude_private = (options & PUT_CLASSAD_NO_PRIVATE) == PUT_CLASSAD_NO_PRIVATE;
+
+	classad::ClassAdUnParser unp;
+	unp.SetOldClassAd( true, true );
+
+	classad::References blacklist;
+	for (classad::References::const_iterator attr = whitelist.begin(); attr != whitelist.end(); ++attr) {
+		if ( ! ad.Lookup(*attr) || (exclude_private && compat_classad::ClassAdAttributeIsPrivate(attr->c_str()))) {
+			blacklist.insert(*attr);
+		}
+	}
+
+	int numExprs = whitelist.size() - blacklist.size();
+
+	bool send_server_time = false;
+	if( publish_server_timeMangled ){
+		//add one for the ATTR_SERVER_TIME expr
+		// if its in the whitelist but not the blacklist, add it to the blacklist instead
+		// since its already been counted in that case.
+		if (whitelist.find(ATTR_SERVER_TIME) != whitelist.end() && 
+			blacklist.find(ATTR_SERVER_TIME) == blacklist.end()) {
+			blacklist.insert(ATTR_SERVER_TIME);
+		} else {
+			++numExprs;
+		}
+		send_server_time = true;
+	}
+
+
+	sock->encode( );
+	if( !sock->code( numExprs ) ) {
+		return false;
+	}
+
+	std::string buf;
+	for (classad::References::const_iterator attr = whitelist.begin(); attr != whitelist.end(); ++attr) {
+
+		if (blacklist.find(*attr) != blacklist.end())
+			continue;
+
+		classad::ExprTree const *expr = ad.Lookup(*attr);
+		buf = *attr;
+		buf += " = ";
+		unp.Unparse( buf, expr );
+		ConvertDefaultIPToSocketIP(attr->c_str(),buf,*sock);
+
+		if ( ! sock->prepare_crypto_for_secret_is_noop() &&
+			compat_classad::ClassAdAttributeIsPrivate(attr->c_str()) )
+		{
+			sock->put(SECRET_MARKER);
+			sock->put_secret(buf.c_str());
+		}
+		else if ( ! sock->put(buf.c_str()) ){
+			return false;
+		}
+	}
+
+	return _putClassAdTrailingInfo(sock, ad, send_server_time, excludeTypes);
+}
 
 bool EvalTree(classad::ExprTree* eTree, classad::ClassAd* mine, classad::Value* v)
 {
diff --git a/src/condor_utils/classad_oldnew.h b/src/condor_utils/classad_oldnew.h
index f7721ad..753135d 100644
--- a/src/condor_utils/classad_oldnew.h
+++ b/src/condor_utils/classad_oldnew.h
@@ -36,7 +36,9 @@ class ReliSock;
 
 void AttrList_setPublishServerTimeMangled( bool publish);
 
-classad::ClassAd* getClassAd( Stream *sock );
+namespace compat_classad { class ClassAd; } //forward declaration
+compat_classad::ClassAd* getClassAd( Stream *sock );
+
 bool getClassAd( Stream *sock, classad::ClassAd& ad );
 
 /** Get the ClassAd from the CEDAR stream.  This will not block.
@@ -52,36 +54,33 @@ bool getClassAdNoTypes( Stream *sock, classad::ClassAd& ad );
 /** Send the ClassAd on the CEDAR stream
  * @param sock the stream
  * @param ad the ClassAd to be sent
- * @param exclude_private whether to exclude private attributes
- * @param attr_whitelist list of attributes to send (default is to send all)
  */
-int putClassAd ( Stream *sock, classad::ClassAd& ad, bool exclude_private = false, StringList *attr_whitelist=NULL );
+int putClassAd (Stream *sock, classad::ClassAd& ad);
 
-/** Send the ClassAd on the CEDAR stream.  This will not block even if the send socket is full.
- *  Returns 2 if this would have blocked; the ClassAd will be buffered in memory.
+/** Send the ClassAd on the CEDAR stream, this function has the functionality of all of the above
  * @param sock the stream
  * @param ad the ClassAd to be sent
- * @param exclude_private whether to exclude private attributes
- * @param attr_whitelist list of attributes to send (default is to send all)
+ * @param whitelist list of attributes to send (default is to send all)
+ * @param options one or more of PUT_CLASS_AD_* flags
+ *  if the PUT_CLASSAD_NON_BLOCKING flag is used, then This will not block even if the send socket is full.
+ *  and the return value is 2 if it would have blocked; the ClassAd will be buffered in memory.
  */
-int putClassAdNonblocking(ReliSock *sock, classad::ClassAd& ad, bool exclude_private = false, StringList *attr_whitelist=NULL );
+int putClassAd (Stream *sock, classad::ClassAd& ad, int options, const classad::References * whitelist = NULL);
+// options valuees for putClassad
+#define PUT_CLASSAD_NO_PRIVATE          0x01 // exclude private attributes
+#define PUT_CLASSAD_NO_TYPES            0x02 // exclude MyType and TargetType from output.
+#define PUT_CLASSAD_NON_BLOCKING        0x04 // use non-blocking sematics. returns 2 of this would have blocked.
+#define PUT_CLASSAD_NO_EXPAND_WHITELIST 0x08 // use the whitelist argument as-is, (default is to expand internal references before using it)
 
-/** Send the ClassAd on the CEDAR stream, excluding the special handling
- *  for MyType and TargetType. You will rarely want this function.
- * @param sock the stream
- * @param ad the ClassAd to be sent
- * @param exclude_private whether to exclude private attributes
- * @param attr_whitelist list of attributes to send (default is to send all)
- */
-int putClassAdNoTypes ( Stream *sock, classad::ClassAd& ad, bool exclude_private = false );
+// fetch the given attribute from the queryAd and convert it into a set of attributes
+//   the attribute should be a string value containing a comma and/or space separated list of attributes (like StringList)
+//   if allow_list is true, then attribute is permitted to be a classad list of strings each of which is an attribute of the projection.
+// returns:
+//  < 0 if atribute exists but is not a valid projection
+//  0   if no projection or empty projection
+//  > 0 if valid, non-empty projection
+int mergeProjectionFromQueryAd(classad::ClassAd & queryAd, const char * attr_projection, classad::References & projection, bool allow_list = false);
 
-//DO NOT CALL THIS, EXCEPT IN THE ABOVE TWO putClassAds*!
-//the bool exclude types tells the function whether to exclude 
-//  stuff about MyType and TargetType from being included.
-//  true is the same as the old putClassAd()
-//  false is the same as the putClassAdNoTypes()
-int _putClassAd(Stream *sock, classad::ClassAd& ad, bool excludeTypes,
-					bool exclude_private, StringList *attr_whitelist);
 
 //this is a shorthand version of EvalTree w/o a target ad.
 bool EvalTree(classad::ExprTree* eTree, classad::ClassAd* mine, classad::Value* v);
diff --git a/src/condor_utils/command_strings.cpp b/src/condor_utils/command_strings.cpp
index 8be132a..cf53c3c 100644
--- a/src/condor_utils/command_strings.cpp
+++ b/src/condor_utils/command_strings.cpp
@@ -49,6 +49,7 @@ const struct Translation DCTranslation[] = {
 	{ "NEGOTIATE", NEGOTIATE },
 	{ "NEGOTIATE_WITH_SIGATTRS", NEGOTIATE_WITH_SIGATTRS},
 	{ "SEND_JOB_INFO", SEND_JOB_INFO },
+	{ "SEND_RESOURCE_REQUEST_LIST", SEND_RESOURCE_REQUEST_LIST }
 	{ "NO_MORE_JOBS", NO_MORE_JOBS },
 	{ "JOB_INFO", JOB_INFO },
 //	{ "GIVE_STATUS", GIVE_STATUS },					/* Not used */
diff --git a/src/condor_utils/compat_classad.cpp b/src/condor_utils/compat_classad.cpp
index 64813af..bd0cc0b 100644
--- a/src/condor_utils/compat_classad.cpp
+++ b/src/condor_utils/compat_classad.cpp
@@ -915,8 +915,6 @@ int ClassAd::Insert( const char *name, classad::ExprTree *& expr, bool bCache )
 int
 ClassAd::Insert( const char *str )
 {
-	classad::ClassAdParser parser;
-
 		// String escaping is different between new and old ClassAds.
 		// We need to convert the escaping from old to new style before
 		// handing the expression to the new ClassAds parser.
diff --git a/src/condor_utils/compat_classad.h b/src/condor_utils/compat_classad.h
index c78d2c7..4b3aecc 100644
--- a/src/condor_utils/compat_classad.h
+++ b/src/condor_utils/compat_classad.h
@@ -50,6 +50,8 @@ class ClassAdFileParseHelper;
 
 bool ClassAdAttributeIsPrivate( char const *name );
 
+typedef std::set<std::string, classad::CaseIgnLTStr> AttrNameSet;
+
 	/** Print the ClassAd as an old ClassAd to the FILE
 		@param file The file handle to print to.
 		@return TRUE
diff --git a/src/condor_utils/condor_common_c.cpp b/src/condor_utils/condor_common_c.cpp
deleted file mode 100644
index cbb0bf9..0000000
--- a/src/condor_utils/condor_common_c.cpp
+++ /dev/null
@@ -1,28 +0,0 @@
-/***************************************************************
- *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
- * University of Wisconsin-Madison, WI.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you
- * may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ***************************************************************/
-
-#include "condor_common.h"
-
-/**	Suppress:
-	warning LNK4221: no public symbols found; archive member 
-	will be inaccessible */
-int public_symbol () { 
-	return 0;
-}
-	
diff --git a/src/condor_utils/condor_event.cpp b/src/condor_utils/condor_event.cpp
index 81ad2ce..00507f5 100644
--- a/src/condor_utils/condor_event.cpp
+++ b/src/condor_utils/condor_event.cpp
@@ -508,6 +508,9 @@ void
 ULogEvent::insertCommonIdentifiers(ClassAd &adToFill)
 {
 	//if( !adToFill ) return;
+	if(!scheddname) {
+		scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+	}
 	if(scheddname) {
 	  adToFill.Assign("scheddname", scheddname);
 	}
@@ -1435,54 +1438,48 @@ int
 RemoteErrorEvent::writeEvent(FILE *file)
 {
 	char const *error_type = "Error";
-	char messagestr[512];
-
-	ClassAd tmpCl1, tmpCl2;
-	//ClassAd *tmpClP1 = &tmpCl1, *tmpClP2 = &tmpCl2;
 	int retval;
 
-	snprintf(messagestr, 512, "Remote %s from %s on %s",
-			error_type,
-			daemon_name,
-			execute_host);
+	if(!critical_error) error_type = "Warning";
 
-	scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+	if (FILEObj) {
+		char messagestr[512];
+		ClassAd tmpCl1, tmpCl2;
 
-	if(!critical_error) error_type = "Warning";
+		snprintf(messagestr, 512, "Remote %s from %s on %s",
+				 error_type,
+				 daemon_name,
+				 execute_host);
 
-	if (critical_error) {
-		tmpCl1.Assign("endts", (int)eventclock);
-		tmpCl1.Assign("endtype", ULOG_REMOTE_ERROR);
-		tmpCl1.Assign("endmessage", messagestr);
+		if (critical_error) {
+			tmpCl1.Assign("endts", (int)eventclock);
+			tmpCl1.Assign("endtype", ULOG_REMOTE_ERROR);
+			tmpCl1.Assign("endmessage", messagestr);
 
-		// this inserts scheddname, cluster, proc, etc
-		insertCommonIdentifiers(tmpCl2);
+			// this inserts scheddname, cluster, proc, etc
+			insertCommonIdentifiers(tmpCl2);
 
-		MyString tmp;
-		tmp.formatstr("endtype = null");
-		tmpCl2.Insert(tmp.Value());
+			MyString tmp;
+			tmp.formatstr("endtype = null");
+			tmpCl2.Insert(tmp.Value());
 
 			// critical error means this run is ended.
 			// condor_event.o is part of cplus_lib.a, which may be linked by
 			// non-daemons who wouldn't have initialized FILEObj. We don't
 			// need to log events for non-daemons.
-		if (FILEObj) {
 			if (FILEObj->file_updateEvent("Runs", &tmpCl1, &tmpCl2)
 				== QUILL_FAILURE) {
 				dprintf(D_ALWAYS, "Logging Event 5--- Error\n");
 				return 0; // return a error code, 0
 			}
-		}
-
-	} else {
+		} else {
 		        // this inserts scheddname, cluster, proc, etc
-        insertCommonIdentifiers(tmpCl1);
+			insertCommonIdentifiers(tmpCl1);
 
-		tmpCl1.Assign("eventtype", ULOG_REMOTE_ERROR);
-		tmpCl1.Assign("eventtime", (int)eventclock);
-		tmpCl1.Assign("description", messagestr);
+			tmpCl1.Assign("eventtype", ULOG_REMOTE_ERROR);
+			tmpCl1.Assign("eventtime", (int)eventclock);
+			tmpCl1.Assign("description", messagestr);
 
-		if (FILEObj) {
 			if (FILEObj->file_newEvent("Events", &tmpCl1) == QUILL_FAILURE) {
 				dprintf(D_ALWAYS, "Logging Event 5--- Error\n");
 				return 0; // return a error code, 0
@@ -1727,61 +1724,56 @@ ExecuteEvent::getExecuteHost()
 int
 ExecuteEvent::writeEvent (FILE *file)
 {
-	ClassAd tmpCl1, tmpCl2, tmpCl3;
-	//ClassAd *tmpClP1 = &tmpCl1, *tmpClP2 = &tmpCl2, *tmpClP3 = &tmpCl3;
-	MyString tmp = "";
 	int retval;
 
-	//JobAd is defined in condor_shadow.V6/log_events.C and is simply
-	//defined as an external variable here
+	if (FILEObj) {
+		ClassAd tmpCl1, tmpCl2, tmpCl3;
+		MyString tmp = "";
 
-	scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+		scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
 
-	if(scheddname)
-		dprintf(D_FULLDEBUG, "scheddname = %s\n", scheddname);
-	else
-		dprintf(D_FULLDEBUG, "scheddname is null\n");
+		if(scheddname)
+			dprintf(D_FULLDEBUG, "scheddname = %s\n", scheddname);
+		else
+			dprintf(D_FULLDEBUG, "scheddname is null\n");
 
-	if( !executeHost ) {
-		setExecuteHost("");
-	}
+		if( !executeHost ) {
+			setExecuteHost("");
+		}
 
-	dprintf(D_FULLDEBUG, "executeHost = %s\n", executeHost);
+		dprintf(D_FULLDEBUG, "executeHost = %s\n", executeHost);
 
-	dprintf(D_FULLDEBUG, "Executehost name = %s\n", remoteName ? remoteName : "" );
+		dprintf(D_FULLDEBUG, "Executehost name = %s\n", remoteName ? remoteName : "" );
 
-	tmpCl1.Assign("endts", (int)eventclock);
+		tmpCl1.Assign("endts", (int)eventclock);
 
-	tmp.formatstr("endtype = -1");
-	tmpCl1.Insert(tmp.Value());
+		tmp.formatstr("endtype = -1");
+		tmpCl1.Insert(tmp.Value());
 
-	tmp.formatstr("endmessage = \"UNKNOWN ERROR\"");
-	tmpCl1.Insert(tmp.Value());
+		tmp.formatstr("endmessage = \"UNKNOWN ERROR\"");
+		tmpCl1.Insert(tmp.Value());
 
-	// this inserts scheddname, cluster, proc, etc
-	insertCommonIdentifiers(tmpCl2);
+		// this inserts scheddname, cluster, proc, etc
+		insertCommonIdentifiers(tmpCl2);
 
-	tmp.formatstr("endtype = null");
-	tmpCl2.Insert(tmp.Value());
+		tmp.formatstr("endtype = null");
+		tmpCl2.Insert(tmp.Value());
 
-	if (FILEObj) {
 		if (FILEObj->file_updateEvent("Runs", &tmpCl1, &tmpCl2) == QUILL_FAILURE) {
 			dprintf(D_ALWAYS, "Logging Event 1--- Error\n");
 			return 0; // return a error code, 0
 		}
-	}
 
-	if( !remoteName ) {
-		setRemoteName("");
-	}
-	tmpCl3.Assign("machine_id", remoteName);
+		if( !remoteName ) {
+			setRemoteName("");
+		}
+		tmpCl3.Assign("machine_id", remoteName);
 
-	// this inserts scheddname, cluster, proc, etc
-	insertCommonIdentifiers(tmpCl3);
+		// this inserts scheddname, cluster, proc, etc
+		insertCommonIdentifiers(tmpCl3);
 
-	tmpCl3.Assign("startts", (int)eventclock);
+		tmpCl3.Assign("startts", (int)eventclock);
 
-	if(FILEObj) {
 		if (FILEObj->file_newEvent("Runs", &tmpCl3) == QUILL_FAILURE) {
 			dprintf(D_ALWAYS, "Logging Event 1--- Error\n");
 			return 0; // return a error code, 0
@@ -1869,24 +1861,22 @@ int
 ExecutableErrorEvent::writeEvent (FILE *file)
 {
 	int retval;
-	char messagestr[512];
-	ClassAd tmpCl1, tmpCl2;
-	//ClassAd *tmpClP1 = &tmpCl1, *tmpClP2 = &tmpCl2;
-	MyString tmp = "";
 
-	scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+	if (FILEObj) {
+		char messagestr[512];
+		ClassAd tmpCl1, tmpCl2;
+		MyString tmp = "";
 
-	tmpCl1.Assign("endts", (int)eventclock);
-	tmpCl1.Assign("endtype", ULOG_EXECUTABLE_ERROR);
-	tmpCl1.Assign("endmessage", messagestr);
+		tmpCl1.Assign("endts", (int)eventclock);
+		tmpCl1.Assign("endtype", ULOG_EXECUTABLE_ERROR);
+		tmpCl1.Assign("endmessage", messagestr);
 
-	// this inserts scheddname, cluster, proc, etc
-	insertCommonIdentifiers(tmpCl2);
+		// this inserts scheddname, cluster, proc, etc
+		insertCommonIdentifiers(tmpCl2);
 
-	tmp.formatstr( "endtype = null");
-	tmpCl2.Insert(tmp.Value());
+		tmp.formatstr( "endtype = null");
+		tmpCl2.Insert(tmp.Value());
 
-	if (FILEObj) {
 		if (FILEObj->file_updateEvent("Runs", &tmpCl1, &tmpCl2) == QUILL_FAILURE) {
 			dprintf(D_ALWAYS, "Logging Event 12--- Error\n");
 			return 0; // return a error code, 0
@@ -1897,17 +1887,14 @@ ExecutableErrorEvent::writeEvent (FILE *file)
 	{
 	  case CONDOR_EVENT_NOT_EXECUTABLE:
 		retval = fprintf (file, "(%d) Job file not executable.\n", errType);
-		sprintf(messagestr,  "Job file not executable");
 		break;
 
 	  case CONDOR_EVENT_BAD_LINK:
 		retval=fprintf(file,"(%d) Job not properly linked for Condor.\n", errType);
-		sprintf(messagestr,  "Job not properly linked for Condor");
 		break;
 
 	  default:
 		retval = fprintf (file, "(%d) [Bad error number.]\n", errType);
-		sprintf(messagestr,  "Unknown error");
 	}
 
 	if (retval < 0) return 0;
@@ -1992,23 +1979,20 @@ CheckpointedEvent::~CheckpointedEvent(void)
 int
 CheckpointedEvent::writeEvent (FILE *file)
 {
-	char messagestr[512];
-	ClassAd tmpCl1;
-	//ClassAd *tmpClP1 = &tmpCl1;
-
-	sprintf(messagestr,  "Job was checkpointed");
+	if (FILEObj) {
+		char messagestr[512];
+		ClassAd tmpCl1;
 
-	scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+		sprintf(messagestr,  "Job was checkpointed");
 
-	// this inserts scheddname, cluster, proc, etc
-	insertCommonIdentifiers(tmpCl1);
+		// this inserts scheddname, cluster, proc, etc
+		insertCommonIdentifiers(tmpCl1);
 
-	tmpCl1.Assign("eventtype", ULOG_CHECKPOINTED);
-	tmpCl1.Assign("eventtime", (int)eventclock);
+		tmpCl1.Assign("eventtype", ULOG_CHECKPOINTED);
+		tmpCl1.Assign("eventtime", (int)eventclock);
 
-	tmpCl1.Assign("description", messagestr);
+		tmpCl1.Assign("description", messagestr);
 
-	if (FILEObj) {
 		if (FILEObj->file_newEvent("Events", &tmpCl1) == QUILL_FAILURE) {
 			dprintf(D_ALWAYS, "Logging Event 6--- Error\n");
 			return 0; // return a error code, 0
@@ -2287,19 +2271,6 @@ JobEvictedEvent::readEvent( FILE *file )
 int
 JobEvictedEvent::writeEvent( FILE *file )
 {
-  char messagestr[512], checkpointedstr[6], terminatestr[512];
-  ClassAd tmpCl1, tmpCl2;
-  //ClassAd *tmpClP1 = &tmpCl1, *tmpClP2 = &tmpCl2;
-  MyString tmp = "";
-
-  //JobAd is defined in condor_shadow.V6/log_events.C and is simply
-  //defined as an external variable here
-
-  strcpy(checkpointedstr, "");
-  strcpy(messagestr, "");
-  strcpy(terminatestr, "");
-
-
   int retval;
 
   if( fprintf(file, "Job was evicted.\n\t") < 0 ) {
@@ -2308,16 +2279,10 @@ JobEvictedEvent::writeEvent( FILE *file )
 
   if( terminate_and_requeued ) {
     retval = fprintf( file, "(0) Job terminated and was requeued\n\t" );
-    sprintf(messagestr,  "Job evicted, terminated and was requeued");
-    strcpy(checkpointedstr, "false");
   } else if( checkpointed ) {
     retval = fprintf( file, "(1) Job was checkpointed.\n\t" );
-    sprintf(messagestr,  "Job evicted and was checkpointed");
-    strcpy(checkpointedstr, "true");
   } else {
     retval = fprintf( file, "(0) Job was not checkpointed.\n\t" );
-    sprintf(messagestr,  "Job evicted and was not checkpointed");
-    strcpy(checkpointedstr, "false");
   }
 
   if( retval < 0 ) {
@@ -2347,23 +2312,18 @@ JobEvictedEvent::writeEvent( FILE *file )
 		  return_value) < 0 ) {
 	return 0;
       }
-      sprintf(terminatestr,  " (1) Normal termination (return value %d)", return_value);
     }
     else {
       if( fprintf(file, "\t(0) Abnormal termination (signal %d)\n",
 		  signal_number) < 0 ) {
 	return 0;
       }
-      sprintf(terminatestr,  " (0) Abnormal termination (signal %d)", signal_number);
 
       if( core_file ) {
 	retval = fprintf( file, "\t(1) Corefile in: %s\n", core_file );
-	strcat(terminatestr, " (1) Corefile in: ");
-	strcat(terminatestr, core_file);
       }
       else {
 	retval = fprintf( file, "\t(0) No core file\n" );
-	strcat(terminatestr, " (0) No core file ");
       }
       if( retval < 0 ) {
 	return 0;
@@ -2374,8 +2334,6 @@ JobEvictedEvent::writeEvent( FILE *file )
       if( fprintf(file, "\t%s\n", reason) < 0 ) {
 	return 0;
       }
-      strcat(terminatestr,  " reason: ");
-      strcat(terminatestr,  reason);
     }
 
   }
@@ -2386,30 +2344,67 @@ JobEvictedEvent::writeEvent( FILE *file )
 		writeUsageAd(file, pusageAd);
 	}
 
-  scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+	if (FILEObj) {
+		char messagestr[512], checkpointedstr[6], terminatestr[512];
+		ClassAd tmpCl1, tmpCl2;
+		MyString tmp = "";
+
+		strcpy(checkpointedstr, "");
+		strcpy(messagestr, "");
+		strcpy(terminatestr, "");
+
+		if( terminate_and_requeued ) {
+			sprintf(messagestr,  "Job evicted, terminated and was requeued");
+			strcpy(checkpointedstr, "false");
+		} else if( checkpointed ) {
+			sprintf(messagestr,  "Job evicted and was checkpointed");
+			strcpy(checkpointedstr, "true");
+		} else {
+			sprintf(messagestr,  "Job evicted and was not checkpointed");
+			strcpy(checkpointedstr, "false");
+		}
 
-  tmpCl1.Assign("endts", (int)eventclock);
-  tmpCl1.Assign("endtype", ULOG_JOB_EVICTED);
+		if(terminate_and_requeued ) {
+			if( normal ) {
+				sprintf(terminatestr,  " (1) Normal termination (return value %d)", return_value);
+			} else {
+				sprintf(terminatestr,  " (0) Abnormal termination (signal %d)", signal_number);
 
-  tmp.formatstr( "endmessage = \"%s%s\"", messagestr, terminatestr);
-  tmpCl1.Insert(tmp.Value());
+				if( core_file ) {
+					strcat(terminatestr, " (1) Corefile in: ");
+					strcat(terminatestr, core_file);
+				} else {
+					strcat(terminatestr, " (0) No core file ");
+				}
+			}
 
-  tmpCl1.Assign("wascheckpointed", checkpointedstr);
-  tmpCl1.Assign("runbytessent", sent_bytes);
-  tmpCl1.Assign("runbytesreceived", recvd_bytes);
+			if( reason ) {
+				strcat(terminatestr,  " reason: ");
+				strcat(terminatestr,  reason);
+			}
+		}
 
-  // this inserts scheddname, cluster, proc, etc
-  insertCommonIdentifiers(tmpCl2);
+		tmpCl1.Assign("endts", (int)eventclock);
+		tmpCl1.Assign("endtype", ULOG_JOB_EVICTED);
 
-  tmp.formatstr( "endtype = null");
-  tmpCl2.Insert(tmp.Value());
+		tmp.formatstr( "endmessage = \"%s%s\"", messagestr, terminatestr);
+		tmpCl1.Insert(tmp.Value());
 
-  if (FILEObj) {
-	  if (FILEObj->file_updateEvent("Runs", &tmpCl1, &tmpCl2) == QUILL_FAILURE) {
-		  dprintf(D_ALWAYS, "Logging Event 2 --- Error\n");
-		  return 0; // return a error code, 0
-	  }
-  }
+		tmpCl1.Assign("wascheckpointed", checkpointedstr);
+		tmpCl1.Assign("runbytessent", sent_bytes);
+		tmpCl1.Assign("runbytesreceived", recvd_bytes);
+
+		// this inserts scheddname, cluster, proc, etc
+		insertCommonIdentifiers(tmpCl2);
+
+		tmp.formatstr( "endtype = null");
+		tmpCl2.Insert(tmp.Value());
+
+		if (FILEObj->file_updateEvent("Runs", &tmpCl1, &tmpCl2) == QUILL_FAILURE) {
+			dprintf(D_ALWAYS, "Logging Event 2 --- Error\n");
+			return 0; // return a error code, 0
+		}
+	}
 
   return 1;
 }
@@ -2579,26 +2574,23 @@ int
 JobAbortedEvent::writeEvent (FILE *file)
 {
 
-	char messagestr[512];
-	ClassAd tmpCl1;
-	//ClassAd *tmpClP1 = &tmpCl1;
-	MyString tmp = "";
-
-	scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+	if (FILEObj) {
+		char messagestr[512];
+		ClassAd tmpCl1;
+		MyString tmp = "";
 
-	if (reason)
-		snprintf(messagestr,  512, "Job was aborted by the user: %s", reason);
-	else
-		sprintf(messagestr,  "Job was aborted by the user");
+		if (reason)
+			snprintf(messagestr,  512, "Job was aborted by the user: %s", reason);
+		else
+			sprintf(messagestr,  "Job was aborted by the user");
 
-	// this inserts scheddname, cluster, proc, etc
-	insertCommonIdentifiers(tmpCl1);
+		// this inserts scheddname, cluster, proc, etc
+		insertCommonIdentifiers(tmpCl1);
 
-	tmpCl1.Assign("eventtype", ULOG_JOB_ABORTED);
-	tmpCl1.Assign("eventtime", (int)eventclock);
-	tmpCl1.Assign("description", messagestr);
+		tmpCl1.Assign("eventtype", ULOG_JOB_ABORTED);
+		tmpCl1.Assign("eventtime", (int)eventclock);
+		tmpCl1.Assign("description", messagestr);
 
-	if (FILEObj) {
 		if (FILEObj->file_newEvent("Events", &tmpCl1) == QUILL_FAILURE) {
 			dprintf(D_ALWAYS, "Logging Event 7--- Error\n");
 			return 0; // return a error code, 0
@@ -2724,16 +2716,6 @@ TerminatedEvent::getCoreFile( void )
 int
 TerminatedEvent::writeEvent( FILE *file, const char* header )
 {
-  char messagestr[512];
-  ClassAd tmpCl1, tmpCl2;
-  //ClassAd *tmpClP1 = &tmpCl1, *tmpClP2 = &tmpCl2;
-  MyString tmp = "";
-
-  //JobAd is defined in condor_shadow.V6/log_events.C and is simply
-  //defined as an external variable here
-
-  strcpy(messagestr, "");
-
 	int retval=0;
 
 	if( normal ) {
@@ -2741,7 +2723,6 @@ TerminatedEvent::writeEvent( FILE *file, const char* header )
 					returnValue) < 0 ) {
 			return 0;
 		}
-		sprintf(messagestr,  "(1) Normal termination (return value %d)", returnValue);
 
 	} else {
 		if( fprintf(file, "\t(0) Abnormal termination (signal %d)\n",
@@ -2749,16 +2730,11 @@ TerminatedEvent::writeEvent( FILE *file, const char* header )
 			return 0;
 		}
 
-		sprintf(messagestr,  "(0) Abnormal termination (signal %d)", signalNumber);
-
 		if( core_file ) {
 			retval = fprintf( file, "\t(1) Corefile in: %s\n\t",
 							  core_file );
-			strcat(messagestr, " (1) Corefile in: ");
-			strcat(messagestr, core_file);
 		} else {
 			retval = fprintf( file, "\t(0) No core file\n\t" );
-			strcat(messagestr, " (0) No core file ");
 		}
 	}
 
@@ -2790,18 +2766,34 @@ TerminatedEvent::writeEvent( FILE *file, const char* header )
 		writeUsageAd(file, pusageAd);
 	}
 
-	scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+	if (FILEObj) {
+		char messagestr[512];
+		ClassAd tmpCl1, tmpCl2;
+		MyString tmp = "";
 
-	tmpCl1.Assign("endmessage", messagestr);
-	tmpCl1.Assign("runbytessent", sent_bytes);
-	tmpCl1.Assign("runbytesreceived", recvd_bytes);
+		strcpy(messagestr, "");
 
-	// this inserts scheddname, cluster, proc, etc
-	insertCommonIdentifiers(tmpCl2);
+		if( normal ) {
+			sprintf(messagestr,  "(1) Normal termination (return value %d)", returnValue);
+		} else {
+			sprintf(messagestr,  "(0) Abnormal termination (signal %d)", signalNumber);
+			if( core_file ) {
+				strcat(messagestr, " (1) Corefile in: ");
+				strcat(messagestr, core_file);
+			} else {
+				strcat(messagestr, " (0) No core file ");
+			}
+		}
 
-	tmpCl2.Assign("endts", (int)eventclock);
+		tmpCl1.Assign("endmessage", messagestr);
+		tmpCl1.Assign("runbytessent", sent_bytes);
+		tmpCl1.Assign("runbytesreceived", recvd_bytes);
+
+		// this inserts scheddname, cluster, proc, etc
+		insertCommonIdentifiers(tmpCl2);
+
+		tmpCl2.Assign("endts", (int)eventclock);
 
-	if (FILEObj) {
 		if (FILEObj->file_updateEvent("Runs", &tmpCl1, &tmpCl2) == QUILL_FAILURE) {
 			dprintf(D_ALWAYS, "Logging Event 3--- Error\n");
 			return 0; // return a error code, 0
@@ -2946,30 +2938,24 @@ JobTerminatedEvent::~JobTerminatedEvent(void)
 int
 JobTerminatedEvent::writeEvent (FILE *file)
 {
-  ClassAd tmpCl1, tmpCl2;
-  //ClassAd *tmpClP1 = &tmpCl1, *tmpClP2 = &tmpCl2;
-  MyString tmp = "";
-
-  //JobAd is defined in condor_shadow.V6/log_events.C and is simply
-  //defined as an external variable here
-
-  scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+	if (FILEObj) {
+		ClassAd tmpCl1, tmpCl2;
+		MyString tmp = "";
 
-  tmpCl1.Assign("endts", (int)eventclock);
-  tmpCl1.Assign("endtype", ULOG_JOB_TERMINATED);
+		tmpCl1.Assign("endts", (int)eventclock);
+		tmpCl1.Assign("endtype", ULOG_JOB_TERMINATED);
 
-  // this inserts scheddname, cluster, proc, etc
-  insertCommonIdentifiers(tmpCl2);
+		// this inserts scheddname, cluster, proc, etc
+		insertCommonIdentifiers(tmpCl2);
 
-  tmp.formatstr( "endtype = null");
-  tmpCl2.Insert(tmp.Value());
+		tmp.formatstr( "endtype = null");
+		tmpCl2.Insert(tmp.Value());
 
-  if (FILEObj) {
-	  if (FILEObj->file_updateEvent("Runs", &tmpCl1, &tmpCl2) == QUILL_FAILURE) {
-		  dprintf(D_ALWAYS, "Logging Event 4--- Error\n");
-		  return 0; // return a error code, 0
-	  }
-  }
+		if (FILEObj->file_updateEvent("Runs", &tmpCl1, &tmpCl2) == QUILL_FAILURE) {
+			dprintf(D_ALWAYS, "Logging Event 4--- Error\n");
+			return 0; // return a error code, 0
+		}
+	}
 
   if( fprintf(file, "Job terminated.\n") < 0 ) {
 	  return 0;
@@ -3281,49 +3267,44 @@ ShadowExceptionEvent::readEvent (FILE *file)
 int
 ShadowExceptionEvent::writeEvent (FILE *file)
 {
-	char messagestr[512];
-	ClassAd tmpCl1, tmpCl2;
-	//ClassAd *tmpClP1 = &tmpCl1, *tmpClP2 = &tmpCl2;
-	MyString tmp = "";
-
-	scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+	if (FILEObj) {
+		char messagestr[512];
+		ClassAd tmpCl1, tmpCl2;
+		MyString tmp = "";
 
-	snprintf(messagestr, 512, "Shadow exception: %s", message);
-	messagestr[COUNTOF(messagestr)-1] = 0;
+		snprintf(messagestr, 512, "Shadow exception: %s", message);
+		messagestr[COUNTOF(messagestr)-1] = 0;
 
 		// remove the new line in the end if any
-	if  (messagestr[strlen(messagestr)-1] == '\n')
-		messagestr[strlen(messagestr)-1] = '\0';
+		if  (messagestr[strlen(messagestr)-1] == '\n')
+			messagestr[strlen(messagestr)-1] = '\0';
 
-	if (began_execution) {
-		tmpCl1.Assign("endts", (int)eventclock);
-		tmpCl1.Assign("endtype", ULOG_SHADOW_EXCEPTION);
-		tmpCl1.Assign("endmessage", messagestr);
-		tmpCl1.Assign("runbytessent", sent_bytes);
+		if (began_execution) {
+			tmpCl1.Assign("endts", (int)eventclock);
+			tmpCl1.Assign("endtype", ULOG_SHADOW_EXCEPTION);
+			tmpCl1.Assign("endmessage", messagestr);
+			tmpCl1.Assign("runbytessent", sent_bytes);
 
-		tmpCl1.Assign("runbytesreceived", recvd_bytes);
+			tmpCl1.Assign("runbytesreceived", recvd_bytes);
 
-		// this inserts scheddname, cluster, proc, etc
-		insertCommonIdentifiers(tmpCl2);
+			// this inserts scheddname, cluster, proc, etc
+			insertCommonIdentifiers(tmpCl2);
 
-		tmp.formatstr( "endtype = null");
-		tmpCl2.Insert(tmp.Value());
+			tmp.formatstr( "endtype = null");
+			tmpCl2.Insert(tmp.Value());
 
-		if (FILEObj) {
 			if (FILEObj->file_updateEvent("Runs", &tmpCl1, &tmpCl2) == QUILL_FAILURE) {
 				dprintf(D_ALWAYS, "Logging Event 13--- Error\n");
 				return 0; // return a error code, 0
 			}
-		}
-	} else {
-		// this inserts scheddname, cluster, proc, etc
-        insertCommonIdentifiers(tmpCl1);
+		} else {
+			// this inserts scheddname, cluster, proc, etc
+			insertCommonIdentifiers(tmpCl1);
 
-		tmpCl1.Assign("eventtype", ULOG_SHADOW_EXCEPTION);
-		tmpCl1.Assign("eventtime", (int)eventclock);
-		tmpCl1.Assign("description", messagestr);
+			tmpCl1.Assign("eventtype", ULOG_SHADOW_EXCEPTION);
+			tmpCl1.Assign("eventtime", (int)eventclock);
+			tmpCl1.Assign("description", messagestr);
 
-		if (FILEObj) {
 			if (FILEObj->file_newEvent("Events", &tmpCl1) == QUILL_FAILURE) {
 				dprintf(D_ALWAYS, "Logging Event 14 --- Error\n");
 				return 0; // return a error code, 0
@@ -3408,23 +3389,20 @@ JobSuspendedEvent::readEvent (FILE *file)
 int
 JobSuspendedEvent::writeEvent (FILE *file)
 {
-	char messagestr[512];
-	ClassAd tmpCl1;
-	//ClassAd *tmpClP1 = &tmpCl1;
-	MyString tmp = "";
-
-	sprintf(messagestr, "Job was suspended (Number of processes actually suspended: %d)", num_pids);
+	if (FILEObj) {
+		char messagestr[512];
+		ClassAd tmpCl1;
+		MyString tmp = "";
 
-	scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+		sprintf(messagestr, "Job was suspended (Number of processes actually suspended: %d)", num_pids);
 
-	// this inserts scheddname, cluster, proc, etc
-	insertCommonIdentifiers(tmpCl1);
+		// this inserts scheddname, cluster, proc, etc
+		insertCommonIdentifiers(tmpCl1);
 
-	tmpCl1.Assign("eventtype", ULOG_JOB_SUSPENDED);
-	tmpCl1.Assign("eventtime", (int)eventclock);
-	tmpCl1.Assign("description", messagestr);
+		tmpCl1.Assign("eventtype", ULOG_JOB_SUSPENDED);
+		tmpCl1.Assign("eventtime", (int)eventclock);
+		tmpCl1.Assign("description", messagestr);
 
-	if (FILEObj) {
 		if (FILEObj->file_newEvent("Events", &tmpCl1) == QUILL_FAILURE) {
 			dprintf(D_ALWAYS, "Logging Event 8--- Error\n");
 			return 0; // return a error code, 0
@@ -3485,23 +3463,20 @@ JobUnsuspendedEvent::readEvent (FILE *file)
 int
 JobUnsuspendedEvent::writeEvent (FILE *file)
 {
-	char messagestr[512];
-	ClassAd tmpCl1;
-	//ClassAd *tmpClP1 = &tmpCl1;
-	MyString tmp = "";
-
-	sprintf(messagestr, "Job was unsuspended");
+	if (FILEObj) {
+		char messagestr[512];
+		ClassAd tmpCl1;
+		MyString tmp = "";
 
-	scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+		sprintf(messagestr, "Job was unsuspended");
 
-	// this inserts scheddname, cluster, proc, etc
-	insertCommonIdentifiers(tmpCl1);
+		// this inserts scheddname, cluster, proc, etc
+		insertCommonIdentifiers(tmpCl1);
 
-	tmpCl1.Assign("eventtype", ULOG_JOB_UNSUSPENDED);
-	tmpCl1.Assign("eventtime", (int)eventclock);
-	tmpCl1.Assign("description", messagestr);
+		tmpCl1.Assign("eventtype", ULOG_JOB_UNSUSPENDED);
+		tmpCl1.Assign("eventtime", (int)eventclock);
+		tmpCl1.Assign("description", messagestr);
 
-	if (FILEObj) {
  	    if (FILEObj->file_newEvent("Events", &tmpCl1) == QUILL_FAILURE) {
 			dprintf(D_ALWAYS, "Logging Event 9--- Error\n");
 			return 0; // return a error code, 0
@@ -3639,25 +3614,22 @@ JobHeldEvent::readEvent( FILE *file )
 int
 JobHeldEvent::writeEvent( FILE *file )
 {
-	char messagestr[512];
-	ClassAd tmpCl1;
-	//ClassAd *tmpClP1 = &tmpCl1;
-
-	if (reason)
-		snprintf(messagestr, 512, "Job was held: %s", reason);
-	else
-		sprintf(messagestr, "Job was held: reason unspecified");
+	if (FILEObj) {
+		char messagestr[512];
+		ClassAd tmpCl1;
 
-	scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+		if (reason)
+			snprintf(messagestr, 512, "Job was held: %s", reason);
+		else
+			sprintf(messagestr, "Job was held: reason unspecified");
 
-	// this inserts scheddname, cluster, proc, etc
-	insertCommonIdentifiers(tmpCl1);
+		// this inserts scheddname, cluster, proc, etc
+		insertCommonIdentifiers(tmpCl1);
 
-	tmpCl1.Assign("eventtype", ULOG_JOB_HELD);
-	tmpCl1.Assign("eventtime", (int)eventclock);
-	tmpCl1.Assign("description", messagestr);
+		tmpCl1.Assign("eventtype", ULOG_JOB_HELD);
+		tmpCl1.Assign("eventtime", (int)eventclock);
+		tmpCl1.Assign("description", messagestr);
 
-	if (FILEObj) {
 		if (FILEObj->file_newEvent("Events", &tmpCl1) == QUILL_FAILURE) {
 			dprintf(D_ALWAYS, "Logging Event 10--- Error\n");
 			return 0; // return a error code, 0
@@ -3800,26 +3772,23 @@ JobReleasedEvent::readEvent( FILE *file )
 int
 JobReleasedEvent::writeEvent( FILE *file )
 {
-	char messagestr[512];
-	ClassAd tmpCl1;
-	//ClassAd *tmpClP1 = &tmpCl1;
-	MyString tmp = "";
-
-	if (reason)
-		snprintf(messagestr, 512, "Job was released: %s", reason);
-	else
-		sprintf(messagestr, "Job was released: reason unspecified");
+	if (FILEObj) {
+		char messagestr[512];
+		ClassAd tmpCl1;
+		MyString tmp = "";
 
-	scheddname = getenv( EnvGetName( ENV_SCHEDD_NAME ) );
+		if (reason)
+			snprintf(messagestr, 512, "Job was released: %s", reason);
+		else
+			sprintf(messagestr, "Job was released: reason unspecified");
 
-	// this inserts scheddname, cluster, proc, etc
-	insertCommonIdentifiers(tmpCl1);
+		// this inserts scheddname, cluster, proc, etc
+		insertCommonIdentifiers(tmpCl1);
 
-	tmpCl1.Assign("eventtype", ULOG_JOB_RELEASED);
-	tmpCl1.Assign("eventtime", (int)eventclock);
-	tmpCl1.Assign("description", messagestr);
+		tmpCl1.Assign("eventtype", ULOG_JOB_RELEASED);
+		tmpCl1.Assign("eventtime", (int)eventclock);
+		tmpCl1.Assign("description", messagestr);
 
-	if (FILEObj) {
 		if (FILEObj->file_newEvent("Events", &tmpCl1) == QUILL_FAILURE) {
 			dprintf(D_ALWAYS, "Logging Event 11--- Error\n");
 			return 0; // return a error code, 0
diff --git a/src/condor_utils/condor_fsync.cpp b/src/condor_utils/condor_fsync.cpp
index 310b8cb..7b9625f 100644
--- a/src/condor_utils/condor_fsync.cpp
+++ b/src/condor_utils/condor_fsync.cpp
@@ -10,3 +10,18 @@ int condor_fsync(int fd, const char* /*path*/)
 
 	return fsync(fd);
 }
+
+int condor_fdatasync(int fd, const char* /*path*/)
+{
+	if (!condor_fsync_on)
+	{
+		return 0;
+	}
+
+#ifdef HAVE_FDATASYNC
+	return fdatasync(fd);
+#else
+	return fsync(fd);
+#endif
+}
+
diff --git a/src/condor_utils/condor_fsync.h b/src/condor_utils/condor_fsync.h
index d0068fe..e0232de 100644
--- a/src/condor_utils/condor_fsync.h
+++ b/src/condor_utils/condor_fsync.h
@@ -22,11 +22,12 @@
 #define _CONDOR_FSYNC_H
 
 /*
- * Conditionally fsyncs based on configuration knob.
+ * Conditionally fsyncs/fdatasyncs based on configuration knob.
  * path parameter is currently not used but may be used
  * in the future to further conditionalize fsyncs based
  * on location of file.
  */
 int condor_fsync( int fd, const char* path = NULL );
+int condor_fdatasync( int fd, const char* path = NULL );
 
 #endif 
diff --git a/src/condor_utils/condor_query.h b/src/condor_utils/condor_query.h
index 67cb788..b9681c1 100644
--- a/src/condor_utils/condor_query.h
+++ b/src/condor_utils/condor_query.h
@@ -163,6 +163,7 @@ class CondorQuery
 
 	// get the query filter ad --- useful for debugging
 	QueryResult getQueryAd (ClassAd &);
+	QueryResult getRequirements (MyString & req) { return (QueryResult) query.makeQuery (req); }
 	
 	// set the type for the next generic query
 	void setGenericQueryType(const char*);
diff --git a/src/condor_utils/cron_job.cpp b/src/condor_utils/cron_job.cpp
index 46f9b97..d0ddcd1 100644
--- a/src/condor_utils/cron_job.cpp
+++ b/src/condor_utils/cron_job.cpp
@@ -448,6 +448,8 @@ CronJob::ProcessOutputQueue( void )
 		dprintf( D_FULLDEBUG, "%s: %d lines in Queue\n",
 				 GetName(), linecount );
 
+		status = ProcessOutputSep( m_stdOutBuf->GetQueueSep() );
+
 		// Read all of the data from the queue
 		char	*linebuf;
 		while( ( linebuf = m_stdOutBuf->GetLineFromQueue( ) ) != NULL ) {
diff --git a/src/condor_utils/cron_job_io.cpp b/src/condor_utils/cron_job_io.cpp
index fce8eb4..291cc60 100644
--- a/src/condor_utils/cron_job_io.cpp
+++ b/src/condor_utils/cron_job_io.cpp
@@ -55,6 +55,10 @@ CronJobOut::Output( const char *buf, int len )
 
 	// Check for record delimitter
 	if ( '-' == buf[0] ) {
+		if (buf[1]) {
+			m_q_sep = &buf[1];
+			m_q_sep.trim();
+		}
 		return 1;
 	}
 
@@ -103,6 +107,7 @@ CronJobOut::FlushQueue( void )
 	while( ! m_lineq.dequeue( line ) ) {
 		free( line );
 	}
+	m_q_sep.clear();
 
 	// Return the size
 	return size;
@@ -117,6 +122,7 @@ CronJobOut::GetLineFromQueue( void )
 	if ( ! m_lineq.dequeue( line ) ) {
 		return line;
 	} else {
+		m_q_sep.clear();
 		return NULL;
 	}
 }
diff --git a/src/condor_utils/file_sql.cpp b/src/condor_utils/file_sql.cpp
index a182293..6c15858 100644
--- a/src/condor_utils/file_sql.cpp
+++ b/src/condor_utils/file_sql.cpp
@@ -435,6 +435,10 @@ FILESQL *FILEObj = NULL;
 
 /*static */ FILESQL *
 FILESQL::createInstance(bool use_sql_log) { 
+	if ( !use_sql_log ) {
+		return NULL;
+	}
+
 	FILESQL *ptr = NULL;
 	MyString outfilename = "";
 
diff --git a/src/condor_utils/generic_query.cpp b/src/condor_utils/generic_query.cpp
index 99d1b0e..bc0d3e6 100644
--- a/src/condor_utils/generic_query.cpp
+++ b/src/condor_utils/generic_query.cpp
@@ -246,14 +246,13 @@ setFloatKwList (char **value)
 
 // make query
 int GenericQuery::
-makeQuery (ExprTree *&tree)
+makeQuery (MyString &req)
 {
 	int		i, value;
 	char	*item;
 	float   fvalue;
-	MyString req = "";
 
-	tree = NULL;
+	req = "";
 
 	// construct query requirement expression
 	bool firstCategory = true;
@@ -348,8 +347,18 @@ makeQuery (ExprTree *&tree)
 		req += " )";
 	}
 
-	// absolutely no constraints at all
-	if (firstCategory) { req += "TRUE"; }
+	return Q_OK;
+}
+
+int GenericQuery::
+makeQuery (ExprTree *&tree)
+{
+	MyString req;
+	int status = makeQuery(req);
+	if (status != Q_OK) return status;
+
+	// If there are no constraints, then we match everything.
+	if (req.empty()) req = "TRUE";
 
 	// parse constraints and insert into query ad
 	if (ParseClassAdRvalExpr (req.Value(), tree) > 0) return Q_PARSE_ERROR;
@@ -357,7 +366,6 @@ makeQuery (ExprTree *&tree)
 	return Q_OK;
 }
 
-
 // helper functions --- clear 
 void GenericQuery::
 clearQueryObject (void)
diff --git a/src/condor_utils/generic_query.h b/src/condor_utils/generic_query.h
index dc8843a..5e65d66 100644
--- a/src/condor_utils/generic_query.h
+++ b/src/condor_utils/generic_query.h
@@ -59,6 +59,7 @@ class GenericQuery
 	
 	// make the query expression
 	int makeQuery (ExprTree *&tree);
+	int makeQuery (MyString &expr);
 
 	// overloaded operators
     // friend ostream &operator<< (ostream &, GenericQuery &);  // display
diff --git a/src/condor_utils/get_full_hostname.cpp b/src/condor_utils/get_full_hostname.cpp
deleted file mode 100644
index f655427..0000000
--- a/src/condor_utils/get_full_hostname.cpp
+++ /dev/null
@@ -1,206 +0,0 @@
-/***************************************************************
- *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
- * University of Wisconsin-Madison, WI.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you
- * may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ***************************************************************/
-
-
-//#include "condor_common.h"
-//#include "condor_debug.h"
-//#include "condor_string.h"
-//#include "condor_config.h"
-//#include "internet.h"
-//#include "condor_netdb.h"
-//
-//
-//char* get_full_hostname_from_hostent( struct hostent* host_ptr,
-//									  const char* host );
-//
-//// Returns the full hostname of the given host in a newly allocated
-//// string, which should be de-allocated with delete [].  If the
-//// optional 2nd arg is non-NULL, set it to point to the hostent we get
-//// back.  WARNING: Using the 2nd arg is _not_ thread-safe.
-//
-//char*
-//get_full_hostname( const char* host, struct in_addr* sin_addrp )
-//{
-//	struct hostent *host_ptr;
-//	char const *tmp;
-//    char **pptr;
-//    struct in_addr *inaddr;
-//	bool have_full = false;
-//    bool found = false;
-//
-//	if( (tmp = strchr(host, '.')) ) {
-//		have_full = true;
-//	}
-//
-//
-//	if( ! sin_addrp && have_full ) {
-//			// Caller doesn't want the IP addr, and the name already
-//			// has a dot.  That's as good as we're going to do, so we
-//			// should just exit w/o calling gethostbyname().
-//		dprintf( D_HOSTNAME, "Given name is fully qualified, done\n" );
-//		return strnewp( host );
-//	}
-//
-//	if( have_full ) {
-//		ASSERT( sin_addrp );
-//		dprintf( D_HOSTNAME, "Trying to find IP addr for \"%s\"\n",
-//				 host );
-//	} else {
-//		if( sin_addrp ) {
-//			dprintf( D_HOSTNAME, "Trying to find full hostname and "
-//					 "IP addr for \"%s\"\n", host );
-//		} else {
-//			dprintf( D_HOSTNAME, "Trying to find full hostname for "
-//					 "\"%s\"\n", host );
-//		}
-//	}
-//
-//	dprintf( D_HOSTNAME, "Calling gethostbyname(%s)\n", host );
-//	if( (host_ptr = condor_gethostbyname( host )) == NULL ) {
-//			// If the resolver can't find it, just return NULL
-//		if( sin_addrp ) {
-//			memset( sin_addrp, 0, sizeof(struct in_addr) );
-//		}
-//        // gethostbyname does not set errno. Instead, it sets h_errno. Also hstrerror
-//        // is the function to get a string that explains error. If this turns out to
-//        // work all platforms, the next line must be uncommented.
-//        //dprintf(D_HOSTNAME, "gethostbyname() failed: %s\n", hstrerror(h_errno));
-//		dprintf( D_HOSTNAME, "gethostbyname() failed: %s (errno: %d)\n",
-//				 strerror(errno), errno );
-//		return NULL;
-//	}
-//    if( sin_addrp ) {
-//        for (pptr = host_ptr->h_addr_list; *pptr != NULL; pptr++) {
-//            inaddr = (struct in_addr *)*pptr;
-//            dprintf( D_HOSTNAME, "Found IP addr in hostent: %s\n", inet_ntoa(*inaddr) );
-//            // check if loopback
-//            if (inaddr->s_addr == INADDR_LOOPBACK) {
-//                // we don't want to return loopback address when we have other
-//                // addresses
-//                if (!found) {
-//                    *sin_addrp = *inaddr;
-//                    found = true;
-//                }
-//                continue;
-//            }
-//            // copy the address
-//            *sin_addrp = *inaddr;
-//            found = true;
-//            // check if public address
-//            if (!is_priv_net(inaddr->s_addr)) {
-//                break;
-//            }
-//        }
-//    }
-//
-//	if( have_full ) {
-//			// we're done.
-//		return strnewp( host );
-//	}
-//
-//		// now that we have a hostent, call our helper to find the
-//		// right fully qualified name out of it (this is shared with
-//		// a method in the Daemon object, too...)
-//	return get_full_hostname_from_hostent( host_ptr, host );
-//}
-//
-//
-//// Returns the full hostname out of the given hostent in a newly
-//// allocated string, which should be de-allocated with delete [] the
-//// optional 2nd arg is non-NULL, set it to point to the hostent we get
-//// back.  WARNING: This method is _not_ thread-safe.
-//char*
-//get_full_hostname_from_hostent( struct hostent* host_ptr,
-//								const char* host )
-//{
-//	const char* tmp_host;
-//	char* full_host;
-//	char* tmp;
-//	int h, i;
-//
-//	if( ! host_ptr ) {
-//		dprintf( D_ALWAYS, "get_full_hostname_from_hostent() called with "
-//				 "no hostent!\n" );
-//		return NULL;
-//	}
-//
-//	dprintf( D_HOSTNAME, "Trying to find full hostname from hostent\n" );
-//
-//		// See if it's correct in the hostent we've got.
-//	if( host_ptr->h_name &&
-//		(tmp = strchr(host_ptr->h_name, '.')) ) {
-//			// There's a '.' in the "name", use that as full.
-//		dprintf( D_HOSTNAME, "Main name in hostent \"%s\" is fully "
-//				 "qualified\n", host_ptr->h_name );
-//		return strnewp( host_ptr->h_name );
-//	}
-//
-//	dprintf( D_HOSTNAME, "Main name in hostent \"%s\" contains no '.', "
-//			 "checking aliases\n",
-//			 host_ptr->h_name ? host_ptr->h_name : "NULL" );
-//
-//		// We still haven't found it yet, try all the aliases
-//		// until we find one with a '.'
-//	for( i=0; host_ptr->h_aliases[i]; i++ ) {
-//		dprintf( D_HOSTNAME, "Checking alias \"%s\"\n",
-//				 host_ptr->h_aliases[i] );
-//		if( (tmp = strchr(host_ptr->h_aliases[i], '.')) ) {
-//			dprintf( D_HOSTNAME, "Alias \"%s\" is fully qualified\n",
-//				host_ptr->h_aliases[i] );
-//			return strnewp( host_ptr->h_aliases[i] );
-//		}
-//	}
-//
-//	dprintf( D_HOSTNAME, "No host alias is fully qualified, looking for "
-//			 "DEFAULT_DOMAIN_NAME\n" );
-//
-//	if( host ) {
-//		tmp_host = host;
-//	} else {
-//		tmp_host = host_ptr->h_name;
-//	}
-//
-//		// Still haven't found it, try to param for the domain.
-//	if( (tmp = param("DEFAULT_DOMAIN_NAME")) ) {
-//		dprintf( D_HOSTNAME, "DEFAULT_DOMAIN_NAME is defined: \"%s\"\n", tmp );
-//		h = strlen( tmp_host );
-//		i = strlen( tmp );
-//		if( tmp[0] == '.' ) {
-//			full_host = new char[h+i+1];
-//			sprintf( full_host, "%s%s", tmp_host, tmp );
-//		} else {
-//			full_host = new char[h+i+2];
-//			sprintf( full_host, "%s.%s", tmp_host, tmp );
-//		}
-//		free( tmp );
-//		dprintf( D_HOSTNAME, "Full hostname for \"%s\" is \"%s\"\n",
-//				 tmp_host, full_host );
-//		return full_host;
-//	}
-//
-//	dprintf( D_HOSTNAME, "DEFAULT_DOMAIN_NAME not defined\n" );
-//
-//		// Still can't find it, just give up.
-//	full_host = strnewp( tmp_host );
-//	dprintf( D_HOSTNAME, "Failed to find full hostname for \"%s\", "
-//			 "returning \"%s\"\n", tmp_host, full_host );
-//	return full_host;
-//}
-//
-//
diff --git a/src/condor_utils/get_full_hostname.h b/src/condor_utils/get_full_hostname.h
deleted file mode 100644
index 969c2d0..0000000
--- a/src/condor_utils/get_full_hostname.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/***************************************************************
- *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
- * University of Wisconsin-Madison, WI.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you
- * may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ***************************************************************/
-
-#ifndef GET_FULL_HOSTNAME_H
-#define GET_FULL_HOSTNAME_H
-
-//extern char* get_full_hostname( const char*,
-//								struct in_addr *sin_addrp = NULL );
-//
-//extern char* get_full_hostname_from_hostent( struct hostent* host_ptr,
-//											 const char* host );
-
-#endif /* GET_FULL_HOSTNAME_H */
diff --git a/src/condor_utils/inet_ntoa.unix.cpp b/src/condor_utils/inet_ntoa.unix.cpp
deleted file mode 100644
index f4cdd89..0000000
--- a/src/condor_utils/inet_ntoa.unix.cpp
+++ /dev/null
@@ -1,72 +0,0 @@
-/***************************************************************
- *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
- * University of Wisconsin-Madison, WI.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you
- * may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ***************************************************************/
-
-#include "condor_common.h"
-#ifndef HAS_INET_NTOA
-
-#if defined(HPUX11)
-
-/* 64-bit gcc has a problem where it can't return by value a struct of a
-	certain size when linking against system libraries. This function, plus
-	one other which I think we don't use, have this problem. So, I've written
-	my own inet_ntoa implementation which should work for hpux11 on a parisc
-	architecture. Some endian issues might need to be fixed, however when
-	we go to ia64 hpux11 if the endianess is different */
-
-char *
-inet_ntoa( struct in_addr inaddr ) {
-	/* if in_addr is 4 bytes wide, then 3(the ascii space requirement for
-		0xff in base ten) * 4 = 12, plus each byte in the in_addr for each
-		period minus one for fence post, plus 1 for the NUL should equal
-		16. The max space requirement for "255.255.255.255\0" */
-	static char buffer[sizeof(struct in_addr) * 3 
-						+ (sizeof(struct in_addr)-1) + 1];
-
-	unsigned char tmp_buf[sizeof(struct in_addr)];
-	unsigned char tmp_buf2[1024];
-	int max_bytes = sizeof(struct in_addr);
-	int i;
-
-	/* clean the ascii buffer out */
-	memset(buffer, 0, 
-		sizeof(struct in_addr) * 3 + (sizeof(struct in_addr)-1) + 1);
-
-	/* XXX This assumes big endian */
-	for(i = 0; i < max_bytes; i++) {
-		tmp_buf[i] = ((unsigned char*)&inaddr)[i];
-	}
-	
-	/* perform the conversion */
-	for(i = 0; i < max_bytes; i++) {
-		sprintf(tmp_buf2, "%u", tmp_buf[i]);
-		strcat(buffer, tmp_buf2);
-		if (i != (max_bytes - 1)) {
-			strcat(buffer, ".");
-		}
-	}
-	return buffer;
-}
-
-
-#else
-#error Please supply an implementation of inet_ntoa() for this platform!
-#endif
-
-#endif
-
diff --git a/src/condor_utils/killfamily.cpp b/src/condor_utils/killfamily.cpp
index 226980d..f696cf1 100644
--- a/src/condor_utils/killfamily.cpp
+++ b/src/condor_utils/killfamily.cpp
@@ -21,11 +21,6 @@
 #include "condor_common.h"
 #include "killfamily.h"
 #include "../condor_procapi/procapi.h"
-#include "dynuser.h"
-
-#ifdef WIN32
-extern dynuser *myDynuser;
-#endif
 
 KillFamily::KillFamily( pid_t pid, priv_state priv, int test_only )
 {
diff --git a/src/condor_utils/libcondorapi_stubs.cpp b/src/condor_utils/libcondorapi_stubs.cpp
index c269c37..2bca78b 100644
--- a/src/condor_utils/libcondorapi_stubs.cpp
+++ b/src/condor_utils/libcondorapi_stubs.cpp
@@ -111,6 +111,11 @@ int condor_fsync(int, const char*)
 	return 0;
 }
 
+int condor_fdatasync(int, const char*)
+{
+	return 0;
+}
+
 BEGIN_C_DECLS
 void
 config( int, bool )
diff --git a/src/condor_utils/log_transaction.cpp b/src/condor_utils/log_transaction.cpp
index 1a36395..c56cb0a 100644
--- a/src/condor_utils/log_transaction.cpp
+++ b/src/condor_utils/log_transaction.cpp
@@ -322,7 +322,7 @@ fflush_with_status(stream_with_status_t* s)
 */
 
 static int
-fsync_with_status(stream_with_status_t* s) 
+fdatasync_with_status(stream_with_status_t* s) 
 {
   ASSERT(s);
 
@@ -338,7 +338,7 @@ fsync_with_status(stream_with_status_t* s)
        fileno.  Whether or not this is the right thing to do, it's at
        least backwards-compatible. */
 
-	if (condor_fsync(fd) < 0) {
+	if (condor_fdatasync(fd) < 0) {
 	  s->why = WHY_FSYNC;
 	  s->err = errno;
 	  return -1;
@@ -473,10 +473,10 @@ Transaction::Commit(FILE* fp, void *data_structure, bool nondurable)
 	  }
 
 	  before = time(NULL);
-	  fsync_with_status(&(fps[0]));
+	  fdatasync_with_status(&(fps[0]));
 	  after = time(NULL);
 	  if ( (after - before) > 5 ) {
-		  dprintf( D_FULLDEBUG, "Transaction::Commit(): fsync_with_status() took %ld seconds to run\n", after - before );
+		  dprintf( D_FULLDEBUG, "Transaction::Commit(): fdatasync_with_status() took %ld seconds to run\n", after - before );
 	  }
 
 	  bool failure = fps[0].why != WHY_OK;
@@ -489,7 +489,7 @@ Transaction::Commit(FILE* fp, void *data_structure, bool nondurable)
 	    */
 
 	    fflush_with_status(&(fps[1]));
-	    fsync_with_status(&(fps[1]));
+	    fdatasync_with_status(&(fps[1]));
 
 	    fclose_with_status(&(fps[1]));
 	    bi.fp = NULL;
diff --git a/src/condor_utils/malloc.cpp b/src/condor_utils/malloc.cpp
deleted file mode 100644
index 992b87b..0000000
--- a/src/condor_utils/malloc.cpp
+++ /dev/null
@@ -1,296 +0,0 @@
-/***************************************************************
- *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
- * University of Wisconsin-Madison, WI.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you
- * may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ***************************************************************/
-
-#undef DEBUG
-#ifndef _STORE_H_
-#define _STORE_H_
-
-#ifdef DEBUG
-
-#ifndef lint
-static char *rcs_store_c =
-	"$Header: /space/home/matt/CVS2GIT/CONDOR_SRC-src/src/condor_util_lib/malloc.c,v 1.7 2007-11-07 23:21:28 nleroy Exp $";
-#endif
-
-
-
-
-#include <stdio.h>
-#include "condor_fix_assert.h"
-
-char	*Fmt1 = "%x: %-10s %-35s %-4d %-4d\n";
-
-int printall=1;
-
-FILE *allocout;
-#define MAGIC 12348
-
-static struct chunk {
-	int magic;
-	char *fname;
-	int line;
-	char *ffname;
-	int fline;
-	int allocated;
-#define ALLOCATED 1
-#define FREED 2
-#define FORGOTTEN 3
-	int size;
-	struct chunk *next, *prev;
-	char buf[1];
-} head;
-
-#define OFFSET (head.buf - (char *)&head)
-
-void exit(), abort(), memset(), perror();
-char *sbrk();
-
-char *
-mymalloc(fname, line, size)
-	char *fname;
-	int line, size;
-{
-	struct chunk *p;
-	int s = size + sizeof *p;
-	extern int errno;
-
-	/* round up to multiple of 4 */
-	s = (s+3) & ~3;
-	errno = 0;
-#ifdef lint
-	p = 0;
-#else
-	p = (struct chunk *)sbrk(s);
-#endif
-	if (errno) perror("mymalloc");
-	p->magic = MAGIC;
-	p->fname = fname;
-	p->line = line;
-	p->allocated = ALLOCATED;
-	p->size = size;
-	if (p->next = head.next) p->next->prev = p;
-	p->prev = &head;
-	head.next = p;
-
-	if (printall && allocout) {
-		fprintf(allocout, Fmt1, p->buf, "malloc @", fname, line, size);
-		fflush(allocout);
-	}
-
-	return p->buf;
-}
-
-char *malloc(size)
-	unsigned size;
-{
-	return mymalloc("--malloc--",-1,(int)size);
-}
-
-void
-myfree(fname, line, ptr)
-	char *fname;
-	int line;
-	char *ptr;
-{
-	struct chunk *p;
-
-	if(!ptr) {
-		if (allocout) {
-			fprintf(allocout, ">>>NULL free(%s,%d,0x%x)\n",fname,line,ptr);
-			fflush(allocout);
-			abort();
-		}
-		return;
-	}
-#ifdef lint
-	p = (struct chunk *)0;
-#else
-	p = (struct chunk *)(ptr - OFFSET);
-#endif
-	if (p->magic != MAGIC) {
-		if (allocout) {
-			fprintf(allocout, ">>>bad free(%s,%d,0x%x)\n",fname,line,ptr);
-			fflush(allocout);
-			abort();
-		}
-		return;
-	}
-	switch (p->allocated) {
-		case ALLOCATED: 
-			if (!printall) break;
-			if (!allocout) return;
-			fprintf(allocout, Fmt1, p->buf, "free @", fname, line, p->size);
-			fflush(allocout);
-			break;
-		case FREED:
-			if (!allocout) return;
-			fprintf(allocout,
-				">>>%s line %d (prev %s %d; alloc %s %d): free already free\n",
-				fname,line, p->ffname,p->fline, p->fname, p->line);
-			fflush(allocout);
-			abort();
-			return;
-		case FORGOTTEN:
-			if (!printall) break;
-			if (!allocout) return;
-			fprintf(allocout,">>>%s line %d freeing FORGOTTEN %x, size %d\n",
-				fname, line, p->buf, p->size);
-			fflush(allocout);
-			return;
-		default:
-			if (allocout) {
-				fprintf(allocout, ">>>bad allocated %d (%s,%d,0x%x)\n",
-					p->allocated,fname,line,ptr);
-				fflush(allocout);
-				abort();
-			}
-			return;
-	}
-		
-	p->allocated = FREED;
-	p->ffname = fname;
-	p->fline = line;
-	if (p->prev)
-		p->prev->next = p->next;
-	if (p->next)
-		p->next->prev = p->prev;
-	p->next = p->prev = 0;
-}
-
-/* ARGSUSED */
-void
-free(p)
-	char *p;
-{
-	myfree("--free--",-1,p);
-}
-
-char *
-mycalloc(fname, line, count, size)
-	char *fname;
-	int line, count, size;
-{
-	int s = count*size;
-	char *res = mymalloc(fname,line,s);
-
-	memset(res,0,s);
-	return res;
-}
-
-char *
-calloc(a,b)
-	unsigned a,b;
-{
-	return mycalloc("--calloc--",-1,(int)a,(int)b);
-}
-
-
-char *
-myrealloc(fname, line, ptr, size)
-	char *fname;
-	int line, size;
-	char *ptr;
-{
-	struct chunk *p;
-	char *new;
-#ifdef lint
-	p = (struct chunk *)0;
-#else
-	p = (struct chunk *)(ptr - OFFSET);
-#endif
-	assert(p->buf == ptr);
-	new = mymalloc(fname, line, size);
-	(void) memcpy(new, ptr, p->size);
-	myfree(fname, line, ptr);
-
-	return new;
-}
-
-/* ARGSUSED */
-char *
-realloc(p,n)
-	unsigned n;
-	char *p;
-{
-	return myrealloc( "--realloc--", -1, p, n);
-}
-
-char *
-myalloca(fname, line, size)
-	char *fname;
-	int line, size;
-{
-	fprintf(stderr,"alloca(%d) called, line %d file %d\n",
-		size,line,fname);
-	exit(1);
-}
-
-/* ARGSUSED */
-char *
-alloca(n)
-	int n;
-{
-	abort();
-}
-
-
-showalloc(fname)
-	char *fname;
-{
-	struct chunk *c;
-	register int tot=0;
-	static int num =0;
-
-	if (!allocout) return;
-	fprintf(allocout,"\nshowalloc(%s) %d\n",fname, ++num);
-	for (c = head.next; c; c = c->next) {
-		if (c->allocated == ALLOCATED)
-			fprintf(allocout, Fmt1, c->buf, "", c->fname, c->line, c->size);
-		else fprintf(allocout, ">>>bad alloc type %d: %x:\t%s\t%d\t%d\n",
-			c->allocated, c, c->fname, c->line, c->size);
-		tot += c->size;
-	}
-	fprintf(allocout,"showalloc %d TOTAL %d\n\n",num, tot);
-	(void)fflush(allocout);
-}
-
-clearalloc(fname, print_all)
-char *fname;
-int print_all;
-{
-	static char buf[BUFSIZ];
-	struct chunk *c,*next;
-
-	printall = print_all;
-	if (fname) {
-		if (allocout) (void)fclose(allocout);
-		allocout = fopen(fname,"w");
-		if (!allocout) perror(fname);
-		else setbuf(allocout, buf);
-	}
-	for (c = head.next; c; c = next) {
-		next = c->next;
-		c->allocated = FORGOTTEN;
-		c->next = c->prev = 0;
-	}
-
-	head.next = 0;
-}
-#endif /* DEBUG */
-#endif /* _STORE_H_ */
diff --git a/src/condor_utils/my_dynuser.cpp b/src/condor_utils/my_dynuser.cpp
deleted file mode 100644
index f8162f9..0000000
--- a/src/condor_utils/my_dynuser.cpp
+++ /dev/null
@@ -1,32 +0,0 @@
-/***************************************************************
- *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
- * University of Wisconsin-Madison, WI.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you
- * may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ***************************************************************/
-
-
-#include "condor_common.h"
-#ifdef WIN32
-#include "dynuser.h"
-
-/* This is the global object to access Dynuser. 
-*/
-dynuser		myDyn;
-dynuser		*myDynuser = &myDyn;
-
-#endif //of WIN32
-
-
diff --git a/src/condor_utils/named_classad_list.cpp b/src/condor_utils/named_classad_list.cpp
index d292d59..85ad047 100644
--- a/src/condor_utils/named_classad_list.cpp
+++ b/src/condor_utils/named_classad_list.cpp
@@ -87,14 +87,14 @@ NamedClassAdList::Replace( const char *name, ClassAd *newAd,
 {
 	NamedClassAd	*named_ad = Find( name );
 	if ( NULL == named_ad ) {
-		named_ad = new NamedClassAd( name, newAd );
+		named_ad = New( name, newAd );
 		if ( NULL == named_ad ) {
 			return -1;
 		}
 		dprintf( D_FULLDEBUG,
 				 "Adding '%s' to the 'extra' ClassAd list\n", name );
 		m_ads.push_back( named_ad );
-		return 0;
+		return report_diff;
 	}
 
 	// Did we find a match?
diff --git a/src/condor_utils/param_info.in b/src/condor_utils/param_info.in
index 0889e77..0a816f7 100644
--- a/src/condor_utils/param_info.in
+++ b/src/condor_utils/param_info.in
@@ -363,6 +363,12 @@ customization=seldom
 friendly_name=GSI Daemon Key
 review=?
 
+[GSS_ASSIST_GRIDMAP_CACHE_EXPIRATION]
+default=0
+type=int
+reconfig=true
+customization=seldom
+
 [VMWARE_NETWORKING_TYPE]
 default=
 type=string
@@ -6752,6 +6758,16 @@ friendly_name=Schedd Max File Descriptors
 usage=Set the limit on file descriptor usage for the scheduler.
 review=?
 
+[SHARED_PORT_MAX_FILE_DESCRIPTORS]
+default=4096
+range=0,
+type=int
+reconfig=false
+customization=seldom
+friendly_name=Shared Port Max File Descriptors
+usage=Set the limit on file descriptor usage for condor_shared_port.
+review=?
+
 [USE_RESOURCE_REQUEST_COUNTS]
 default=true
 type=bool
@@ -6761,6 +6777,16 @@ friendly_name=Use Resource Request Counts
 review=?
 tags=negotiator,matchmaker
 
+[NEGOTIATOR_RESOURCE_REQUEST_LIST_SIZE]
+default=20
+range=1,
+type=int
+reconfig=true
+customization=seldom
+friendly_name=Size of Resource Request List
+review=?
+tags=negotiator,matchmaker
+
 [HISTORY_HELPER_MAX_HISTORY]
 default=10000
 type=int
diff --git a/src/condor_utils/setegid.unix.cpp b/src/condor_utils/setegid.unix.cpp
deleted file mode 100644
index f993405..0000000
--- a/src/condor_utils/setegid.unix.cpp
+++ /dev/null
@@ -1,38 +0,0 @@
-/***************************************************************
- *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
- * University of Wisconsin-Madison, WI.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you
- * may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ***************************************************************/
-
-
-#include "config.h"
-#ifndef HAVE_SETEGID
-/*
-** Compatibility routine for systems which utilize setresgid() for
-** this purpose.
-*/
-#if !defined(Darwin) && !defined(CONDOR_FREEBSD)
-int setegid( int egid )
-{
-#if defined(HPUX)
-	return setresgid( -1, egid, -1 );
-#else
-	return setregid( -1, egid, -1 );;
-#endif
-}
-#endif
-
-#endif
diff --git a/src/condor_utils/seteuid.unix.cpp b/src/condor_utils/seteuid.unix.cpp
deleted file mode 100644
index 2db21c0..0000000
--- a/src/condor_utils/seteuid.unix.cpp
+++ /dev/null
@@ -1,35 +0,0 @@
-/***************************************************************
- *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
- * University of Wisconsin-Madison, WI.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you
- * may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ***************************************************************/
-
-
-#include "config.h"
-#ifndef HAVE_SETEGID
-
-/*
-** Compatibility routine for systems which utilize setresuid() for
-** this purpose.
-*/
-#if !defined(Darwin) && !defined(CONDOR_FREEBSD)
-int seteuid( int euid )
-{
-	return setresuid( -1, euid, -1 );
-}
-#endif
-
-#endif
diff --git a/src/condor_utils/setlinebuf.cpp b/src/condor_utils/setlinebuf.cpp
deleted file mode 100644
index 748fc6e..0000000
--- a/src/condor_utils/setlinebuf.cpp
+++ /dev/null
@@ -1,34 +0,0 @@
-/***************************************************************
- *
- * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
- * University of Wisconsin-Madison, WI.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you
- * may not use this file except in compliance with the License.  You may
- * obtain a copy of the License at
- * 
- *    http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ***************************************************************/
-
-#include "config.h"
-
-#ifndef HAVE_SETLINEBUF
-#include <stdio.h>
-
-/*
-** Compatibility routine for HP-UX which has setvbuf() instead of setlinebuf().
-*/
-int
-setlinebuf( FILE *fp)
-{
-	return setvbuf( fp, NULL, _IOLBF, 0 );
-}
-
-#endif
diff --git a/src/condor_utils/stl_string_utils.cpp b/src/condor_utils/stl_string_utils.cpp
index 3512782..d861b58 100644
--- a/src/condor_utils/stl_string_utils.cpp
+++ b/src/condor_utils/stl_string_utils.cpp
@@ -372,3 +372,34 @@ void join(const std::vector< std::string > &v, char const *delim, std::string &r
 		result += (*it);
 	}
 }
+
+// return the next string from the StringTokenIterator as a const std::string *
+// returns NULL when there is no next string.
+//
+const std::string * StringTokenIterator::next_string()
+{
+	if ( ! str) return NULL;
+
+	int ix = ixNext;
+
+	// skip leading separators and whitespace
+	while (str[ix] && strchr(delims, str[ix])) ++ix;
+	ixNext = ix;
+
+	// scan for next delimiter or \0
+	while (str[ix] && !strchr(delims, str[ix])) ++ix;
+	if (ix <= ixNext)
+		return NULL;
+
+	current.assign(str, ixNext, ix-ixNext);
+	ixNext = ix;
+	return &current;
+}
+
+bool StringTokenIterator::next(MyString & tok)
+{
+	const char * p = next(); 
+	tok = p;
+	return p != NULL; 
+}
+
diff --git a/src/condor_utils/stl_string_utils.h b/src/condor_utils/stl_string_utils.h
index 01f4709..9376fc8 100644
--- a/src/condor_utils/stl_string_utils.h
+++ b/src/condor_utils/stl_string_utils.h
@@ -100,4 +100,32 @@ bool lex_cast(const std::string& s, T& v) {
     return ss.eof() && (0 == (ss.rdstate() & std::stringstream::failbit));
 }
 
+// iterate a Null terminated string constant in the same way that StringList does in initializeFromString
+// Use this class instead of creating a throw-away StringList just so you can iterate the tokens in a string.
+//
+// NOTE: there are some subtle differences between this code and StringList::initializeFromString.
+// StringList ALWAYS tokenizes on whitespace regardlist of what delims is set to, but
+// this iterator does not, if you want to tokenize on whitespace, then delims must contain the whitepace characters.
+//
+// NOTE also, this class does NOT copy the string that it is passed.  You must insure that it remains in scope and is
+// unchanged during iteration.  This is trivial for string literals, of course.
+class StringTokenIterator {
+public:
+	StringTokenIterator(const char *s = NULL, int res=40, const char *delim = ", \t\r\n" ) : str(s), delims(delim), ixNext(0) { current.reserve(res); };
+	StringTokenIterator(const std::string & s, int res=40, const char *delim = ", \t\r\n" ) : str(s.c_str()), delims(delim), ixNext(0) { current.reserve(res); };
+
+	void rewind() { ixNext = 0; }
+	const char * next() { const std::string * s = next_string(); return s ? s->c_str() : NULL; }
+	bool next(MyString & tok);
+
+	const std::string * next_string(); // return NULL or a pointer to current token
+
+protected:
+	const char * str;   // The string we are tokenizing. it's not a copy, caller must make sure it continues to exist.
+	const char * delims;
+	int ixNext;
+	std::string current;
+};
+
+
 #endif // _stl_string_utils_h_
diff --git a/src/condor_utils/uids.cpp b/src/condor_utils/uids.cpp
index d072b93..546b1a0 100644
--- a/src/condor_utils/uids.cpp
+++ b/src/condor_utils/uids.cpp
@@ -294,7 +294,10 @@ void uninit_file_owner_ids() {}
 uid_t getuid() { return get_my_uid(); }
 
 // Static/Global objects
-extern dynuser *myDynuser; 	// the "system wide" dynuser object
+
+// This is the global object to access Dynuser.
+dynuser		myDyn;
+dynuser		*myDynuser = &myDyn;
 
 static HANDLE CurrUserHandle = NULL;
 static char *UserLoginName = NULL; // either a "nobody" account or the submitting user
diff --git a/src/condor_utils/write_user_log.cpp b/src/condor_utils/write_user_log.cpp
index c73af1e..4836d53 100644
--- a/src/condor_utils/write_user_log.cpp
+++ b/src/condor_utils/write_user_log.cpp
@@ -1265,7 +1265,7 @@ WriteUserLog::doWriteEvent( ULogEvent *event,
 		const char *fname;
 		if ( is_global_event ) fname = m_global_path;
 		else fname = log.path.c_str();
-		if ( condor_fsync( fileno( fp ), fname ) != 0 ) {
+		if ( condor_fdatasync( fileno( fp ), fname ) != 0 ) {
 		  dprintf( D_ALWAYS,
 				   "fsync() failed in WriteUserLog::writeEvent"
 				   " - errno %d (%s)\n",
