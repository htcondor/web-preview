diff -rNup condor-7.4.1.orig/src/condor_negotiator.V6/matchmaker.cpp condor-7.4.1/src/condor_negotiator.V6/matchmaker.cpp
--- condor-7.4.1.orig/src/condor_negotiator.V6/matchmaker.cpp	2010-03-25 13:49:30.000000000 -0400
+++ condor-7.4.1/src/condor_negotiator.V6/matchmaker.cpp	2010-06-15 14:36:25.000000000 -0400
@@ -36,6 +36,11 @@
 #include "condor_claimid_parser.h"
 #include "misc_utils.h"
 #include "ConcurrencyLimitUtils.h"
+#include "MyString.h"
+
+#include <vector>
+#include <string>
+
 
 #if HAVE_DLOPEN
 #include "NegotiatorPlugin.h"
@@ -48,6 +53,8 @@
 static int comparisonFunction (AttrList *, AttrList *, void *);
 #include "matchmaker.h"
 
+using namespace std;
+
 /* This extracts the machine name from the global job ID user@machine.name#timestamp#cluster.proc*/
 static int get_scheddname_from_gjid(const char * globaljobid, char * scheddname );
 
@@ -834,9 +841,9 @@ negotiationTime ()
 	ClaimIdHash claimIds(MyStringHash);
 	ClassAdList scheddAds;
 	ClassAdList allAds;
-	int unclaimedquota=0; 
-	int staticquota=0;
-	/**
+
+
+/**
 		Check if we just finished a cycle less than NEGOTIATOR_CYCLE_DELAY 
 		seconds ago.  If we did, reset our timer so at least 
 		NEGOTIATOR_CYCLE_DELAY seconds will elapse between cycles.  We do 
@@ -845,16 +852,15 @@ negotiationTime ()
 		the same resource twice).  Note: we must do this check _before_ we 
 		reset GotRescheduledCmd to false to prevent postponing a new 
 		cycle indefinitely.
-	**/
+**/
 	int elapsed = time(NULL) - completedLastCycleTime;
 	int cycle_delay = param_integer("NEGOTIATOR_CYCLE_DELAY",20,0);
 	if ( elapsed < cycle_delay ) {
-		daemonCore->Reset_Timer(negotiation_timerID,
-							cycle_delay - elapsed,
+		daemonCore->Reset_Timer(negotiation_timerID,cycle_delay - elapsed,
 							NegotiatorInterval);
 		dprintf(D_FULLDEBUG,
 			"New cycle requested but just finished one -- delaying %u secs\n",
-			cycle_delay - elapsed);
+				cycle_delay - elapsed);
 		return FALSE;
 	}
 
@@ -864,18 +870,17 @@ negotiationTime ()
 
 	// We need to nuke our MatchList from the previous negotiation cycle,
 	// since a different set of machines may now be available.
+
 	if (MatchList) delete MatchList;
 	MatchList = NULL;
 
 	// ----- Get all required ads from the collector
 	dprintf( D_ALWAYS, "Phase 1:  Obtaining ads from collector ...\n" );
-	if( !obtainAdsFromCollector( allAds, startdAds, scheddAds,
-		claimIds ) )
-	{
+	if( !obtainAdsFromCollector( allAds, startdAds, scheddAds, claimIds ) ) {
 		dprintf( D_ALWAYS, "Aborting negotiation cycle\n" );
 		// should send email here
 		return FALSE;
-	}
+		}
 
 	// Save this for future use.
 	// This _must_ come before trimming the startd ads.
@@ -883,16 +888,17 @@ negotiationTime ()
 	int numDynGroupSlots = untrimmed_num_startds;
 	double minSlotWeight = 0;
 	double untrimmedSlotWeightTotal = sumSlotWeights(startdAds,&minSlotWeight);
-	float unclaimed = 0;
-	
+
+	dprintf( D_ALWAYS, "Phase 1: numDynGroupSlots %d  untrimmedSlotWeightTotal %f \n" ,numDynGroupSlots,untrimmedSlotWeightTotal  );
 	// Register a lookup function that passes through the list of all ads.
 	// ClassAdLookupRegister( lookup_global, &allAds );
 
 	// Compute the significant attributes to pass to the schedd, so
 	// the schedd can do autoclustering to speed up the negotiation cycles.
+
 	if ( job_attr_references ) {
 		free(job_attr_references);
-	}
+		}
 	job_attr_references = compute_significant_attrs(startdAds);
 
 	// ----- Recalculate priorities for schedds
@@ -905,404 +911,864 @@ negotiationTime ()
 	// any of the claimed machines!).
 	int num_trimmed = trimStartdAds(startdAds);
 	if ( num_trimmed > 0 ) {
-		dprintf(D_FULLDEBUG,
-			"Trimmed out %d startd ads not Unclaimed\n",num_trimmed);
+		dprintf(D_FULLDEBUG, "Trimmed out %d startd ads not Unclaimed\n",num_trimmed);
 	}
 
-		// We insert NegotiatorMatchExprXXX attributes into the
-		// "matched ad".  In the negotiator, this means the machine ad.
-		// The schedd will later propogate these attributes into the
-		// matched job ad that is sent to the startd.  So in different
-		// matching contexts, the negotiator match exprs are in different
-		// ads, but they should always be in at least one.
+	// We insert NegotiatorMatchExprXXX attributes into the
+	// "matched ad".  In the negotiator, this means the machine ad.
+	// The schedd will later propogate these attributes into the
+	// matched job ad that is sent to the startd.  So in different
+	// matching contexts, the negotiator match exprs are in different
+	// ads, but they should always be in at least one.
 	insertNegotiatorMatchExprs( startdAds );
 
 	if ( !groupQuotasHash ) {
 		groupQuotasHash = new groupQuotasHashType(100,HashFunc);
 		ASSERT(groupQuotasHash);
-	}
-
-	char *groups = param("GROUP_NAMES");
-	if ( groups ) {
+		}
+	
+	// need to construct group structure
+	// groups is list of group names
+       // in form group.subgroup group.subgroup.subgroup etc
+	
+	char *groupnames = param("GROUP_NAMES"); // need to  change over to std:string at some point
+	string groups;
+	if ( groupnames ) {
 
-		// HANDLE GROUPS (as desired by CDF)
+	// HANDLE GROUPS (as desired by CDF)
 
-		// Populate the groupArray, which contains an entry for
-		// each group.
-		SimpleGroupEntry* groupArray;
-		int i;
-		StringList groupList;		
-		strlwr(groups); // the accountant will want lower case!!!
-		groupList.initializeFromString(groups);
-		free(groups);		
-		groupArray = new SimpleGroupEntry[ groupList.number()+1 ];
-		ASSERT(groupArray);
-		int* numsubmits = new int[groupList.number()+1];
-		ASSERT(numsubmits);
+	// Populate the groupArray, which contains an entry for
+	// each group.
+	
+	
+			
+	strlwr(groupnames); // the accountant will want lower case!!!	
+	string groupList(groupnames);
+	free(groupnames);	
+	SimpleGroupEntry grouptree;
+	SimpleGroupEntry tempentry;
+	// first step is to build top tier group
+	// name is null for now to avoid overlap between group names in the config
+	
+	grouptree.groupName.assign("\0");
+	grouptree.maxAllowed = (double)numDynGroupSlots;  
+	grouptree.quota = 1;  
+	grouptree.usage = 0;
+	grouptree.parent = NULL;
+	grouptree.numsubmits=0; 
+	grouptree.nodequota=0;
+	grouptree.nodemaxAllowed=0;
+	grouptree.unused=0;
+	grouptree.autoregroup=true;
+	
+	
         // Restrict number of slots available for dynamic quotas.
         if ( numDynGroupSlots && DynQuotaMachConstraint ) {
-            int matchedSlots = startdAds.Count( DynQuotaMachConstraint );
-            if ( matchedSlots ) {
-                dprintf(D_FULLDEBUG,
-                    "GROUP_DYNAMIC_MACH_CONSTRAINT constraint reduces machine "
-                    "count from %d to %d\n", numDynGroupSlots, matchedSlots);
-                numDynGroupSlots = matchedSlots;
-            } else {
-                dprintf(D_ALWAYS, "warning: 0 out of %d machines match "
-                        "GROUP_DYNAMIC_MACH_CONSTRAINT for dynamic quotas\n",
-                        numDynGroupSlots);
-                numDynGroupSlots = 0;
-            }
+		int matchedSlots = startdAds.Count( DynQuotaMachConstraint );
+            	if ( matchedSlots ) {
+                	dprintf(D_ALWAYS,"GROUP_DYNAMIC_MACH_CONSTRAINT constraint reduces machine "
+                		"count from %d to %d\n", numDynGroupSlots, matchedSlots);
+                	numDynGroupSlots = matchedSlots;
+            	} else {
+                	dprintf(D_ALWAYS, "warning: 0 out of %d machines match "
+                        	"GROUP_DYNAMIC_MACH_CONSTRAINT for dynamic quotas\n",
+                        	numDynGroupSlots);
+                	numDynGroupSlots = 0;
+            	}
         }
 
-		MyString tmpstr;
-		i = 0;
-		groupQuotasHash->clear();		
-		int unusedslots=0;
-		double quota_fraction;
-		float totalgroupquota=0;
-		groupList.rewind();
-		while ((groups = groupList.next ()))
-		{
-			tmpstr.sprintf("GROUP_QUOTA_%s",groups);
-			float quota = param_double(tmpstr.Value(), -1.0 );
-			if ( quota >= 0.0 ) {
-                // Static groups quotas take priority over any dynamic quota
-                dprintf(D_FULLDEBUG, "group %s static quota = %.3f\n",
-                        groups, quota);
-		staticquota=1;	
-            } else {
-                // Next look for a floating point dynamic quota.
-                tmpstr.sprintf("GROUP_QUOTA_DYNAMIC_%s", groups);
-                double quota_fraction =
-                    param_double(
-                        tmpstr.Value(),     // name
-                        0.0,                // default value
-                        0.0,                // min value
-                        1.0                 // max value
-                    );
-                if (quota_fraction != 0.0) {
-                    // use specified dynamic quota
-                    quota = rint(quota_fraction * numDynGroupSlots);
-                    dprintf(D_FULLDEBUG,
-                        "group %s dynamic quota for %d slots = %.3f\n",
-                            groups, numDynGroupSlots, quota);
-                } else {
-                    // neither a static nor dynamic quota was defined
-                    dprintf(D_ALWAYS,
-                        "ERROR - no quota specified for group %s, ignoring\n",
-                        groups);
-                    continue;
-                }
-            }
-            if ( quota <= 0 ) {
-                // Quota for group may have been set to zero by admin.
-                dprintf(D_ALWAYS,
-                    "zero quota for group %s, ignoring\n",
-                    groups);
-                continue;
-            }
-
-			// store this groups quota into our groupQuotas hash so we 
-			// can easily retrieve the quota for this group elsewhere in 
-			// this class.
-			MyString groupQuotaKey(groups);
-			groupQuotasHash->insert(groupQuotaKey,quota);
-
-			// fill in the info into the groupArray, so we can sort
-			// the groups into the order we want to negotiate them.
-			float usage = accountant.GetWeightedResourcesUsed(groups);
-			groupArray[i].groupName = groups;  // don't free this! (in groupList)
-			groupArray[i].maxAllowed = quota;
-			groupArray[i].usage = usage;
-				// the 'prio' field is used to sort the group array, i.e. to
-				// decide which groups get to negotiate first.  
-				// we sort groups based upon the percentage of their quota
-				// currently being used, so that groups using the least 
-				// percentage amount of their quota get to negotiate first.
-			groupArray[i].prio = ( 100 * usage ) / quota;
-			dprintf(D_FULLDEBUG,
-				"Group Table : group %s quota %.3f usage %.3f prio %2.2f\n",
-					groups,quota,usage,groupArray[i].prio);
-		if (!staticquota){
-			//now count total number of group submitters  and fix up quota
+	MyString tmpstr; // need to change this over to std:string at some point	
+		
+	size_t found;
+
+	//group names should be a comma delimied list
+	//we clean white space from the string
+	found=groupList.find_first_of(" ");
+	while(found!=string::npos){	
+		groupList.erase(found,1);
+		found=groupList.find_first_of(" ");
+	}
+	
+
+	while (!groupList.empty()) {
+		unsigned delim=groupList.find_first_of(",");
+		if (delim==-1) { 
+			groups=groupList;
+			groupList.erase();
+		} else {
+			groups=groupList.substr(0,delim);
+			if (delim+1<groupList.length()) groupList=groupList.substr(delim+1,groupList.length());
+		}
+		
+		
+		
+		
+		tempentry=populategroup(groups, startdAds, scheddAds);
+		size_t delimeter=tempentry.groupName.find_first_of(".");
+		insert(  tempentry, grouptree, delimeter,groups, startdAds,scheddAds);	
+	
+	} //while ((groups = groupList.next ()))
+	// At this point all groups are in the group array and
+	// the group array has the number of submitters for each group at each level
+	// i will be the length of the group array	
+		
+	//groupArray[0] is top of the tree and is a group created so that we can put all users
+	//into some place in the tree
+	//leave the name null for now so it doesn't trip up the sort 
+	dprintf(D_ALWAYS,"attaching submitters\n"); 
+	attachsubmitters(grouptree, startdAds,scheddAds);
+	dumptree(grouptree);
+dprintf(D_ALWAYS,"maxallowed\n");
+	maxAllowedcalc(grouptree);
+	
+	dumptree(grouptree);
+	
+	//now we know number of submitters and max number of slots allowed at each group level
+	scheddAds.Open();
+
+	// if we have users not in a group, we attach them to groupArray[0]
+	// they get to negotiate for any slots not used by subgroups
+	//grouptree.autoregroup is always true
+	if (scheddAds.Length()){
+		scheddAds.Open();
+		int numrunning=0;
+		int numidle=0;
+		ClassAd *ad = NULL;	
+		grouptree.numsubmits=0;
+		//int totalsubmits=0;
+		float schedusagetotal=0;
+		float scheddUsage=0;
+		while( (ad=scheddAds.Next()) ) {
+			ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
+			ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
+			grouptree.numsubmits=grouptree.numsubmits+numrunning+numidle;
+			MyString username;
+			if (ad->LookupString(ATTR_NAME, username) ){
+				//scheddName[79] = '\0'; // make certain we have a terminating NULL
+				scheddUsage = accountant.GetWeightedResourcesUsed(username);
+				schedusagetotal=scheddUsage+schedusagetotal;
+				grouptree.submitterAds.Insert(ad);
+				scheddAds.Delete(ad);
+			}
+		}
+		//safe to change the name now. We need a valid name because negotiate uses groupname as a flag.
+		
+		grouptree.groupName.assign("none\0");	
+		grouptree.usage = schedusagetotal;
+		grouptree.prio = 100;		
+
+	} 
+		
+	// now need to fix up quotas for groups
+	// every group should have a quota description
+	// have to have quota declarations at all levels to enforce hfs at different levels
+	// what we have to do is at bottom level calc quota and unused quota
+	// we reassign unused quota to other subgroups at this level
+	// if no reassignment, we add this unused quota to the unused quota level above.
+	// we then attempt to assign this unused quota to groups below
+	// if we can't, we add it to the group level above.
+		
+	//assigns maxAllowed to be numsubmits if numsubmits is less than quota
+	//otherwise maxAllowed  is the amount of quota not used
+	// we also generate the total number of unused slots
+	// these are slots that can be given to users and groups that have more
+	//submits than quota
+		
+	// Array should be sorted tree
+	// We start at the very end of the array which should be greatest depth
+dprintf(D_ALWAYS,"fairshare\n");
+	fairshare(grouptree);
+	
+	dprintf(D_FULLDEBUG,"negotiationtime: finished fairshare unable to use %f slots\n",grouptree.unused);
+
+	dumptree(grouptree);
+	dprintf(D_ALWAYS,"roundoff1\n");
+	roundoffstage1(grouptree);
+	
+
+	dumptree(grouptree);
+	//at this point we focus on leaves
+	//roundoff that needs to be fixed is within maxAllowed
+	dprintf(D_ALWAYS,"roundoff2\n");
+	double totalroundoff=0;
+	roundoffstage2(grouptree,totalroundoff);
+	
+	dprintf(D_ALWAYS,"negotiationtime: finished roundoff - unable to use %f\n",totalroundoff); 
+/*	
+	// This section is determines how many slots we are off due to roundoff
+	// and then assigns them in a round robin fashion
+	// roundoff error should be small (i.e. b1 slot) in a flat tree with many groups having submitters
+	// roundoff error seems to be larger in deep trees with few submitters
+	// round robin seems
+	for (i=0;i<groupArray.size(); i++){ 
+		if (groupArray[i].nodemaxAllowed>0&&groupArray[i].numsubmits>0) {
+			totalusedslots=totalusedslots+groupArray[i].nodemaxAllowed;
+		} else if (groupArray[i].child==-1){
+			totalusedslots=totalusedslots+groupArray[i].maxAllowed;
+		}
+	}
+		
+	int totalunusedslots=numDynGroupSlots-totalusedslots;
+	dprintf(D_FULLDEBUG,"negotiationtime: total used %d unused slots %d\n",totalusedslots,totalunusedslots);
+	bool gaveroundoff=true;
+	while (totalunusedslots>0&&gaveroundoff){
+		gaveroundoff=false;
+		for (i=0;i<groupArray.size()&&totalunusedslots>0; i++){
+			 if (groupArray[i].nodemaxAllowed>0&&groupArray[i].numsubmits>0){
+		 		groupArray[i].nodemaxAllowed=groupArray[i].nodemaxAllowed+1;
+				totalunusedslots--;
+				gaveroundoff=true;
+			} else if (groupArray[i].maxAllowed>0&&groupArray[i].child==-1&&groupArray[i].autoregroup==true) { 
+				groupArray[i].maxAllowed=groupArray[i].maxAllowed+1; 
+				totalunusedslots--; 
+				gaveroundoff=true;
+			}
+		}
+	}
+*/	
+	dumptree(grouptree);
+		
+		// negotiate for each group
+		
+		negotiatetree( grouptree,untrimmed_num_startds,untrimmedSlotWeightTotal, minSlotWeight, 
+					startdAds, claimIds,scheddAds);
+
+
+	} // if (groups)
+	else {
+		// negotiate w/ all users who do not belong to a group.
+	negotiateWithGroup(untrimmed_num_startds, untrimmedSlotWeightTotal, minSlotWeight, startdAds, claimIds, scheddAds);
+	}
+	
+	// ----- Done with the negotiation cycle
+	dprintf( D_ALWAYS, "---------- Finished Negotiation Cycle ----------\n" );
+
+	completedLastCycleTime = time(NULL);
+
+	return TRUE;
+}
+void Matchmaker::dumptree (SimpleGroupEntry & node){
+
+
+dprintf(D_ALWAYS," Group node %s quota %f nodequota %f maxAllowed %f nodemaxAllowed %f numsubmits %d \n",
+			 node.groupName.c_str(), node.quota, node.nodequota,
+			node.maxAllowed,node.nodemaxAllowed,node.numsubmits);
+if ( node.children.size()==0) return;
+for (int x=0;x<node.children.size();x++) dumptree(node.children[x]);
+
+}
+
+
+void Matchmaker::negotiatetree (SimpleGroupEntry & node, int untrimmed_num_startds,
+					 double untrimmedSlotWeightTotal,
+					 double minSlotWeight,
+					 ClassAdList& startdAds,
+					 ClaimIdHash& claimIds, 
+					 ClassAdList& scheddAds){
+
+if ( node.children.size()==0){
+	if ( node.submitterAds.MyLength() == 0 ) {
+				dprintf(D_ALWAYS,"Group %s - skipping, no submitters\n",node.groupName.c_str());
+				return;
+	}
+
+	dprintf(D_ALWAYS,
+		"Group %s - negotiating\n",node.groupName.c_str());
+	negotiateWithGroup( untrimmed_num_startds,untrimmedSlotWeightTotal, minSlotWeight, 
+					startdAds, claimIds, node.submitterAds, 
+						node.maxAllowed, node.usage, node.groupName.c_str() );
+	return;
+}
+
+
+if ( node.submitterAds.MyLength() == 0 ) {
+	dprintf(D_ALWAYS,"Group %s - skipping, no submitters\n",node.groupName.c_str());
+			
+} else {
+	dprintf(D_ALWAYS,
+		"Group %s - negotiating\n",node.groupName.c_str());
+	negotiateWithGroup(untrimmed_num_startds,untrimmedSlotWeightTotal, minSlotWeight, 
+					startdAds, claimIds, node.submitterAds, 
+					node.nodemaxAllowed,node.usage,node.groupName.c_str());		
+
+}			
+			
+			
+for (int x=0;x<node.children.size();x++) negotiatetree(node.children[x],untrimmed_num_startds,untrimmedSlotWeightTotal, minSlotWeight, 
+					startdAds, claimIds,scheddAds);		
+
+}
+
+
+void Matchmaker::maxAllowedcalc (SimpleGroupEntry & node) {
+
+
+
+if (node.staticquota){
+	if (node.parent!=NULL&&node.parent->maxAllowed<=0){
+				node.quota=0;
+				node.maxAllowed=0;
+		} else if (node.parent!=NULL){
+			if (node.parent->maxAllowed <node.quota) { //this would be a config error if true
+					node.maxAllowed =node.parent->maxAllowed;
+					dprintf(D_ALWAYS,"negotiationtime: Error in config. Subgroup %s static quota larger than parent group %s. Setting quota to match parent. \n",
+						node.groupName.c_str(), node.parent->groupName.c_str());	
+			}		
+			else node.maxAllowed=node.quota;
+			node.quota=node.maxAllowed/node.parent->maxAllowed;
+		}
+	} else if (node.parent!=NULL){
+		node.maxAllowed=node.quota*node.parent->maxAllowed;	
+		}
+if (node.children.size()==0) return;
+
+double grouptotal=0;
+for (int x=0;x<node.children.size();x++){
+	maxAllowedcalc(node.children[x]);
+	grouptotal=node.children[x].quota+grouptotal; 
+}
+
+	node.nodequota=1.0-grouptotal; 
+
+	if (node.nodequota<0)
+			node.nodequota=0; //check for negative
+			
+	node.nodemaxAllowed=
+			node.nodequota*node.maxAllowed;	 	
+
+
+}
+
+
+
+void  Matchmaker::roundoffstage1(SimpleGroupEntry & node){
+//this pushes all the roundoff and accumulated error
+// down into leaves
+// 
+double unused;
+if (node.children.size()==0) {
+	node.maxAllowed=node.maxAllowed+node.unused;
+	node.unused=0;
+	return;
+}
+if (node.children.size()>0&&node.numsubmits>0&&node.nodemaxAllowed>0){
+			if (node.unused>0){
+				double nodeshare=node.nodequota*node.unused;
+				node.nodemaxAllowed=node.nodemaxAllowed+nodeshare;
+				node.unused=node.unused-nodeshare; 
+			}
+		
+			unused=node.nodemaxAllowed-floorf(node.nodemaxAllowed)+node.unused;			
+			node.nodemaxAllowed=floorf(node.nodemaxAllowed);
+			//hand out unused to our children			
+			double childshare=0;				
+			node.unused=0;
+			for (int x=0;x<node.children.size();x++){
+				childshare=unused*node.children[x].quota; 
+ 				node.children[x].unused=childshare;			
+			}				
+													
+		} else if (node.children.size()>0)  {
+			
+			double childshare=0;
+		  	//now we iterate across children handing out pie
+			for (int x=0;x<node.children.size();x++){
+				childshare=node.unused*node.children[x].quota; 
+ 				node.children[x].unused=childshare;
+				
+			}
+			node.unused=0;
+		
+		}
+		
+ for (int x=0;x<node.children.size();x++) roundoffstage1(node.children[x]);
+}
+
+
+
+double   Matchmaker::roundoffstage2(SimpleGroupEntry & node, double treeroundoff){
+double totalroundoff=0;
+
+if (node.children.size()==0){
+	totalroundoff=node.maxAllowed-floor(node.maxAllowed)+treeroundoff;
+	node.maxAllowed=floor(node.maxAllowed);	
+   if (totalroundoff>1) {
+   	node.maxAllowed=node.maxAllowed+1;
+	totalroundoff= totalroundoff-1;
+	
+	}
+	return totalroundoff;
+}
+
+for (int x=0;x<node.children.size();x++){
+totalroundoff= roundoffstage2(node.children[x], totalroundoff)+totalroundoff;
+
+}
+return totalroundoff;
+}
+
+
+
+
+void Matchmaker::insert ( SimpleGroupEntry &tempentry, SimpleGroupEntry & node , size_t delimeter, string namestring, ClassAdList& startdAds, ClassAdList& scheddAds ){
+
+string parent, group;
+SimpleGroupEntry newentry;
+SimpleGroupEntry * temp;
+size_t delim2;
+size_t delim=tempentry.groupName.find_first_of(".");
+//parent=namestring.substr(0,delim); 
+
+if (delimeter==string::npos||delim==string::npos){ //i don't have a parent and so I just insert myself at the current level
+			tempentry.parent=&node;
+			
+			tempentry.name=tempentry.groupName;
+				dprintf(D_ALWAYS, "attaching self to node : group %s node %s namestring %s\n",
+					tempentry.groupName.c_str(), node.groupName.c_str(), namestring.c_str());
+			node.children.push_back(tempentry);
+		return;
+
+} else { 
+	parent=tempentry.groupName.substr(0,delimeter);
+	for (int x=0; x <node.children.size();x++){
+		dprintf(D_ALWAYS, "insert comparing: group -%s- node -%s- namestring -%s- parent -%s- children[x] -%s-\n",
+					tempentry.groupName.c_str(), node.groupName.c_str(), namestring.c_str(),parent.c_str(),node.children[x].name.c_str());
+		if ( node.children[x].name==parent) { // found our parent
+				delim2=tempentry.groupName.find_first_of(".", delimeter+1);
+				insert (tempentry, node.children[x], delim2, parent, startdAds, scheddAds);					
+		return;
+		}
+	}
+}
+
+
+dprintf(D_ALWAYS, "insert parent not found : group %s node %s namestring %s\n",
+					tempentry.groupName.c_str(), node.groupName.c_str(), namestring.c_str());
+// parent not found
+// insert parent
+newentry=populategroup(parent, startdAds, scheddAds);
+newentry.name=parent;		
+newentry.parent=&node;		
+delim2=namestring.find_first_of(".", delimeter+1);
+node.children.push_back(newentry);
+dprintf(D_ALWAYS, "insert another parent to insert: group %s node %s namestring %s parent %s\n",
+					tempentry.groupName.c_str(), node.groupName.c_str(), namestring.c_str(),parent.c_str());
+insert (tempentry, node.children.back(), delim2, parent, startdAds, scheddAds);
+
+
+
+}
+
+ void Matchmaker::attachsubmitters (SimpleGroupEntry & node, ClassAdList& startdAds, ClassAdList& scheddAds){
+	int numrunning=0;
+	int numidle=0;
+	ClassAd *ad = NULL;
+	string  scheddName;
+	scheddAds.Open();
+	size_t pos;
+	while( (ad=scheddAds.Next()) ) {
+		MyString temp;
+		string temp2,temp3;
+		if (!ad->LookupString(ATTR_NAME, temp)) {
+					continue;
+				}
+		scheddName.assign(temp.Value());
+		// is there a username seperator?
+		pos= scheddName.find_last_of("@");
+		//look for last group seperator
+		//this should separate group from user
+		if ( pos==string::npos) {
+					continue;
+				};
+		temp2=scheddName.substr(0,pos);
+		pos= temp2.find_last_of(".");
+		// is there a group/user seperator? 
+		if ( pos==string::npos) { //assuming here that the last delimited item is a username
+			continue;        //if the user leaves this off, the subitters will appear as users
+			}                //at the parent level
+
+		temp3=temp2.substr(0,pos);
+		if ( temp3.compare(node.groupName)==0 ) { 
+		numidle=0;
+		numrunning=0;
+		ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
+		ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
+            	node.numsubmits=node.numsubmits+numrunning+numidle;
+		node.submitterAds.Insert(ad);
+			scheddAds.Delete(ad);					 
+			}
+           			
+	}
+if ( node.children.size()==0) return;
+for (int x=0;x<node.children.size();x++) attachsubmitters(node.children[x],startdAds, scheddAds);
+}
+Matchmaker::SimpleGroupEntry  Matchmaker::populategroup (string group, ClassAdList& startdAds, ClassAdList& scheddAds){
+
+SimpleGroupEntry tempentry;
+	
+		
+	MyString tmpstr;
+	tmpstr.sprintf("GROUP_QUOTA_%s",group.c_str());
+	double quota_fraction = param_double(tmpstr.Value(), -1.0 );
+	if ( quota_fraction >= 0.0 ) {
+                	// Static groups quotas take priority over any dynamic quota
+                	dprintf(D_FULLDEBUG, "group %s static quota = %.3f\n", group.c_str(), quota_fraction);
+			tempentry.staticquota=true;			
+		} else {
+                	// Next look for a floating point dynamic quota.
+                	tmpstr.sprintf("GROUP_QUOTA_DYNAMIC_%s", group.c_str());
+                	quota_fraction =
+                    		param_double(
+                        		tmpstr.Value(),     // name
+                        		0.0,                // default value
+                        		0.0,                // min value
+                        		1.0                 // max value
+                    			);
+                	if (quota_fraction != 0.0) {
+                    		// use specified dynamic quota
+                    		//quota = rint(quota_fraction * numDynGroupSlots);
+                    		dprintf(D_FULLDEBUG, "group %s dynamic quota = %.3f\n",
+                            		group.c_str(),  quota_fraction);
+                	} else {
+                    		// neither a static nor dynamic quota was defined
+                    		dprintf(D_ALWAYS, "ERROR - no quota specified for group %s - ignoring\n",
+                        		group.c_str());
+                    		
+                 	}
+			tempentry.staticquota=false;
+            	}
+
+		tempentry.usage= accountant.GetWeightedResourcesUsed(group.c_str());
+
+		tempentry.groupName=group;
+		tempentry.maxAllowed = 0;  
+		tempentry.quota = quota_fraction;  
+		tempentry.nodequota=0;
+		tempentry.nodemaxAllowed=0;
+		tempentry.parent = NULL;
+		tempentry.unused = 0;
+		tempentry.numsubmits=0;
+		tempentry.autoregroup = false;
+		
+		tempentry.prio = ( 100 * tempentry.usage ) / quota_fraction;
+		dprintf(D_ALWAYS,"Group Table : group %s quota %.3f usage %.3f prio %2.2f\n",
+					group.c_str(),quota_fraction,tempentry.usage,tempentry.prio);
+					
+			/* It would be nice to do this up front
+			 * however, the stl req for having a const for the copy constructor and operator =
+			 * doesn't fly with the classAd list attached to the node
+			 * 	
+					//now count total number of group submitters  and fix up quota
                 	int numrunning=0;
 			int numidle=0;
 			ClassAd *ad = NULL;
-			char scheddName[80];
-			numsubmits[i]=0;
+			//char scheddName[80];
+			string  scheddName;
 			scheddAds.Open();
+			size_t pos;
 			while( (ad=scheddAds.Next()) ) {
-				if (!ad->LookupString(ATTR_NAME, scheddName, sizeof(scheddName))) {
+				MyString temp;
+				string temp2,temp3;
+				if (!ad->LookupString(ATTR_NAME, temp)) {
 					continue;
 				}
-				scheddName[79] = '\0'; // make certain we have a terminating NULL
-				char *sep = strchr(scheddName,'.');	// is there a group seperator?
-				if ( !sep ) {
+				scheddName.assign(temp.Value());
+				// is there a username seperator?
+				pos= scheddName.find_last_of("@");
+				//look for last group seperator
+				//this should separate group from user
+				if ( pos==string::npos) {
 					continue;
 				};
-				 *sep = '\0'; 
-				if ( strcasecmp(scheddName,groups)==0 ) { 
+				temp2=scheddName.substr(0,pos);
+				pos= temp2.find_last_of(".");
+				// is there a group/user seperator? 
+				if ( pos==string::npos) { //assuming here that the last delimited item is a username
+					continue;        //if the user leaves this off, the subitters will appear as users
+					}                //at the parent level
+
+				temp3=temp2.substr(0,pos);
+				if ( temp3.compare(group)==0 ) { 
 					numidle=0;
 					numrunning=0;
 					ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
 					ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
-		        		numsubmits[i]=numsubmits[i]+numrunning+numidle;
-            			}
-			} 		   
-		   	if( numsubmits[i]==0){
-		   		unusedslots=unusedslots+(int)groupArray[i].maxAllowed;		   
-		   	} else if(numsubmits[i]<quota ) {
-			 	unusedslots=unusedslots+(int)groupArray[i].maxAllowed-numsubmits[i];
-			}
-			totalgroupquota=totalgroupquota+quota;	
-			dprintf(D_FULLDEBUG, "group %s numgroupsubmits=%d quota=%f totalgroupquota=%f unusedslots=%d\n",groups, numsubmits[i], quota,totalgroupquota, unusedslots);
-		
-			} //if notstaticquota
-			i++;
-		} //while groups
-		int groupArrayLen = i;
-		
-
-			// pull out the submitter ads that specify a group from the
-			// scheddAds list, and insert them into a list specific to 
-			// the specified group.
-		ClassAd *ad = NULL;
-		char scheddName[80];
-		scheddAds.Open();
-		while( (ad=scheddAds.Next()) ) {
-			if (!ad->LookupString(ATTR_NAME, scheddName, sizeof(scheddName))) {
-				continue;
-			}
-			scheddName[79] = '\0'; // make certain we have a terminating NULL
-			char *sep = strchr(scheddName,'.');	// is there a group seperator?
-			if ( !sep ) {
-				continue;
-			}
-			*sep = '\0';
-			for (i=0; i<groupArrayLen; i++) {
-				if ( strcasecmp(scheddName,groupArray[i].groupName)==0 ) {
-					groupArray[i].submitterAds.Insert(ad);
-					scheddAds.Delete(ad);
-					break;
-				}
+            				tempentry.numsubmits=tempentry.numsubmits+numrunning+numidle;
+					tempentry.submitterAds.Insert(ad);
+					scheddAds.Delete(ad);					 
+					}
+           			
 			}
-		}
-		
-		if (!staticquota){
-		
-		// totalgroupquota is num slots claimed in config for groups
-		// unclamedquota is quota not claimed in config..could be for user jobs
-		// unusedslots is number of totalgroupquota that goes unused due to lack of submitters
+		*/	
+		bool default_autoregroup = param_boolean("GROUP_AUTOREGROUP",false);
+		MyString autoregroup_param;
+		autoregroup_param.sprintf("GROUP_AUTOREGROUP_%s",tempentry.groupName.c_str());	
+		if(param_boolean(autoregroup_param.Value(),default_autoregroup))
+			tempentry.autoregroup=true;
+		else 
+			tempentry.autoregroup=false;
+			
+		dprintf(D_FULLDEBUG,"negotiationtime: group %s autoregroup %s\n",
+			tempentry.groupName.c_str(),(tempentry.autoregroup)?"true":"false");
+		//add the entry to the vector			
 
-		unclaimed=numDynGroupSlots-totalgroupquota;
-		unclaimedquota=numDynGroupSlots-(int)totalgroupquota;
-		
-		// to fix up roundoff
-		if (unclaimed<1) unclaimedquota=0;
+
+return tempentry;
+}
+
+double Matchmaker::fairshare (SimpleGroupEntry & node) {
+
+double unused=0;
+double parentunused=0;
+
+if (node.children.size()==0) {//a leaf node
+	unused=node.maxAllowed-node.numsubmits;
+	if (unused <=0) {		
+		node.unused=0;	
+		return 0; //we have enough submitters to use all quota
+	}	
+	
+	node.unused=unused;
+	node.maxAllowed=node.numsubmits; //maxAllowed greater than number of submitters
+
+	return unused;
+} else { //not a leaf
+// get all unused from children
+ for (int x=0;x<node.children.size();x++){
+ 	unused=fairshare(node.children[x])+unused;
+	}
+	if (unused>0) 
+		node.unused=node.unused+unused;
+
+	//add in unused from our submitters
+	
+	if (node.nodemaxAllowed>0){ 
+		parentunused=node.nodemaxAllowed-node.numsubmits;
+		if (parentunused>0)
+				node.unused=node.unused+parentunused;		
+	}
+	if (node.unused>0){
+	if (node.autoregroup==true)				
+			node.unused=redistribute(node,node.unused);
+		else {
+			node.autoregroup=true;
+			node.unused=redistribute(node,node.unused);
+			node.autoregroup=false;
 		
-		dprintf(D_FULLDEBUG, " numDynGroupSlots=%d totalgroupquota=%f unclaimedquota=%d\n",numDynGroupSlots,totalgroupquota,unclaimedquota);
-			
-		scheddAds.Open();
-		// here we check for submitters that are not in a group with quota
-		int nongroupusers=scheddAds.Length();
-		dprintf(D_FULLDEBUG, " nongroupusers=%d totalgroupquota=%f\n",nongroupusers,totalgroupquota);
-		if (nongroupusers){
-			scheddAds.Open();
-			int numrunning=0;
-			int numidle=0;
+		}
+	}
+return node.unused;		
+	}
+
+}
+
+double Matchmaker::redistribute( SimpleGroupEntry & node, double unused)
+{
+	
+	
+    	dprintf(D_FULLDEBUG,"fairshare called on  %s auto %s maxallowed %f numsubmits %d group unused %f called with unused %f \n",
+    		node.groupName.c_str(),(node.autoregroup)?"true":"false",  node.maxAllowed, 
+    		node.numsubmits,node.unused,unused);
+	if (node.autoregroup==false) return unused;
+
+
+	if (node.children.size()==0) { //we are leaf and see if we can use the unused
+  		double canonlyuse=node.numsubmits-node.maxAllowed;
+ 
+  		dprintf(D_FULLDEBUG,"fairshare leaf %s maxallowed %f numsubmits %d unused %f canonlyuse %f\n",
+   				node.groupName.c_str(), node.maxAllowed, node.numsubmits,unused,canonlyuse);
+  		if (canonlyuse>0) {
+     			if (unused>=canonlyuse){
+  				node.maxAllowed=node.maxAllowed+canonlyuse;	
+				return unused-canonlyuse;
+  			} else {//we can use more but are only offered unused amount return 0 because we took them all
+  				node.maxAllowed=node.maxAllowed+unused; 
+  				return 0;
+
+  			}
+  		}//canonlyuse is 0 or less..can't use any
+  		return unused;
+	} else { //not a leaf
+
+  		dprintf(D_FULLDEBUG,"fairshare not a leaf node  %s maxallowed %f numsubmits %d unused %f \n", 
+  			node.groupName.c_str(), node.maxAllowed, node.numsubmits,unused);
+
+		// we dish out a fairshare to all our children
+		// child will point at rightmost child
+		double remaining=unused; //what we use to calculate share with
+		bool gavesome=true; 
+		while (gavesome&&remaining>0){   
+			gavesome=false; //reset gavesome flag each iteration across children
 			
-			numsubmits[groupArrayLen]=0;
-			int totalsubmits=0;
-			float schedusagetotal=0;
-			float scheddUsage=0;
-			while( (ad=scheddAds.Next()) ) {
-				ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
-				ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
-				numsubmits[groupArrayLen]=numsubmits[groupArrayLen]+numrunning+numidle;
-				if (ad->LookupString(ATTR_NAME, scheddName, sizeof(scheddName))) {
-					scheddName[79] = '\0'; // make certain we have a terminating NULL
-					scheddUsage = accountant.GetWeightedResourcesUsed(scheddName);
-					schedusagetotal=scheddUsage+schedusagetotal;
-					dprintf(D_FULLDEBUG, " nongroupusers=%d schedusagetotal=%f\n",nongroupusers,schedusagetotal);	
-					groupArray[groupArrayLen].submitterAds.Insert(ad);
-					scheddAds.Delete(ad);
-				}
-			}
-			groupArray[groupArrayLen].groupName = "none\0"; 
-			groupArray[groupArrayLen].maxAllowed = unclaimedquota;			
-			groupArray[groupArrayLen].usage = schedusagetotal;
-			groupArray[groupArrayLen].prio = 100;		
-			if(numsubmits[groupArrayLen] ==0 ){
-		 		  unusedslots=unusedslots+(int)groupArray[groupArrayLen].maxAllowed;
-		   	} else if(numsubmits[groupArrayLen]<(int)groupArray[groupArrayLen].maxAllowed ) {
-			 	unusedslots=unusedslots+(int)groupArray[groupArrayLen].maxAllowed-numsubmits[groupArrayLen];
+			double childshare=0;
+			double totalgiven=0; //count of what was given away this round
+			double notgiven=0;
+			//we first check to see if we have submitters and give a share to them if they have quota	
+			if ( node.autoregroup==true&&node.nodequota>0&&node.numsubmits>0) {
+				childshare=remaining*node.nodequota;
+				//A childshare could be a small percent of a node but that could mean the difference between getting
+				//another slot or not
+				//Eventually we will get to a state where remaining is really small and we are handing out very small
+				//childshare. There is no point iterating giving out 1/100 of a slot, so we handout what is remaining.
+				if (remaining<0.5) {
+					childshare=remaining; 
+					remaining=0;
+				}
+				double canonlyuse=node.numsubmits-node.nodemaxAllowed;
+ 				if (childshare>0&&canonlyuse>0) {
+    		 			if (childshare>=canonlyuse){
+  						node.nodemaxAllowed=node.nodemaxAllowed+canonlyuse;
+						
+						totalgiven=canonlyuse;
+  					} else {//we can use more but are only offered unused amount return 0 because we took them all
+  						node.nodemaxAllowed=node.nodemaxAllowed+childshare; 
+						
+						totalgiven=childshare;
+					}
+				gavesome=true;
+  				}
+				if (gavesome) 	
+					dprintf(D_FULLDEBUG,"fairshare gave some to non group user %s maxallowed=%f nodemaxAllowed=%f remaining %f\n",
+						node.groupName.c_str(),node.maxAllowed,node.nodemaxAllowed,remaining);
+	
 			}
-			groupArrayLen=groupArrayLen+1;
-		} else {
-			unusedslots=unusedslots+unclaimedquota;
-		}
-		dprintf(D_FULLDEBUG, " built array totalgroupquota=%f unusedslots=%d\n",totalgroupquota,unusedslots);
-		
-		// now we reassign unused slots for autogroup groups based upon percent group quota is of total slots
-		// this keeps fair share percentages the same as unused slots are spread around
-		float quotatotal=0;
-		float* oldquota = new float[groupArrayLen]; 
-		for (i=0;i<groupArrayLen;i++) { 
-			oldquota[i]=groupArray[i].maxAllowed;
-			quotatotal=quotatotal+oldquota[i];
-		}
-		//we know total unusedslots
-		int saveunusedslots=unusedslots;		
-		int unusedslotstotal=unusedslots;
-		int slotflag=1; 
-		int given=0;
-                
-		while (unusedslots>0 && slotflag){
-		 	int myshare=0;
-		  	slotflag=0;
-			int leftoverpie=unusedslots;
-			for (i=0; (i<groupArrayLen && unusedslots>0); i++){
-				double percentofunused=0;
-				dprintf(D_ALWAYS,"Group %s - unusedslots to give=%d maxallowed=%f \n",groupArray[i].groupName, unusedslots,groupArray[i].maxAllowed);
-		 		if (numsubmits[i]>groupArray[i].maxAllowed) {
-					// hand out unused slots to non group users if they had quota
-					if((i==groupArrayLen-1)&&nongroupusers&&groupArray[i].maxAllowed>0){
-						double piefraction=(double) leftoverpie*(double)oldquota[i]/(double)numDynGroupSlots;
-						if (piefraction>0 && piefraction<1) {
-							myshare=1;
-						} else {
-							myshare=rint((double)leftoverpie*(double)oldquota[i]/(double)numDynGroupSlots);
-						}
-						if (unusedslots<myshare) myshare=unusedslots;
-						groupArray[i].maxAllowed=groupArray[i].maxAllowed+myshare;
-						given=given+myshare;
-						slotflag=1;
-						unusedslots=unusedslots-myshare;
+			
+			//now we iterate across children handing out pie
+			for (int x=0;x<node.children.size();x++){ 
+				if (node.children[x].autoregroup==true){
+ 		 			if (remaining<0.5) {
+						childshare=remaining;
+						remaining=0;
 					} else {
-						// hand out unused slots to group users with autoregroup
-						bool default_autoregroup = param_boolean("GROUP_AUTOREGROUP",false);
-						MyString autoregroup_param;
-						autoregroup_param.sprintf("GROUP_AUTOREGROUP_%s",groupArray[i].groupName);
-						if(param_boolean(autoregroup_param.Value(),default_autoregroup)){			
-							double piefraction=(double) leftoverpie*(double)oldquota[i]/(double)numDynGroupSlots;
-							if (piefraction>0 && piefraction<1) {
-								myshare=1;
-							} else {
-								myshare=rint((double)leftoverpie*(double)oldquota[i]/(double)numDynGroupSlots);
+						childshare=remaining*node.children[x].quota; 
+					}
+					dprintf(D_FULLDEBUG,"fairshare %s maxallowed %f numsubmits %d childshare %f unused %f\n",
+						node.children[x].groupName.c_str(),node.children[x].maxAllowed , node.children[x].numsubmits,
+						childshare, unused);
+ 		
+                			notgiven=0;
+		 			if (childshare>0) {
+		  				if (node.children[x].unused==0){
+		  					notgiven=redistribute(node.children[x],childshare);
+		  					if (notgiven<childshare){ //we gave some or all
+								gavesome=1; 
+								totalgiven=totalgiven+(childshare-notgiven);
+							
 							}
-							if (unusedslots<myshare) myshare=unusedslots;
-							groupArray[i].maxAllowed=groupArray[i].maxAllowed+myshare;
-							given=given+myshare;
-							slotflag=1;
-							unusedslots=unusedslots-myshare;
+	
 						}
-					} 
-			    } else {
-				groupArray[i].maxAllowed=(float)numsubmits[i];}
-		 	
-		 	}
-			dprintf(D_ALWAYS,"totalunusedslots=%d given=%d \n", unusedslotstotal,given); 
-			if(given==0)slotflag=0;
-		}
-		dprintf(D_ALWAYS,"totalunusedslots=%d given=%d \n", unusedslotstotal,given);
-		
-		delete [] oldquota;
-		oldquota = NULL;
-		} //if notstaticquota
-
-			// now sort the group array
-		qsort(groupArray,groupArrayLen,sizeof(SimpleGroupEntry),groupSortCompare);		
-
-			// and negotiate for each group
-		for (i=0;i<groupArrayLen;i++) {
-			if ( groupArray[i].submitterAds.MyLength() == 0 ) {
-				dprintf(D_ALWAYS,
-					"Group %s - skipping, no submitters\n",
-					groupArray[i].groupName);
-				continue;
-			}
-			if ( groupArray[i].usage >= groupArray[i].maxAllowed  &&
-				 !ConsiderPreemption ) 
-			{
-				dprintf(D_ALWAYS,
-						"Group %s - skipping, at or over quota (usage=%.3f)\n",
-						groupArray[i].groupName,groupArray[i].usage);
-				continue;
-			}
-			dprintf(D_ALWAYS,
-				"Group %s - negotiating\n",groupArray[i].groupName);
-			negotiateWithGroup( untrimmed_num_startds,untrimmedSlotWeightTotal, minSlotWeight, 
-					startdAds, claimIds, groupArray[i].submitterAds, 
-					groupArray[i].maxAllowed, groupArray[i].usage,groupArray[i].groupName );
-		}
-		if (staticquota){
-		
-			// if GROUP_AUTOREGROUP is set to true, then for any submitter
-			// assigned to a group that did match, insert the submitter
-			// ad back into the main scheddAds list.  this way, we will
-			// try to match it again below .
-		bool default_autoregroup = param_boolean("GROUP_AUTOREGROUP",false);
-		for (i=0; i<groupArrayLen; i++) {
-			ad = NULL;
-			MyString autoregroup_param;
-			autoregroup_param.sprintf("GROUP_AUTOREGROUP_%s",groupArray[i].groupName);
-			if(param_boolean(autoregroup_param.Value(),default_autoregroup)) {
-				dprintf(D_ALWAYS,
-						"Group %s - autoregroup inserting %d submitters\n",
-						groupArray[i].groupName,
-						groupArray[i].submitterAds.MyLength());
+					}
 
-				groupArray[i].submitterAds.Open();
-				while( (ad=groupArray[i].submitterAds.Next()) ) {
-					scheddAds.Insert(ad);				
-				}
+	
+				dprintf(D_FULLDEBUG,"after fairshare  %s  maxallowed %f numsubmits %d childshare %f unused %f remaining %f notgiven %f totalgiven %f\n",
+		 			node.children[x].groupName.c_str(), node.children[x].maxAllowed, node.children[x].
+		 			numsubmits,childshare, unused, remaining, notgiven, totalgiven);
+			}
+			
 			}
+	
+			remaining=remaining-totalgiven;
+			if (remaining<0) remaining=0; //precaution against roundoff
+			
+			dprintf(D_FULLDEBUG,"fairshare  group %s maxallowed %f numsubmits %d unused %f remaining %f gavesome %d\n",
+			node.groupName.c_str(), node.maxAllowed, node.numsubmits, unused, remaining, (int)gavesome);
+	
+		}
+		return remaining; 
 		}
-		
-		
-		
-		
-		
-		} //if notstaticquota
 
-			// finally, cleanup 
-		delete []  groupArray;
-		groupArray = NULL;
-		delete [] numsubmits;
-		numsubmits = NULL;
+}
+
 
-			// print out a message stating we are about to negotiate below w/
-			// all users who did not specify a group
-		dprintf(D_ALWAYS,"Group *none* - negotiating\n");
 
-	} // if (groups)
-	
-		// negotiate w/ all users who do not belong to a group.
-	negotiateWithGroup(untrimmed_num_startds, untrimmedSlotWeightTotal, minSlotWeight, startdAds, claimIds, scheddAds);
-	
-	// ----- Done with the negotiation cycle
-	dprintf( D_ALWAYS, "---------- Finished Negotiation Cycle ----------\n" );
 
-	completedLastCycleTime = time(NULL);
 
-	return TRUE;
-}
 
 Matchmaker::SimpleGroupEntry::
 SimpleGroupEntry()
 {
-	groupName = NULL;
+	groupName.assign("\0");
 	prio = 0;
+	parent = NULL;
 	maxAllowed = (float) INT_MAX;
 }
 
 Matchmaker::SimpleGroupEntry::
+SimpleGroupEntry(const Matchmaker::SimpleGroupEntry& entry)
+{
+	ClassAd *ad = NULL;
+	
+	groupName=entry.groupName;
+	prio=entry.prio;
+	maxAllowed=entry.maxAllowed;
+	nodemaxAllowed=entry.nodemaxAllowed;
+	quota=entry.quota;
+	usage=entry.usage;
+	parent=entry.parent;
+	nodequota=entry.nodequota;
+	autoregroup=entry.autoregroup;
+	numsubmits=entry.numsubmits;
+	staticquota=entry.staticquota;
+	unused=entry.unused;
+	children=entry.children;
+	name=entry.name;
+/*
+ * see note in populategroup
+ * stl requires const Matchmaker::SimpleGroupEntry& entry
+ * 
+
+	submitterAds.Open();
+	while( (ad=submitterAds.Next()) ) {
+		submitterAds.Delete(ad);				
+		}
+	
+	entry.submitterAds.Open();
+	while (ad=entry.submitterAds.Next()) {
+		submitterAds.Insert(ad);
+		}
+*/
+}
+
+Matchmaker::SimpleGroupEntry::
 ~SimpleGroupEntry()
 {
-	// Note: don't free groupName!  See comment above.
+	
+}
+
+	
+Matchmaker::SimpleGroupEntry & Matchmaker::SimpleGroupEntry::operator = (const SimpleGroupEntry  & entry) {
+	
+	ClassAd *ad = NULL;
+		
+	groupName=entry.groupName;
+	prio=entry.prio;
+	maxAllowed=entry.maxAllowed;
+	nodemaxAllowed=entry.nodemaxAllowed;
+	quota=entry.quota;
+	usage=entry.usage;
+	parent=entry.parent;
+	nodequota=entry.nodequota;
+	autoregroup=entry.autoregroup;
+	numsubmits=entry.numsubmits;
+	staticquota=entry.staticquota;
+	unused=entry.unused;
+	children=entry.children;
+	name=entry.name;
+/*
+	submitterAds.Open();
+	while( (ad=submitterAds.Next()) ) {
+		submitterAds.Delete(ad);				
+		}
+	
+	entry.submitterAds.Open();
+	while (ad=entry.submitterAds.Next()) {
+		submitterAds.Insert(ad);
+		}
+*/		
+	return *this;
 }
 
+
 int Matchmaker::
 negotiateWithGroup ( int untrimmed_num_startds,
 					 double untrimmedSlotWeightTotal,
diff -rNup condor-7.4.1.orig/src/condor_negotiator.V6/matchmaker.h condor-7.4.1/src/condor_negotiator.V6/matchmaker.h
--- condor-7.4.1.orig/src/condor_negotiator.V6/matchmaker.h	2010-03-25 13:49:30.000000000 -0400
+++ condor-7.4.1/src/condor_negotiator.V6/matchmaker.h	2010-06-15 14:36:19.000000000 -0400
@@ -27,6 +27,9 @@
 #include "string_list.h"
 #include "dc_collector.h"
 #include "condor_ver_info.h"
+#include <string>
+
+using namespace std;
 
 /* FILESQL include */
 #include "file_sql.h"
@@ -196,7 +199,7 @@ class Matchmaker : public Service
 		                       double slotWeightTotal,
 		                            /* result parameters: */
 		                       double &pieLeft);
-
+	
 		void MakeClaimIdHash(ClassAdList &startdPvtAdList, ClaimIdHash &claimIds);
 		char const *getClaimId (const char *, const char *, ClaimIdHash &, MyString &);
 		void addRemoteUserPrios( ClassAd* ad );
@@ -380,7 +383,7 @@ class Matchmaker : public Service
 			int m_rejPreemptForRank;    //   - startd RANKs new job lower?
 			int m_rejForSubmitterLimit;     //  - not enough group quota?
 			float m_submitterLimit;
-			
+		 	
 			
 		};
 		MatchListType* MatchList;
@@ -395,15 +398,46 @@ class Matchmaker : public Service
 		{
 		public:
 			SimpleGroupEntry();
+			SimpleGroupEntry(const Matchmaker::SimpleGroupEntry& entry);
 			~SimpleGroupEntry();
-			char *groupName;
+			string groupName;
 			float prio;
-			float maxAllowed;
-			float usage;
-			ClassAdList submitterAds;			
+			double maxAllowed;
+			double nodequota;
+			double nodemaxAllowed;
+			double quota;
+			double usage;
+			double unused;
+			bool autoregroup;
+			SimpleGroupEntry * parent;
+
+			int numsubmits;
+			bool staticquota;
+			ClassAdList submitterAds;
+			void sort(int length);
+			std::vector<SimpleGroupEntry> children; //children
+			std::string name;   // name string
+			 
+		SimpleGroupEntry & operator = (const SimpleGroupEntry  & entry);
+				
 		};
 		static int groupSortCompare(const void*, const void*);
 		
+		double redistribute( SimpleGroupEntry & node, double unused);
+		double fairshare (SimpleGroupEntry & node);
+		SimpleGroupEntry populategroup (string group, ClassAdList& startdAds, ClassAdList& scheddAds);
+		void insert ( SimpleGroupEntry &tempentry, SimpleGroupEntry & node , size_t delimeter, string namestring, ClassAdList& startdAds, ClassAdList& scheddAds );
+		void maxAllowedcalc (SimpleGroupEntry & node);
+		void  roundoffstage1(SimpleGroupEntry & node);
+		double roundoffstage2(SimpleGroupEntry & node, double treeroundoff);
+		void negotiatetree (SimpleGroupEntry & node, int untrimmed_num_startds,
+					 double untrimmedSlotWeightTotal,
+					 double minSlotWeight,
+					 ClassAdList& startdAds,
+					 ClaimIdHash& claimIds, 
+					 ClassAdList& scheddAds);
+		void dumptree (SimpleGroupEntry & node);
+		void attachsubmitters (SimpleGroupEntry & node, ClassAdList& startdAds, ClassAdList& scheddAds);		 
 		char RejectsTable[40];
 		char MatchesTable[40];
 		int prevLHF;
