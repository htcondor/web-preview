diff -rNup condor-7.9.1.orig/src/condor_starter.V6.1/baseStarter.cpp condor-7.9.1/src/condor_starter.V6.1/baseStarter.cpp
--- condor-7.9.1.orig/src/condor_starter.V6.1/baseStarter.cpp	2012-08-16 15:51:24.000000000 -0400
+++ condor-7.9.1/src/condor_starter.V6.1/baseStarter.cpp	2013-03-19 11:42:12.086014632 -0400
@@ -2975,3 +2975,23 @@ CStarter::WriteAdFiles()
 
 	return ret_val;
 }
+
+
+int
+CStarter::updateJobAttr (const char *name, const char *expr)
+{
+	if( jic && (jic->jobUniverse() == CONDOR_UNIVERSE_LOCAL)) {		
+		return (jic->updateJobAttr( name, expr));
+	}
+       return  0;	
+}
+
+int
+CStarter::getJobAttr (const char *name, MyString &expr )
+{
+	if( jic && (jic->jobUniverse() == CONDOR_UNIVERSE_LOCAL) ) {		
+		return (jic->getJobAttr( name, expr ));
+	}
+       return  0 ;	
+}
+
diff -rNup condor-7.9.1.orig/src/condor_starter.V6.1/io_proxy.cpp condor-7.9.1/src/condor_starter.V6.1/io_proxy.cpp
--- condor-7.9.1.orig/src/condor_starter.V6.1/io_proxy.cpp	2012-08-16 15:51:24.000000000 -0400
+++ condor-7.9.1/src/condor_starter.V6.1/io_proxy.cpp	2013-03-19 11:42:12.087014640 -0400
@@ -22,10 +22,13 @@
 #include "condor_random_num.h"
 #include "io_proxy.h"
 #include "io_proxy_handler.h"
+#include "local_io_proxy_handler.h"
 #include "ipv6_hostname.h"
+#include "starter.h"
 
 #define IO_PROXY_COOKIE_SIZE 32
 
+extern CStarter *Starter;
 static char * cookie_create( int length );
 
 IOProxy::IOProxy()
@@ -72,13 +75,21 @@ int IOProxy::connect_callback( Stream *
 	}
 	
 	if(accept_client) {
-		IOProxyHandler *handler = new IOProxyHandler();
-		if(!handler->init(client,cookie)) {
-			dprintf(D_ALWAYS,"IOProxy: couldn't register request callback!\n");
-			client->close();
-			delete client;
+		if( Starter->jic && (Starter->jic->jobUniverse() == CONDOR_UNIVERSE_LOCAL)) {		
+			LocalIOProxyHandler *handler = new LocalIOProxyHandler();
+			if(!handler->init(client,cookie)) {
+				dprintf(D_ALWAYS,"IOProxy: couldn't register LocalIOProxyHandler callback!\n");
+				client->close();
+				delete client;
+			}		
+		} else {	
+			IOProxyHandler *handler = new IOProxyHandler();
+			if(!handler->init(client,cookie)) {
+				dprintf(D_ALWAYS,"IOProxy: couldn't register IOProxyHandler callback!\n");
+				client->close();
+				delete client;
+			}
 		}
-
 	} else {
 		client->close();
 		delete client;
diff -rNup condor-7.9.1.orig/src/condor_starter.V6.1/io_proxy_handler.cpp condor-7.9.1/src/condor_starter.V6.1/io_proxy_handler.cpp
--- condor-7.9.1.orig/src/condor_starter.V6.1/io_proxy_handler.cpp	2012-08-16 15:51:24.000000000 -0400
+++ condor-7.9.1/src/condor_starter.V6.1/io_proxy_handler.cpp	2013-03-19 11:42:12.087014640 -0400
@@ -130,7 +130,7 @@ Format tokens recognized:
 */
 
 int
-sscanf_chirp( char const *input,char const *fmt,... )
+IOProxyHandler::sscanf_chirp( char const *input,char const *fmt,... )
 {
   va_list args;
   int args_parsed = 0;
@@ -192,6 +192,8 @@ sscanf_chirp( char const *input,char con
   return args_parsed;
 }
 
+
+
 /*
 Handle an incoming line from the client.
 A valid cookie is assumed to have been received, so decode and execute any request.
diff -rNup condor-7.9.1.orig/src/condor_starter.V6.1/io_proxy_handler.h condor-7.9.1/src/condor_starter.V6.1/io_proxy_handler.h
--- condor-7.9.1.orig/src/condor_starter.V6.1/io_proxy_handler.h	2012-08-16 15:51:24.000000000 -0400
+++ condor-7.9.1/src/condor_starter.V6.1/io_proxy_handler.h	2013-03-19 11:42:12.087014640 -0400
@@ -34,15 +34,16 @@ public:
 	IOProxyHandler();
 	~IOProxyHandler();
 
-	bool init( Stream *stream, const char *cookie );
+	virtual bool init( Stream *stream, const char *cookie );
 
-private:
+protected:
 	int handle_request( Stream *s );
 	void handle_cookie_request( ReliSock *r, char *line );
-	void handle_standard_request( ReliSock *r, char *line );
+	virtual void handle_standard_request( ReliSock *r, char *line );
 	int convert( int result, int unix_errno );
 	void fix_chirp_path( char *path );
-
+        int sscanf_chirp( char const *input,char const *fmt,... );
+	
 	char *cookie;
 	int got_cookie;
 };
diff -rNup condor-7.9.1.orig/src/condor_starter.V6.1/jic_local.h condor-7.9.1/src/condor_starter.V6.1/jic_local.h
--- condor-7.9.1.orig/src/condor_starter.V6.1/jic_local.h	2012-08-16 15:51:24.000000000 -0400
+++ condor-7.9.1/src/condor_starter.V6.1/jic_local.h	2013-03-19 11:42:12.087014640 -0400
@@ -175,8 +175,7 @@ public:
 			@param filename File to remove from the job's output list 
 		*/
 	void removeFromOutputFiles( const char* filename );
-
-
+	
 protected:
 
 		// // // // // // // // // // // //
diff -rNup condor-7.9.1.orig/src/condor_starter.V6.1/jic_local_schedd.cpp condor-7.9.1/src/condor_starter.V6.1/jic_local_schedd.cpp
--- condor-7.9.1.orig/src/condor_starter.V6.1/jic_local_schedd.cpp	2012-08-16 15:51:24.000000000 -0400
+++ condor-7.9.1/src/condor_starter.V6.1/jic_local_schedd.cpp	2013-03-19 11:42:12.088014648 -0400
@@ -52,7 +52,7 @@ JICLocalSchedd::JICLocalSchedd( const ch
 	dprintf( D_ALWAYS,
 			 "Starter running a job under a schedd listening at %s\n",
 			 schedd_addr );
-
+        
 	job_updater = NULL;
 	m_cleanup_retry_tid = -1;
 	m_num_cleanup_retries = 0;
@@ -73,7 +73,7 @@ JICLocalSchedd::~JICLocalSchedd()
 	}
 	if( job_updater ) {
 		delete job_updater;
-	}
+	}	
 	if( m_cleanup_retry_tid >= 0 ) {
 		daemonCore->Cancel_Timer(m_cleanup_retry_tid);
 		m_cleanup_retry_tid = -1;
@@ -108,6 +108,13 @@ JICLocalSchedd::init( void )
 		this->starter_user_policy->init( this->job_ad, this );
 		this->starter_user_policy->startTimer( );
 	}
+	
+	// If the user wants it, initialize our io proxy
+	// Must have user priv to drop the config info	
+	// into the execute dir.
+        priv_state priv = set_user_priv();
+	initIOProxy();
+	priv = set_priv(priv);
 	return ( ret );
 }
 
@@ -507,7 +514,6 @@ JICLocalSchedd::initLocalUserLog( void )
 	return true;
 }
 
-
 void
 JICLocalSchedd::retryJobCleanup( void )
 {
@@ -551,3 +557,73 @@ JICLocalSchedd::notifyStarterError( cons
 	}
 	return true;
 }
+
+
+
+int
+JICLocalSchedd::getJobAttr( const char *name, MyString &expr )
+{
+
+	ExprTree *e = job_ad->LookupExpr(name);
+	if(e) {
+		expr = ExprTreeToString(e);
+		dprintf(D_SYSCALLS,"JICLocalSchedd::getJobAttr(%s) = %s\n",name,expr.Value());
+		return 1;
+	} else {
+		dprintf(D_SYSCALLS,"JICLocalSchedd::getJobAttr(%s) is UNDEFINED\n",name);
+		expr = "UNDEFINED";
+		return 0;
+	}
+}
+
+int
+JICLocalSchedd::updateJobAttr( const char *name, const char *expr)
+{
+        dprintf(D_SYSCALLS,"JICLocalSchedd::updateJobAttr(%s) = %s\n",name,expr);
+	int result = (int)job_updater->updateAttr( name, expr, false, true );
+	if (result){
+		ASSERT(job_ad);
+	 	job_ad->AssignExpr(name,expr);
+	}
+	return result; 
+}
+
+bool
+JICLocalSchedd::initIOProxy( void )
+{
+	int want_io_proxy = 0;
+	MyString io_proxy_config_file;
+
+		// the admin should have the final say over whether
+		// chirp is enabled
+        bool enableIOProxy = true;
+	enableIOProxy = param_boolean("ENABLE_CHIRP", true);
+	
+	if (!enableIOProxy) {
+		dprintf(D_ALWAYS, "ENABLE_CHIRP is false in config file, not enabling chirp\n");
+		return false;
+	}
+
+	if( job_ad->LookupBool( ATTR_WANT_IO_PROXY, want_io_proxy ) < 1 ) {
+		dprintf( D_FULLDEBUG, "JICLocalSchedd::initIOProxy(): "
+				 "Job does not define %s\n", ATTR_WANT_IO_PROXY );
+		want_io_proxy = 0;
+	} else {
+		dprintf( D_ALWAYS, "Job has %s=%s\n", ATTR_WANT_IO_PROXY,
+				 want_io_proxy ? "true" : "false" );
+	}
+
+	if( want_io_proxy ) {
+		io_proxy_config_file.sprintf( "%s%cchirp.config",
+				 Starter->GetWorkingDir(), DIR_DELIM_CHAR );
+		if( !io_proxy.init(io_proxy_config_file.Value()) ) {
+			dprintf( D_FAILURE|D_ALWAYS, 
+					 "Couldn't initialize IO Proxy.\n" );
+			return false;
+		}
+		dprintf( D_ALWAYS, "Initialized IO Proxy.\n" );
+		return true;
+	}
+	return false;
+}
+
diff -rNup condor-7.9.1.orig/src/condor_starter.V6.1/jic_local_schedd.h condor-7.9.1/src/condor_starter.V6.1/jic_local_schedd.h
--- condor-7.9.1.orig/src/condor_starter.V6.1/jic_local_schedd.h	2012-08-16 15:51:24.000000000 -0400
+++ condor-7.9.1/src/condor_starter.V6.1/jic_local_schedd.h	2013-03-19 11:42:12.088014648 -0400
@@ -24,6 +24,8 @@
 #include "jic_local_file.h"
 #include "../condor_schedd.V6/qmgr_job_updater.h"
 #include "starter_user_policy.h"
+#include "file_transfer.h"
+#include "io_proxy.h"
 
 /** 
 	This is the child class of JICLocalFile (and therefore JICLocal
@@ -151,8 +153,16 @@ public:
 
 	virtual bool notifyStarterError( const char* err_msg, bool critical, int hold_reason_code, int hold_reason_subcode );
 
+        int getJobAttr( const char *name, MyString &expr );
+        int updateJobAttr( const char *name, const char *expr);
+
+	
 protected:
 
+	IOProxy io_proxy;
+	        /// If the job ad says so, initialize our IO proxy
+	bool initIOProxy( void );
+	        	
 	void setExitCodeToRequeue();
 
 		/// This version confirms we're handling a "local" universe job. 
@@ -196,6 +206,8 @@ protected:
 	StarterUserPolicy *starter_user_policy;
 
 	bool m_tried_notify_job_exit;
+	int want_io_proxy;
+	bool enableIOProxy;
 };
 
 #endif /* _CONDOR_JIC_LOCAL_SCHEDD_H */
diff -rNup condor-7.9.1.orig/src/condor_starter.V6.1/job_info_communicator.h condor-7.9.1/src/condor_starter.V6.1/job_info_communicator.h
--- condor-7.9.1.orig/src/condor_starter.V6.1/job_info_communicator.h	2012-08-16 15:51:24.000000000 -0400
+++ condor-7.9.1/src/condor_starter.V6.1/job_info_communicator.h	2013-03-19 11:42:12.088014648 -0400
@@ -358,6 +358,10 @@ public:
 	
 		/* Update Job ClassAd with checkpoint info and log it */
 	virtual void updateCkptInfo(void) {};
+	
+        virtual int getJobAttr( const char *, MyString & ) { return 0; }
+        virtual int updateJobAttr( const char *, const char *){ return 0; }
+	virtual WriteUserLog * getUserLog(){ return u_log->getWriteUserLog();}
 
 protected:
 
@@ -445,6 +449,7 @@ protected:
 	virtual void writeExecutionVisa( ClassAd& );
 
 
+	
 		// // // // // // // // // // // //
 		// Protected data members
 		// // // // // // // // // // // //
diff -rNup condor-7.9.1.orig/src/condor_starter.V6.1/local_io_proxy_handler.cpp condor-7.9.1/src/condor_starter.V6.1/local_io_proxy_handler.cpp
--- condor-7.9.1.orig/src/condor_starter.V6.1/local_io_proxy_handler.cpp	1969-12-31 19:00:00.000000000 -0500
+++ condor-7.9.1/src/condor_starter.V6.1/local_io_proxy_handler.cpp	2013-03-19 11:42:24.075109830 -0400
@@ -0,0 +1,1327 @@
+/***************************************************************
+ *
+ * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+
+#include "condor_common.h"
+#include "local_io_proxy_handler.h"
+#include "starter.h"
+#include "../condor_chirp/chirp_protocol.h"
+#include "filename_tools.h"
+#include "basename.h"
+#include "condor_event.h"
+#include <errno.h>
+#include "directory.h"
+
+extern CStarter *Starter;
+
+int get_file_info_new( const char *logical_name, char *&actual_url );
+static void append_buffer_info( MyString &url, const char *method, char const *path );
+int get_buffer_info( int *bytes_out, int *block_size_out, int *prefetch_bytes_out );
+static void complete_path( const char *short_path, MyString &full_path );
+static int use_local_access( const char *file );
+static int use_compress( const char *method, const char *path );
+static int use_fetch( const char *method, const char *path );
+static int use_append( const char *method, const char *path );
+static int use_special_access( const char *file );
+int ulog( ClassAd *ad );
+static int stat_string( char *line, struct stat *info );
+#if defined(Solaris)
+static int statfs_string( char *line, struct statvfs *info );
+#else
+static int statfs_string( char *line, struct statfs *info );
+#endif
+/*
+Initialize this handler on the given stream.
+The process at the other side of the stream must present
+the cookie passed in as an argument.  This r
+Returns true on success, false otherwise.
+*/
+
+bool LocalIOProxyHandler::init( Stream *s, const char *c )
+{
+	cookie = strdup(c);
+	if(!cookie) return false;
+
+	daemonCore->Register_Socket( s, "LocalIOProxy client", (SocketHandlercpp) &LocalIOProxyHandler::handle_request, "LocalIOProxyHandler::handle_request", this );
+
+	return true;
+}
+
+/*
+Handle an incoming line from the client.
+A valid cookie is assumed to have been received, so decode and execute any request.
+This is similar to the Shadow BTReceivers and pseudi_ops code. Not that we don't have to
+perform allowread/allowwrite checks as in RemoteResource because the jic initIOProxy code won't init the
+IOProxy if ATTR_WANT_IO_PROXY or ENABLE_CHIRP are false.
+*/
+
+void LocalIOProxyHandler::handle_standard_request( ReliSock *r, char *line )
+{
+	char *url = NULL;
+	char path[CHIRP_LINE_MAX];
+	char newpath[CHIRP_LINE_MAX];
+	char flags_string[CHIRP_LINE_MAX];
+	char name[CHIRP_LINE_MAX];
+	char expr[CHIRP_LINE_MAX];
+	int result, offset, whence, length, flags, mode, fd, stride_length;
+	int stride_skip, uid, gid, actime, modtime;
+	char *buffer = NULL;
+	condor_errno_t terrno;
+	
+	dprintf(D_SYSCALLS,"IOProxyHandler_local: request: %s\n",line);
+
+	flags_string[0] = 0;
+	priv_state old_priv = set_user_priv();
+	
+	if(sscanf_chirp(line,"open %s %s %d",path,flags_string,&mode)==3) {
+
+		/*
+		Open is a rather special case.
+		First, we attempt to look up the file name and
+		convert it into a physical url.  Then, we make
+		sure that we know how to open the url.
+		Finally, we actually open it.
+		*/
+
+		dprintf(D_SYSCALLS,"Getting mapping for file %s\n",path);
+
+		result = get_file_info_new(path,url);
+		if(result==0) {
+			dprintf(D_SYSCALLS,"Directed to use url %s\n",url);
+			ASSERT( strlen(url) < CHIRP_LINE_MAX );
+			if(!strncmp(url,"remote:",7)) {
+				strncpy(path,url+7,CHIRP_LINE_MAX);
+			} else if(!strncmp(url,"buffer:remote:",14)) {
+				strncpy(path,url+14,CHIRP_LINE_MAX);
+			} else {
+				EXCEPT("File %s maps to url %s, which I don't know how to open.\n",path,url);
+			}
+		} else {
+			EXCEPT("Unable to map file %s to a url: %s\n",path,strerror(errno));
+		}
+
+		dprintf(D_SYSCALLS,"Which simplifies to file %s\n",path);
+
+		flags = 0;
+
+		if( strchr(flags_string,'w') ) {
+			if( strchr(flags_string,'r') ) {
+				flags |= O_RDWR;
+			} else {
+				flags |= O_WRONLY;
+			}
+		} else {
+			flags |= O_RDONLY;
+		}
+
+		if(strchr(flags_string,'c')) flags |= O_CREAT;
+		if(strchr(flags_string,'t')) flags |= O_TRUNC;
+		if(strchr(flags_string,'x')) flags |= O_EXCL;
+		if(strchr(flags_string,'a')) flags |= O_APPEND;
+
+		errno = 0;
+		result = safe_open_wrapper_follow( path , flags , mode);
+		
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		
+		sprintf(line,"%d",convert(result,errno));
+		r->put_line_raw(line);
+
+		// Stat stuff
+		if(result >= 0) {
+			buffer = (char*) malloc(1024);
+			if (buffer) {
+				struct stat stat_buf;
+				result= stat(path, &stat_buf);
+				terrno = (condor_errno_t)errno;
+				if(result == 0) {
+					if(stat_string(buffer, &stat_buf) < 0) {
+						result = -1;
+						terrno = (condor_errno_t)errno;
+					}
+				}
+				dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+				r->put_bytes_raw(buffer,strlen(buffer));
+				free( buffer );
+			}
+		}
+
+		free( url );
+		url = NULL;
+	} else  if(sscanf_chirp(line,"close %d",&fd)==1) {
+
+		errno = 0;
+		result = close( fd);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );	
+		sprintf(line,"%d",convert(result,errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"lseek %d %d %d",&fd,&offset,&whence)) {
+
+		int whence_valid = 1;
+
+		switch(whence) {
+			case 0:
+				whence = SEEK_SET;
+				break;
+			case 1:
+				whence = SEEK_CUR;
+				break;
+			case 2:
+				whence = SEEK_END;
+				break;
+			default:
+				whence_valid = 0;
+				break;
+		}
+
+		if(whence_valid) {
+			errno = 0;
+		        result = lseek( fd , offset , whence);
+			terrno = (condor_errno_t)errno;
+			dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+			result = convert(result,errno);
+		} else {
+			result = CHIRP_ERROR_INVALID_REQUEST;
+		}
+		sprintf(line,"%d",result);
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"unlink %s",path)==1) {
+
+		errno = 0;
+		result = unlink( path);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line,"%d",convert(result,errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"rename %s %s",path,newpath)==2) {
+
+		errno = 0;
+		result = rename( path , newpath);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line,"%d",convert(result,errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"mkdir %s %d",path,&mode)==2) {
+
+		errno = 0;
+		result = mkdir(path,mode);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line,"%d",convert(result,errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"rmdir %s",path)==1) {
+
+		errno = 0;
+		result = rmdir( path);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line,"%d",convert(result,errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"fsync %d",&fd)==1) {
+
+		errno = 0;
+		result = fsync(fd);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line,"%d",convert(result,errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"lookup %s",path)==1) {
+
+		errno = 0;
+		result = get_file_info_new(path,url);	
+		if(result==0) {
+			dprintf(D_SYSCALLS,"Filename %s maps to url %s\n",path,url);
+			sprintf(line,"%u",(unsigned int)strlen(url));
+			r->put_line_raw(line);
+			r->put_bytes_raw(url,strlen(url));
+		} else {
+			sprintf(line,"%d",convert(result,errno));
+			r->put_line_raw(line);
+		}
+
+		free( url );
+		url = NULL;
+	} else if(sscanf_chirp(line,"set_job_attr %s %s",name,expr)==2) {
+                
+		result = Starter->updateJobAttr(name,expr);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line,"%d",convert(result,errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"get_job_attr %s",name)==1) {
+
+		MyString recv_expr;
+		result = Starter->getJobAttr(name,recv_expr);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		if( result ) {
+			sprintf(line,"%u",(unsigned int)recv_expr.Length());
+			r->put_line_raw(line);
+			r->put_bytes_raw(recv_expr.Value(),recv_expr.Length());
+		} else {
+			sprintf(line,"%d",convert(result,errno));
+			r->put_line_raw(line);
+		}	
+
+	}else if(sscanf_chirp(line,"constrain %s",expr)==1) {
+	
+		MyString reqs;
+		MyString newreqs;
+		result = 0;
+		if (( Starter->updateJobAttr("AgentRequirements",expr) == 1) && 
+			( Starter->getJobAttr("Requirements",reqs) == 1)) {
+			if(!strstr(reqs.Value(),"AgentRequirements")) {
+				newreqs.sprintf("(%s) && AgentRequirements",reqs.Value());
+				dprintf(D_SYSCALLS,"\tchanging Requirements to %s\n",newreqs.Value());
+				result= Starter->updateJobAttr("Requirements", newreqs.Value());
+			}	
+			
+		}
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line,"%d",convert(result,errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"read %d %d",&fd,&length)==2) {
+
+		buffer = (char*) malloc(length);
+		terrno = (condor_errno_t)errno;
+		if(buffer) {
+			memset( (void *) buffer, 0, (unsigned)length );
+			errno = 0;
+			result = read( fd, ( void *) buffer, (size_t) length);
+			terrno = (condor_errno_t)errno;
+			sprintf(line,"%d",convert(result,errno));
+			r->put_line_raw(line);
+			if(result > 0) {
+				r->put_bytes_raw(buffer,result);
+			}
+			free(buffer);
+		} else {
+			sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+		}
+	   	dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+	} else if(sscanf_chirp(line,"write %d %d",&fd,&length)==2) {
+
+		buffer = (char*) malloc(length);
+		terrno = (condor_errno_t)errno;
+		if(buffer) {
+			memset( (void *) buffer, 0, (unsigned)length );
+			result = r->get_bytes_raw(buffer,length);
+			if(result==length) {
+				errno = 0;
+				result = write( fd,  buffer, length);
+				terrno = (condor_errno_t)errno;
+				sprintf(line,"%d",convert(result,errno));
+			} else {
+				sprintf(line,"%d",CHIRP_ERROR_INVALID_REQUEST);
+			}
+			free(buffer);
+		} else {
+			sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		r->put_line_raw(line);
+		
+	} else if(sscanf_chirp(line,"ulog %s", name)==1) {
+
+		GenericEvent event;
+		ClassAd *ad;
+
+		// setInfoText truncates name to 128 bytes
+		event.setInfoText( name );
+
+		ad = event.toClassAd();
+		ASSERT(ad);
+
+		result = ulog( ad );
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result,errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line, "pread %d %d %d", &fd, &length, &offset) == 3){ 
+		
+		buffer = (char*) malloc(length);
+		terrno = (condor_errno_t)errno;
+		if(buffer) {
+			memset( (void *) buffer, 0, (unsigned)length );
+			errno = 0;
+			result = pread( fd, ( void *) buffer, (size_t) length, offset );
+			terrno = (condor_errno_t)errno;
+			sprintf(line,"%d",convert(result,errno));
+			r->put_line_raw(line);
+			if(result > 0) {
+				r->put_bytes_raw(buffer,result);
+			}
+			free(buffer);
+		} else {
+			sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+			r->put_line_raw(line);
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+	} else if(sscanf_chirp(line,"pwrite %d %d %d", &fd, &length, &offset) == 3){
+
+		buffer = (char*) malloc(length);
+		terrno = (condor_errno_t)errno;
+		if(buffer) {
+			memset( (void *) buffer, 0, (unsigned)length );
+			result = r->get_bytes_raw(buffer,length);
+			if(result == length) {
+				errno = 0;
+				result = pwrite( fd,  ( void *)buffer, (size_t)length, (off_t)offset);
+				terrno = (condor_errno_t)errno;
+				sprintf(line,"%d",convert(result,errno));
+			} else {
+				sprintf(line,"%d",CHIRP_ERROR_INVALID_REQUEST);
+			}
+			free(buffer);
+		} else {
+			sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		r->put_line_raw(line);
+		
+	} else if(sscanf_chirp(line, "sread %d %d %d %d %d", &fd, &length, &offset,
+						   &stride_length, &stride_skip) == 5)
+	{
+		buffer = (char*) malloc(length);
+		
+		if(buffer) {
+			memset( (void *) buffer, 0, (unsigned)length );
+			errno = EINVAL;
+			result = -1;
+			unsigned int total = 0;
+
+			while(total < length && stride_length > 0) {
+				// For last read (make sure we only read total of 'len' bytes)
+				if(length - total < stride_length) {
+					stride_length = length - total;
+				}
+				result = pread( fd, (void*)&buffer[total], stride_length, offset );
+				if(result >= 0) {
+					total += result;
+					offset += stride_skip;
+				} else {
+					break;
+				}
+			}								 
+			sprintf(line,"%d",convert(total,errno));
+			r->put_line_raw(line);
+			if(total > 0) {
+				r->put_bytes_raw(buffer,total);
+			}
+			free(buffer);
+		} else {
+			sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+			r->put_line_raw(line);
+		}
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+	} else if(sscanf_chirp(line,"swrite %d %d %d %d %d", &fd, &length, &offset,
+						   &stride_length, &stride_skip) == 5) 
+	{
+		buffer = (char*) malloc(length);
+		result = -1;
+		terrno = (condor_errno_t)errno;
+		if(buffer) {
+			memset( (void *) buffer, 0, (unsigned)length );
+			result = r->get_bytes_raw(buffer,length);
+			if(result==length) {
+				errno = EINVAL;
+				result = -1;
+				unsigned int total = 0;
+		
+				while(total < length && stride_length > 0) {
+					// For last write (make sure we only write 'len' bytes)
+					if(length - total < stride_length) {
+						stride_length = length - total;
+					}
+					result = pwrite( fd, (void*)&buffer[total], stride_length, offset);
+					if(result >= 0) {
+						total += result;
+						offset += stride_skip;
+					} else {
+						break;
+					}
+				}
+				terrno = (condor_errno_t)errno;	
+				sprintf(line,"%d",convert(total,errno));
+			} else {
+				sprintf(line,"%d",CHIRP_ERROR_INVALID_REQUEST);
+			}
+			free(buffer);
+		} else {
+			sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		r->put_line_raw(line);
+		
+	} else if(sscanf_chirp(line,"rmall %s", &path) == 1) {
+		
+		errno = 0;
+		// Try to rmdir 
+		result = rmdir(path);
+		terrno = (condor_errno_t)errno;
+		// If rmdir failed, try again after removing everthing in directory
+		if(result == -1) {
+			Directory dir(path);
+			if(dir.Remove_Entire_Directory()) {
+				result = rmdir(path);
+			}
+			terrno = (condor_errno_t)errno;	
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"fstat %d", &fd) == 1) {
+
+		buffer = (char*) malloc(1024);
+		terrno = (condor_errno_t)errno;
+		if(buffer) {
+			memset( (void *) buffer, 0, 1024 );
+			errno = 0;
+			struct stat stat_buf;
+			result = fstat(fd, &stat_buf);
+			terrno = (condor_errno_t)errno;
+			if(result == 0) {
+				if(stat_string(buffer, &stat_buf) < 0) {
+					result = -1;
+					terrno = (condor_errno_t)errno;
+				}
+			}
+			
+			sprintf(line,"%d",convert(result,errno));
+			r->put_line_raw(line);
+			if(result == 0) {
+				r->put_bytes_raw(buffer,strlen(buffer));
+			}
+			free(buffer);
+		} else {
+			sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+			r->put_line_raw(line);
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+	} 
+#ifdef WIN32
+#else	
+	else if(sscanf_chirp(line,"fstatfs %d", &fd) == 1) {
+
+		buffer = (char*) malloc(1024);
+		terrno = (condor_errno_t)errno;
+		if(buffer) {
+			memset( (void *) buffer, 0, 1024 );
+#if defined(Solaris)
+			struct statvfs statfs_buf;
+			result = fstatvfs(fd, &statfs_buf);
+#else
+			struct statfs statfs_buf;
+			result = fstatfs(fd, &statfs_buf);
+#endif			
+			terrno = (condor_errno_t)errno;
+			if(result == 0) {
+				if(statfs_string(line, &statfs_buf) < 0) {
+					result = -1;
+					terrno = (condor_errno_t)errno;
+				}
+			}
+			
+			sprintf(line, "%d", convert(result, errno));
+			r->put_line_raw(line);
+			if(result == 0) {
+				r->put_bytes_raw(buffer,strlen(buffer));
+			}
+			free(buffer);
+		} else {
+			sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+			r->put_line_raw(line);
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+	} else if(sscanf_chirp(line,"fchown %d %d %d", &fd, &uid, &gid) == 3) {
+
+		errno = 0;
+		result = fchown(fd, uid, gid);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"fchmod %d %d", &fd, &mode) == 2) {
+
+		errno = 0;
+		result = fchmod(fd, (mode_t)mode);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"ftruncate %d %d", &fd, &length) == 2) {
+
+		errno = 0;
+		result = ftruncate(fd, length);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"link %s %s", &path, &newpath) == 2) {
+
+		errno = 0;
+		result = link(path, newpath);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"symlink %s %s", &path, &newpath) == 2) {
+
+		errno = 0;
+		result = symlink(path, newpath);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"readlink %s %d", &path, &length) == 2) {
+
+		buffer = (char*)malloc(length);
+		result = -1;
+		terrno = (condor_errno_t)errno;
+		if (buffer) {
+			memset( (void *) buffer, 0, (unsigned)length );
+			errno = 0;
+			result = readlink(path, buffer, length);
+			terrno = (condor_errno_t)errno;
+		}
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+		if(result >= 0) {
+			r->put_bytes_raw(buffer,result);
+			free(buffer);
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+	} else if(sscanf_chirp(line,"lstat %s", &path) == 1) {
+
+		buffer = (char*) malloc(1024);
+		terrno = (condor_errno_t)errno;
+		if(buffer) {
+			memset( (void *) buffer, 0, 1024 );
+			errno = 0;
+			struct stat stat_buf;
+			result = lstat(path, &stat_buf);
+			terrno = (condor_errno_t)errno;
+			if(result == 0) {
+				if(stat_string(buffer, &stat_buf) < 0) {
+					result = -1;
+					terrno = (condor_errno_t)errno;
+				}
+			}	
+			sprintf(line, "%d", convert(result, errno));
+			r->put_line_raw(line);
+			if(result == 0) {
+				r->put_bytes_raw(buffer,strlen(buffer));
+			}
+			free(buffer);
+		} else {
+			sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+			r->put_line_raw(line);
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+	} else if(sscanf_chirp(line,"statfs %s", &path) == 1) {
+
+		buffer = (char*) malloc(1024);
+		terrno = (condor_errno_t)errno;
+		if(buffer) {
+			memset( (void *) buffer, 0, 1024 );
+			errno = 0;
+#if defined(Solaris)
+			struct statvfs statfs_buf;
+			result = statvfs(path, &statfs_buf);
+#else
+			struct statfs statfs_buf;
+			result = statfs(path, &statfs_buf);
+#endif
+			terrno = (condor_errno_t)errno;
+			if(result == 0) {
+				if(statfs_string(buffer, &statfs_buf) < 0) {
+					result= -1;
+					terrno = (condor_errno_t)errno;
+				}
+			}		
+			sprintf(line, "%d", convert(result, errno));
+			r->put_line_raw(line);
+			if(result == 0) {
+				r->put_bytes_raw(buffer,strlen(buffer));
+			}
+			free(buffer);
+		} else {
+			sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+			r->put_line_raw(line);
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+	} else if(sscanf_chirp(line,"chown %s %d %d", &path, &uid, &gid) == 3) {
+
+		errno = 0;
+		result = chown(path, uid, gid);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"lchown %s %d %d", &path, &uid, &gid) == 3) {
+
+		errno = 0;
+		result = lchown(path, uid, gid);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"truncate %s %d", &path, &length) == 2) {
+
+		errno = 0;
+		result = truncate(path, length);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+
+	} 
+#endif // ! WIN32	
+	else if(sscanf_chirp(line,"getfile %s", &path) == 1) {
+		
+		void *buf = NULL;
+		errno = 0;
+		result = -1;
+		fd = safe_open_wrapper_follow( path, O_RDONLY );
+		terrno = (condor_errno_t)errno;
+		if(fd >= 0) {
+			struct stat info;
+			stat(path, &info);
+			int length = info.st_size;
+			buf = (void *)malloc( (unsigned)length );
+			terrno = (condor_errno_t)errno;
+			if (buf){
+				memset( buf, 0, (unsigned)length );
+				errno = 0;
+				result = read( fd , buf , length);
+				terrno = (condor_errno_t)errno;
+			} 
+		} else {
+			result = fd;
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line,"%d",convert(result,errno));
+		r->put_line_raw(line);
+		if(result >= 0) {
+			r->put_bytes_raw( (char *)buf,result);
+			free(buf);
+			close(fd);
+		}
+
+	} else if(sscanf_chirp(line,"putfile %s %d %d", &path, &mode, &length) == 3){
+
+		// First check if putfile is possible
+		result = 0;
+		errno = 0;
+		fd = safe_open_wrapper_follow(path, O_CREAT | O_WRONLY | O_TRUNC | _O_BINARY, mode);
+		terrno = (condor_errno_t)errno;
+		if( fd < 0 ) {
+			result = -1;
+		}
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+		
+		if(result >= 0) {
+			buffer = (char*) malloc(length);
+			terrno = (condor_errno_t)errno;
+			if(buffer) {
+				if ( length > 0) {
+					memset( (void *) buffer, 0, (unsigned)length );
+					result = r->get_bytes_raw(buffer,length);	
+					// Now actually putfile
+					errno = 0;
+					result = write(fd, buffer, length);
+					terrno = (condor_errno_t)errno;
+				} else {
+					result = 1;
+				}
+				sprintf(line, "%d", convert(result, errno));
+				r->put_line_raw(line);
+			} else {
+				sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+				r->put_line_raw(line);
+			}
+		close(fd);	
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+	} else if(sscanf_chirp(line,"getlongdir %s", &path) == 1) {
+
+		buffer = (char*) malloc(1024);
+		terrno = (condor_errno_t)errno;
+		result = -1;
+		MyString msg, check;
+		if( buffer) {
+			memset( (void *) buffer, 0, 1024 );	
+			errno = 0;
+			const char *next;
+			Directory directory(path);
+			struct stat stat_buf;
+		
+			// Get directory's contents
+			while((next = directory.Next())) {
+				msg.sprintf_cat("%s\n", next);
+				check.sprintf("%s%c%s", path, DIR_DELIM_CHAR, next);
+				result = stat(check.Value(), &stat_buf);
+				terrno = (condor_errno_t)errno;
+				if(result == -1) {
+					break;
+				}
+				if(stat_string(buffer, &stat_buf) < 0) {
+					result= -1;
+					terrno = (condor_errno_t)errno;
+					break;
+				}
+				msg.sprintf_cat("%s", buffer);
+			}
+
+			if(msg.Length() > 0) {
+				msg.sprintf_cat("\n");	// Needed to signify end of data
+				result = msg.Length();
+			}
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+		if(result>0) {
+			r->put_bytes_raw(msg.Value(),msg.Length());
+		}
+
+	} else if(sscanf_chirp(line,"getdir %s", &path) == 1) {
+
+		errno = 0;
+		result = -1;
+		MyString msg;
+		const char *next;
+		Directory directory(path);
+
+		// Get directory's contents
+		while((next = directory.Next())) {
+			msg.sprintf_cat("%s", next);
+			msg.sprintf_cat("\n");
+		}
+		terrno = (condor_errno_t)errno;
+		if(msg.Length() > 0) {
+			msg.sprintf_cat("\n");	// Needed to signify end of data
+			result = msg.Length();
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+		if(result>0) {
+			r->put_bytes_raw(msg.Value(),msg.Length());
+		}
+
+	} else if(sscanf_chirp(line,"whoami %d", &length) == 1) {
+
+		buffer = (char*)malloc(length);
+		terrno = (condor_errno_t)errno;
+		if(buffer) {
+			memset( (void *) buffer, 0, (unsigned)length );
+			errno = 0;
+			int size = 6;
+			if(length < size) {
+				result= -1;
+			} else {
+			result = sprintf(buffer, "CONDOR");
+			}
+			terrno = (condor_errno_t)errno;
+			sprintf(line, "%d", convert(result, errno));
+			r->put_line_raw(line);
+			if(result>0) {
+				r->put_bytes_raw(buffer,result);
+			}
+			free(buffer);
+		} else {
+			sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+			r->put_line_raw(line);
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+	} else if(sscanf_chirp(line,"whoareyou %s %d", &path, &length) == 2) {
+
+		buffer = (char*)malloc(length);
+		terrno = (condor_errno_t)errno;
+		if(buffer) {
+			memset( (void *) buffer, 0, (unsigned)length );
+			errno = 0;
+			int size = 6;
+			if(length < size) {
+				result = -1;
+			} else {
+				result = sprintf(buffer, "CONDOR");
+			}
+			terrno = (condor_errno_t)errno;
+			sprintf(line, "%d", convert(result, errno));
+			r->put_line_raw(line);
+			if(result>0) {
+				r->put_bytes_raw(buffer,result);
+			}
+			free(buffer);
+		} else {
+			sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+			r->put_line_raw(line);
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+	} else  if(sscanf_chirp(line,"stat %s", &path) == 1) {
+		
+		buffer = (char*) malloc(1024);
+		terrno = (condor_errno_t)errno;
+		if(buffer) {
+			memset( (void *) buffer, 0, 1024 );	
+			errno = 0;
+			struct stat stat_buf;
+			result = stat(path, &stat_buf);
+			terrno = (condor_errno_t)errno;
+			if(result == 0) {
+				if(stat_string(buffer, &stat_buf) < 0) {
+					result = -1;
+					terrno = (condor_errno_t)errno;
+				}
+			}
+			sprintf(line, "%d", convert(result, errno));
+			r->put_line_raw(line);
+			if(result==0) {
+				r->put_bytes_raw(buffer,strlen(buffer));
+			}
+			free(buffer);
+		} else {
+			sprintf(line,"%d",CHIRP_ERROR_NO_MEMORY);
+			r->put_line_raw(line);
+		}
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+	} else  if(sscanf_chirp(line,"access %s %d", &path, &mode) == 2) {
+		
+		errno = 0;
+		result = access(path, mode);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"chmod %s %d", &path, &mode) == 2) {
+
+		errno = 0;
+		result = chmod(path, mode);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+
+	} else if(sscanf_chirp(line,"utime %s %d %d", &path, &actime, &modtime) == 3){
+	
+		struct utimbuf ut;
+		ut.actime = actime;
+		ut.modtime = modtime;
+		
+		errno = 0;
+		result = utime(path, &ut);
+		terrno = (condor_errno_t)errno;
+		dprintf( D_SYSCALLS, "\tresult = %d, errno = %d\n", result, terrno );
+		sprintf(line, "%d", convert(result, errno));
+		r->put_line_raw(line);
+
+	} else if(strncmp(line,"version",7)==0) {
+	    sprintf(line,"%d",CHIRP_VERSION);
+	    r->put_line_raw(line);
+	}
+	else {
+		sprintf(line,"%d",CHIRP_ERROR_INVALID_REQUEST);
+		r->put_line_raw(line);
+	}
+	set_priv( old_priv );
+	dprintf(D_SYSCALLS,"LocalIOProxyHandler: response: %s\n",line);
+}
+
+int
+get_file_info_new( const char *logical_name, char *&actual_url )
+{
+	MyString remap_list;
+	MyString	split_dir;
+	MyString	split_file;
+	MyString	full_path;
+	MyString	remap;
+	MyString urlbuf;
+	const char	*method;
+
+	dprintf( D_SYSCALLS, "\tlogical_name = \"%s\"\n", logical_name );
+
+	ASSERT( actual_url == NULL );
+
+	/* The incoming logical name might be a simple, relative, or complete path */
+	/* We need to examine both the full path and the simple name. */
+
+	filename_split( logical_name, split_dir, split_file );
+	complete_path( logical_name, full_path );
+
+	/* Any name comparisons must check the logical name, the simple name, and the full path */
+
+	if(Starter->jic->jobClassAd()->LookupString(ATTR_FILE_REMAPS,remap_list) &&
+	  (filename_remap_find( remap_list.Value(), logical_name, remap ) ||
+	   filename_remap_find( remap_list.Value(), split_file.Value(), remap ) ||
+	   filename_remap_find( remap_list.Value(), full_path.Value(), remap ))) {
+
+		dprintf(D_SYSCALLS,"\tremapped to: %s\n",remap.Value());
+
+		/* If the remap is a full URL, return right away */
+		/* Otherwise, continue processing */
+
+		if(strchr(remap.Value(),':')) {
+			dprintf(D_SYSCALLS,"\tremap is complete url\n");
+			actual_url = strdup(remap.Value());
+			return 0;
+		} else {
+			dprintf(D_SYSCALLS,"\tremap is simple file\n");
+			complete_path( remap.Value(), full_path );
+		}
+	} else {
+		dprintf(D_SYSCALLS,"\tnot remapped\n");
+	}
+
+	dprintf( D_SYSCALLS,"\tfull_path = \"%s\"\n", full_path.Value() );
+
+	/* Now, we have a full pathname. */
+	/* Figure out what url modifiers to slap on it. */
+
+#ifdef HPUX
+	/* I have no idea why this is happening, but I have seen it happen many
+	 * times on the HPUX version, so here is a quick hack -Todd 5/19/95 */
+	if ( full_path == "/usr/lib/nls////strerror.cat" )
+		full_path = "/usr/lib/nls/C/strerror.cat\0";
+#endif
+
+	if( use_special_access(full_path.Value()) ) {
+		method = "special";
+	} else if( use_local_access(full_path.Value()) ) {
+		method = "local";
+	} else {
+		method = "remote";
+	}
+
+	if( use_fetch(method,full_path.Value()) ) {
+		urlbuf += "fetch:";
+	}
+
+	if( use_compress(method,full_path.Value()) ) {
+		urlbuf += "compress:";
+	}
+
+	append_buffer_info(urlbuf,method,full_path.Value());
+
+	if( use_append(method,full_path.Value()) ) {
+		urlbuf += "append:";
+	}
+
+	urlbuf += method;
+	urlbuf += ":";
+	urlbuf += full_path;
+	actual_url = strdup(urlbuf.Value());
+
+	dprintf(D_SYSCALLS,"\tactual_url: %s\n",actual_url);
+
+	return 0;
+}
+
+int get_buffer_info( int *bytes_out, int *block_size_out, int *prefetch_bytes_out )
+{
+	int bytes=0, block_size=0;
+
+	Starter->jic->jobClassAd()->LookupInteger(ATTR_BUFFER_SIZE,bytes);
+	Starter->jic->jobClassAd()->LookupInteger(ATTR_BUFFER_BLOCK_SIZE,block_size);
+
+	if( bytes<0 ) bytes = 0;
+	if( block_size<0 ) block_size = 0;
+	if( bytes<block_size ) block_size = bytes;
+
+	*bytes_out = bytes;
+	*block_size_out = block_size;
+	*prefetch_bytes_out = 0;
+
+	dprintf(D_SYSCALLS,"\tbuffer configuration is bytes=%d block_size=%d\n",bytes, block_size );
+
+	return 0;
+}
+
+
+static void append_buffer_info( MyString &url, const char *method, char const *path )
+{
+	MyString buffer_list;
+	MyString buffer_string;
+	MyString dir;
+	MyString file;
+	int s,bs,ps;
+	int result;
+
+	filename_split(path,dir,file);
+
+	/* Do not buffer special device files, whether local or remote */
+	if(!strncmp(path,"/dev/",5)) return;
+
+	/* Get the default buffer setting */
+	get_buffer_info( &s, &bs, &ps );
+
+	/* Now check for individual file overrides */
+	/* These lines have the same syntax as a remap list */
+
+	if(Starter->jic->jobClassAd()->LookupString(ATTR_BUFFER_FILES,buffer_list)) {
+		if( filename_remap_find(buffer_list.Value(),path,buffer_string) ||
+		    filename_remap_find(buffer_list.Value(),file.Value(),buffer_string) ) {
+
+			/* If the file is merely mentioned, turn on the default buffer */
+			url += "buffer:";
+
+			/* If there is also a size setting, use that */
+			result = sscanf(buffer_string.Value(),"(%d,%d)",&s,&bs);
+			if( result==2 ) url += buffer_string;
+
+			return;
+		}
+	}
+
+	/* Turn on buffering if the value is set and is not special or local */
+	/* In this case, use the simple syntax 'buffer:' so as not to confuse old libs */
+
+	if( s>0 && bs>0 && strcmp(method,"local") && strcmp(method,"special")  ) {
+		url += "buffer:";
+	}
+}
+
+/* Return true if this JobAd attribute contains this path */
+
+static int attr_list_has_file( const char *attr, const char *path )
+{
+	char const *file;
+	MyString str;
+
+	file = condor_basename(path);
+
+	Starter->jic->jobClassAd()->LookupString(attr,str);
+	StringList list(str.Value());
+
+	if( list.contains_withwildcard(path) || list.contains_withwildcard(file) ) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+/*
+If short_path is an absolute path, copy it to full path.
+Otherwise, tack the current directory on to the front
+of short_path, and copy it to full_path.
+Notice that the old shadow kept track of the job as it
+moved around, but there is no such notion in this shadow,
+so CurrentWorkingDir is replaced with the job's iwd.
+*/
+ 
+static void complete_path( const char *short_path, MyString &full_path )
+{
+	if(short_path[0]==DIR_DELIM_CHAR) {
+		full_path = short_path;
+	} else {
+		// strcpy(full_path,CurrentWorkingDir);
+		full_path.sprintf("%s%s%s",
+						  Starter->jic->jobIWD(),
+						  DIR_DELIM_STRING,
+						  short_path);
+	}
+}
+
+static int use_special_access( const char *file )
+{
+	return
+		!strcmp(file,"/dev/tcp") ||
+		!strcmp(file,"/dev/udp") ||
+		!strcmp(file,"/dev/icmp") ||
+		!strcmp(file,"/dev/ip");	
+}
+
+static int use_local_access( const char *file )
+{
+	return
+		!strcmp(file,"/dev/null") ||
+		!strcmp(file,"/dev/zero") ||
+		attr_list_has_file( ATTR_LOCAL_FILES, file );
+}
+
+static int use_compress( const char * /* method */, const char *path )
+{
+	return attr_list_has_file( ATTR_COMPRESS_FILES, path );
+}
+
+static int use_fetch( const char * /* method */, const char *path )
+{
+	return attr_list_has_file( ATTR_FETCH_FILES, path );
+}
+static int use_append( const char * /* method */, const char *path )
+{
+	return attr_list_has_file( ATTR_APPEND_FILES, path );
+}
+
+int
+ulog( ClassAd *ad )
+{
+	ULogEvent *event = instantiateEvent(ad);
+	int result = 0;
+	char const *critical_error = NULL;
+	MyString CriticalErrorBuf;
+	bool event_already_logged = false;
+	bool put_job_on_hold = false;
+	char const *hold_reason = NULL;
+	char *hold_reason_buf = NULL;
+	int hold_reason_code = 0;
+	int hold_reason_sub_code = 0;
+
+	if(!event) {
+		MyString add_str;
+		ad->sPrint(add_str);
+		dprintf(
+		  D_ALWAYS,
+		  "invalid event ClassAd in ulog: %s\n",
+		  add_str.Value());
+		return 0;
+	}
+
+	if(ad->LookupInteger(ATTR_HOLD_REASON_CODE,hold_reason_code)) {
+		put_job_on_hold = true;
+		ad->LookupInteger(ATTR_HOLD_REASON_SUBCODE,hold_reason_sub_code);
+		ad->LookupString(ATTR_HOLD_REASON,&hold_reason_buf);
+		if(hold_reason_buf) {
+			hold_reason = hold_reason_buf;
+		}
+	}
+
+	if( event->eventNumber == ULOG_REMOTE_ERROR ) {
+		RemoteErrorEvent *err = (RemoteErrorEvent *)event;
+
+		if(!err->getExecuteHost() || !*err->getExecuteHost()) {
+			//Insert remote host information.
+			char *execute_host = NULL;
+			err->setExecuteHost(daemonCore->InfoCommandSinfulString());
+			delete[] execute_host;
+		}
+
+		if(err->isCriticalError()) {
+			CriticalErrorBuf.sprintf(
+			  "Error from %s: %s",
+			  err->getExecuteHost(),
+			  err->getErrorText());
+
+			critical_error = CriticalErrorBuf.Value();
+			if(!hold_reason) {
+				hold_reason = critical_error;
+			}
+
+			event_already_logged = true;
+		}
+	}
+	
+	if( !event_already_logged ) {
+			if(!Starter->jic->getUserLog()->writeEvent( event, ad ) ) {
+				MyString add_str;
+				ad->sPrint(add_str);
+				dprintf(
+				  D_ALWAYS,
+				  "unable to log event in ulog: %s\n",
+				  add_str.Value());
+				result = -1;
+			}
+
+	}
+	
+	delete event;
+	
+	if(put_job_on_hold) {
+		hold_reason = critical_error;
+		if(!hold_reason) {
+			hold_reason = "Job put on hold by remote host.";
+		}
+		Starter->jic->holdJob(hold_reason_buf,hold_reason_code,hold_reason_sub_code);
+	}
+
+	return result;
+}
+static int stat_string( char *line, struct stat *info )
+{
+#ifdef WIN32
+	return 0;
+#else
+	return sprintf(line,"%lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld\n",
+		(long long) info->st_dev,
+		(long long) info->st_ino,
+		(long long) info->st_mode,
+		(long long) info->st_nlink,
+		(long long) info->st_uid,
+		(long long) info->st_gid,
+		(long long) info->st_rdev,
+		(long long) info->st_size,
+		(long long) info->st_blksize,
+		(long long) info->st_blocks,
+		(long long) info->st_atime,
+		(long long) info->st_mtime,
+		(long long) info->st_ctime
+	);
+#endif
+}
+
+#if defined(Solaris)
+static int statfs_string( char *line, struct statvfs *info )
+#else
+static int statfs_string( char *line, struct statfs *info )
+#endif
+{
+#ifdef WIN32
+	return 0;
+#else
+	return sprintf(line,"%lld %lld %lld %lld %lld %lld %lld\n",
+#  if defined(Solaris)
+		(long long) info->f_fsid,
+		(long long) info->f_frsize,
+#  else
+		(long long) info->f_type,
+		(long long) info->f_bsize,
+#  endif
+		(long long) info->f_blocks,
+		(long long) info->f_bfree,
+		(long long) info->f_bavail,
+		(long long) info->f_files,
+		(long long) info->f_ffree
+	);
+#endif
+}
diff -rNup condor-7.9.1.orig/src/condor_starter.V6.1/local_io_proxy_handler.h condor-7.9.1/src/condor_starter.V6.1/local_io_proxy_handler.h
--- condor-7.9.1.orig/src/condor_starter.V6.1/local_io_proxy_handler.h	1969-12-31 19:00:00.000000000 -0500
+++ condor-7.9.1/src/condor_starter.V6.1/local_io_proxy_handler.h	2013-03-19 11:42:12.089014657 -0400
@@ -0,0 +1,48 @@
+/***************************************************************
+ *
+ * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+
+#ifndef LOCAL_IO_PROXY_HANDLER_H
+#define LOCAl_IO_PROXY_HANDLER_H
+
+/*
+The IOProxyHandler object reads data from an incoming Stream,
+and translates the Chirp protocol into remote system calls
+back to the shadow.
+*/
+#include "io_proxy_handler.h"
+#include "condor_daemon_core.h"
+
+class LocalIOProxyHandler : public IOProxyHandler {
+public:
+	LocalIOProxyHandler() {};
+	~LocalIOProxyHandler() {};
+
+	bool init( Stream *stream, const char *cookie );
+
+private:
+
+	void handle_standard_request( ReliSock *r, char *line );
+
+};
+
+#endif
+
+
+
diff -rNup condor-7.9.1.orig/src/condor_starter.V6.1/local_user_log.h condor-7.9.1/src/condor_starter.V6.1/local_user_log.h
--- condor-7.9.1.orig/src/condor_starter.V6.1/local_user_log.h	2012-08-16 15:51:24.000000000 -0400
+++ condor-7.9.1/src/condor_starter.V6.1/local_user_log.h	2013-03-19 11:42:12.089014657 -0400
@@ -132,7 +132,9 @@ public:
 		 * @param checkpointed - whether the job was checkpointed or not
 		 **/
 	bool logRequeueEvent( ClassAd* ad, bool checkpointed );
-
+	
+        WriteUserLog * getWriteUserLog(){ return &u_log;}
+	
 private:
 		// // // // // // // // // // // //
 		// Private helper methods
diff -rNup condor-7.9.1.orig/src/condor_starter.V6.1/starter.h condor-7.9.1/src/condor_starter.V6.1/starter.h
--- condor-7.9.1.orig/src/condor_starter.V6.1/starter.h	2012-08-16 15:51:24.000000000 -0400
+++ condor-7.9.1/src/condor_starter.V6.1/starter.h	2013-03-19 11:42:12.090014666 -0400
@@ -189,7 +189,11 @@ public:
 			once everything is cleaned, calls JIC::allJobsGone().
 		*/
 	virtual bool cleanupJobs( void );
-
+	
+	
+	virtual int updateJobAttr (const char *name, const char *expr);
+        virtual int getJobAttr (const char *name, MyString &expr);
+	
 		/** Return the Execute dir */
 	const char *GetExecuteDir() const { return Execute; }
 
