{"id": 209, "title": "Ticket #209: Create a service to publish Condor events via JMS", "description": "<blockquote>\nWorking with Purdue and Indiana, we would like to create a Condor daemon core service that reads the Event Log and publishes the events via Java JMS messaging.\n\n<p>Note this ticket is somewhat related to <span class=\"ticket\"><a class=\"new\" href=\"/wiki-archive/tickets/?ticket=125\" onclick=\"get_ticket_and_populate_wrapper('125'); return false;\" title=\"Create a daemonCore skeleton for Java services\">#125</a></span>.</p></blockquote>", "remarks": "<blockquote>\n<em>2009-Feb-26 13:21:52 by wooj:</em> <br/>\n\nmeeting note\n\n<p>Plan\n\n</p><p>(1) Merge JNI code : We first need to merge two different code of Faisal and Jungha. I will have a look at java_config.cpp and java_config.h\n\n</p><p>(2) Developing Event API which parses event log. Three possible ways exist\n</p><ul>\n<li>(a) JNI\n</li><li>(b) Pure Java version. We think this will be the best way finally. Might want to use Java New IO(NIO)\n</li><li>(c) Shared memory. David will find some example code to refer\n</li><li>(d) use named pipe between master daemon and Java thread\n</li></ul>\n\n<p>(3) Next stage is to connect with JMS \\\\\n</p><ul>\n<li>(a) Intefaces to jms client\n</li><li>(b) Test server\n</li></ul>\n\n<p>We will have next conference call between March 16th and 20th.\nPlease upload Faisal's code after review and let me know how to check in my code to trac.\n\n</p><p>We aim to have working version by mid April.\n\n</p><p></p><hr/>\n<em>2009-Mar-08 01:11:40 by wooj:</em> <br/>\n\nLog Event Parser architecture\n\n<p>&lt;Entity definition&gt;\n\n</p><p></p><ol>\n<li>Java thread\nJava Thread periodically probes event log file(ex, condor/log/EventLog) and reads new events if any change has been made to that file since last probe.\nThese new events will be consumed by JMS.\n\n<p></p></li><li>C++ shared library\nJava thread has to read event information stored in event log file. However, it actually cannot parse the log file directly because it does not know the log format of each type of event. Only C++ classes that aware of condor_event.h can correctly parse event information written in log file. We think reusing the condor event log parsing code will be the best solution since the authors of the code know best about the format and the way to parse. When C++ class needs to return newly parsed events to Java, JNI will play a role.\nWith JNI, native C++ program can read/write to/from a buffer that was allocated from Java application.It will be good if C++ program serializes event class and Java program rebuilds the same sequence of bytes, which enables Java to read interesting fields of event class. However, Java application is not compatible with C++ Event class or not be able to invoke C++ class methods. ( Remark: I found Cedar can do this. so my argument is not correct any longer. For the same reason, Cedar should be considered if it provides better performance)\n</li></ol>\n\n<p>So we have to use Java Language type object to exchange event information between Java and C++. Basically, C++ classes need to compose parse-able string which includes eventType, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=JobId\" title=\"Job Id\">JobId</a></span>, cluser Id, and so on. This string will be received and then parsed by Java to reconstruct original Job event information. We do this by overriding serialization routine.\n\n</p><p>Every C++ event class, defined in condor_event.h such as <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExecuteEvent\" title=\"Execute Event\">ExecuteEvent</a></span>, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=TerminatedEvent\" title=\"Terminated Event\">TerminatedEvent</a></span> and so on, would have its corresponding Java class.(remark: I changed \"should\" to \"would\" since this is not the only way to obtain goal) The java class will be more like \"struct\" in C language since it will not have any member function but accessors. Some methods of ULogEvent are protected, and these protected method in C++ cannot be accessed from Java unless a class is derived from it or friends class. For example, strToRusage() method in ULogEvent should be called so as to get proper string information before C++ shared library sends it.\n\n</p><p>All those protected member functions will be substituted with String type member variables for Java to easily access them.\n\n</p><p></p><ul>\n<ol>\n<li>Serialization plan\nOur solution is to override the serialization routine and send one standard format of ULogEvent that filled in all necessary fields for every different type of event. C++ class should send Event type too. By doing so, Java can selectively choose required fields to rebuild event instance.At this point, the ULogEventNumber seems to be good enough to find out the type of event.\n</li></ol>\n</ul>\n\n<p>This is the flow of serialization.\n</p><ul>\n<ol>\n<li>First, Java thread receives an serialized event object from C++ and checks the event type.If that one is ULOG_EXECUTE, it creates new Java <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExecuteEvent\" title=\"Execute Event\">ExecuteEvent</a></span> instance. The serialized event object would be a char string delimited by some delimiters.(remark: We do not used serialization for delivering an event object between C++ and Java. Instead, I used XML string)\n\n<p></p></li><li>The message delivery between Java thread and JMS\nSince huge number of Event log size will be generated and read in a working condor pool,the message produced by Java thread must be consumed fast enough by JMS not to lose newly arrived events.\n\n<p></p></li><li>If we allocate new message buffer whenever a new event message arrives, it is going to definitely kill the system due to excessive memory management efforts. Java garbage collector will allocate and free memory frequently just for one time use of each event message. To prevent this from happening, we suggest the much more efficient way to minimize memory allocation/deallocation.That is to manage memory by ourselves. It will minimize the work of garbage collector.We gradually increase the memory buffer size up to threshold point but reuse an event which is consumed by JMS.\n\n<p></p></li><li>JMS notifies Java thread of the end of use\nHere's more detailed explanation.Keep a circular message queue like structure ( not exactly circular queue but let's assume that for the time being).Java thread acts as a producer and JMS as a consumer.Proper synchronization between reader/consumer will be provided. Usually Queue's heap size needed for this circular queue is fixed but our heap size will varies over time, at least at the bootstrap time. When many events arrive, heap size should be increased to accommodate new events if Java thread cannot find a slot. Similarly, when the number of event is small, heap size should not be too big. However, those dynamic heap size does not work very well with fixed size circular queue. We think dynamic circular queue would be the best candidate for memory management. Managing queue size manually will gradually increase the heap size used by queue and at a certain point, memory usage will saturate and stay the same if events are created with almost constant speed. Every time JMS consumes an event from this queue, it will put empty buffer back to queue. By doing this, Java thread does not return this empty buffer but reuses it for receiving another event from C++ shared library.\n</li></ol>\n</ul>\n\n<p></p><hr/>\n<em>2009-May-16 23:25:44 by wooj:</em> <br/>\n\nMay 16 Progress memo\n\n<p>Integration Demo\n- Showed that Java Daemon provides JBoss Message Queue(JBoss MQ)\nwith Java event objects successfully. Jalaja's EJB is now ready to consume\ncondor Job events. We verified this by printing out each event's fields to stdout from JBoss Application server.\n\n</p><p>What is done during this semester\n</p><ol>\n<li>Read one event at a time from condor's <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=EventLog\" title=\"Event Log\">EventLog</a></span> file.        I modified  test_log_reader.cpp so as to be able to support open(), readEvent(), close() functions that are invoked from Java.\n</li><li>Construct Abstract Syntax Tree(AST) and transform it to <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=RecordExpr\" title=\"Record Expr\">RecordExpr</a></span>, which is the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span> representation in Java.\n        <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span> library 2.4 from Wisconsin is used for step 2.\n</li><li>Instantiates Java event object derived from Abstract base class named ULogEvent.\n</li><li>Sends message queue Java event objects. From this point, Jalaja's EJB code is notified of\n   message receipt and it will store each event into the database. I will complete the receiving part. We used  JBoss MQ API implementation for this step.\n</li></ol>\n\n<p>What's to do (Implementation limitation)\n</p><ol>\n<li>We verified Java part of condor Java daemon works correctly. I need to show C++ daemonCore part of\ncondor Java daemon works fine too. This demo will be done on May 18th.\n</li><li>When Java daemon transmits events to the JBoss MQ, we assumed Message queue is placed in the same machine\nas condor java daemon runs. We're having remote queue access issue, i.e, sending events to remote site is not working\ndue to \"connection refusal\" problem for JNDI lookup. We're guessing this might came from firewall configuration.\n</li><li>Message buffer management routine needs to be built according to our initial plan. As of now, the current Java daemon\ncreates a buffer whenever it needs. Since Java daemon will process huge number of events per second, this will necessarily cause huge number of\nmemory allocation/deallocation done by Java garbage collector. This buffer management work is scheduled to be done by May 18th.\n</li><li>Exception handling for event fields lookup. Some fields have values not in the valid range. For example, the executable image size contains negative value. I added Null Pointer exception handle routine for <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=JobImageSizeEvent\" title=\"Job Image Size Event\">JobImageSizeEvent</a></span>. Other exceptions will be handled as I run more experiment on various types of events.\n</li></ol>\n\n<p>Possible changes to be made\n</p><ol>\n<li>Rather than instantiating each event object, we would better to deliver <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span> to JBoss Queue. This is because the life of instantiated object is very short and fields lookup is the only goal of the EJB code. Moreover, serialization/deserialization may significantly slow down events processing speed.\nAfter finishing TO-DO work, I will work on this so as to provide benchmark data.\n</li><li>We used \"serializable\" interface for object serialization/deserialization. It is known that we can expect 30 to 40% speed gain when Externalizable interface is used compared to \"serializable\".\n       Our own readExternal/writeExternal method should be written to use \"Externalizable\" interface.\n</li></ol>\n\n<p>Summer work plan\n</p><ol>\n<li>I will work on supporting multiple destination. Sending the same job event object to multiple queue instance will burden Java daemon and we need to do some stress test.\n</li></ol>\n\n<p></p><hr/>\n<em>2009-May-26 16:19:07 by wooj:</em> <br/>\n\nNow it is possible to launch condor_javad from command line. Since our daemon should be running from command line with other Condor daemons, we run this test.\n  Previous test has been done from Netbeans, i.e, pure Java daemon test.\n We're having one issue related to thread.\n  From design perspective, we want to support various ways to read\nevents from Condor. So we will create each thread for different methods.\n  However, we want only one JVM be running on the system.\n  new C++ thread object is turned out to be using boostrap class loader\nwhen it attaches itself to JVM created by main thread.\n  Thus system class(jar files needed for sending events to the JBoss\nqueue) cannot be loaded from new thread. This leads to\n<span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassNotFoundException\" title=\"Class Not Found Exception\">ClassNotFoundException</a></span>.\n  We're looking into that issue.\n\n<p>Features added to Condor Java daemon\n\n</p><p>(1) Memory buffer management class\n This class is to minimize memory allocation by reusing previously\nallocated memory buffer for receiving new events.\n     Keeps two queues. One for empty buffer list and another for buffer\nfilled with data.\n     Message producer gets empty buffer from this class using\nrequestEmptyBuffer().\n     After fetching job event, it returns this buffer to data buffer\nlist by addDataBuffer(byte[])\n     Message Consumer obtains job event data by calling\nrequestDataBuffer() and returns it after use by the use of\nreturnUsedBuffer(byte[])\n\n</p><p></p><pre>    All methods of MemoryUseManager are thread-safely synchronized.\n    Internal data structures, i.e, linked lists, are also thread-safe\nsince it's using collections.synchronizeList wrapper class.\n</pre>\n\n<p>(2) Job Event message consumer thread\n     Current implementation instantiates two identical instance of\nmessage consumer thread It works well with the producer.\n     Each thread and While statement of JNIEventLog class sleep 1\nmillisecond  to prevent starvation even though I don't see any blocking\nissue without sleep.\n     The processing speed roughly got doubled when two threads sends\nmessages to JBoss queue compared to previous version without thread.\n\n</p><p>(3) condor.javad package re-factored to edu.purdue.rcac.condor.javad.*\n    Now <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CondorJavaDaemon\" title=\"Condor Java Daemon\">CondorJavaDaemon</a></span> project is ready to be compiled immediately\nafter check-out.\n    Moreover, it is self-containing. Thus you won't have reference\nresolve issue.\n    ClassAd-pojo project has been modified accordingly.\n    I cc-ed Jaewoo to let him know this modification to prevent possible\nconflicts.\n\n</p><p>(4) Resolve <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassNotFound\" title=\"Class Not Found\">ClassNotFound</a></span> issue\n  Condor_javad used to yield \"<span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassNotFoundException\" title=\"Class Not Found Exception\">ClassNotFoundException</a></span>\" when it attaches\nitself to previously created JVM.\n  This problem happens because attachThread() uses bootstrap class\nloader but not system class loader.\n  We solve this problem by explicitly setting systemClassLoader to that\nthread.\n   Now, our condor_javad works well when it is executed from command line.\n\n</p><p>(5) Improve message sending speed\n    Added worker thread that sends job event message to the JBoss queue.\nWe run two instance of this thread.\n    For this purpose, all public methods of the buffer management class\nare declared to be 'synchronized', i.e, thread-safe. Internal data\nstructure is improved too to deal with synchronization issue.\n\n</p><p>(6) Remove the limitation of number of events that JNIEventLog class handles\n    Now it works as 'real daemon'. It never dies. When the job event is\nnot available, e.g, no job event happens, it sleeps longer than usual.\nIt sleeps 5 seconds. In usual case, it sleeps only 1 milli second.\n\n</p><p>TODO after come back\n- Guarantee the order of job event message while multiple worker threads\nare running. We're thinking of numbering each event.\n\n</p><p>- Embed schedd_info to each job event. Originally job event generated by\ncondor does not have schedd info. We will put this info to the job event\nobject.\n\n</p><p>- Measure the performance of JMS client that sending events to the queue\n\n</p><p></p><hr/>\n<em>2009-Aug-05 15:52:54 by wooj:</em> <br/>\n\nSorry for not being able to post regularly. I will do that from now on.\n\n<p>----Serialization speed up ----\n</p><ul>\nTo speed up object serialization,  job event class implements \"Externalizable\" rather than \"Serializable\".\n  Roughly 168 objects are sent per second now. This is improved result compared to roughly 80 objects before.\n I applied interface change to <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=JobImageSizeEvent\" title=\"Job Image Size Event\">JobImageSizeEvent</a></span> class only. More speed can be expected if I finish change for all object class.\n</ul>\n\n<p>==== ( 07/06  ~ 07/10) compiled on mdw-9. had some errors on condor_javad project ====\n\n</p><p></p><ul>\nThe issue we had on mdw-9 has been resolved and thus compile is done successfully.\nActually the problem does not relate to g++ version.\nI blocked some part of Imakefile after I successfully compiled condor from my local machine.\nSince another compile target belongs to  that remark, Imake could not generate correct Makefile.\nThat led to weird errors complaining \"cannot find header files\"\n</ul>\n\n<p>Java\n==== (1) <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CondorJavaDaemon\" title=\"Condor Java Daemon\">CondorJavaDaemon</a></span> ====\n</p><ul>\nJob Event serialization changed from implementing Serializable interface to Externalizable.\n<li>Two more job event type, namely <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=JobAbortedEvent\" title=\"Job Aborted Event\">JobAbortedEvent</a></span> and <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=JobEvictedEvent\" title=\"Job Evicted Event\">JobEvictedEvent</a></span> are added.\n</li><li>SerialVersionUID added for all job events to save time taken for computing class fingerprint\n</li><li>Hostname added to every job event. It has some issues though. First, getting hostname seems to delay processing speed. Second, it does not get the fully qualified hostname. Only \"narae\" or IP addr returns. I will come up with new method not to invoke gethostname() frequently.\n</li><li>Added <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=JobHeldEvent\" title=\"Job Held Event\">JobHeldEvent</a></span>, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=JobSuspendedEvent\" title=\"Job Suspended Event\">JobSuspendedEvent</a></span>, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=JobUnsuspendedEvent\" title=\"Job Unsuspended Event\">JobUnsuspendedEvent</a></span>, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ShadowExceptionEvent\" title=\"Shadow Exception Event\">ShadowExceptionEvent</a></span>\n</li><li>Added Nullpointer exception handling routine for some class if needed fields were not in the event so thus causing parsing errors\n</li><li>Modified <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=EventFactory\" title=\"Event Factory\">EventFactory</a></span> to instantiate event class according to the new classes\n</li></ul>\n\n<p>==== (2) Condor-job-manager ====\n</p><ul>\nJobStatusHandlerMDBean has been slightly modified to read hostname of each received job event.\nOthers are remaining the same.\n</ul>\n\n<p>Our Javad is ready for system test for tg-dev01(RHEL4 machine). Since I don't have root permission for that machine,\nWe decided to get the same environment as tg-dev01 before tg-dev01 has necessary libraries.\nI installed RHEL5 to mdw-9 machine.\nI compiled the condor 7.2.0  from RHEL5 local machine and copied back to tg-dev01.\nWhen I launch condor_javad daemon, it complains that libc2.4 is not present.\nI checked tg-dev01 is using 2.3.4.\nActually tg-dev01 is RHEL4 machine so we cannot run JavaD until rcac admin installs virtual machine for RHEL5.\n\n</p><p>===07/13- 07/17  Condor compile on Red Hat Enterprise Linux 4 (RHEL4) ===\n\n</p><p>I installed RHEL4  to Jaewoo's old machine and found out some development package such as gcc and java are not installed.\nHowever, Red Hat did not allow me to update packages since I don't have subscription number.\n(I downloaded RHEL5 as 30days free trial with no support option)\nI tried to request another 30-day trial request but they did not allow that.\nWithout those package updates, I will not be able to compile condor_javad.\nSo I think we need to ask some help from preston or rcac admin to allow us to install RHEL4 with their subscription.\nEither RCAC Admin allows me to be a root of RHEL4 machine having valid subscription number of ITap or getting subscription number is needed.\n\n</p><p>==== 7/20 - 7/24  Condor JavaD RHEL4 compile ====\n</p><ul>\ntried to compile condor javad from RHEL4 machine.\n<li>\"undefined reference to XXXX\" errors: This problem happened due to low gcc version so I upgraded it to 4.1.2\n</li><li>Then \"/usr/bin/ld : cannot find -lssp_sharedthread\" happened. After googling and Dave's advice, we got to know this problem might resulted from glibc 2.3.6 since ssp library has been shipped within glibc from version 2.4.\nMy RHEL4 machine does not have subscription number so couldn't update the package properly.\n</li><li>So We decided to go with NMI build from Wisconsin CS dept. Applied for the account.\n</li></ul>\n\n<p>== 07/27 - 08/05 ===\n</p><ul>\nBuild Condor JavaD using NMI build. Find out no official RHEL4 binary exist. I need to compile on RHEL3 to generate RHEL4 binary.\n</ul>\n\n<p></p><hr/>\n<em>2009-Aug-12 15:32:48 by wooj:</em> <br/>\n\n<span class=\"section\"><h2>RHAS 3 NMI Build basics </h2></span>\n<span class=\"subsection\"><h3>submit file</h3></span>\nneed to write submit file, scp file(input file specification), and a few perl scripts for each stage\n\n<p></p><pre>  remote_pre.pl : tasks needs to be done after my source code copied to compile machine.\n  remote_task.pl: tasks for real compile such as \"configure\",\"make\" and so on.\n  remote_post.pl: after successful compile, we make execute node compress result and give it back to us\n</pre>\n\n<p></p><pre>  and so on..\n</pre>\n\n<p> For those perl scripts, I got help from <a class=\"external\" href=\"http://www.cs.wisc.edu/condor/nmi/builds/usersguide/\">http://www.cs.wisc.edu/condor/nmi/builds/usersguide/</a>\n\n</p><p><span class=\"subsection\"></span></p><h3>Fixed the errors \"warning: cannot find match ..\"</h3>\nThis error is known to be happened due to misspelling in the prerequisite specification. Although I don't see any misspelling, I removed all prerequisite except platform and gcc prerequisite to RHEL4. After that it does not wait forever in the queue.\n\n<p><span class=\"subsection\"></span></p><h3>\"Cannot find the executable\"</h3>\nI wrote 5 perl scripts for each stage such as remote_declare, remote_pre, remote_task and so on.\nRemote_pre.pl prepares the circumstance or make the code ready to be compiled from the execute node.\nI got help from wisc nmi staff.\n\n<p><span class=\"subsection\"></span></p><h3>Reply from Todd</h3>\n\n<p></p><ul>\nTwo things you need to know about Metronome to get this to work.\nFirst, Metronome doesn't guess file extensions, so if your remote post\nscript has the name 'remote_post.pl', the submit file needs to looks like:\n</ul>\n\n<p>remote_post = remote_post.pl\n\n</p><p></p><pre> \tSecond, Metronome does not automatically take any files to the\nexecute host.  You'll need to specify which files on the submit node\nyou'll need on the execute node.  A simple way to do this would be like\nthis:\n</pre>\n\n<p>remote_post = scripts/remote_post.pl\ninputs = condor_javad.scp, scripts.scp\n\n</p><p>where scripts.scp looks like\n\n</p><p>method = scp\nscp_file = /home/wooj/scripts\nrecursive = true\n\n</p><p>This will transfer the whole 'scripts' directory to the execute node, and\nyou can just move all your scripts into that directory (whever you\nactually put it).\n\n</p><p></p><pre> \tPlease let us know if you have any additional problems.\n</pre>\n\n<p>- Todd\n\n</p><p><span class=\"section\"></span></p><h2>NMI Build for RHAS3 and RHAS4 </h2>\n\n<p><span class=\"subsection\"></span></p><h3>RHAS4 </h3>\n- configure : ./configure --disable-full-port --without-gsoap\nThis is because RHAS4 is not one of the supported platforms of the official condor distribution.\nAs I mentioned, Wisconsin condor team compiles code on RHEL3 and that binary is compatible with RHEL4.\n\n<p><span class=\"subsection\"></span></p><h3>RHAS3 </h3>\n- configure : ./configure --without-gsoap\n\"--without-gsoap\" option needed because some errors related to gsoap external library occurred.\nI don't really understand why this error happens. With this option, all errors go away.\n\n<p><span class=\"subsection\"></span></p><h3>ENV Variable setting</h3>\n\n<p>Remote execute machines do not set up JAVA_HOME variable which is needed to compile condor_javad. So I set up this ENV variable from each nmi execute machine through perl scripts.\n(They seem to provide nicer way to set up ENV variable through 'nmi_put_attr\" command line tools but it did not work for me)\n\n</p><p>...\n#Condor JavaD requires JDK to be installed\n$ENV{'JAVA_HOME'} = '/prereq/java-1.5.0_08';\n...\n\n</p><p>Fortunately, they disclose the location where prerequisite software are installed.\nJava-1.5 is installed /prereq/java-1.5.0_08 on every RHEL4 and RHEL3 machine.\n\n</p><p>Now we can proceed to the real system deployment stage.\n\n</p><p>(4) deploying compiled code to tg-dev\n\n</p><p></p><hr/>\n<em>2009-Aug-21 14:06:30 by wooj:</em> <br/>\n\n<span class=\"section\"><h2>Condor JavaD Integration test</h2></span>\n\n<p>We've submitted a job through SWING client. This swing client submits user job through condor birdbath. Condor Schedd logs updated events to <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=EventLog\" title=\"Event Log\">EventLog</a></span> log file on tg-dev01.rcac.purdue.edu. Its update events such as\n\"<span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExecutedEvent\" title=\"Executed Event\">ExecutedEvent</a></span>\" ,\"JobImageSizeEvent\",\"HeldEvent\",and <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=JobTerminatedEvent\" title=\"Job Terminated Event\">JobTerminatedEvent</a></span>\" arrived from tg-dev01 to mdw-23 on which Message Handler is running(JBOSS).\nAnd then, Jalaja's Message handler updates job status to \"Running\" and then \"Completed\".\n\n</p><p>One issue we're having is that if the update events for a single job come too fast, the order in which its status is updated cannot be guaranteed to be right. For example, SWING client only shows \"Running\" even though it already received \"Terminated\". But if the job takes reasonable amount of time, it works fine.\n\n</p><p><span class=\"section\"></span></p><h2>NMI build done</h2>\n\n<p>Now, NMI build compiling condor_javad is checked in to <a class=\"external\" href=\"https://repo.rcac.purdue.edu/svn/sgw/NMI\">https://repo.rcac.purdue.edu/svn/sgw/NMI</a>\nThis NMI build turns in compile jobs to Wisconsin CS condor pool. Instead of compiling code from multiple platform manually, users can write NMI build script\nby designating target platform and software requirements.\nNMI condor finds suitable target machine for each platform specified, and run, gather result and then finally returns\nresults to the user.\n\n</p><p>We wanted to compile our condor javad and condor 7.2.0 from Red Hat Advanced server 3 since so is tg-dev01. It includes all perl script need to submit NMI build from Wisconsin CS submit node.\nThe result executables are also available under /result directory.\n\n</p><p></p><hr/>\n<em>2009-Aug-31 17:59:27 by wooj:</em> <br/>\n\n<span class=\"section\"><h2>CondorJavaDeamon handles all types of condor events</h2></span>\n\n<p>Up to now, our <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CondorJavaDaemon\" title=\"Condor Java Daemon\">CondorJavaDaemon</a></span> can process 11 most essential types of events.\nI have added the rest 18 event classes so our <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CondorJavaDaemon\" title=\"Condor Java Daemon\">CondorJavaDaemon</a></span> now it handles all event types.\n\n</p><p>Events in which type number are 002,003,013,017,018,020,022,023,024,026 and 027 will not have any\nparsing problem since I've run experiment with <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=EventLog\" title=\"Event Log\">EventLog</a></span> got from tg-condor.\nSo our <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CondorJavaDaemon\" title=\"Condor Java Daemon\">CondorJavaDaemon</a></span> will handle them successfully.\n\n</p><p>Other events in which type number are 014,015,016,019,021,025,028 have not been tested yet due to the lack of\nsample events from tg-condor <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=EventLog\" title=\"Event Log\">EventLog</a></span> file.\nFor those events, our CondorJavaDaemon.jar may successfully handle them or not.\n\n</p><p><span class=\"section\"></span></p><h2>Message Filtering functionality added</h2>\n\n<p><span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=MessageFilter\" title=\"Message Filter\">MessageFilter</a></span> class has been added to <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CondorJavaDaemon\" title=\"Condor Java Daemon\">CondorJavaDaemon</a></span> and tested locally on mdw-23 (Ubuntu 8.0.4).The next thing to do is compiling from RHEL3 and deploy it to tg-dev01.rcac.purdue.edu(RHEL3).\n\n</p><p><span class=\"subsection\"></span></p><h3>How it works</h3>\n\n<p>1. Users(Administrators) set two macros in condor_config file as follows\n\n</p><p>JAVAD_EVENT_ALLOW= ULOG_SUBMIT, ULOG_JUNGHA, ULOG_EXECUTE, ULOG_JOB_EVICTED, ULOG_JOB_TERMINATED\nJAVAD_EVENT_DENY = ULOG_JOB_TERMINATED\n\n</p><p>2. condor_javad reads configuration and exports it to JVM's system property directly.\n\n</p><p>3. Condor Java Daemon retrieves JVM system property and instantiates a <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=MessageFilter\" title=\"Message Filter\">MessageFilter</a></span> object.\nIf both macros are set, workingFilter is calculated by allowset minus denyset (set difference).\nEvery  message is filtered by workingFilter right before it is being sent to JBoss queue.\n\n</p><p>4. Error handling\n- If an invalid log type such as ULOG_JUNGHA is specified in macros, it is ignored.\n- If JAVAD_EVENT_ALLOW is not set, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CondorJavaDeamon\" title=\"Condor Java Deamon\">CondorJavaDeamon</a></span> adds all event types defined in ULogEventNumber.java dynamically.\n- If none of macros are set in the condor_config, default behavior is to allow all types of events.</p></blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2021-Sep-28 08:45</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/4bd149fa3dc27d717009a2aea8c5ad8c972be3b6\">[64499]</a></span>: Merged <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/1d682797c4de74f320bec30bafeeaca3834401c5\">[64352]</a></span>, Merge pull request <span class=\"ticket\"><a class=\"new\" href=\"/wiki-archive/tickets/?ticket=209\" onclick=\"get_ticket_and_populate_wrapper('209'); return false;\" title=\"Create a service to publish Condor events via JMS\">#209</a></span> from htcondor/master-HTCONDOR-720-branch HTCONDOR-720 add NOBODY_SLOT_USER. a better way to configure SLOT&lt;n&gt;_\u00e2\u20ac\u00a6 Committer: <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=GitHub\" title=\"Git Hub\">GitHub</a></span>  (By Tim Theisen )</td></tr>\n</tbody></table>", "type": "enhance", "last_change": "2010-Jan-31 13:20", "status": "new", "created": "2009-Feb-11 13:16", "fixed_version": "2009-Feb-11 13:16", "broken_version": "", "priority": "4", "subsystem": "Unknown", "assigned_to": "wooj", "derived_from": "", "creator": "tannenba", "rust": "", "customer_group": "purdue", "visibility": "public", "notify": "dbraun@purdue.edu", "due_date": ""}