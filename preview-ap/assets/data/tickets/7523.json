{"id": 7523, "title": "Ticket #7523: Add for_each_with_index() function to ClassAds?", "description": "<blockquote>\nTJ may have other good, or better, examples.\n\n<p><strong>Motivating example</strong> <br/>\n\nDetermining how many of a p-slot's GPUs have been assigned to interactive jobs.  The config knobbery to add an attribute to each slot which is <code>true</code> for interactive jobs and to then \"roll up\" that attribute for the p-slot is straightforward.\n\n</p><p>However, the expression that computes how many slots are both assigned a GPU and are interactive is not simple.  (It may become simpler in the future, because we should be able to roll up expressions, e.g., how many interactive GPUs this slot has.)  Each component looks something like\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">igv0 = child_gpus[0] * child_interactive[0]</pre></div>\n\n\n<p>which wouldn't be so bad except that indexing off the end of a list is an error, not undefined, so you need to write a list for each possible length:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">igl2 = { $(igv0), $(igv1) }</pre></div>\n\n\n<p>and choose the correct-length list:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">ifthenelse( size(child_gpus) == 1, sum(igl1),\n      ifthenelse( size(child_gpus) == 2, sum(igl2), ...</pre></div>\n\n\n<p>up to as many child slots the pslot is willing to make (in this case, limited by the number of GPUs).\n\n</p><p>This, of course, is absurd.\n\n</p><p><strong>Proposal</strong> <br/>\n\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">InteractiveGPUs = for_each_with_index( count_if_interactive, child_gpus )\nfor_each_with_index = ifthenelse( MY.child_interactive[TARGET.index], TARGET.value, 0 )\n</pre></div>\n\n\n<p>The function <code>for_each_with_index()</code> takes an attribute reference and a list.  For each item in the list, the attribute referenced is evaluated in the context of its own ad (MY) and a context ad (TARGET) which has two attributes: <code>index</code>, which is the position of the item in the list, and <code>value</code>, which is the corresponding value.  The result of the evaluation is stored at the corresponding index of the list which is the return value.\n\n</p><p>IIRC, we generally disallow self-referencing attributes, so that shouldn't be a problem.  We may also, however, may wish to make it invalid (an error) to call <code>for_each_with_index()</code> from inside an evaluation of <code>for_each_with_index()</code>.\n\n</p><p>For usability reasons, it may be nice to immediately investigate the possibility of allowing the attribute reference to be an expression, with \"its own\" ad being the ad in which the function call is being made.\n\n</p><p>Further extensions are fairly obvious (and include things like making the evaluation more function-call like by including argument references), but we don't shouldn't let this ticket get bogged down by them.\n\n</p><p>Further discussion, however, may be valuable if simple semantic changes would simplify implementation and/or performance.</p></blockquote>", "remarks": "<blockquote>\n</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "enhance", "last_change": "2020-Feb-25 16:42", "status": "new", "created": "2020-Feb-25 16:42", "fixed_version": "2020-Feb-25 16:42", "broken_version": "", "priority": "4", "subsystem": "ClassAd", "assigned_to": "", "derived_from": "", "creator": "tlmiller", "rust": "", "customer_group": "other", "visibility": "public", "notify": "tlmiller@cs.wisc.edu, johnkn@cs.wisc.edu", "due_date": ""}