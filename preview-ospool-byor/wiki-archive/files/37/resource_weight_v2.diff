diff --git a/src/condor_accountant.V6/Accountant.C b/src/condor_accountant.V6/Accountant.C
index 718fc49..98a8c57 100644
--- a/src/condor_accountant.V6/Accountant.C
+++ b/src/condor_accountant.V6/Accountant.C
@@ -42,6 +42,7 @@ MyString Accountant::ResourceRecord="Resource.";
 
 MyString Accountant::PriorityAttr="Priority";
 MyString Accountant::ResourcesUsedAttr="ResourcesUsed";
+MyString Accountant::ResourcesUsedRWAttr="ResourcesUsedRW";
 MyString Accountant::UnchargedTimeAttr="UnchargedTime";
 MyString Accountant::AccumulatedUsageAttr="AccumulatedUsage";
 MyString Accountant::BeginUsageTimeAttr="BeginUsageTime";
@@ -53,6 +54,7 @@ MyString Accountant::LastUpdateTimeAttr="LastUpdateTime";
 MyString Accountant::RemoteUserAttr="RemoteUser";
 MyString Accountant::StartTimeAttr="StartTime";
 
+MyString Accountant::ResourceWeightAttr=ATTR_RESOURCE_WEIGHT;
 
 //------------------------------------------------------------------
 // Constructor - One time initialization
@@ -162,6 +164,8 @@ void Accountant::Initialize()
 
   DiscountSuspendedResources = param_boolean(
                              "NEGOTIATOR_DISCOUNT_SUSPENDED_RESOURCES",false);
+  UseResourceWeights = param_boolean("NEGOTIATOR_USE_RESOURCE_WEIGHTS",false);
+
 
   dprintf(D_ACCOUNTANT,"PRIORITY_HALFLIFE=%f\n",HalfLifePeriod);
   dprintf(D_ACCOUNTANT,"NICE_USER_PRIO_FACTOR=%f\n",NiceUserPriorityFactor);
@@ -270,6 +274,17 @@ int Accountant::GetResourcesUsed(const MyString& CustomerName)
 }
 
 //------------------------------------------------------------------
+// Return the number of resources used (floating point version)
+//------------------------------------------------------------------
+
+float Accountant::GetResourcesUsedFloat(const MyString& CustomerName) 
+{
+  float ResourcesUsedRW=0.0;
+  GetAttributeFloat(CustomerRecord+CustomerName,ResourcesUsedRWAttr,ResourcesUsedRW);
+  return ResourcesUsedRW;
+}
+
+//------------------------------------------------------------------
 // Return the priority of a customer
 //------------------------------------------------------------------
 
@@ -464,18 +479,22 @@ void Accountant::AddMatch(const MyString& CustomerName, ClassAd* ResourceAd)
   MyString ResourceName=GetResourceName(ResourceAd);
   time_t T=time(0);
 
-  // dprintf(D_ACCOUNTANT,"Accountant::AddMatch - CustomerName=%s, ResourceName=%s\n",CustomerName.Value(),ResourceName.Value());
+  dprintf(D_ACCOUNTANT,"Accountant::AddMatch - CustomerName=%s, ResourceName=%s\n",CustomerName.Value(),ResourceName.Value());
 
   // Check if the resource is used
   MyString RemoteUser;
   if (GetAttributeString(ResourceRecord+ResourceName,RemoteUserAttr,RemoteUser)) {
     if (CustomerName==RemoteUser) {
-      // dprintf(D_ACCOUNTANT,"Match already existed!\n");
+	  dprintf(D_ACCOUNTANT,"Match already existed!\n");
       return;
     }
     RemoveMatch(ResourceName,T);
   }
-  
+
+  float ResourceWeight=1.0;
+  if(ResourceAd->EvalFloat(ResourceWeightAttr.Value(),NULL,ResourceWeight) == 0) {
+	  ResourceWeight = 1.0;
+  }
 
   int ResourcesUsed=0;
   GetAttributeInt(CustomerRecord+CustomerName,ResourcesUsedAttr,ResourcesUsed);
@@ -486,6 +505,7 @@ void Accountant::AddMatch(const MyString& CustomerName, ClassAd* ResourceAd)
   bool update_group_info = false;
   MyString GroupName;
   int GroupResourcesUsed=0;
+  float GroupResourcesUsedRW = 0.0;
   int GroupUnchargedTime=0;
   if ( GroupNamesList ) {
 	  GroupName = CustomerName;
@@ -498,6 +518,7 @@ void Accountant::AddMatch(const MyString& CustomerName, ClassAd* ResourceAd)
 	  if ( pos != -1 && GroupNamesList->contains_anycase(GroupName.Value()) ) {
 			update_group_info = true;			
 			GetAttributeInt(CustomerRecord+GroupName,ResourcesUsedAttr,GroupResourcesUsed);
+			GetAttributeFloat(CustomerRecord+GroupName,ResourcesUsedRWAttr,GroupResourcesUsedRW);
 			GetAttributeInt(CustomerRecord+GroupName,UnchargedTimeAttr,GroupUnchargedTime);
 	  }
   }
@@ -515,11 +536,15 @@ void Accountant::AddMatch(const MyString& CustomerName, ClassAd* ResourceAd)
   // there is a group record to update
   if ( update_group_info ) {
 	  // Update customer's group resource usage count
+	  GroupResourcesUsedRW+=ResourceWeight;
 	  GroupResourcesUsed++;
+	  dprintf(D_ACCOUNTANT, "GroupResourcesUsedRW becomes: %.3f\n", GroupResourcesUsedRW);
+	  SetAttributeFloat(CustomerRecord+GroupName,ResourcesUsedRWAttr,GroupResourcesUsedRW);
 	  SetAttributeInt(CustomerRecord+GroupName,ResourcesUsedAttr,GroupResourcesUsed);
 	  // add negative "uncharged" time if match starts after last update 
 	  GroupUnchargedTime-=T-LastUpdateTime;
 	  SetAttributeInt(CustomerRecord+GroupName,UnchargedTimeAttr,GroupUnchargedTime);
+	  SetAttributeFloat(ResourceRecord+ResourceName,ResourceWeightAttr,ResourceWeight);
   }
 
   // Set reosurce's info: user, and start-time
@@ -564,7 +589,9 @@ void Accountant::RemoveMatch(const MyString& ResourceName, time_t T)
 	bool update_group_info = false;
 	MyString GroupName;
 	int GroupResourcesUsed=0;
+	float GroupResourcesUsedRW=0.0;
 	int GroupUnchargedTime=0;
+	float ResourceWeight=1.0;
 	if ( GroupNamesList ) {
 	  GroupName = CustomerName;
 	  int pos = GroupName.FindChar('.');	// '.' is the group seperater
@@ -576,7 +603,12 @@ void Accountant::RemoveMatch(const MyString& ResourceName, time_t T)
 	  if ( pos != -1 && GroupNamesList->contains_anycase(GroupName.Value()) ) {
 			update_group_info = true;			
 			GetAttributeInt(CustomerRecord+GroupName,ResourcesUsedAttr,GroupResourcesUsed);
+			GetAttributeFloat(CustomerRecord+GroupName,ResourcesUsedRWAttr,GroupResourcesUsedRW);
 			GetAttributeInt(CustomerRecord+GroupName,UnchargedTimeAttr,GroupUnchargedTime);
+			GetAttributeFloat(ResourceRecord+ResourceName,ResourceWeightAttr,ResourceWeight);
+			if(ResourceWeight <= 0.0) {
+				ResourceWeight = 1.0;
+			}
 	  }
 	}
 
@@ -594,6 +626,13 @@ void Accountant::RemoveMatch(const MyString& ResourceName, time_t T)
 	if ( update_group_info ) {
 	  // Update customer's group resource usage count
       if (GroupResourcesUsed>0) GroupResourcesUsed--;
+	  if (GroupResourcesUsedRW>0.0) { 
+	  	GroupResourcesUsedRW -= ResourceWeight;
+		if(GroupResourcesUsedRW < 0.0) {
+		  GroupResourcesUsedRW = 0.0;
+		}
+	  }
+	  SetAttributeFloat(CustomerRecord+GroupName,ResourcesUsedRWAttr,GroupResourcesUsedRW);
 	  SetAttributeInt(CustomerRecord+GroupName,ResourcesUsedAttr,GroupResourcesUsed);
 	  // update uncharged time
 	  GroupUnchargedTime+=T-StartTime;
@@ -681,6 +720,7 @@ void Accountant::UpdatePriorities()
   float AccumulatedUsage;
   float RecentUsage;
   int ResourcesUsed;
+  float ResourcesUsedRW;
   int BeginUsageTime;
 
   AcctLog->table.startIterations();
@@ -703,6 +743,7 @@ void Accountant::UpdatePriorities()
     if (ad->LookupFloat(AccumulatedUsageAttr.Value(),AccumulatedUsage)==0) AccumulatedUsage=0;
     if (ad->LookupInteger(BeginUsageTimeAttr.Value(),BeginUsageTime)==0) BeginUsageTime=0;
     if (ad->LookupInteger(ResourcesUsedAttr.Value(),ResourcesUsed)==0) ResourcesUsed=0;
+	if (ad->LookupFloat(ResourcesUsedRWAttr.Value(),ResourcesUsedRW)==0) ResourcesUsedRW=0.0;
 
     RecentUsage=float(ResourcesUsed)+float(UnchargedTime)/TimePassed;
     Priority=Priority*AgingFactor+RecentUsage*(1-AgingFactor);
@@ -722,7 +763,7 @@ void Accountant::UpdatePriorities()
 
 	AcctLog->CommitTransaction();
 	
-    dprintf(D_ACCOUNTANT,"CustomerName=%s , Old Priority=%5.3f , New Priority=%5.3f , ResourcesUsed=%d\n",key,OldPrio,Priority,ResourcesUsed);
+    dprintf(D_ACCOUNTANT,"CustomerName=%s , Old Priority=%5.3f , New Priority=%5.3f , ResourcesUsed=%d , ResourcesUsedRW=%f\n",key,OldPrio,Priority,ResourcesUsed,ResourcesUsedRW);
     dprintf(D_ACCOUNTANT,"RecentUsage=%8.3f, UnchargedTime=%d, AccumulatedUsage=%5.3f, BeginUsageTime=%d\n",RecentUsage,UnchargedTime,AccumulatedUsage,BeginUsageTime);
 
   }
diff --git a/src/condor_c++_util/condor_attributes.C b/src/condor_c++_util/condor_attributes.C
index 1799862..978b251 100644
--- a/src/condor_c++_util/condor_attributes.C
+++ b/src/condor_c++_util/condor_attributes.C
@@ -467,6 +467,7 @@ const char *ATTR_REMOVE_KILL_SIG          = "RemoveKillSig";
 const char *ATTR_REMOVE_REASON            = "RemoveReason";
 const char *ATTR_REQUEUE_REASON           = "RequeueReason";
 const char *ATTR_REQUIREMENTS             = "Requirements";
+const char *ATTR_RESOURCE_WEIGHT          = "ResourceWeight";
 const char *ATTR_RESULT                   = "Result";
 const char *ATTR_RSC_BYTES_SENT			 = "RSCBytesSent";
 const char *ATTR_RSC_BYTES_RECVD			 = "RSCBytesRecvd";
diff --git a/src/condor_includes/condor_accountant.h b/src/condor_includes/condor_accountant.h
index 8370ae5..4101024 100644
--- a/src/condor_includes/condor_accountant.h
+++ b/src/condor_includes/condor_accountant.h
@@ -49,6 +49,7 @@ public:
   void Initialize();  // Configuration
 
   int GetResourcesUsed(const MyString& CustomerName); // get # of used resources
+  float GetResourcesUsedFloat(const MyString& CustomerName); // same for float
   float GetPriority(const MyString& CustomerName); // get priority for a customer
   void SetPriority(const MyString& CustomerName, float Priority); // set priority for a customer
 
@@ -109,7 +110,8 @@ private:
   float HalfLifePeriod;     // The time in sec in which the priority is halved by aging
   MyString LogFileName;      // Name of Log file
   int	MaxAcctLogSize;		// Max size of log file
-  bool   DiscountSuspendedResources;
+  bool  DiscountSuspendedResources;
+  bool  UseResourceWeights; 
   StringList *GroupNamesList;
 
   //--------------------------------------------------------
@@ -132,6 +134,7 @@ private:
   static MyString PriorityAttr;
   static MyString UnchargedTimeAttr;
   static MyString ResourcesUsedAttr;
+  static MyString ResourcesUsedRWAttr;
   static MyString AccumulatedUsageAttr;
   static MyString BeginUsageTimeAttr;
   static MyString LastUsageTimeAttr;
@@ -142,6 +145,8 @@ private:
   static MyString RemoteUserAttr;
   static MyString StartTimeAttr;
 
+  static MyString ResourceWeightAttr;
+
   //--------------------------------------------------------
   // Utility functions
   //--------------------------------------------------------
diff --git a/src/condor_includes/condor_attributes.h b/src/condor_includes/condor_attributes.h
index 633b302..6513e93 100644
--- a/src/condor_includes/condor_attributes.h
+++ b/src/condor_includes/condor_attributes.h
@@ -406,6 +406,7 @@ extern const char * ATTR_REMOVE_KILL_SIG;
 extern const char * ATTR_REMOVE_REASON;
 extern const char * ATTR_REQUEUE_REASON;
 extern const char * ATTR_REQUIREMENTS;
+extern const char * ATTR_RESOURCE_WEIGHT;
 extern const char * ATTR_RESULT;
 extern const char * ATTR_RSC_BYTES_SENT;
 extern const char * ATTR_RSC_BYTES_RECVD;
diff --git a/src/condor_negotiator.V6/matchmaker.C b/src/condor_negotiator.V6/matchmaker.C
index e8de544..1274f35 100644
--- a/src/condor_negotiator.V6/matchmaker.C
+++ b/src/condor_negotiator.V6/matchmaker.C
@@ -61,6 +61,8 @@ typedef int (*lessThanFunc)(AttrList*, AttrList*, void*);
 
 static bool want_simple_matching = false;
 
+MyString ResourceWeightAttr = ATTR_RESOURCE_WEIGHT;
+
 //added by ameet - dirty hack - needs to be removed soon!!!
 //#include "../condor_c++_util/queuedbmanager.h"
 //QueueDBManager queueDBManager;
@@ -367,6 +369,8 @@ reinitialize ()
 		free( preferred_collector );
 	}
 
+	useResourceWeights = param_boolean("NEGOTIATOR_USE_RESOURCE_WEIGHTS", false);
+
 	want_simple_matching = param_boolean("NEGOTIATOR_SIMPLE_MATCHING",false);
 	want_matchlist_caching = param_boolean("NEGOTIATOR_MATCHLIST_CACHING",true);
 	ConsiderPreemption = param_boolean("NEGOTIATOR_CONSIDER_PREEMPTION",true);
@@ -942,10 +946,10 @@ negotiationTime ()
 		while ((groups = groupList.next ()))
 		{
 			tmpstr.sprintf("GROUP_QUOTA_%s",groups);
-			int quota = param_integer(tmpstr.Value(), -1 );
-			if ( quota >= 0 ) {
+			float quota = param_double(tmpstr.Value(), -1.0 );
+			if ( quota >= 0.0 ) {
                 // Static groups quotas take priority over any dynamic quota
-                dprintf(D_FULLDEBUG, "group %s static quota = %d\n",
+                dprintf(D_FULLDEBUG, "group %s static quota = %.3f\n",
                         groups, quota);
             } else {
                 // Next look for a floating point dynamic quota.
@@ -961,7 +965,7 @@ negotiationTime ()
                     // use specified dynamic quota
                     quota = (int)(quota_fraction * numDynGroupSlots);
                     dprintf(D_FULLDEBUG,
-                        "group %s dynamic quota for %d slots = %d\n",
+                        "group %s dynamic quota for %d slots = %.3f\n",
                             groups, numDynGroupSlots, quota);
                 } else {
                     // neither a static nor dynamic quota was defined
@@ -971,7 +975,7 @@ negotiationTime ()
                     continue;
                 }
             }
-            if ( quota <= 0 ) {
+            if ( quota <= 0.0 ) {
                 // Quota for group may have been set to zero by admin.
                 dprintf(D_ALWAYS,
                     "zero quota for group %s, ignoring\n",
@@ -980,8 +984,10 @@ negotiationTime ()
             }
 
 			int usage  = accountant.GetResourcesUsed(groups);
+			float usageRW = accountant.GetResourcesUsedFloat(groups);
 			groupArray[i].groupName = groups;  // don't free this! (in groupList)
 			groupArray[i].maxAllowed = quota;
+			groupArray[i].usageRW = usageRW;
 			groupArray[i].usage = usage;
 				// the 'prio' field is used to sort the group array, i.e. to
 				// decide which groups get to negotiate first.  
@@ -990,8 +996,8 @@ negotiationTime ()
 				// percentage amount of their quota get to negotiate first.
 			groupArray[i].prio = ( 100 * usage ) / quota;
 			dprintf(D_FULLDEBUG,
-				"Group Table : group %s quota %d usage %d prio %2.2f\n",
-				groups,quota,usage,groupArray[i].prio);
+				"Group Table : group %s quota %.3f usage %d(%.3f) prio %2.2f\n",
+					groups,quota,usage,usageRW,groupArray[i].prio);
 			i++;
 		}
 		int groupArrayLen = i;
@@ -1032,13 +1038,24 @@ negotiationTime ()
 					groupArray[i].groupName);
 				continue;
 			}
-			if ( groupArray[i].usage >= groupArray[i].maxAllowed  &&
-				 !ConsiderPreemption ) 
-			{
-				dprintf(D_ALWAYS,
-					"Group %s - skipping, at or over quota (usage=%d)\n",
-					groupArray[i].groupName,groupArray[i].usage);
-				continue;
+			if(useResourceWeights) {
+				if ( groupArray[i].usageRW >= groupArray[i].maxAllowed  &&
+					 !ConsiderPreemption ) 
+					{
+						dprintf(D_ALWAYS,
+								"Group %s - skipping, at or over quota (usage=%.3f)\n",
+								groupArray[i].groupName,groupArray[i].usageRW);
+						continue;
+					}
+			} else {
+				if ( groupArray[i].usage >= groupArray[i].maxAllowed  &&
+					 !ConsiderPreemption ) 
+					{
+						dprintf(D_ALWAYS,
+								"Group %s - skipping, at or over quota (usage=%d)\n",
+								groupArray[i].groupName,groupArray[i].usage);
+						continue;
+					}
 			}
 			dprintf(D_ALWAYS,"Group %s - negotiating\n",
 				groupArray[i].groupName);
@@ -1108,13 +1125,14 @@ int Matchmaker::
 negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 					 ClaimIdHash& claimIds, 
 					 ClassAdList& scheddAds, 
-					 int groupQuota, const char* groupAccountingName)
+					 float groupQuota, const char* groupAccountingName)
 {
 	ClassAd		*schedd;
 	char		scheddName[80];
 	char		scheddAddr[32];
 	int			result;
 	int			numStartdAds;
+	double      resourceWeightTotal;
 	double		maxPrioValue;
 	double		maxAbsPrioValue;
 	double		normalFactor;
@@ -1128,6 +1146,7 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 	int			scheddUsage;
 	int			totalTime;
 	int			MaxscheddLimit;
+	double      MaxscheddLimitRW;
 	int			hit_schedd_prio_limit;
 	int			hit_network_prio_limit;
 	bool ignore_schedd_limit;
@@ -1167,6 +1186,11 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 		if ( numStartdAds > groupQuota ) {
 			numStartdAds = groupQuota;
 		}
+		resourceWeightTotal = sumResourceWeights(startdAds);
+		if ( resourceWeightTotal > groupQuota ) {
+			resourceWeightTotal = groupQuota;
+		}
+
 			// Calculate how many machines are left over after dishing out
 			// rounded share of machines to each submitter.
 			// What's left are the user-prio "pie crumbs".
@@ -1179,10 +1203,12 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 			maxAbsPrioValue,
 			normalFactor,
 			normalAbsFactor,
+			resourceWeightTotal,
 				/* result parameters: */
 			userprioCrumbs );
 
 		MaxscheddLimit = 0;
+		MaxscheddLimitRW = 0.0;
 		// ----- Negotiate with the schedds in the sorted list
 		dprintf( D_ALWAYS, "Phase 4.%d:  Negotiating with schedds ...\n",
 			spin_pie );
@@ -1231,6 +1257,12 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 			free(schedd_ver_string);
 			schedd_ver_string = NULL;
 
+			double scheddLimitRW = 0.0;
+			double scheddUsageRW = 0.0;
+
+			float resourceWeight = 1.0;
+			schedd->EvalFloat(ResourceWeightAttr.Value(), NULL, resourceWeight);
+
 			calculateScheddLimit(
 				scheddName,
 				groupAccountingName,
@@ -1240,9 +1272,13 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 				maxAbsPrioValue,
 				normalFactor,
 				normalAbsFactor,
+				resourceWeight,
+				resourceWeightTotal,
 					/* result parameters: */
 				scheddLimit,
+				scheddLimitRW,
 				scheddUsage,
+				scheddUsageRW,
 				scheddShare,
 				scheddAbsShare,
 				scheddPrio,
@@ -1262,6 +1298,9 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 			if( scheddLimit > MaxscheddLimit ) {
 				MaxscheddLimit = scheddLimit;
 			}
+			if( scheddLimitRW > MaxscheddLimitRW ) {
+				MaxscheddLimitRW = scheddLimitRW;
+			}
 
 			if ( num_idle_jobs > 0 ) {
 				dprintf (D_FULLDEBUG, "  Calculating schedd limit with the "
@@ -1282,6 +1321,12 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 					userprioCrumbs, scheddLimit - scheddLimitWithoutCrumbs);
 				dprintf (D_FULLDEBUG, "    MaxscheddLimit   = %d\n",
 					MaxscheddLimit);
+				dprintf (D_FULLDEBUG, "    scheddLimitRW    = %f\n",
+					scheddLimitRW);
+				dprintf (D_FULLDEBUG, "    scheddUsageRW    = %f\n",
+					scheddUsageRW);
+				dprintf (D_FULLDEBUG, "    MaxscheddLimitRW = %f\n",
+					MaxscheddLimitRW);
 			}
 
 			// initialize reasons for match failure; do this now
@@ -1292,6 +1337,7 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 			rejPreemptForPrio = 0;
 			rejPreemptForPolicy = 0;
 			rejPreemptForRank = 0;
+			rejForGroupQuota = 0;
 
 			// Optimizations: 
 			// If number of idle jobs = 0, don't waste time with negotiate.
@@ -1324,11 +1370,17 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 					}
 					int numMatched = 0;
 					startTime = time(NULL);
+					double limitRWUsed = 0.0;
+					//if(useResourceWeights && groupAccountingName) {
+					//	limitRWUsed = accountant.GetResourcesUsedFloat(groupAccountingName);
+					//	dprintf(D_ALWAYS, "about to negotiate for group %s with allocation %.3f (%.3f used)\n",
+					//			groupAccountingName, scheddLimitRW, limitRWUsed);
+					//}
 					result=negotiate( scheddName,scheddAddr,scheddPrio,
-								  scheddAbsShare, scheddLimit,
-								  startdAds, claimIds, 
-								  scheddVersion, ignore_schedd_limit,
-								  startTime, numMatched);
+									  scheddAbsShare, scheddLimit, scheddLimitRW,
+									  startdAds, claimIds, 
+									  scheddVersion, ignore_schedd_limit,
+									  startTime, numMatched, limitRWUsed);
 					updateNegCycleEndTime(startTime, schedd);
 
 					if( numMatched > scheddLimitWithoutCrumbs ) {
@@ -1387,8 +1439,10 @@ negotiateWithGroup ( int untrimmed_num_startds, ClassAdList& startdAds,
 			}
 		}
 		scheddAds.Close();
+		// does MaxScheddLimit[RW] ever gest updated in this loop?
 	} while ( (hit_schedd_prio_limit == TRUE || hit_network_prio_limit == TRUE)
-			 && (MaxscheddLimit > 0) && (startdAds.MyLength() > 0) );
+			  && ( useResourceWeights ? (MaxscheddLimitRW > 0.0) : (MaxscheddLimit > 0) )
+			  && (startdAds.MyLength() > 0) );
 
 	return TRUE;
 }
@@ -1482,6 +1536,21 @@ trimStartdAds(ClassAdList &startdAds)
 	return removed;
 }
 
+double Matchmaker::
+sumResourceWeights(ClassAdList &startdAds)
+{
+	ClassAd *ad = NULL;
+	double sum = 0.0;
+
+	startdAds.Open();
+	while( (ad=startdAds.Next()) ) {
+		float resourceWeight = 1.0;
+		ad->EvalFloat(ResourceWeightAttr.Value(), NULL, resourceWeight);
+		sum+=resourceWeight;
+	}
+	return sum;
+}
+
 bool Matchmaker::
 obtainAdsFromCollector (
 						ClassAdList &allAds,
@@ -1768,10 +1837,11 @@ Matchmaker::MakeClaimIdHash(ClassAdList &startdPvtAdList, ClaimIdHash &claimIds)
 
 int Matchmaker::
 negotiate( char *scheddName, char *scheddAddr, double priority, double share,
-		   int scheddLimit,
+		   int scheddLimit, double scheddLimitRW,
 		   ClassAdList &startdAds, ClaimIdHash &claimIds, 
 		   const CondorVersionInfo & scheddVersion,
-		   bool ignore_schedd_limit, time_t startTime, int &numMatched)
+		   bool ignore_schedd_limit, time_t startTime, 
+		   int &numMatched, double &limitRWUsed)
 {
 	ReliSock	*sock;
 	int			reply;
@@ -1882,22 +1952,42 @@ negotiate( char *scheddName, char *scheddAddr, double priority, double share,
 
 
 		// Handle the case if we are over the scheddLimit
-		if ( numMatched >= scheddLimit ) {
-			if ( ignore_schedd_limit ) {
-				only_consider_startd_rank = true;
-				if ( display_overlimit ) {  // print message only once
-					display_overlimit = false;
-					dprintf (D_FULLDEBUG, 	
-						"    Over submitter resource limit (%d) ... "
-					    "only consider startd ranks\n", scheddLimit);
+		if(useResourceWeights) {
+			if( limitRWUsed >= scheddLimitRW ) {
+				if( ignore_schedd_limit ) {
+					only_consider_startd_rank = true;
+					if( display_overlimit ) {
+						display_overlimit = false;
+						dprintf(D_FULLDEBUG,
+								"    Over submitter resource limit (%f) ... "
+								"only consider startd ranks\n", scheddLimitRW);
+					}
+				} else {
+					dprintf (D_ALWAYS, 	
+							 "    Reached submitter resource limit: %f ... stopping\n", limitRWUsed);
+					break;	// get out of the infinite for loop & stop negotiating
 				}
 			} else {
-				dprintf (D_ALWAYS, 	
-				"    Reached submitter resource limit: %d ... stopping\n", numMatched);
-				break;	// get out of the infinite for loop & stop negotiating
+				only_consider_startd_rank = false;
 			}
 		} else {
-			only_consider_startd_rank = false;
+			if ( numMatched >= scheddLimit ) {
+				if ( ignore_schedd_limit ) {
+					only_consider_startd_rank = true;
+					if ( display_overlimit ) {  // print message only once
+						display_overlimit = false;
+						dprintf (D_FULLDEBUG, 	
+								 "    Over submitter resource limit (%d) ... "
+								 "only consider startd ranks\n", scheddLimit);
+					}
+				} else {
+					dprintf (D_ALWAYS, 	
+							 "    Reached submitter resource limit: %d ... stopping\n", numMatched);
+					break;	// get out of the infinite for loop & stop negotiating
+				}
+			} else {
+				only_consider_startd_rank = false;
+			}
 		}
 
 
@@ -1932,10 +2022,18 @@ negotiate( char *scheddName, char *scheddAddr, double priority, double share,
 				// So in this case, return MM_RESUME since there still may be 
 				// jobs which the schedd wants scheduled but have not been considered
 				// as candidates for no preemption or user priority preemption.
-			if ( numMatched >= scheddLimit ) {
-				return MM_RESUME;
+			if ( useResourceWeights ) {
+				if( limitRWUsed >= scheddLimitRW ) {
+					return MM_RESUME;
+				} else {
+					return MM_DONE;
+				}
 			} else {
-				return MM_DONE;
+				if ( numMatched >= scheddLimit ) {
+					return MM_RESUME;
+				} else {
+					return MM_DONE;
+				}
 			}
 		}
 		else
@@ -1980,7 +2078,9 @@ negotiate( char *scheddName, char *scheddAddr, double priority, double share,
 			// 2e(i).  find a compatible offer
 			if (!(offer=matchmakingAlgorithm(scheddName, scheddAddr, request,
 											 startdAds, priority,
-											 share, only_consider_startd_rank)))
+											 share, 
+											 limitRWUsed, scheddLimitRW,
+											 only_consider_startd_rank)))
 			{
 				int want_match_diagnostics = 0;
 				request.LookupBool (ATTR_WANT_MATCH_DIAGNOSTICS,
@@ -2007,6 +2107,8 @@ negotiate( char *scheddName, char *scheddAddr, double priority, double share,
 							"PREEMPTION_REQUIREMENTS == False";
 					} else if (rejPreemptForPrio) {
 						diagnostic_message = "insufficient priority";
+					} else if (rejForGroupQuota) {
+						diagnostic_message = "group quota exceeded";
 					} else {
 						diagnostic_message = "no match found";
 					}
@@ -2092,6 +2194,9 @@ negotiate( char *scheddName, char *scheddAddr, double priority, double share,
 		} else  {
 			startdAds.Delete (offer);
 		}	
+
+		limitRWUsed += GetResourceWeight(offer);
+
 	}
 
 
@@ -2143,11 +2248,45 @@ EvalNegotiatorMatchRank(char const *expr_name,ExprTree *expr,
 	return rank;
 }
 
+float Matchmaker::
+GetResourceWeight(ClassAd *candidate) 
+{
+	float ResourceWeight = 1.0;
+	MyString candidateName;
+	candidate->LookupString(ATTR_NAME, candidateName);
+	
+	if(candidate->EvalFloat(ResourceWeightAttr.Value(), NULL, 
+							  ResourceWeight) == 0) {
+		dprintf(D_FULLDEBUG, "Can't get ResourceWeight for '%s'; using 1.0\n", 
+				candidateName.Value());
+		ResourceWeight = 1.0;
+	}
+	return ResourceWeight;
+}
+
+bool Matchmaker::
+GroupQuotaPermits(ClassAd *candidate, double &used, double total) 
+{
+	float ResourceWeight = GetResourceWeight(candidate);
+	if((used + ResourceWeight) <= total) {
+		dprintf(D_FULLDEBUG, 
+				"GroupQuota available.  ResourceWeight: %.3f "
+				"Available: was %.3f, becomes %.3f\n", 
+				ResourceWeight, total - used, total - (used+ResourceWeight));
+		used += ResourceWeight;
+		return true;
+	} 
+	dprintf(D_FULLDEBUG, "GroupQuota not available.  ResourceWeight: %.3f "
+			"Available: %.3f\n", ResourceWeight, total - used);
+	return false;
+}
+
 
 ClassAd *Matchmaker::
 matchmakingAlgorithm(char *scheddName, char *scheddAddr, ClassAd &request,
 					 ClassAdList &startdAds,
 					 double preemptPrio, double share,
+					 double limitRWUsed, double scheddLimitRW,
 					 bool only_for_startdrank)
 {
 		// to store values pertaining to a particular candidate offer
@@ -2173,6 +2312,7 @@ matchmakingAlgorithm(char *scheddName, char *scheddAddr, ClassAd &request,
 		// request attributes
 	int				requestAutoCluster = -1;
 
+	dprintf(D_FULLDEBUG, "matchmakingAlgorithm: limit %f used %f\n", scheddLimitRW, limitRWUsed);
 
 		// Check resource constraints requested by request
 	rejForConcurrencyLimit = 0;
@@ -2249,7 +2389,8 @@ matchmakingAlgorithm(char *scheddName, char *scheddAddr, ClassAd &request,
 				rejForConcurrencyLimit,
 				rejPreemptForPrio,
 				rejPreemptForPolicy,
-				rejPreemptForRank);
+				rejPreemptForRank,
+				rejForGroupQuota);
 		}
 			//  TODO  - compare results, reserve net bandwidth
 		return cached_bestSoFar;
@@ -2344,11 +2485,11 @@ matchmakingAlgorithm(char *scheddName, char *scheddAddr, ClassAd &request,
 	rejPreemptForPrio = 0;
 	rejPreemptForPolicy = 0;
 	rejPreemptForRank = 0;
+	rejForGroupQuota = 0;
 
 	// scan the offer ads
 	startdAds.Open ();
 	while ((candidate = startdAds.Next ())) {
-
 			// the candidate offer and request must match
 		if( !( *candidate == request ) ) {
 				// they don't match; continue
@@ -2454,6 +2595,12 @@ matchmakingAlgorithm(char *scheddName, char *scheddAddr, ClassAd &request,
 		}
 #endif
 
+		if(useResourceWeights && 
+		   !GroupQuotaPermits(candidate, limitRWUsed, scheddLimitRW)) {
+			rejForGroupQuota++;
+			continue;
+		}
+
 		candidatePreJobRankValue = EvalNegotiatorMatchRank(
 		  "NEGOTIATOR_PRE_JOB_RANK",NegotiatorPreJobRank,
 		  request,candidate);
@@ -2540,7 +2687,8 @@ matchmakingAlgorithm(char *scheddName, char *scheddAddr, ClassAd &request,
 	if ( MatchList ) {
 		MatchList->set_diagnostics(rejForNetwork, rejForNetworkShare, 
 		    rejForConcurrencyLimit,
-			rejPreemptForPrio, rejPreemptForPolicy, rejPreemptForRank);
+			rejPreemptForPrio, rejPreemptForPolicy, rejPreemptForRank,
+			rejForGroupQuota);
 			// only bother sorting if there is more than one entry
 		if ( MatchList->length() > 1 ) {
 			dprintf(D_FULLDEBUG,"Start of sorting MatchList (len=%d)\n",
@@ -2552,6 +2700,9 @@ matchmakingAlgorithm(char *scheddName, char *scheddAddr, ClassAd &request,
 		ClassAd *bestCached = MatchList->pop_candidate();
 		// TODO - do bestCached and bestSoFar refer to the same
 		// machine preference? (sanity check)
+		if(bestCached != bestSoFar) {
+			dprintf(D_ALWAYS, "INSANE: bestCached != bestSoFar\n");
+		}
 		bestCached = NULL; // just to remove unused variable warning
 	}
 
@@ -2879,10 +3030,14 @@ Matchmaker::calculateScheddLimit(
 	double maxAbsPrioValue,
 	double normalFactor,
 	double normalAbsFactor,
+	float resourceWeight,
+	double resourceWeightTotal,
 		/* result parameters: */
 	int &scheddLimit,
+	double &scheddLimitRW,
 	int &scheddUsage,
-	double scheddShare,
+	double &scheddUsageRW,
+	double &scheddShare,
 	double &scheddAbsShare,
 	double &scheddPrio,
 	double &scheddPrioFactor,
@@ -2891,27 +3046,43 @@ Matchmaker::calculateScheddLimit(
 		// calculate the percentage of machines that this schedd can use
 	scheddPrio = accountant.GetPriority ( scheddName );
 	scheddUsage = accountant.GetResourcesUsed ( scheddName );
+	scheddUsageRW = accountant.GetResourcesUsedFloat( scheddName );
 	scheddShare = maxPrioValue/(scheddPrio*normalFactor);
 	double unroundedScheddLimit;
 	if ( param_boolean("NEGOTIATOR_IGNORE_USER_PRIORITIES",false) ) {
 			// why is this not assigned to numStartdAds?
 		unroundedScheddLimit = 500000;
+		scheddLimitRW = DBL_MAX;
 	} else {
 		unroundedScheddLimit = (scheddShare*numStartdAds)-scheddUsage;
+		scheddLimitRW = (scheddShare*resourceWeightTotal)-scheddUsageRW;
 	}
 	if( unroundedScheddLimit < 0 ) {
 		unroundedScheddLimit = 0;
 	}
+	if( scheddLimitRW < 0 ) {
+		scheddLimitRW = 0.0;
+	}
+
 	if ( groupAccountingName ) {
 		int maxAllowed = groupQuota - accountant.GetResourcesUsed(groupAccountingName);
+		float maxAllowedRW = resourceWeightTotal 
+			- accountant.GetResourcesUsedFloat(groupAccountingName);
 		if ( maxAllowed < 0 ) maxAllowed = 0;
+		if ( maxAllowedRW < 0 ) maxAllowedRW = 0.0;
 		if ( unroundedScheddLimit > maxAllowed ) {
 			unroundedScheddLimit = maxAllowed;
 		}
+		if ( scheddLimitRW > maxAllowedRW ) {
+			scheddLimitRW = maxAllowedRW;
+		}
 	}
 
 	scheddLimit  = (int) rint(unroundedScheddLimit);
 	scheddLimitRoundoff = unroundedScheddLimit - scheddLimit;
+	if(scheddLimitRoundoff < 0.0) {
+		dprintf(D_ALWAYS, "Negative scheddLimitRoundoff: %.3f", scheddLimitRoundoff);
+	}
 
 		// calculate this schedd's absolute fair-share for allocating
 		// resources other than CPUs (like network capacity and licenses)
@@ -2930,8 +3101,9 @@ Matchmaker::calculateUserPrioCrumbs(
 	double maxAbsPrioValue,
 	double normalFactor,
 	double normalAbsFactor,
+	double resourceWeightTotal,
 		/* result parameters: */
-	int &userprioCrumbs )
+	int &userprioCrumbs)
 {
 	ClassAd *schedd;
 
@@ -2953,8 +3125,12 @@ Matchmaker::calculateUserPrioCrumbs(
 		double scheddPrioFactor = 0.0;
 		MyString scheddName;
 		double scheddLimitRoundoff = 0.0;
+		float resourceWeight = 1.0;
+		double scheddLimitRW = 0.0;
+		double scheddUsageRW = 0.0;
 
 		schedd->LookupString( ATTR_NAME, scheddName );
+		schedd->EvalFloat(ResourceWeightAttr.Value(), NULL, resourceWeight);
 
 		calculateScheddLimit(
 			scheddName.Value(),
@@ -2965,9 +3141,13 @@ Matchmaker::calculateUserPrioCrumbs(
 			maxAbsPrioValue,
 			normalFactor,
 			normalAbsFactor,
+			resourceWeight,
+			resourceWeightTotal,
 				/* result parameters: */
 			scheddLimit,
+			scheddLimitRW,
 			scheddUsage,
+			scheddUsageRW,
 			scheddShare,
 			scheddAbsShare,
 			scheddPrio,
@@ -2978,6 +3158,9 @@ Matchmaker::calculateUserPrioCrumbs(
 	scheddAds.Close();
 
 	userprioCrumbs = (int)rint( roundoff_sum );
+	if(userprioCrumbs < 0) {
+		dprintf(D_ALWAYS, "Negative userprioCrumbs: %d\n", userprioCrumbs);
+	}
 }
 
 void Matchmaker::
@@ -3165,6 +3348,7 @@ MatchListType(int maxlen)
 	m_rejPreemptForPrio = 0;
 	m_rejPreemptForPolicy = 0; 
 	m_rejPreemptForRank = 0;
+	m_rejForGroupQuota = 0;
 }
 
 Matchmaker::MatchListType::
@@ -3195,7 +3379,8 @@ get_diagnostics(int & rejForNetwork,
 					int & rejForConcurrencyLimit,
 					int & rejPreemptForPrio,
 					int & rejPreemptForPolicy,
-					int & rejPreemptForRank)
+				    int & rejPreemptForRank,
+				    int & rejForGroupQuota)
 {
 	rejForNetwork = m_rejForNetwork;
 	rejForNetworkShare = m_rejForNetworkShare;
@@ -3203,6 +3388,7 @@ get_diagnostics(int & rejForNetwork,
 	rejPreemptForPrio = m_rejPreemptForPrio;
 	rejPreemptForPolicy = m_rejPreemptForPolicy;
 	rejPreemptForRank = m_rejPreemptForRank;
+	rejForGroupQuota = m_rejForGroupQuota;
 }
 
 void Matchmaker::MatchListType::
@@ -3211,7 +3397,8 @@ set_diagnostics(int rejForNetwork,
 					int rejForConcurrencyLimit,
 					int rejPreemptForPrio,
 					int rejPreemptForPolicy,
-					int rejPreemptForRank)
+				    int rejPreemptForRank,
+				    int rejForGroupQuota)
 {
 	m_rejForNetwork = rejForNetwork;
 	m_rejForNetworkShare = rejForNetworkShare;
@@ -3219,6 +3406,7 @@ set_diagnostics(int rejForNetwork,
 	m_rejPreemptForPrio = rejPreemptForPrio;
 	m_rejPreemptForPolicy = rejPreemptForPolicy;
 	m_rejPreemptForRank = rejPreemptForRank;
+	m_rejForGroupQuota = rejForGroupQuota;
 }
 
 void Matchmaker::MatchListType::
diff --git a/src/condor_negotiator.V6/matchmaker.h b/src/condor_negotiator.V6/matchmaker.h
index 4abbf65..bbc7a1c 100644
--- a/src/condor_negotiator.V6/matchmaker.h
+++ b/src/condor_negotiator.V6/matchmaker.h
@@ -121,19 +121,22 @@ class Matchmaker : public Service
 		**/
 		int negotiate( char *scheddName, char *scheddAddr, 
 		   double priority, double share,
-		   int scheddLimit,
+		   int scheddLimit, double scheddLimitRW,
 		   ClassAdList &startdAds, ClaimIdHash &claimIds, 
 		   const CondorVersionInfo & scheddVersion,
-		   bool ignore_schedd_limit, time_t startTime, int &numMatched);
+		   bool ignore_schedd_limit, time_t startTime, 
+		   int &numMatched, double &limitRWUsed);
 
 		int negotiateWithGroup ( int untrimmed_num_startds,
 			ClassAdList& startdAds, 
 			ClaimIdHash& claimIds, ClassAdList& scheddAds, 
-			int groupQuota=INT_MAX, const char* groupAccountingName=NULL);
+			float groupQuota=INT_MAX, const char* groupAccountingName=NULL);
 
 		
 		ClassAd *matchmakingAlgorithm(char*,char*,ClassAd&,ClassAdList&,
-									  double=-1.0, double=1.0, bool=false);
+									  double, double, 
+									  double, double,
+									  bool);
 		int matchmakingProtocol(ClassAd &request, ClassAd *offer, 
 						ClaimIdHash &claimIds, Sock *sock,
 						char* scheddName, char* scheddAddr);
@@ -152,7 +155,9 @@ class Matchmaker : public Service
 			@param normalAbsFactor Normalization for prio factors
 
 			@param scheddLimit Resulting submitter share of this pie
+			@param scheddLimitRW Resulting submitter weighted share
 			@param scheddUsage Set to number of slots claimed by this submitter
+			@param scheddUsageRW Set to quantity of quota claimed by this submitter
 			@param scheddShare Resulting fractional share by prio and factor
 			@param scheddAbsShare Resulting fractional share by prio factor
 			@param scheddPrio User priority
@@ -168,10 +173,14 @@ class Matchmaker : public Service
 		                          double maxAbsPrioValue,
 		                          double normalFactor,
 		                          double normalAbsFactor,
+								  float resourceWeight,
+								  double resourceWeightTotal,
 		                            /* result parameters: */
 		                          int &scheddLimit,
+								  double &scheddLimitRW,
 		                          int &scheddUsage,
-		                          double scheddShare,
+								  double &scheddUsageRW,
+		                          double &scheddShare,
 		                          double &scheddAbsShare,
 		                          double &scheddPrio,
 		                          double &scheddPrioFactor,
@@ -199,6 +208,7 @@ class Matchmaker : public Service
 		                              double maxAbsPrioValue,
 		                              double normalFactor,
 		                              double normalAbsFactor,
+									  double resourceWeightTotal,
 		                                   /* result parameters: */
 		                              int &userprioCrumbs );
 
@@ -220,6 +230,10 @@ class Matchmaker : public Service
 			// trim out startd ads that are not in the Unclaimed state.
 		int trimStartdAds(ClassAdList &startdAds);
 
+		float GetResourceWeight(ClassAd *candidate);
+		bool GroupQuotaPermits(ClassAd *candidate, double &used, double total);
+		double sumResourceWeights(ClassAdList &startdAds);
+
 		/* ODBC insert functions */
 		void insert_into_rejects(char *userName, ClassAd& job);
 		void insert_into_matches(char * userName, ClassAd& request, ClassAd& offer);
@@ -234,6 +248,7 @@ class Matchmaker : public Service
 		ExprTree *PreemptionRank; 	// rank preemption candidates
 		ExprTree *NegotiatorPreJobRank;  // rank applied before job rank
 		ExprTree *NegotiatorPostJobRank; // rank applied after job rank
+		bool useResourceWeights; // Should resource weights be used or do all machines count 1.
 		bool want_matchlist_caching;	// should we cache matches per autocluster?
 		bool ConsiderPreemption; // if false, negotiation is faster (default=true)
 		/// Should the negotiator inform startds of matches?
@@ -288,6 +303,7 @@ class Matchmaker : public Service
 		int rejPreemptForPrio;	//   - insufficient prio to preempt?
 		int rejPreemptForPolicy; //   - PREEMPTION_REQUIREMENTS == False?
 		int rejPreemptForRank;	//   - startd RANKs new job lower?
+		int rejForGroupQuota;   //   - not enough group quota?
 
 
 		// Class used to store each individual entry in the
@@ -332,13 +348,15 @@ class Matchmaker : public Service
 					int & rejForConcurrencyLimit,
 					int & rejPreemptForPrio,
 					int & rejPreemptForPolicy,
-					int & rejPreemptForRank);
+					int & rejPreemptForRank,
+					int & rejForGroupQuota);
 			void set_diagnostics(int rejForNetwork,
 					int rejForNetworkShare,
 					int rejForConcurrencyLimit,
 					int rejPreemptForPrio,
 					int rejPreemptForPolicy,
-					int rejPreemptForRank);
+					int rejPreemptForRank,
+					int rejForGroupQuota);
 			void add_candidate(ClassAd* candidate,
 					double candidateRankValue,
 					double candidatePreJobRankValue,
@@ -364,7 +382,9 @@ class Matchmaker : public Service
 			int m_rejForConcurrencyLimit;	//   - limited concurrency?
 			int m_rejPreemptForPrio;	//   - insufficient prio to preempt?
 			int m_rejPreemptForPolicy; //   - PREEMPTION_REQUIREMENTS == False?
-			int m_rejPreemptForRank;	//   - startd RANKs new job lower?
+			int m_rejPreemptForRank;    //   - startd RANKs new job lower?
+			int m_rejForGroupQuota;     //   - not enough group quota?
+			
 			
 		};
 		MatchListType* MatchList;
@@ -382,8 +402,9 @@ class Matchmaker : public Service
 			~SimpleGroupEntry();
 			char *groupName;
 			float prio;
-			int maxAllowed;
+			float maxAllowed;
 			int usage;
+			float usageRW;
 			ClassAdList submitterAds;			
 		};
 		static int groupSortCompare(const void*, const void*);
diff --git a/src/condor_startd.V6/ResMgr.C b/src/condor_startd.V6/ResMgr.C
index 1296a89..ff329b9 100644
--- a/src/condor_startd.V6/ResMgr.C
+++ b/src/condor_startd.V6/ResMgr.C
@@ -142,6 +142,7 @@ ResMgr::init_config_classad( void )
 #if HAVE_HIBERNATE
 	configInsert( config_classad, "HIBERNATE", false );
 #endif /* HAVE_HIBERNATE */
+	configInsert( config_classad, ATTR_RESOURCE_WEIGHT, false );
 
 		// Next, try the IS_OWNER expression.  If it's not there, give
 		// them a resonable default, instead of leaving it undefined. 
diff --git a/src/condor_startd.V6/Resource.C b/src/condor_startd.V6/Resource.C
index 148feca..30c56d4 100644
--- a/src/condor_startd.V6/Resource.C
+++ b/src/condor_startd.V6/Resource.C
@@ -1452,6 +1452,8 @@ Resource::publish( ClassAd* cap, amask_t mask )
 					"should be added by ResMgr!", ATTR_CPU_BUSY );
 		}
 
+		caInsert(cap, r_classad, ATTR_RESOURCE_WEIGHT);
+
 			// Include everything from STARTD_EXPRS.
 			// And then include everything from SLOTx_STARTD_EXPRS
 		daemonCore->publish(cap);
