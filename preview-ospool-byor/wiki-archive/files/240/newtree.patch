diff -rNup condor-7.4.2.orig/src/condor_negotiator.V6/matchmaker.cpp condor-7.4.2/src/condor_negotiator.V6/matchmaker.cpp
--- condor-7.4.2.orig/src/condor_negotiator.V6/matchmaker.cpp	2010-10-21 10:54:55.000000000 -0400
+++ condor-7.4.2/src/condor_negotiator.V6/matchmaker.cpp	2010-10-27 14:49:24.000000000 -0400
@@ -994,8 +994,8 @@ negotiationTime ()
     }
 
 	free(groupnames);	
-	std::vector<SimpleGroupEntry> groupArray(1);
-	SimpleGroupEntry tempentry;
+	SimpleGroupEntry grouptree;
+	SimpleGroupEntry * tempentry;
 	// first step is to build top tier group
 	// name is null for now to avoid overlap between group names in the config
 	
@@ -1016,23 +1016,18 @@ negotiationTime ()
             	}
         }
 
-	groupArray[0].groupName.assign("\0");
-	groupArray[0].maxAllowed = (float)numDynGroupSlots;  
-	groupArray[0].quota = 1;  
-	groupArray[0].usage = 0;
-	groupArray[0].parent = -1;
-	groupArray[0].child = -1; 
-	groupArray[0].left =-1;
-	groupArray[0].right = -1;
-	groupArray[0].numsubmits=0; 
-	groupArray[0].nodequota=0;
-	groupArray[0].nodemaxAllowed=0;
-	groupArray[0].unused=0;
-	groupArray[0].autoregroup=true;
-	
+	grouptree.groupName.assign("nogroup\0");
+	grouptree.maxAllowed = (double)untrimmedSlotWeightTotal;  //numDynGroupSlots
+	grouptree.quota = 1;  
+	grouptree.usage = 0;
+	grouptree.parent = NULL;
+	grouptree.numsubmits=0; 
+	grouptree.staticquota=false;
+	grouptree.unused=0;
+	grouptree.autoregroup=true;
+ 
 
-	MyString tmpstr; // need to change this over to std:string at some point	
-	double quota_fraction;		
+	MyString tmpstr; // need to change this over to std:string at some point		
 	size_t found;
 
 	//group names should be a comma delimied list
@@ -1043,7 +1038,6 @@ negotiationTime ()
 		found=groupList.find_first_of(" ");
 	}
 	
-
 	while (!groupList.empty()) {
 		unsigned delim=groupList.find_first_of(",");
 		if (delim==-1) { 
@@ -1053,298 +1047,33 @@ negotiationTime ()
 			groups=groupList.substr(0,delim);
 			if (delim+1<groupList.length()) groupList=groupList.substr(delim+1,groupList.length());
 		}
-		tmpstr.sprintf("GROUP_QUOTA_%s",groups.c_str());
-		quota_fraction = param_double(tmpstr.Value(), -1.0 );
-		if ( quota_fraction >= 0.0 ) {
-                	// Static groups quotas take priority over any dynamic quota
-                	dprintf(D_FULLDEBUG, "group %s static quota = %.3f\n", groups.c_str(), quota_fraction);
-			tempentry.staticquota=true;			
-		} else {
-                	// Next look for a floating point dynamic quota.
-                	tmpstr.sprintf("GROUP_QUOTA_DYNAMIC_%s", groups.c_str());
-                	quota_fraction =
-                    		param_double(
-                        		tmpstr.Value(),     // name
-                        		0.0,                // default value
-                        		0.0,                // min value
-                        		1.0                 // max value
-                    			);
-                	if (quota_fraction >= 0.0) {
-                    		// use specified dynamic quota
-                    		//quota = rint(quota_fraction * numDynGroupSlots);
-                    		dprintf(D_FULLDEBUG, "group %s dynamic quota for %d slots = %.3f\n",
-                            		groups.c_str(), numDynGroupSlots, quota_fraction);
-                	} else {
-                    		// neither a static nor dynamic quota was defined
-                    		dprintf(D_ALWAYS, "ERROR - no quota specified for group %s - using 0\n",
-                        		groups.c_str());
-                  
-				quota_fraction = 0.0;
-                 	}
-			tempentry.staticquota=false;
-            	}
-
-		// fill in the info into the groupArray, so we can sort
-		// the groups into the order we want to negotiate them.
-		
-		float usage = accountant.GetWeightedResourcesUsed(groups.c_str());
-
-		tempentry.groupName=groups;
-		tempentry.maxAllowed = 0;  
-		tempentry.quota = quota_fraction;  
-		tempentry.nodequota=0;
-		tempentry.nodemaxAllowed=0;
-		tempentry.usage = usage;
-		tempentry.parent = -1;
-		tempentry.child = -1; 
-		tempentry.left =-1;
-		tempentry.right = -1;
-		tempentry.unused = 0;
-		tempentry.numsubmits=0;
-		tempentry.autoregroup = false;
-		
-		// the 'prio' field is used to sort the group array, i.e. to
-		// decide which groups get to negotiate first.  
-		// we sort groups based upon the percentage of their quota
-		// currently being used, so that groups using the least 
-		// percentage amount of their quota get to negotiate first.
-		
-		tempentry.prio = ( 100 * usage ) / quota_fraction;
-		dprintf(D_ALWAYS,"Group Table : group %s quota %.3f usage %.3f prio %2.2f\n",
-					groups.c_str(),quota_fraction,usage,tempentry.prio);
-
-			//now count total number of group submitters  and fix up quota
-                	int numrunning=0;
-			int numidle=0;
-			ClassAd *ad = NULL;
-			//char scheddName[80];
-			string  scheddName;
-			scheddAds.Open();
-			size_t pos;
-			while( (ad=scheddAds.Next()) ) {
-				MyString temp;
-				string temp2,temp3;
-				if (!ad->LookupString(ATTR_NAME, temp)) {
-					continue;
-				}
-                // important to case-fold these so group names match 
-                temp.lower_case();
-				scheddName.assign(temp.Value());
-				// is there a username seperator?
-				pos= scheddName.find_last_of("@");
-				//look for last group seperator
-				//this should separate group from user
-				if ( pos==string::npos) {
-					continue;
-				};
-				temp2=scheddName.substr(0,pos);
-				pos= temp2.find_last_of(".");
-				// is there a group/user seperator? 
-				if ( pos==string::npos) { //assuming here that the last delimited item is a username
-					continue;        //if the user leaves this off, the subitters will appear as users
-					}                //at the parent level
-
-				temp3=temp2.substr(0,pos);
-				if ( temp3.compare(groups)==0 ) { 
-					numidle=0;
-					numrunning=0;
-					ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
-					ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
-            				tempentry.numsubmits=tempentry.numsubmits+numrunning+numidle;					 
-					}
-           			
-			}
 			
-		bool default_autoregroup = param_boolean("GROUP_AUTOREGROUP",false);
-		MyString autoregroup_param;
-		autoregroup_param.sprintf("GROUP_AUTOREGROUP_%s",tempentry.groupName.c_str());	
-		if(param_boolean(autoregroup_param.Value(),default_autoregroup))
-			tempentry.autoregroup=true;
-		else 
-			tempentry.autoregroup=false;
-			
-		dprintf(D_FULLDEBUG,"negotiationtime: slots %d group %s autoregroup %s\n",
-			numDynGroupSlots, tempentry.groupName.c_str(),(tempentry.autoregroup)?"true":"false");
-		//add the entry to the vector
-		groupArray.push_back(tempentry);	
+		tempentry=populategroup(groups, startdAds, scheddAds);
+		size_t delimeter=tempentry->groupName.find_first_of(".");
+		insert(  tempentry, grouptree, delimeter,groups, startdAds,scheddAds);	
 	
 	} //while ((groups = groupList.next ()))
 	// At this point all groups are in the group array and
 	// the group array has the number of submitters for each group at each level
 	// i will be the length of the group array	
-		
-	//groupArray[0] is top of the tree and is a group created so that we can put all users
-	//into some place in the tree
-	//leave the name null for now so it doesn't trip up the sort 
-	
-
-	// sort the list here
-	// leave non group users at end of array
-    // The sort() method constructs the tree topology, by assigning children to parents
-    // And then does a topological sort of nodes, so that (a) children always come
-    // after parents and (b) all peers (children of a particular parent) are contiguous.
-    // These properties are assumed by several of the tree processing loops that follow.
-    // Also worth noting that children of each parent are stored as linked list of indices,
-    // and the links are denoted as '.left' and '.right' members.  Not to be confused with
-    // 'left' and 'right' children in a traditional binary tree (HFS trees are not binary, but
-    // may have arbitrary numbers of children for any parent).
-	dprintf(D_FULLDEBUG,"negotiationtime:sorting\n");
-	sort(groupArray,groupArray.size());
+	dumptree(grouptree);	
+	dprintf(D_ALWAYS,"attaching submitters\n"); 
+	attachsubmitters(grouptree, grouptree, startdAds,scheddAds);
+
+	dumptree(grouptree);
+	dprintf(D_ALWAYS,"maxallowed\n");
+	maxAllowedcalc(grouptree);
 
+	dumptree(grouptree);
 	
-	for (i=0;i<groupArray.size();i++) {
-		dprintf(D_FULLDEBUG,"negotiationtime: finished sort - slots %d group %s auto %s quota %f maxAllowed %f numsubmits %d parent %d child %d  left %d right %d i %d\n",
-			numDynGroupSlots, groupArray[i].groupName.c_str(),(groupArray[i].autoregroup)?"true":"false", groupArray[i].quota, groupArray[i].maxAllowed,groupArray[i].numsubmits, 
-			groupArray[i].parent, groupArray[i].child, groupArray[i].left, groupArray[i].right ,i);
-     	}	
-
-	// pull out the submitter ads that specify a group from the
-	// scheddAds list, and insert them into a list specific to 
-	// the specified group.
-	ClassAd *ad = NULL;
-	string scheddName;
-	scheddAds.Open();
-	while( (ad=scheddAds.Next()) ) {
-		MyString temp;
-		string temp2, temp3;
-		if (!ad->LookupString(ATTR_NAME, temp)) {
-					continue;
-				}
-        // important to case-fold these so group names match 
-        temp.lower_case();
-		scheddName.assign(temp.Value());
-		// have to assume there is username attached to accounting group name in job submission
-		// go put 0 at last seperator
-		// chop off hostname
-		size_t pos= scheddName.find_last_of("@");
-		if ( pos==string::npos ) {
-			continue;
-		}
-
-		temp2=scheddName.substr(0,pos);
-		pos= temp2.find_last_of(".");
-		;	
-		if ( pos==string::npos ) {  //assuming here that the last delimited item is a username
-			continue;        //if the user leaves this off, the subitters will appear as groupless users
-		}                     //at the parent level
-;
-		temp3=temp2.substr(0,pos);
-		for (i=1; i<groupArray.size(); i++) {
-			if ( temp3.compare(groupArray[i].groupName)==0 ) {
-				groupArray[i].submitterAds.Insert(ad);
-				scheddAds.Delete(ad);
-				break;
-			}
-		}
-	}//while( (ad=scheddAds.Next()) )
-	
-	scheddAds.Open();
-		
-	// here we check for submitters that are not in a group at all or a group with no quota
-	int nongroupusers=scheddAds.Length();
-					
-	// if we have users not in a group, we attach them to groupArray[0]
-	// they get to negotiate for any slots not used by subgroups
-	//groupArray[0].autoregroup is always true
-	if (nongroupusers){
-		scheddAds.Open();
-		int numrunning=0;
-		int numidle=0;
-			
-		groupArray[0].numsubmits=0;
-		//int totalsubmits=0;
-		float schedusagetotal=0;
-		float scheddUsage=0;
-		while( (ad=scheddAds.Next()) ) {
-			ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
-			ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
-			groupArray[0].numsubmits=groupArray[0].numsubmits+numrunning+numidle;
-			MyString username;
-			if (ad->LookupString(ATTR_NAME, username) ){
-				//scheddName[79] = '\0'; // make certain we have a terminating NULL
-				scheddUsage = accountant.GetWeightedResourcesUsed(username);
-				schedusagetotal=scheddUsage+schedusagetotal;
-				groupArray[0].submitterAds.Insert(ad);
-				
-				scheddAds.Delete(ad);
-			}
-		}
-		//safe to change the name now. We need a valid name because negotiate uses groupname as a flag.
-		
-		groupArray[0].groupName.assign("none\0");	
-		groupArray[0].usage = schedusagetotal;
-		groupArray[0].prio = 100;		
-
-	} //if (nongroupusers)
-		
-		
-	
-	
-	
-	for ( i=0;i<groupArray.size();i++) {
-		dprintf(D_FULLDEBUG,"negotiationtime: finished inserting submitters - slots %d group %s quota %f maxAllowed %f numsubmits %d  i %d\n",
-		numDynGroupSlots, groupArray[i].groupName.c_str(), groupArray[i].quota, groupArray[i].maxAllowed,groupArray[i].numsubmits, i);
-     	}
-     
-	//now we need to convert the quota_fraction to an actual slot count
-	//which means walking down the tree
-    //Due to topological sort of nodes, this corresponds to breadth-first tree traversal.
-	for (unsigned pos=1;pos<groupArray.size();pos++){
-		if (groupArray[pos].staticquota){
-			if (groupArray[groupArray[pos].parent].maxAllowed<=0){
-				groupArray[pos].quota=0;
-				groupArray[pos].maxAllowed=0;
-			} else {
-				if (groupArray[groupArray[pos].parent].maxAllowed <groupArray[pos].quota) { //this would be a config error if true
-					groupArray[pos].maxAllowed =groupArray[groupArray[pos].parent].maxAllowed;
-					dprintf(D_ALWAYS,"negotiationtime: Error in config. Subgroup %s static quota larger than parent group %s. Setting quota to match parent. \n",
-						groupArray[pos].groupName.c_str(), groupArray[groupArray[pos].parent].groupName.c_str());	
-				}		
-				else groupArray[pos].maxAllowed=groupArray[pos].quota;
-				groupArray[pos].quota=(double)groupArray[pos].maxAllowed/(double)groupArray[groupArray[pos].parent].maxAllowed;
-			}
-		} else {
-			groupArray[pos].maxAllowed=(double)groupArray[pos].quota*(double)groupArray[groupArray[pos].parent].maxAllowed;	
-		}	
-		groupArray[pos].unused=0;
-	}//for (int pos=0;pos<groupArrayLen;pos++)
-	
-	//now we compute each non leaf node's quota for users not in a subgroup
-    // Due to topological sort of nodes, this corresonds to depth-first tree traversal.
-	for ( unsigned pos=groupArray.size()-1;pos>0;pos--){ 
-		float grouptotal=0; 		//the sum of the quota for all subgroups 
-		int currentparent=groupArray[pos].parent; 
-		while (currentparent==groupArray[pos].parent){		
-			grouptotal=groupArray[pos].quota+grouptotal; 
-			pos--;
-		} 
-		pos++;			
-     		groupArray[groupArray[pos].parent].nodequota=1.0-(double)grouptotal; // users get the remaining quota
-			
-	 	if (groupArray[groupArray[pos].parent].nodequota<0)
-			groupArray[groupArray[pos].parent].nodequota=0; //check for negative
-			
-		groupArray[groupArray[pos].parent].nodemaxAllowed=
-			(double)groupArray[groupArray[pos].parent].nodequota*(double)groupArray[groupArray[pos].parent].maxAllowed;	 	
-	}
-	
-	
-	for (i=0;i<groupArray.size();i++) {
-		dprintf(D_FULLDEBUG,"negotiationtime: finished maxallowed calc -  slots %d group %s quota %f nodequota %f maxAllowed %f nodemaxAllowed %f numsubmits %d  i %d\n",
-			numDynGroupSlots, groupArray[i].groupName.c_str(), groupArray[i].quota, groupArray[i].nodequota,
-			groupArray[i].maxAllowed,groupArray[i].nodemaxAllowed,groupArray[i].numsubmits,i);
-     	}
-	
-	//now we know number of submitters and max number of slots allowed at each group level
-
 	// top of fairshare negotiation loop
 	// We need to redistribute slots that end up as rejected during negotiation
 	
 	
-	int  loophalt=0; 
-	bool extraslots=true;	
-	while (extraslots==true&&loophalt<5){	
-		extraslots=false;	
+	//int  loophalt=0; 
+	//bool extraslots=true;	
+	//while (extraslots==true&&loophalt<5){	
+	//	extraslots=false;	
 		
 	// now need to fix up quotas for groups
 	// every group should have a quota description
@@ -1363,183 +1092,34 @@ negotiationTime ()
 		
 	// Array should be sorted tree
 	// We start at the very end of the array which should be greatest depth
-        // Due to topological sort of nodes, this corresonds to depth-first tree traversal.
-	for (i=groupArray.size()-1; i>=1; i--) {
-		int currentparent=groupArray[i].parent;
-		float unused=0;
-		float parentunused=0;
-		unsigned j;	
-		
-		groupArray[currentparent].unused=0;
-			
-		// we iterate backwards until the parent changes
-		// this gets us the number of unused slots in our peer groups
-		//and total number of submitters in our peer groups
-		for (j=i; j>=1 && currentparent==groupArray[j].parent; j--) {
-			if (groupArray[j].child==-1) { //leaf
-				unused=groupArray[j].maxAllowed-groupArray[j].numsubmits;	  
-			if (unused>0){
-				groupArray[j].unused=unused;
-				groupArray[j].maxAllowed=groupArray[j].numsubmits;
-			} else {
-				if  (unused==groupArray[j].maxAllowed)groupArray[j].maxAllowed=0; //no submitters
-				groupArray[j].unused=0;
-				unused=0;
-			}
-			groupArray[groupArray[j].parent].unused=groupArray[groupArray[j].parent].unused+unused;
-			} else { //not a leaf
-				if (groupArray[j].unused>0) 
-					groupArray[groupArray[j].parent].unused=groupArray[groupArray[j].parent].unused+groupArray[j].unused;
-			}
-		}
-		i=j+1;
-		
-		if (groupArray[groupArray[i].parent].nodemaxAllowed>0){ 
-			parentunused=groupArray[groupArray[i].parent].nodemaxAllowed-groupArray[groupArray[i].parent].numsubmits;
-			if (parentunused>0)
-				groupArray[groupArray[i].parent].unused=groupArray[groupArray[i].parent].unused+parentunused;		
-		}
-		if (groupArray[currentparent].autoregroup==true)				
-			groupArray[currentparent].unused=fairshare(groupArray,currentparent,groupArray[currentparent].unused);
-		else {
-			groupArray[currentparent].autoregroup=true;
-			groupArray[currentparent].unused=fairshare(groupArray,currentparent,groupArray[currentparent].unused);
-			groupArray[currentparent].autoregroup=false;
-		
-		}
-		dprintf(D_FULLDEBUG,"negotiationtime: after fairshare setting parent unused ->group %s auto %s quota %f maxallowed %f  unused %f\n",
-			groupArray[currentparent].groupName.c_str(), (groupArray[currentparent].autoregroup)?"true":"false", groupArray[currentparent].quota, 
-		 	groupArray[currentparent].maxAllowed, groupArray[currentparent].unused);			
-	} //for
+	dprintf(D_ALWAYS,"fairshare\n");
+	double unusedbyhfs=fairshare(grouptree);
 	
-	dprintf(D_FULLDEBUG,"negotiationtime: finished fairshare unable to use %f slots\n",groupArray[0].unused);
-
-	for (i=0;i<groupArray.size();i++) {
-		dprintf(D_FULLDEBUG,"negotiationtime: finished fairshare - slots %d group %s auto %s quota %f maxAllowed %f nodemaxAllowed %f numsubmits %d i %d\n",
-			numDynGroupSlots, groupArray[i].groupName.c_str(),(groupArray[i].autoregroup)?"true":"false",groupArray[i].quota, groupArray[i].maxAllowed, groupArray[i].nodemaxAllowed, groupArray[i].numsubmits, 
-			 i);
-     	}
-	for (i=0;i<groupArray.size();i++) groupArray[i].unused=0;
-	
-    // Due to topological sort of nodes, this corresonds to breadth-first tree traversal.
-    // here a non-zero '.unused' also doubles as 'not-yet-visted' flag
-	for (i=0;i<groupArray.size();i++) {	
-		float unused=0;	
-		
-		if (groupArray[i].child!=-1&&groupArray[i].numsubmits>0&&groupArray[i].nodemaxAllowed>0){
-			if (groupArray[i].unused>0){
-				float nodeshare=groupArray[i].nodequota*groupArray[i].unused;
-				groupArray[i].nodemaxAllowed=groupArray[i].nodemaxAllowed+nodeshare;
-				groupArray[i].unused=groupArray[i].unused-nodeshare; 
-			}
-		
-			unused=groupArray[i].nodemaxAllowed-floorf(groupArray[i].nodemaxAllowed)+groupArray[i].unused;			
-			groupArray[i].nodemaxAllowed=floorf(groupArray[i].nodemaxAllowed);
-			//hand out unused to our children
-			int currentchild=groupArray[i].child;
-			float childshare=0;
-
-		  	//now we iterate across children handing out pie
-			while (currentchild!=-1){ 
-				childshare=unused*groupArray[currentchild].quota; 
- 				groupArray[currentchild].unused=childshare;
-				currentchild=groupArray[currentchild].left;
-			}				
-			groupArray[i].unused=0;				
-													
-		} else if (groupArray[i].child!=-1)  {
-			int currentchild=groupArray[i].child;
-			float childshare=0;
-		  	//now we iterate across children handing out pie
-			while (currentchild!=-1){ 
-				childshare=groupArray[i].unused*groupArray[currentchild].quota; 
- 				groupArray[currentchild].unused=childshare;
-				currentchild=groupArray[currentchild].left;
-			}
-			groupArray[i].unused=0;
-		
-		} 
-
-	}
+	dprintf(D_FULLDEBUG,"negotiationtime: finished fairshare unable to use %f slots %f\n",grouptree.unused,unusedbyhfs);
+	resetunused(grouptree);
+	dumptree(grouptree);
 	
+	dprintf(D_ALWAYS,"roundoff1\n");
+	double stage1roundoff= roundoffstage1(grouptree);
 	
-	for (i=0;i<groupArray.size();i++) {
-		dprintf(D_FULLDEBUG,"negotiationtime: mid roundoff - slots %d group %s auto %s quota %f maxAllowed %f nodemaxAllowed %f unused %f numsubmits %d i %d\n",
-			numDynGroupSlots, groupArray[i].groupName.c_str(),(groupArray[i].autoregroup)?"true":"false",groupArray[i].quota, groupArray[i].maxAllowed,
-			groupArray[i].nodemaxAllowed, groupArray[i].unused,  groupArray[i].numsubmits, 
-			 i);
-     	}
+
+	dumptree(grouptree);
+
 	//at this point we focus on leaves
 	//roundoff that needs to be fixed is within maxAllowed
-	// Due to topological sort of nodes, this corresonds to depth-first tree traversal.
-	float totalroundoff=0;
-	for (i=groupArray.size()-1; i>=1; i--) {
-		int currentparent=groupArray[i].parent;
-		float roundoff;
-		unsigned j;	
-		//this gathers all partial slots for this family of groups
-		for (j=i; j>=1 && currentparent==groupArray[j].parent; j--) {			
-			if (groupArray[j].child==-1) { //leaf
-				if (groupArray[j].maxAllowed==0){
-					totalroundoff=totalroundoff+groupArray[j].unused;
-				
-				} else {
-					groupArray[j].maxAllowed=groupArray[j].maxAllowed+groupArray[j].unused;
-					roundoff =groupArray[j].maxAllowed-floor(groupArray[j].maxAllowed);
-					groupArray[j].maxAllowed=floor(groupArray[j].maxAllowed);
-					totalroundoff=totalroundoff+roundoff;
-				}
-	  
-			}
-		}
-		//This distributes round robin the slots as integers
-		//if we end up with a fraction of a slot, that partial slot is handed to the next family
-		//we want to ensure that all slots get used
-		//its possible that they all will and we will still have a fraction of a slot left over
-		//this is simply due to roundoff errors compounded 
-		int endofgroup=j+1;
-		bool gavesome=true;
-		while (gavesome&&totalroundoff>=1){
-		gavesome=false;
-		for (j=i; j>=1 &&totalroundoff>=1&& currentparent==groupArray[j].parent; j--) {
-			if (groupArray[j].child==-1&&groupArray[j].maxAllowed>0) { //leaf
-				groupArray[j].maxAllowed=groupArray[j].maxAllowed+1;
-				totalroundoff=totalroundoff-1;
-				gavesome=true;
-			}
-		}
-		}
-		i=endofgroup;
-	//get to this point and totalroundoff is handed to next family
-	}
-	
-	dprintf(D_ALWAYS,"negotiationtime: finished roundoff - unable to use %f\n",totalroundoff);
-	
-	if (totalroundoff>0) { //off by one slot due to roundoff
-		bool gaveroundoff=true;
-		while (totalroundoff>0&&gaveroundoff){
-		gaveroundoff=false;
-		for (i=0;i<groupArray.size()&&totalroundoff>0; i++){
-			 if (groupArray[i].nodemaxAllowed>0&&groupArray[i].numsubmits>0){
-		 		groupArray[i].nodemaxAllowed=groupArray[i].nodemaxAllowed+1;
-				totalroundoff--;
-				gaveroundoff=true;
-			} else if (groupArray[i].maxAllowed>0&&groupArray[i].child==-1&&groupArray[i].autoregroup==true) { 
-				groupArray[i].maxAllowed=groupArray[i].maxAllowed+1; 
-				totalroundoff--; 
-				gaveroundoff=true;
-			}
-		}
-		}
+	dprintf(D_ALWAYS,"roundoff2 %f\n", stage1roundoff);
+	double totalroundoff=0;
+	totalroundoff=roundoffstage2(grouptree,stage1roundoff);
 	
-	}
+	while (totalroundoff>=1) totalroundoff=roundoffstage2(grouptree,totalroundoff);
+ 	
+	
+	dprintf(D_ALWAYS,"negotiationtime: finished roundoff - unable to use %f\n",totalroundoff); 
 
+
+	dumptree(grouptree);
 	
-	for (i=0;i<groupArray.size();i++) {
-		dprintf(D_FULLDEBUG,"negotiationtime: finished roundoff - slots %d group %s auto %s quota %f maxAllowed %f nodemaxAllowed %f numsubmits %d i %d\n",
-			numDynGroupSlots, groupArray[i].groupName.c_str(),(groupArray[i].autoregroup)?"true":"false",groupArray[i].quota, groupArray[i].maxAllowed, groupArray[i].nodemaxAllowed, groupArray[i].numsubmits, 
-			 i);
-     	}
+/*
 		for (i=0;i<groupArray.size();i++) groupArray[i].unused=0;
 		double totalextraslots =0;
 		// negotiate for each group
@@ -1623,6 +1203,10 @@ negotiationTime ()
 			groupArray[i].submitterAds.Delete( tmp );
      		}
 	}
+*/		
+		negotiatetree( grouptree,untrimmed_num_startds,untrimmedSlotWeightTotal, minSlotWeight, 
+			startdAds, claimIds,scheddAds);
+	
 	} // if (groups)
 	else {
 		// negotiate w/ all users who do not belong to a group.
@@ -1648,50 +1232,628 @@ negotiationTime ()
 }
 
 
+void Matchmaker::dumptree (SimpleGroupEntry & node){
+ 
+ if (node.parent==NULL)
+ 	dprintf(D_ALWAYS," DumpTree Group node %s quota %f maxAllowed %f numsubmits %d unused %f\n",
+			 node.groupName.c_str(),  node.quota,
+			node.maxAllowed,node.numsubmits, node.unused);
+ else 
+	dprintf(D_ALWAYS," DumpTree Group node %s parent %s quota %f maxAllowed %f numsubmits %d unused %f\n",
+			 node.groupName.c_str(), node.parent->groupName.c_str(), node.quota,
+			node.maxAllowed,node.numsubmits, node.unused);
+	if ( node.children.size()==0) return;
+	for (unsigned int x=0;x<node.children.size();x++) dumptree(*node.children[x]);
+ 
+}
+
+void Matchmaker::resetunused (SimpleGroupEntry & node){
+	node.unused=0;
+	if ( node.children.size()==0) return;
+	for (unsigned int x=0;x<node.children.size();x++) resetunused(*node.children[x]);
+	
+}
+
+void Matchmaker::negotiatetree (SimpleGroupEntry & node, int untrimmed_num_startds,
+					 double untrimmedSlotWeightTotal,
+					 double minSlotWeight,
+					 ClassAdList& startdAds,
+					 ClaimIdHash& claimIds, 
+					 ClassAdList& scheddAds){
+
+if ( node.children.size()==0){
+	if ( node.submitterAds.MyLength() == 0 ) {
+				dprintf(D_ALWAYS,"Group %s - skipping, no submitters\n",node.groupName.c_str());
+				return;
+	}
+
+	dprintf(D_ALWAYS,
+		"Group %s - negotiating\n",node.groupName.c_str());
+	negotiateWithGroup( untrimmed_num_startds,untrimmedSlotWeightTotal, minSlotWeight, 
+					startdAds, claimIds, node.submitterAds, 
+						node.maxAllowed, node.usage, node.groupName.c_str() );
+	return;
+}			
+			
+			
+for (int x=0;x<node.children.size();x++) negotiatetree(*node.children[x],untrimmed_num_startds,untrimmedSlotWeightTotal, minSlotWeight, 
+					startdAds, claimIds,scheddAds);		
+
+}
+
+
+void Matchmaker::maxAllowedcalc (SimpleGroupEntry & node) {
+
+if (node.parent!=NULL ){
+if (node.staticquota){
+	if (node.parent->maxAllowed<=0){
+	
+		node.quota=0;
+		node.maxAllowed=0;
+	} else {
+		if (node.parent->maxAllowed <node.quota) { //this would be a config error if true
+			node.maxAllowed =node.parent->maxAllowed;
+			dprintf(D_ALWAYS,"negotiationtime: Error in config. Subgroup %s static quota larger than parent group %s. Setting quota to match parent. \n",
+						node.groupName.c_str(), node.parent->groupName.c_str());	
+		} else {
+		node.maxAllowed=node.quota;
+		 
+		}	
+	node.quota=node.maxAllowed/node.parent->maxAllowed;
+	}
+} else {
+
+	node.maxAllowed=node.quota*node.parent->maxAllowed;	
+}
+
+
+}
+
+			
+if (node.children.size()==0) return;
+
+
+for (unsigned int x=0;x<node.children.size();x++) maxAllowedcalc(*node.children[x]);
+}
 
-float Matchmaker::fairshare( std::vector<SimpleGroupEntry> &groupArray, int index, float unused)
-{
-	int child=groupArray[index].child;
 
-    dprintf(D_FULLDEBUG,"fairshare called on  %s auto %s index %d maxallowed %f numsubmits %d group unused %f called with unused %f \n",
-    		groupArray[index].groupName.c_str(),(groupArray[index].autoregroup)?"true":"false", index, groupArray[index].maxAllowed, 
-    		groupArray[index].numsubmits,groupArray[index].unused,unused);
 
-	if (groupArray[index].autoregroup) { //if we have unused, we can't use them
-		if (child==-1) { //we are leaf and see if we can use the unused
-  			float canonlyuse=(float)groupArray[index].numsubmits-groupArray[index].maxAllowed;
+double  Matchmaker::roundoffstage1(SimpleGroupEntry & node){
+//this pushes all the roundoff and accumulated error
+// down into leaves
+// 
+	double roundoff=0;
+	double unused=0;
+	if (node.children.size()==0) {
+		dprintf(D_ALWAYS, "leaf node %s - unused %f maxallowed %f\n", 
+				node.groupName.c_str(),node.unused,node.maxAllowed);
+		node.maxAllowed=node.maxAllowed+node.unused;
+		node.unused=0;
+		if ((void*)&node==(void*)node.parent->children.back()){
+			int y=0;
+			dprintf(D_ALWAYS, "-leaf node %s - unused %f maxallowed %f roundoff %f\n", 
+				node.groupName.c_str(),node.unused,node.maxAllowed, roundoff);
+			for (unsigned int x=0;x<node.parent->children.size();x++){
+
+				
+				
+				roundoff=node.parent->children[x]->maxAllowed-floor(node.parent->children[x]->maxAllowed)+roundoff;
+				
+				dprintf(D_ALWAYS, "--leaf node %s - unused %f maxallowed %f roundoff %f\n", 
+				node.parent->children[x]->groupName.c_str(),node.parent->children[x]->unused,
+				node.parent->children[x]->maxAllowed, roundoff);
+				
+				
+				node.parent->children[x]->maxAllowed=floor(node.parent->children[x]->maxAllowed);
+				
+				
+				if (roundoff>1){
+					node.parent->children[y]->maxAllowed=node.parent->children[y]->maxAllowed+1;
+					roundoff=roundoff-1;
+					y++;
+				dprintf(D_ALWAYS, "----leaf node gave to %s - unused %f maxallowed %f roundoff %f\n", 
+				node.parent->children[y]->groupName.c_str(),node.parent->children[y]->unused,
+				node.parent->children[y]->maxAllowed, roundoff);
+				
+				}
+			}
+				
+		
+		}
+		
+		dprintf(D_ALWAYS, "leaf node ret %s - roundoff %f\n", 
+				node.groupName.c_str(), roundoff);
+		return roundoff;
+	}
+	
+
+			double childshare=0;
+			unused=node.unused;
+			bool child=false;
+			bool internal=false;
+			
+			// this is workaround for comparisions of double against zero  ( node.unused >0)
+			// that causes an infinite loop. 
+			// 	
+			while (node.unused > (double)0.000001){ 
+			double totalused=0;
+
+			for (unsigned int x=0;unused>0&&node.unused>0&&x<node.children.size();x++){
+				if (node.children[x]->children.size()==0) child=true;
+				if (node.children[x]->children.size()>0) internal=true;
+				if (unused<0.05) childshare=unused;	
+				else childshare=node.unused*node.children[x]->quota;
+				dprintf(D_ALWAYS, "--- dishing out to node %s - node.unused %f child.unused %f unused %f  maxallowed %f childshare %f\n", 
+			  node.children[x]->groupName.c_str(),node.unused, node.children[x]->unused,unused,node.children[x]->maxAllowed, childshare);				 
+ 				node.children[x]->unused=node.children[x]->unused+childshare;
+				unused=unused-childshare;
+				totalused=totalused+childshare;
+				dprintf(D_ALWAYS, "--- dished out to node %s - node.unused %f child.unused %f unused %f  maxallowed %f childshare %f\n", 
+				  node.children[x]->groupName.c_str(),node.unused, node.children[x]->unused,unused,node.children[x]->maxAllowed, childshare);				 
  
-  			dprintf(D_FULLDEBUG,"fairshare leaf %s maxallowed %f numsubmits %d unused %f canonlyuse %f\n",
-                    groupArray[index].groupName.c_str(), groupArray[index].maxAllowed, groupArray[index].numsubmits,unused,canonlyuse);
-            if (canonlyuse>0) {
-     			if (unused>=canonlyuse){
-                    groupArray[index].maxAllowed=groupArray[index].maxAllowed+canonlyuse;	
-                    return unused-canonlyuse;
-                } else {//we can use more but are only offered unused amount return 0 because we took them all
-                    groupArray[index].maxAllowed=groupArray[index].maxAllowed+unused; 
-                    return 0;
+					
+			}
+			
+			node.unused=node.unused-totalused;
+			dprintf(D_ALWAYS, "-----%s node.unused %lf unused %lf totalused %lf\n",node.groupName.c_str(), node.unused, unused, totalused);
 
-                }
+			}
+			
+		
+			node.unused=0;
+			
+			//unusual case where the node has leaf nodes and internal nodes
+			//strip off leaf node fractions
+			if (child&&internal){
+				double introundoff=0;
+				
+				for (unsigned int x=0;x<node.children.size();x++){
+					if (node.children[x]->children.size()==0){
+						introundoff=introundoff+node.children[x]->unused-floor(node.children[x]->unused);
+						node.children[x]->unused=floor(node.children[x]->unused);
+					}
+					
+			
+				}
+				
+				dprintf(D_ALWAYS, "--- introundoff node %s - introundoff %f\n", 
+				  node.groupName.c_str(),introundoff);				 
+				//hand off whole slots to leaf nodes
+				for (unsigned int x=0;(introundoff>1)&&x<node.children.size();x++){
+						if (node.children[x]->children.size()==0){
+							node.children[x]->unused=node.children[x]->unused+1;					
+							introundoff=introundoff-1;
+							dprintf(D_ALWAYS, "--- dished whole slot\n");
+						}
+					
+			
+				}
+				double unusedroundoff=introundoff;
+				dprintf(D_ALWAYS, "--- trying dishing roundoff\n");
+				
+				while (unusedroundoff > (double)0.000001){
+					double totalused=0;
+					double childshare;
+					dprintf(D_ALWAYS, "--- dishing roundoff\n"); 
+					for (unsigned int x=0;introundoff>0&&unusedroundoff>0&&x<node.children.size();x++){
+						if (node.children[x]->children.size()>0){
+							if (unusedroundoff<0.05) childshare=unusedroundoff;	
+							else childshare=introundoff*node.children[x]->quota;
+							node.children[x]->unused=node.children[x]->unused+childshare;
+							unusedroundoff=unusedroundoff-childshare;
+							totalused=totalused+childshare;
+							dprintf(D_ALWAYS, "--- dished roundoff out to node %s - child.unused %f unused %f  maxallowed %f childshare %f introundoff %f unusedroundoff %f\n", 
+				  node.children[x]->groupName.c_str(), node.children[x]->unused,unused,node.children[x]->maxAllowed, childshare,introundoff, unusedroundoff);				 
+ 
+					
+						}
+
+
+					}
+					introundoff=introundoff-totalused;
+			
+				}
+				
+				
+				
+				
+			} 
+		
+		
+ 	for (unsigned int x=0;x<node.children.size();x++) roundoff=roundoffstage1(*node.children[x])+roundoff;
+ 	dprintf(D_ALWAYS, "int node ret %s - roundoff %lf\n", 
+				node.groupName.c_str(), roundoff);
+ 	return roundoff;
+}
+
+
+
+/* roundoffstage2 allocates whole slots in round robin fashion
+ * It walks the tree and hands out a slot to groups that can use the
+ * slot. It doesn't test autoregroup, the logic being that any 
+ * group could be a 'victim' of roundoff error 
+ */
+double   Matchmaker::roundoffstage2(SimpleGroupEntry & node, double treeroundoff){
+	double totalroundoff=treeroundoff;
+
+	if (node.children.size()==0){
+		if ( node.numsubmits>node.maxAllowed) {
+			node.maxAllowed=node.maxAllowed+1;
+			return treeroundoff-1;
+		} else return treeroundoff;
+
+	}
+	for (unsigned int x=0;totalroundoff>=1&&x<node.children.size();x++){
+          	totalroundoff= roundoffstage2(*node.children[x], totalroundoff);
+	 }
+
+ return totalroundoff;
+}
+
+
+/* insert
+ * inserts a node int the tree. If a node's aprent doesn't exist, the parent is created
+ */ 
+void Matchmaker::insert ( SimpleGroupEntry *tempentry, SimpleGroupEntry & node , size_t delimeter, string namestring, ClassAdList& startdAds, ClassAdList& scheddAds ){
+
+	string parent, group;
+	SimpleGroupEntry * newentry;
+	//SimpleGroupEntry * temp;
+	size_t delim2;
+	size_t delim=tempentry->groupName.find_first_of(".");
+		
+	if (delimeter==string::npos||delim==string::npos){ //i don't have a parent and so I just insert myself at the current level
+		tempentry->parent=&node;
+		tempentry->name=tempentry->groupName;
+		dprintf(D_ALWAYS, "attaching self to node : group %s node %s namestring %s\n",
+					tempentry->groupName.c_str(), node.groupName.c_str(), namestring.c_str());
+		node.children.push_back(tempentry);
+		return;
+
+	} else { 
+		parent=tempentry->groupName.substr(0,delimeter);
+		for (unsigned int x=0; x <node.children.size();x++){
+		
+			dprintf(D_ALWAYS, "insert comparing: group -%s- node -%s- namestring -%s- parent -%s- children[x] -%s- quota %f\n",
+					tempentry->groupName.c_str(), node.groupName.c_str(), namestring.c_str(),parent.c_str(),node.children[x]->name.c_str(), node.children[x]->quota );
+			if ( node.children[x]->name==parent) { // found our parent
+				delim2=tempentry->groupName.find_first_of(".", delimeter+1);
+				insert (tempentry, *node.children[x], delim2, parent, startdAds, scheddAds);					
+				return;
+			}
+		}
+	}
+
+
+	dprintf(D_ALWAYS, "insert parent not found : group %s node %s namestring %s\n",
+					tempentry->groupName.c_str(), node.groupName.c_str(), namestring.c_str());
+	// parent not found
+	// create and insert parent
+	
+	newentry=populategroup(parent, startdAds, scheddAds);
+	newentry->name=parent;		
+	newentry->parent=&node;		
+	delim2=namestring.find_first_of(".", delimeter+1);
+	node.children.push_back(newentry);
+	dprintf(D_ALWAYS, "insert another parent to insert: group %s node %s namestring %s parent %s\n",
+					tempentry->groupName.c_str(), node.groupName.c_str(), namestring.c_str(),parent.c_str());
+	insert (tempentry, *node.children.back(), delim2, parent, startdAds, scheddAds);
+}
+
+/* attachsubmitters attaches submitter ads to the groups in the tree
+ * This stage could be eliminated and done in populategroup if a different 
+ * copy constructor could be used. See the note in populategroup.
+ */
+void Matchmaker::attachsubmitters (SimpleGroupEntry & node, SimpleGroupEntry & tree, ClassAdList& startdAds, ClassAdList& scheddAds){
+	int numrunning=0;
+	int numidle=0;
+	ClassAd *ad = NULL;
+	string  scheddName;
+	scheddAds.Open();
+	size_t pos;
+
+	if ( node.children.size()!=0){
+		double quota=0;
+		for (unsigned int x=0 ; x<node.children.size();x++) quota+=node.children[x]->quota;
+		SimpleGroupEntry * newentry= new SimpleGroupEntry;
+		newentry->quota=1-quota;
+		newentry->parent=&node;
+		newentry->groupName=node.groupName;
+		newentry->name=node.name;
+		newentry->usage=node.usage;
+		newentry->autoregroup=node.autoregroup;
+		newentry->prio=node.prio;
+		newentry->unused=0;
+		newentry->numsubmits=0;
+		newentry->staticquota=node.staticquota;
+		newentry->maxAllowed=0;
+		dprintf(D_ALWAYS, "attaching group %s to node %s parent %s \n",
+					newentry->groupName.c_str(), node.groupName.c_str(), newentry->parent->groupName.c_str());
+		node.children.push_back(newentry);
+		
+		for (unsigned int x=0;x<node.children.size();x++) attachsubmitters(*node.children[x],tree,startdAds, scheddAds);
+	} else {
+	
+	
+	while( (ad=scheddAds.Next()) ) {
+		MyString temp;
+		string temp2,temp3;
+		if (!ad->LookupString(ATTR_NAME, temp)) {
+					scheddAds.Delete(ad);
+					continue;
+				}
+		scheddName.assign(temp.Value());
+		// is there a username seperator?
+		pos= scheddName.find_last_of("@");
+		//look for last group seperator
+		//this should separate group from user
+		
+		if ( pos==string::npos) {
+
+			SimpleGroupEntry * nongroupusers=tree.children.back();
+			numidle=0;
+			numrunning=0;
+			ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
+			ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
+            		nongroupusers->numsubmits=nongroupusers->numsubmits+numrunning+numidle;
+			nongroupusers->submitterAds.Insert(ad);
+			nongroupusers->usage=nongroupusers->usage+accountant.GetWeightedResourcesUsed(temp);
+			scheddAds.Delete(ad);
+			continue;
+				};
+		temp2=scheddName.substr(0,pos);
+		pos= temp2.find_last_of(".");
+		
+		// is there a group/user seperator? 
+		if ( pos==string::npos) { 
+
+			SimpleGroupEntry * nongroupusers=tree.children.back();
+			numidle=0;
+			numrunning=0;
+			ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
+			ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
+			nongroupusers->numsubmits=nongroupusers->numsubmits+numrunning+numidle;
+			nongroupusers->submitterAds.Insert(ad);
+			nongroupusers->usage=nongroupusers->usage+accountant.GetWeightedResourcesUsed(temp);
+			scheddAds.Delete(ad);
+					//assuming here that the last delimited item is a username
+			continue;        //if the user leaves this off, the subitters will appear as users
+			}                //at the parent level
+
+		temp3=temp2.substr(0,pos);
+		
+		if ( temp3.compare(node.groupName)==0 ) {
+			numidle=0;
+			numrunning=0;
+			ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
+			ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
+            		node.numsubmits=node.numsubmits+numrunning+numidle;
+			node.submitterAds.Insert(ad);
+			scheddAds.Delete(ad);					 
+			}
+           			
+	}
+	
+	}
+
+}
+
+/* populategroup populates the node with group information
+ *
+ */
+Matchmaker::SimpleGroupEntry * Matchmaker::populategroup (string group, ClassAdList& startdAds, ClassAdList& scheddAds){
+	SimpleGroupEntry * tempentry= new SimpleGroupEntry;	
+	MyString tmpstr;
+	
+	tmpstr.sprintf("GROUP_QUOTA_%s",group.c_str());
+	double quota_fraction = param_double(tmpstr.Value(), -1.0 );
+	
+	if ( quota_fraction >= 0.0 ) {
+                	// Static groups quotas take priority over any dynamic quota
+                	dprintf(D_FULLDEBUG, "group %s static quota = %.3f\n", group.c_str(), quota_fraction);
+			tempentry->staticquota=true;			
+		} else {
+                	// Next look for a floating point dynamic quota.
+                	tmpstr.sprintf("GROUP_QUOTA_DYNAMIC_%s", group.c_str());
+                	quota_fraction =
+                    		param_double(
+                        		tmpstr.Value(),     // name
+                        		0.0,                // default value
+                        		0.0,                // min value
+                        		1.0                 // max value
+                    			);
+                	if (quota_fraction != 0.0) {
+                    		// use specified dynamic quota
+                    		//quota = rint(quota_fraction * numDynGroupSlots);
+                    		dprintf(D_FULLDEBUG, "group %s dynamic quota = %.3f\n",
+                            		group.c_str(),  quota_fraction);
+                	} else {
+                    		// neither a static nor dynamic quota was defined
+                    		dprintf(D_ALWAYS, "ERROR - no quota specified for group %s - ignoring\n",
+                        		group.c_str());
+                    		
+                 	}
+			tempentry->staticquota=false;
+            	}
+
+		tempentry->usage= accountant.GetWeightedResourcesUsed(group.c_str());
+
+		tempentry->groupName=group;
+		tempentry->maxAllowed = 0;  
+		tempentry->quota = quota_fraction;  
+
+		tempentry->parent = NULL;
+		tempentry->unused = 0;
+		tempentry->numsubmits=0;
+		tempentry->autoregroup = false;
+		
+		tempentry->prio = ( 100 * tempentry->usage ) / quota_fraction;
+		dprintf(D_ALWAYS,"Group Table : group %s quota %.3f usage %.3f prio %2.2f\n",
+					group.c_str(),quota_fraction,tempentry->usage,tempentry->prio);
+					
+			/* It would be nice to do this up front
+			 * however, the stl req for having a const for the copy constructor and operator =
+			 * doesn't fly with the classAd list attached to the node
+			 * 	
+					//now count total number of group submitters  and fix up quota
+                	int numrunning=0;
+			int numidle=0;
+			ClassAd *ad = NULL;
+			//char scheddName[80];
+			string  scheddName;
+			scheddAds.Open();
+			size_t pos;
+			while( (ad=scheddAds.Next()) ) {
+				MyString temp;
+				string temp2,temp3;
+				if (!ad->LookupString(ATTR_NAME, temp)) {
+					continue;
+				}
+				scheddName.assign(temp.Value());
+				// is there a username seperator?
+				pos= scheddName.find_last_of("@");
+				//look for last group seperator
+				//this should separate group from user
+				if ( pos==string::npos) {
+					continue;
+				};
+				temp2=scheddName.substr(0,pos);
+				pos= temp2.find_last_of(".");
+				// is there a group/user seperator? 
+				if ( pos==string::npos) { //assuming here that the last delimited item is a username
+					continue;        //if the user leaves this off, the subitters will appear as users
+					}                //at the parent level
+
+				temp3=temp2.substr(0,pos);
+				if ( temp3.compare(group)==0 ) { 
+					numidle=0;
+					numrunning=0;
+					ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
+					ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
+            				tempentry.numsubmits=tempentry.numsubmits+numrunning+numidle;
+					tempentry.submitterAds.Insert(ad);
+					scheddAds.Delete(ad);					 
+					}
+           			
+			}
+		*/	
+	bool default_autoregroup = param_boolean("GROUP_AUTOREGROUP",false);
+	MyString autoregroup_param;
+	autoregroup_param.sprintf("GROUP_AUTOREGROUP_%s",tempentry->groupName.c_str());	
+	if(param_boolean(autoregroup_param.Value(),default_autoregroup))
+		tempentry->autoregroup=true;
+	else 
+		tempentry->autoregroup=false;
+			
+	dprintf(D_FULLDEBUG,"negotiationtime: group %s autoregroup %s\n",
+			tempentry->groupName.c_str(),(tempentry->autoregroup)?"true":"false");
+					
+	return tempentry;
+}
+
+
+
+/* fairshare 
+ * in fairshare a a node's unused quota is determined by the unused quota of it's children
+ * combined with the unused quota of the node itself. It then calls redistribute on itself
+ * with this value of unused quota. Redistribute attempts to distribute the quota across the node's
+ * children. Some of the children could have had extra quota while some could use extra quota.
+ * fairshare combined with redistribute "bubbles up" unused quota from the bottom of the tree
+ * and ensures that HFS is applied at all levels of the tree.
+ */ 
+double Matchmaker::fairshare (SimpleGroupEntry & node) {
+
+	double unused=0;
+	
+
+	if (node.children.size()==0) {//a leaf node
+		unused=node.maxAllowed-node.numsubmits;
+		if (unused <=0) {		
+			node.unused=0;	
+			return 0; //we have enough submitters to use all quota
+		}	
+	
+	node.unused=unused;
+	node.maxAllowed=node.numsubmits; //maxAllowed greater than number of submitters
+
+	return unused;
+	
+	} else { //not a leaf
+		// get all unused from children
+ 		for (unsigned int x=0;x<node.children.size();x++){
+ 			unused=fairshare(*node.children[x])+unused;
+		}
+		if (unused>0) 
+			node.unused=node.unused+unused;
+
+		if (node.unused>0){
+			if (node.autoregroup==true)				
+				node.unused=redistribute(node,node.unused);
+			else {
+				node.autoregroup=true;  //
+				node.unused=redistribute(node,node.unused);
+				node.autoregroup=false;
+		
+			}
+		}
+	return node.unused;		
+	}
+
+}
+
+
+
+/* redistribute
+ * the function of HFS that distributes unused quota to a node's children
+ * unused is number of slots it would like to distribute to the node
+ * it returns the number of slots that were not used. These can be used elsewhere in the tree
+ * The function returns unused if autoregroup is false which it needed if it drills down into a tree. 
+ * but because of this, autoregroup needs to be toggled in fairshare when calling on a node that has autoregroup children
+ * and is not itself autoregroup
+ */
+double Matchmaker::redistribute( SimpleGroupEntry & node, double unused)
+{
+	
+    	dprintf(D_FULLDEBUG,"redistribute called on  %s auto %s maxallowed %f numsubmits %d group unused %f called with unused %f \n",
+    		node.groupName.c_str(),(node.autoregroup)?"true":"false",  node.maxAllowed, 
+    		node.numsubmits,node.unused,unused);
+		
+	if (node.autoregroup==false) return unused;
+
+	if (node.children.size()==0) { //we are leaf and see if we can use the unused
+  		double canonlyuse=node.numsubmits-node.maxAllowed;
+ 
+  		dprintf(D_FULLDEBUG,"redistribute leaf %s maxallowed %f numsubmits %d unused %f canonlyuse %f\n",
+   				node.groupName.c_str(), node.maxAllowed, node.numsubmits,unused,canonlyuse);
+   		if (canonlyuse>0) {
+      			if (unused>=canonlyuse){
+  				node.maxAllowed=node.maxAllowed+canonlyuse;	
+ 				return unused-canonlyuse;
+   			} else {//we can use more but are only offered unused amount return 0 because we took them all
+  				node.maxAllowed=node.maxAllowed+unused; 
+   				return 0;
+ 
+   			}
+		
             }//canonlyuse is 0 or less..can't use any
             return unused;
         } else { //not a leaf
-
-            dprintf(D_FULLDEBUG,"fairshare not a leaf node  %s maxallowed %f numsubmits %d unused %f \n", 
-                    groupArray[index].groupName.c_str(), groupArray[index].maxAllowed, groupArray[index].numsubmits,unused);
+  		dprintf(D_FULLDEBUG,"redistribute not a leaf node  %s maxallowed %f numsubmits %d unused %f \n", 
+  			node.groupName.c_str(), node.maxAllowed, node.numsubmits,unused);
 
                 // we dish out a fairshare to all our children
                 // child will point at rightmost child
-            float remaining=unused; //what we use to calculate share with
+            double remaining=unused; //what we use to calculate share with
             bool gavesome=true;
             float R = 1.0;
             const int maxiter = 100;
             int niter = 0;
             while (gavesome&&remaining>0){   
                 gavesome=false; //reset gavesome flag each iteration across children
-                int currentchild=child;
-                float childshare=0;
-                float totalgiven=0; //count of what was given away this round
-                float notgiven=0;
+                bool noremaining=false;
+                double childshare=0;
+                double totalgiven=0; //count of what was given away this round
+                double notgiven=0;
                 bool giveaway_mode = false;   
 
                 // "giveaway" is when we decide to deviate from true fair-share and
@@ -1707,50 +1869,27 @@ float Matchmaker::fairshare( std::vector
 
                 if (giveaway_mode) {
                     dprintf(D_FULLDEBUG, "fairshare group \"%s\" entering give-away mode iteration %d, remaining= %.15g\n", 
-                            groupArray[index].groupName.c_str(), 1+niter, double(remaining));
+                            node.groupName.c_str(), 1+niter, double(remaining));
                 }
 
-                    //we first check to see if we have submitters and give a share to them if they have quota	
-                if ( groupArray[index].autoregroup==true&&groupArray[index].nodequota>0&&groupArray[index].numsubmits>0) {
-                    if (giveaway_mode) {
-                        childshare = remaining;
-                    } else {
-                        childshare = R*remaining*groupArray[index].nodequota;
-                    }
-                    float canonlyuse=(float)groupArray[index].numsubmits-groupArray[index].nodemaxAllowed;
-                    if (childshare>0 && canonlyuse>0) {
-    		 			if (childshare > canonlyuse){
-                            groupArray[index].nodemaxAllowed=groupArray[index].nodemaxAllowed+canonlyuse;
-                            totalgiven = canonlyuse;
-                            if (giveaway_mode) remaining -= canonlyuse;
-                        } else {//we can use more but are only offered unused amount return 0 because we took them all
-                            groupArray[index].nodemaxAllowed=groupArray[index].nodemaxAllowed+childshare; 
-                            totalgiven = childshare;
-                            if (giveaway_mode) remaining = 0;
-                        }
-                        gavesome=true;
-                    }
-                    if (gavesome) 	
-                        dprintf(D_FULLDEBUG,"fairshare gave some to non group user %s maxallowed=%f nodemaxAllowed=%f remaining %f\n",
-                                groupArray[index].groupName.c_str(),groupArray[index].maxAllowed,groupArray[index].nodemaxAllowed,remaining);
-                }
-			
+		
                     //now we iterate across children handing out pie
-                while ((currentchild != -1) && (remaining > 0)) { 
-                    if (groupArray[currentchild].autoregroup==true){
+			for (unsigned int x=0;remaining>0.000001&&x<node.children.size();x++){ 
+				if (node.children[x]->autoregroup==true){
                         if (giveaway_mode) {
                             childshare = remaining;
                         } else {
-                            childshare = R*remaining*groupArray[currentchild].quota; 
+                            childshare = R*remaining*node.children[x]->quota;
                         }
-                        dprintf(D_FULLDEBUG,"fairshare %s index %d maxallowed %f numsubmits %d childshare %f unused %f\n",
-                                groupArray[currentchild].groupName.c_str(),index,groupArray[currentchild].maxAllowed , groupArray[currentchild].numsubmits,
+			dprintf(D_FULLDEBUG,"redistribute %s maxallowed %f numsubmits %d childshare %f unused %f\n",
+				node.children[x]->groupName.c_str(),node.children[x]->maxAllowed , node.children[x]->numsubmits,
                                 childshare, unused);
  		
                         notgiven=0;
                         if (childshare>0) {
-                            if (groupArray[currentchild].unused==0){
-                                notgiven=fairshare(groupArray,currentchild,childshare);
+                            if (node.children[x]->unused==0){
+                            
+				notgiven=redistribute(*node.children[x],childshare);
                                 if (notgiven<childshare){ //we gave some or all
                                     gavesome=true;
                                     totalgiven=totalgiven+(childshare-notgiven);
@@ -1760,11 +1899,11 @@ float Matchmaker::fairshare( std::vector
                         }
 
 	
-                        dprintf(D_FULLDEBUG,"after fairshare  %s index %d maxallowed %f numsubmits %d childshare %f unused %f remaining %f notgiven %f totalgiven %f\n",
-                                groupArray[currentchild].groupName.c_str(),index, groupArray[currentchild].maxAllowed, groupArray[currentchild].
+				dprintf(D_FULLDEBUG,"after redistribute  %s  maxallowed %f numsubmits %d childshare %f unused %f remaining %f notgiven %f totalgiven %f\n",
+		 			node.children[x]->groupName.c_str(), node.children[x]->maxAllowed, node.children[x]->
                                 numsubmits,childshare, unused, remaining, notgiven, totalgiven);
                     }
-                    currentchild=groupArray[currentchild].left;
+                    
                 }
 
                 // Use remaining/totalgiven as a multiplier next iteration for fast convergence.
@@ -1777,199 +1916,26 @@ float Matchmaker::fairshare( std::vector
                 // If we're in giveaway mode, we already updated remaining as we went.
                 // Otherwise we're in fairshare mode, so we update here.
                 if (!giveaway_mode) remaining -= totalgiven;
-                if (remaining<0) remaining=0; //precaution against roundoff
-
-                dprintf(D_FULLDEBUG,"fairshare  group %s index %d maxallowed %f numsubmits %d unused %f remaining %f gavesome %d\n",
-                        groupArray[index].groupName.c_str(),index, groupArray[index].maxAllowed, groupArray[index].numsubmits, unused, remaining, (int)gavesome);
-
+                if (remaining<0.00001) remaining=0; //precaution against roundoff
 
+			dprintf(D_FULLDEBUG,"redistribute  group %s maxallowed %f numsubmits %d unused %f remaining %f gavesome %d\n",
+			node.groupName.c_str(), node.maxAllowed, node.numsubmits, unused, remaining, (int)gavesome);
+ 
                 // This is defensive, and if it triggers it means something we did not expect happened.
                 // I'm checking against (1+maxiter) to allow maxiter remaining-giveaway one iteration to
                 // happen, and then another to detect that nothing was given.
                 niter += 1;
                 if (niter > (1+maxiter)) {
-                    dprintf(D_ALWAYS, "fairshare halting on iteration limit: group= \"%s\" niter= %d unused= %.15g remaining= %.15g totalgiven= %.15g\n",
-                            groupArray[index].groupName.c_str(), niter, double(unused), double(remaining), double(totalgiven));
+                    dprintf(D_ALWAYS, "redistribute halting on iteration limit: group= \"%s\" niter= %d unused= %.15g remaining= %.15g totalgiven= %.15g\n",
+                            node.groupName.c_str(), niter, double(unused), double(remaining), double(totalgiven));
                     break;
                 }
 	
             }
-            dprintf(D_FULLDEBUG, "fairshare nonleaf completed after %d iteratations group= \"%s\"\n", niter, groupArray[index].groupName.c_str());
+            dprintf(D_FULLDEBUG, "redistribute nonleaf completed after %d iteratations group= \"%s\"\n", niter, node.groupName.c_str());
             return remaining; 
 		}
-	} else { //no autoregroup so return unused
-
-		return unused;
-
-	}
-}
-
-
-void Matchmaker::sort(std::vector<SimpleGroupEntry>  &groupArray, int length)
-{
-	// sort groups into a tree within an array
-	// walk thru current group array
-	// each group must specify a quota at every level
-	int level=0;
-	int position=1;
-	int index=0;
-	int newlength=length-1;
-
-	dprintf(D_ALWAYS,"Sort : sorting group vector\n");
-	
-	std::vector<SimpleGroupEntry> groupArraytemp(length);
-	
-	groupArraytemp[0]=groupArray[0];
-	// could use an iterator and erase, but no sense in breaking down the vector
-	// since we would build it again
-	for (int j=1;j<length;j++){
-		groupArray[j-1]=groupArray [j];				
-	}
-
-	// level can't be greater than length because there can't be more subgroups than the number of groups in the array
-	while (level<=length&&newlength>0){
-        	bool found=false; 		
-		for (index=0;!found&&index<newlength;index++){	      
-			int mylevel=0;
-			string tempname2;
-			
-			//start at bottom top of tree so front of array is filled with top nodes
-			// and tail of array is filled with lower nodes or leaves.	
-			// put the name of current group in tempname
-			size_t pos= groupArray[index].groupName.find_first_of(".");		
-			while (pos!=string::npos){         // count the seperators which tells us number of subgroups
-					mylevel++;
-					pos= groupArray[index].groupName.find_first_of(".",pos+1);
-							
-			}
-			
-			// mylevel is count of subgroups in this particular group
-			// if it the same as our current level then we add it to the new array
-			if (mylevel==level){
-				found=true;;
-				groupArraytemp [position]=groupArray[index];
-				if (mylevel==0){ //deal with top level groups. an unusual case because they have no parent
-					if (position>1){
-				 		groupArraytemp[position].left=position-1;
-						groupArraytemp[position-1].right=position;	
-					} else { //else position is 1..special case
-					 	groupArraytemp[position].left=-1;	
-					 
-					}
-					groupArraytemp[position].parent=0;
-					groupArraytemp[0].child=position;
-				} else {// if this is a subgroup then assign the parent field
-					if (mylevel>0){ //cut off last subgroup leaving the parent group string
-						size_t last=groupArray[index].groupName.find_last_of(".");
-						if (last !=string::npos) tempname2=groupArray[index].groupName.substr(0,last);
-						else tempname2=groupArray[index].groupName;
-						
-						bool foundsibling=false;
-						bool foundparent=false;
-						for (int len = position-1; len>=0;len--){
-							//if our parent string matches a group name we found our parent
-
-							if (!foundparent&&(groupArraytemp[len].groupName.compare(tempname2)==0)){
-								groupArraytemp [position].parent=len;
-								groupArraytemp [len].child=position; //child will be left most sibling
-								foundparent=true;
-							}
-							
-							//if our parent string matches the parent string of another element
-							//we found a sibling
-							
-							string tempname4;	
-							size_t lastdel=groupArraytemp[len].groupName.find_last_of(".");
-							if (lastdel !=string::npos) tempname4=groupArraytemp[len].groupName.substr(0,lastdel);
-							else tempname4=groupArraytemp [len].groupName;
-							//top most groups are dealt with above
-
-							if (!foundsibling&&lastdel !=string::npos&&(tempname2.compare(tempname4)==0)){
-								groupArraytemp [position].left=len;
-								groupArraytemp [len].right=position;	
-								foundsibling=true;
-							}
-
-						}
-					}
-				} 
-				//remove the just found entry from the array
-				for (int j=index+1;j<newlength;j++)
-	 				groupArray[j-1]=groupArray [j];
-				
-				newlength--; 
-				for (int i=0;i<newlength;i++) {
-					dprintf(D_FULLDEBUG,"Sorting : grouparray group %s parent %d child %d  left %d right %d i %d\n",
-					groupArray[i].groupName.c_str(),  groupArray[i].parent, groupArray[i].child,groupArray[i].left,
-		 			groupArray[i].right ,i);
-				}					
-				
-				position++;
-			} // if (mylevel==level)
-		
-		} //for
-		if (!found) level++;
-	} //while
-	//copy the array back to original array
-	for (int i=0;i<length;i++) groupArray[i]=groupArraytemp [i];
-	
-	dprintf(D_FULLDEBUG,"Sort : stage two\n");		
-	for (int i=0;i<length;i++) {
-		dprintf(D_FULLDEBUG,"midsort : grouparray group %s parent %d child %d  left %d right %d i %d\n",
-			groupArray[i].groupName.c_str(),  groupArray[i].parent, groupArray[i].child,groupArray[i].left,
-			 groupArray[i].right ,i);
-	}
-	
-
-	for (int i=length-1;i>1;i--){
-		if (i-1!=groupArray[i].left) {//if not equal immediateleft is not left node		
-	 		if (groupArray[i].left!=-1){ //there is a left sibling
-			
-				//fix the links for the i-1 node we're moving
-				if (groupArray[i-1].left!=-1) groupArray[groupArray[i-1].left].right=groupArray[i].left;
-				if (groupArray[i-1].right!=-1)groupArray[groupArray[i-1].right].left=groupArray[i].left;
-				
-				//fix our own  links		
-				if (groupArray[groupArray[i].left].left!=-1)groupArray[groupArray[groupArray[i].left].left].right=i-1;
-				groupArray[i].left=i-1;
-				groupArraytemp [0]=groupArray[i-1];
-				groupArray [i-1]=groupArray[groupArray[i].left];
-				groupArray [groupArray[i].left]=groupArraytemp[0];
-				
-				if (groupArray[i].parent!=-1)groupArray[i-1].parent=groupArray[i].parent;
-		
-     			} else if (groupArray[i-1].right!=-1){ 
-				//there isn't a left sibling but the next one is already rightmost if -1
-		
-     		    		//we have to find the rightmost sibling under a new parent
-      				 // if no left node we are a single group with no peers or 
-       				// we walked all peer subgroups and are now at left most node
-           			int rightmost=i-1;
-				while(rightmost>0&&groupArray[rightmost].right!=-1) 
-					rightmost=groupArray[rightmost].right;
-			
-				if (groupArray[i-1].left!=-1) groupArray[groupArray[i-1].left].right=rightmost;
-				if (groupArray[i-1].right!=-1)groupArray[groupArray[i-1].right].left=rightmost;
-				if (groupArray[rightmost].left!=-1)groupArray[groupArray[rightmost].left].right=i-1;
-				groupArraytemp [0]=groupArray[i-1];
-				groupArray [i-1]=groupArray[rightmost];
-				groupArray [rightmost]=groupArraytemp[0];
-				
-		
-			}
-	
-		}
 	
-	}
-
-	for (int i=0;i<length;i++) {
-		dprintf(D_FULLDEBUG,"Sorted : grouparray group %s parent %d child %d  left %d right %d i %d\n",
-			groupArray[i].groupName.c_str(),  groupArray[i].parent, groupArray[i].child,groupArray[i].left,
-		 	groupArray[i].right ,i);
-	}
-   
-
-	dprintf(D_FULLDEBUG,"Sort : leaving\n");
 }
 
 
@@ -1979,10 +1945,7 @@ SimpleGroupEntry()
 {
 	groupName.assign("\0");
 	prio = 0;
-	parent = -1;
-	left = -1;
-	right = -1;
-	usage = 0.0f;
+	parent = NULL;
 	maxAllowed = (float) INT_MAX;
 }
 
@@ -1990,23 +1953,33 @@ Matchmaker::SimpleGroupEntry::
 SimpleGroupEntry(const Matchmaker::SimpleGroupEntry& entry)
 {
 	groupName=entry.groupName;
-
 	prio=entry.prio;
 	maxAllowed=entry.maxAllowed;
-	nodemaxAllowed=entry.nodemaxAllowed;
+
 	quota=entry.quota;
 	usage=entry.usage;
 	parent=entry.parent;
-	left=entry.left;
-	nodequota=entry.nodequota;
-	right=entry.right;
 	autoregroup=entry.autoregroup;
 	numsubmits=entry.numsubmits;
-	child=entry.child;
 	staticquota=entry.staticquota;
 	unused=entry.unused;
-	//don't need to do submitter ads
-	//if this is used elsewhere that capability will need to be added
+	children=entry.children;
+	name=entry.name;
+/*
+ * see note in populategroup
+ * stl requires const Matchmaker::SimpleGroupEntry& entry
+ * 
+
+	submitterAds.Open();
+	while( (ad=submitterAds.Next()) ) {
+		submitterAds.Delete(ad);				
+		}
+	
+	entry.submitterAds.Open();
+	while (ad=entry.submitterAds.Next()) {
+		submitterAds.Insert(ad);
+		}
+*/
 }
 
 Matchmaker::SimpleGroupEntry::
@@ -2018,26 +1991,33 @@ Matchmaker::SimpleGroupEntry::
 	
 Matchmaker::SimpleGroupEntry & Matchmaker::SimpleGroupEntry::operator = (const SimpleGroupEntry  & entry) {
 	
-		
+	ClassAd *ad = NULL;
 	groupName=entry.groupName;
-
 	prio=entry.prio;
 	maxAllowed=entry.maxAllowed;
-	nodemaxAllowed=entry.nodemaxAllowed;
+	
 	quota=entry.quota;
 	usage=entry.usage;
 	parent=entry.parent;
-	left=entry.left;
-	nodequota=entry.nodequota;
-	right=entry.right;
+
 	autoregroup=entry.autoregroup;
 	numsubmits=entry.numsubmits;
-	child=entry.child;
 	staticquota=entry.staticquota;
 	unused=entry.unused;
-	//don't need to do submitter ads
-	//if this is used elsewhere that capability will need to be added
+
+	children=entry.children;
+	name=entry.name;
+/*
+	submitterAds.Open();
+	while( (ad=submitterAds.Next()) ) {
+		submitterAds.Delete(ad);				
+		}
 	
+	entry.submitterAds.Open();
+	while (ad=entry.submitterAds.Next()) {
+		submitterAds.Insert(ad);
+		}
+*/	
 	return *this;
 }
 
@@ -2048,7 +2028,7 @@ negotiateWithGroup ( int untrimmed_num_s
 					 double minSlotWeight,
 					 ClassAdList& startdAds,
 					 ClaimIdHash& claimIds, 
-					 ClassAdList& scheddAds, double & groupUsed,
+					 ClassAdList& scheddAds, // double & groupUsed,
 					 float groupQuota,  float groupusage,const char* groupAccountingName)
 {
 	ClassAd		*schedd;
@@ -2073,7 +2053,7 @@ negotiateWithGroup ( int untrimmed_num_s
 	int			num_idle_jobs;
 	time_t		startTime;
 	
-	groupUsed=0;
+	double groupUsed=0;
 
 	// ----- Sort the schedd list in decreasing priority order
 	dprintf( D_ALWAYS, "Phase 3:  Sorting submitter ads by priority ...\n" );
diff -rNup condor-7.4.2.orig/src/condor_negotiator.V6/matchmaker.h condor-7.4.2/src/condor_negotiator.V6/matchmaker.h
--- condor-7.4.2.orig/src/condor_negotiator.V6/matchmaker.h	2010-10-21 10:54:55.000000000 -0400
+++ condor-7.4.2/src/condor_negotiator.V6/matchmaker.h	2010-10-27 14:47:10.000000000 -0400
@@ -130,7 +130,7 @@ class Matchmaker : public Service
 								 double untrimmedSlotWeightTotal,
 								 double minSlotWeight,
 			ClassAdList& startdAds, 
-			ClaimIdHash& claimIds, ClassAdList& scheddAds, double & groupUsed,
+			ClaimIdHash& claimIds, ClassAdList& scheddAds, //double & groupUsed,
 			float groupQuota=INT_MAX, float groupusage=0.0, const char* groupAccountingName=NULL);
 
 		
@@ -402,28 +402,42 @@ class Matchmaker : public Service
 			~SimpleGroupEntry();
 			string groupName;
 			float prio;
-			float maxAllowed;
-			float nodequota;
-			float nodemaxAllowed;
-			float quota;
-			float usage;
-			float unused;
+			double maxAllowed;
+			double quota;
+			double usage;
+			double unused;
 			bool autoregroup;
-			int parent;        // index of parent node
-			int left;          // index of peer (shares same parent) (linked list)
-			int right;         // index of peer (linked list)
-			int child;         // index to first child in linked list
+			SimpleGroupEntry * parent;
 			int numsubmits;
 			bool staticquota;
 			ClassAdList submitterAds;
+			std::vector<SimpleGroupEntry *> children; //children
+			std::string name;   // name string
 			void sort(int length);
+
 			
 		SimpleGroupEntry & operator = (const SimpleGroupEntry  & entry);
 				
 		};
 		static int groupSortCompare(const void*, const void*);
-		float fairshare( std::vector<SimpleGroupEntry> &groupArray, int index, float unused);
-		void sort( std::vector<SimpleGroupEntry> &groupArray,int length);
+		
+		double redistribute( SimpleGroupEntry & node, double unused);
+		double fairshare (SimpleGroupEntry & node);
+		SimpleGroupEntry * populategroup (string group, ClassAdList& startdAds, ClassAdList& scheddAds);
+		void insert ( SimpleGroupEntry * tempentry, SimpleGroupEntry & node , size_t delimeter, string namestring, ClassAdList& startdAds, ClassAdList& scheddAds );
+		void maxAllowedcalc (SimpleGroupEntry & node);
+		double  roundoffstage1(SimpleGroupEntry & node);
+		double roundoffstage2(SimpleGroupEntry & node, double treeroundoff);
+		void negotiatetree (SimpleGroupEntry & node, int untrimmed_num_startds,
+					 double untrimmedSlotWeightTotal,
+					 double minSlotWeight,
+					 ClassAdList& startdAds,
+					 ClaimIdHash& claimIds, 
+					 ClassAdList& scheddAds);
+		void dumptree (SimpleGroupEntry & node);
+		void resetunused (SimpleGroupEntry & node);
+		void attachsubmitters (SimpleGroupEntry & node, SimpleGroupEntry & tree, ClassAdList& startdAds, ClassAdList& scheddAds);		 
+
 
 		char RejectsTable[40];
 		char MatchesTable[40];
