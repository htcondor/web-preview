{"id": 2007, "title": "Ticket #2007: Can stduniv run as a vanilla job with standalone checkpointing?", "description": "<blockquote>\n<span class=\"section\"><h2>Motivation </h2></span>\n\n<p></p><ol>\n<li>The users of Condor's stduniv constitute a small userbase.\n</li><li>Of that small user base, an even smaller group relies in remote I/O. The\nlarger group specifically turns it off.\n</li><li>There are multiple user space third party checkpointers, such as DMTCP,\ncryopid, etc., and several application specific checkpointers, like Gromacs,\nthat people would like to use with Condor.\n</li></ol>\n\n<p><span class=\"section\"></span></p><h2>Problem Statement</h2>\n\n<p></p><ol>\n<li>What services would Condor have to provide to make it easy for\nthird party checkpointing systems (with DMTCP as the motivating\nexample) to use the vanilla universe to maximize goodput and\ncorrectness of execution restart?\n\n<p></p></li><li>If we thought of Condor's standard universe as a third party\nsystem (without remote I/O) and used it in the vanilla universe,\nwhat, if anything, would have to change about the stduniv?\n</li></ol>\n\n<p><span class=\"section\"></span></p><h2>Goal </h2>\n\n<p>These goals presume the assumption of no remote I/O capability by any of\nthe \"third party\" checkpointers, including our own stduniv library when\nused in this context.\n\n</p><p></p><ol>\n<li>Identify what special features about the stduniv we need to propogate\nto the vanilla universe.\n\n<p></p></li><li>Identify what functionality we need from third party checkpointers to\nallow their integration into Condor's vanilla universe.\n\n<p></p></li><li>Identify how Condor Users and Administrators will interact with the new\nfeature.\n</li></ol>\n\n<p><span class=\"section\"></span></p><h2>State of the Art</h2>\n\n<p><span class=\"subsection\"></span></p><h3>The Standard Universe</h3>\n\n<p>This describes the current high-level behavior of the Standard Universe.\n\n</p><p></p><ul>\n<li>Each resource slot in the pool computes (via internal code and a binary tool\nwe ship called condor_ckpt_probe) a \"checkpoint signature\" of\nthe machine and stores it into the slot ad. This is stored in\nthe <code>CheckpointPlatform</code> classad attribute. The value represents\nan opaque token.\n\n<p></p></li><li>The START expression of each slot has in it a reference to\nthe expression <code>IsValidCheckpointPlatform</code>. This expression\nis false if the job is a standard universe job whose defined\n<code>LastCheckpointPlatform</code> value does not match the slot's\n<code>CheckpointPlatform</code> attribute. It is true in all other cases.\n\n<p></p></li><li>When a job initially starts, it must start on a machine that matches\nthe arch/opsys of the submitting machine. Upon successful checkpoint or\nvacation, the <code>CheckpointPlatform</code> value from the slot ad is stored into\nthe <code>LastCheckpointPlatform</code> in the job ad.\n\n<p></p></li><li>When a job restarts, not only must the arch and opsys match from the\nsubmit machine, but it must also match the jobad's\n<code>LastCheckpointPlatform</code> in the slot ad's <code>CheckpointPlatform</code>\nattribute. This ensures that the checkpoint is compatible with\nthe restarting kernel, memory layout, etc.\n\n<p></p></li><li>When a job doing remote i/o checkpoints, there is a logical checkpoint\nof the jobs' files in that they stay unmolested on the submit\nmachine. In the case of a job where remote i/o has been turned off,\nthe files are in a shared location and implicitly preserved when\nthe job moves from one machine to another.\n\n<p></p></li><li>Periodically, the startd tells the starter to send a periodic\ncheckpoint signal to the job which tells it it should emit a\ncheckpoint and keep going.\n\n<p></p></li><li>There is a difference between a periodic checkpoint and a checkpoint\nwhen the job is vacating. The former is SIGTSTP, which means to\ncheckpoint and keep going, and the latter is SIGUSR2, which means to\ncheckpoint and exit.\n\n<p></p></li><li>At vacate time, a checkpoint signal is sent to the job to tell it to\ncheckpoint and then exit.\n\n<p></p></li><li>Using the tool condor_checkpoint_job, a user on the submit machine\ncan tell a single job to checkpoint, no matter where it may be runnning.\n\n<p></p></li><li>Using the tool condor_checkpoint, a user (with the right permissions)\ncan tell a host to checkpoint all stduniv jobs running on that\nmachine no matter who owns them.\n\n<p></p></li><li>The storage and retrieval location of the job's checkpoint image is\ndetermined by the shadow and told to the job just before it reads\nor writes it. The job will read/write the checkpoint image from a\nsocket which is either connected to the shadow (and it gets/puts\nthe file from the submit machine) or a checkpoint server, where\nit will contact it on a specified port and get/put the file.\n\n<p></p></li><li>The standard universe job may only be one process throughout the life\nof the job. This means only a single checkpoint image.\n</li></ul>\n\n<p><span class=\"subsection\"></span></p><h3>The Vanilla Universe</h3>\n\n<p>This describes the state of the art in how a user today uses the vanilla\nuniverse for checkpointing with a third party (or application level)\ncheckpointer.\n\n</p><p></p><ul>\n<li>In both of these cases, checkpoint files are treated as intermediary\nfiles which are moved back and forth along with the job's files.\nThey are kept in the spool directory and are basically files to\nwhich the user has no access.\n\n<p></p></li><li>Even though file transfer plugins exist, I don't know of any third party\ncheckpointer using it.\n</li></ul>\n\n<p><span class=\"subsubsection\"></span></p><h4>Using a Wrapper Script</h4>\n\n<p></p><ul>\n<li>A generally hand-written wrapper script is submitted\nas the vanilla job. The actual job executable(s) is often stored\nas a tarball or something else that the script unpackages,\nprepares, and executes.  The wrapper script may start other\nservices needed by the third party checkpointer.\n\n<p></p></li><li>The wrapper script can be active after forking the application in\nthe background, but the wrapper script must exit with a return\ncode of the application when appropriate.\n\n<p></p></li><li>Using the submit file command <code>KillSig</code>, the submittor of the job sets it\nto a signal that the wrapper script expects. When the job is being\nvacated, the wrapper script receives this signal and enacts a checkpoint.\nThe wrapper has KILL expression amount of time to finish the checkpoint.\n\n<p></p></li><li>While the wrapper script can initiate periodic checkpoints, the\ncheckpoint images, which may be a collection of files and/or\ndirectories, are not moved out of/into the sandbox except at\nvacate and job start boundaries.  Checkpoint files without the\ndata files near to the time of checkpoint are basically useless.\n\n<p></p></li><li>A significant problem faced by a user of a third party checkpointer is\nthe lack of signature matching between the machine upon which\nthe checkpoint was originally take and a resuming machine. This\nwill often cause hard to find and frustrating failures.\n</li></ul>\n\n<p><span class=\"subsubsection\"></span></p><h4>Application Level</h4>\n\n<p></p><ul>\n<li>Using the submit file's <code>KillSig</code> signal, an application can write out one\nor more checkpoint files at vacate time. The <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=KillSig\" title=\"Kill Sig\">KillSig</a></span> is only sent at\nvacate time.\n\n<p></p></li><li>It is up to the application to decipher its own checkpoint files and ensure\nthat they start properly on the resumption machine.\n</li></ul>\n\n<p><span class=\"section\"></span></p><h2>New Design</h2>\n\n<p><span class=\"subsection\"></span></p><h3>Checkpointer Identification</h3>\n\n<p>Checkpointing system need to identify themselves in name, version, and an\nopque token which represents a computed checkpoint signature of a machine.\n\n</p><p><span class=\"subsubsection\"></span></p><h4>Checkpointer Identification, Startd Side</h4>\n\n<p></p><ul>\n<li>The vanilla universe must provide a means for a checkpointer to record\na checkpoint signature and restart on a machine with the same\ncheckpoint signature.\n</li></ul>\n\n<p>Each checkpointer must provide a tool which emits a classad that describes\nthe third party checkpointer. The tool must accept the \"--classad\" option\non the command line. The ad it will emit must have this form:\n\n</p><p></p><pre>\t# XXX is an arbitray length AlphaNumeric name of the checkpointer\n    # with NO underscores\n</pre>\n\n<p></p><pre>\tAAA is a zero padded major number\n\tBBB is a zero padded minor number\n\tCCC is a zero padded patch number\n</pre>\n\n<p></p><pre>\t# And the classad itself\n\tHasCheckpointer_XXX_AAABBBCCC = TRUE\n\tCheckpointerSignature_XXX_AAABBBCCC = \"opaque string\"\n</pre>\n\n<p></p><ul>\n<li>The startd will look into a directory defined by the\n<code>CKPT_SIGNATURE_PROBES_BIN_DIRECTORY</code> config file parameter where\nthe Condor Administrator has placed the checkpoint signature\nidentifcation tools for each third party checkpointer and execute\neach program upon startup/reconfig. Each returned classad is\nmerged into the slot ads for the resource.\n</li></ul>\n\n<p><span class=\"subsubsection\"></span></p><h4>Checkpointer Identification, Submit Side</h4>\n\n<p></p><ul>\n<li>The user will place:\n</li></ul>\n\n<p></p><pre>\t# A comma delimited list of checkpointers the user is willing to use.\n\tUseCheckpointer = XXX_AAABBBCCC\n</pre>\n\n<p>in their submit file.\n\n</p><p>This informs the Condor system that this job cares about what machine\nwith which it will be matched and to keep track of the signature of that\ncheckpointer/version in the job ad.\n\n</p><p></p><ul>\n<li>A new signal definition attribute called <code>ckpt_sig</code> will be\ndefined in the submit file. It will denote a signal number that\nwill be sent to the vanilla job under certain conditions.\n\n<p></p></li><li>A new attribute called <code>PeriodicCkptInterval</code> will be defined in the\nsubmit file which tells the Condor system to send the <code>ckpt_sig</code>\nto the job every N seconds. The shadow tells this information\nto the starter and may override it.\n</li></ul>\n\n<p><span class=\"subsubsection\"></span></p><h4>Use of the Checkpoint Signature Identification</h4>\n\n<p></p><ul>\n<li>The START expression of the slot will have <code>IsValidCheckpointPlatform</code>\nremoved. It will be the onus of the job ad's Requirements\nExpression to know about the LastCheckpointSignature_XXX_AAABBBCCC\nstored in the job ad and that it should match with the slot ad.\n\n<p></p></li><li>When condor_submit sees the <code>UseCheckpointer</code> attribute in the\nsubmit file, it will modify the Requirements Expression to be a\nconjunction of HasCheckpointer_XXX_AAABBBCCC <span class=\"quote\">=?=</span> TRUE}\nexpressions, one for each specified checkpointer. This forces\njobs onto slots that have the checkpointer available.\n</li></ul>\n\n<p>Condor_submit will also inspect the name of each checkpointer and\nrevision and then add additional disjoined expressions which will\nbe true if <code>LastCheckpointSignature_XXX_AAABBBCCC</code> (one for each)\nis not present in the job ad or if it is present and matches\nthe slot ad's appropriate <code>CheckpointerSignature_XXX_AAABBBCCC</code>\nsignature related to the name/version of the desired checkpointer.\nThis forces jobs which previously checkpointed back onto machines\nwith the same signature.\n\n</p><p><span class=\"subsubsection\"></span></p><h4>Checkpointer Identification, Starter Side &amp; Shadow Behavior</h4>\n\n<p></p><ul>\n<li>When a checkpointable vanilla universe job has run (and possibly\ncheckpointed) the first time on a machine, the Starter sends\nback the <code>LastCheckpointerSignature_XXX_AAABBBCCC</code> attribute\n(knowing which one to pick by analysis of the job ad) filled\nin with the correct opaque value so that the shadow places it\ninto the committed job ad. The <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=StarterKnows\" title=\"Starter Knows\">StarterKnows</a></span> to do this because\n<code>LastCheckpointerSignature_XXX_AAABBBCCC</code> won't be in the job ad\non the first run. <strong>Limitation:</strong> It might be too difficult to\nknow that a checkpoint was taken succesfully, so assume it had\nand set the attribute anyway.\n</li></ul>\n\n<p><span class=\"subsection\"></span></p><h3>Checkpoint Asset Management</h3>\n\n<p></p><ul>\n<li>Checkpoint files (or sets of checkpoint images) are meaningless\nwithout the rest of the application's files at the time of\n(or just after) the checkpoint. Here we describe the concept of a\n\"Checkpoint Asset\", which is a collection of everything an application\nneeds to resume its computation at a later time.\n</li></ul>\n\n<p>When a checkpoint is taken, and known to be completed, the entire\nsandbox must be moved off of the machine to another storage\nlocation. However, certain subsets of those files have different\nproperties as other subsets of the files.\n\n</p><p>The submit file must expressly identify, via regexs, files or directories\nwhich will comprise temporary and storage subsets of checkpoint assets.\n\n</p><p>These assets shall be identified in the submit file by:\n\n</p><p></p><pre>\tCheckpointVolatileAssets = &lt;regex&gt;, &lt;regex&gt;, ...\n</pre>\n\n<p><span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CheckpointVolatileAssets\" title=\"Checkpoint Volatile Assets\">CheckpointVolatileAssets</a></span> are be explcitly managed and only needed\nduring the time that the process isn't actually running. For\nexample, after a job resumes, the volatile checkpoint image could\nbe deleted. This makes the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CheckpointVolatileAssets\" title=\"Checkpoint Volatile Assets\">CheckpointVolatileAssets</a></span> different\nfrom the set of application files. These files are usually the checkpoint\nimages themselves.\n\n</p><p></p><pre>\tCheckpointStorageAssets = &lt;regex&gt;, &lt;regex&gt;, ...\n</pre>\n\n<p><span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CheckpointStorageAssets\" title=\"Checkpoint Storage Assets\">CheckpointStorageAssets</a></span> are explicitly managed files which\nare preserved with a checkpoint, but cannot be deleted. They\nare treated like intermediate files and this attribute trumps\nthe calculation of immediate files. If this attribute is left\nunspecified it is exactly the set of files which are all files\nminus the <strong>CheckpointVolatileAssets</strong>.\n\n</p><p>The term <strong>CheckpointAssets</strong> refers to a union of the\n<strong>CheckpointVolatileAssets</strong> and <strong>CheckpointStorageAssets</strong> subsets.\n\n</p><p>We could utilize the (not merged yet) dataflow code to identify\ncheckpoint assets that are not being written any longer.\n\n</p><p></p><ul>\n<li>In the initial implementation, only the most recent checkpoint assets\nfor a job will be stored.\n\n<p></p></li><li>We will use File Transfer Plugins to get/put checkpoint\ninformation from/to distributed storage or some other kind\nof storage.\n\n<p></p></li><li>XXX Ideas that do not have a place in the design document yet:\n<ul>\n<li>Who allocates of storage for Checkpoint Assets.\n</li><li>Do we keep a sequence of Checkpoint Assets for a job?\n</li><li>Who cleans up the Checkpoint Assets?\n</li><li>Who manages the Checkpoint Assets sequencing (LRU eviction, etc).\n</li><li>Where do the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CheckpointAssets\" title=\"Checkpoint Assets\">CheckpointAssets</a></span> go? How is this determined?\n</li></ul>\n</li></ul>\n\n<p><span class=\"subsection\"></span></p><h3>Checkpoint Initiation Events</h3>\n\n<p></p><ul>\n<li>Third party checkpointers may perform their own periodic checkpoints.\n\n<p></p></li><li>When the schedd receives a <code>condor_checkpoint_job</code> request for\na vanilla universe job, it will inform the shadow for the job\nto send a message to the starter to send the <code>ckpt_sig</code>\nto the job. If <code>ckpt_sig</code> is not defined, it is a NOP.\n</li></ul>\n\n<p>An alternative implementation is that the schedd tells the startd\nwhich tells the starter to do it.  It has not been thought out\nwhich is the better option other than that it is likely less\nresource consumption for a schedd to contact a daemon on the\nlocalhost for a short message than on a machine far away.\n\n</p><p><span class=\"section\"></span></p><h2>Assumptions </h2>\n\n<p></p><ul>\n<li>There will be no remote I/O by the Condor standalone checkpointer.\n\n<p></p></li><li>A portion of the integration of a third party checkpointer will be done\nby administrators and a portion by the submittors. This specifically\nmeans that when supporting a new third party checkpointer, the Condor\nadministrator must perform work to allow it to be used.\n\n<p></p></li><li>The application undergoing checkpointing will not perform read\nAND write operations on the same logical file. Performing\nread/write operations on the same logical file during\ncheckpointing will produce inconsistent or undefined results.\n</li></ul>\n\n<p><span class=\"section\"></span></p><h2>Requirements for Third Party Checkpointers</h2>\n\n<p></p><ul>\n<li>The writing of the checkpoint assets must be atomic.\n</li></ul>\n\n<p><span class=\"section\"></span></p><h2>Behavior in Failure Scenarios</h2>\n\n<p>TBD\n\n</p><p><span class=\"section\"></span></p><h2>Limitations </h2>\n\n<p></p><ul>\n<li>There appears to be no perfect way to know if a checkpoint is\nhappening or has successfully occured.\n</li></ul>\n\n<p>TBD\n\n</p><p><span class=\"section\"></span></p><h2>Known Customer Requirements</h2>\n\n<p><span class=\"subsubsection\"></span></p><h4>LIGO </h4>\n\n<p></p><ul>\n<li>On the <strong>CheckpointPlatform</strong> signature:\n</li></ul>\n\n<p></p><pre>\tCurrently we have two pools here in Hannover, the regular one yields:\n   6654 CheckpointPlatform = \"LINUX X86_64 2.6.x normal 0x2aaaaaac7000\"\n</pre>\n\n<p></p><pre>\tthe test pool with GPUs and a few newer nodes yield:\n    256 CheckpointPlatform = \"LINUX X86_64 2.6.x normal 0x2aaaaaac7000\"\n     17 CheckpointPlatform = \"LINUX X86_64 2.6.x normal 0x2aaaaaac9000\"\n</pre>\n\n<p>So, this means that they <strong>could</strong> get away without having the checkpoint\nsignature codes working. Instead they could hand specify an attribute that\ntheir jobs must match against. However, they need a tool which will calculate\nthe above value so they can see when it changes. <strong>However</strong>, if they phase\nchange the pools and a new signature shows up, they have to deal with it by\nhand!\n\n</p><p></p><ul>\n<li>On <code>preemption</code> or <code>periodic</code> style checkpointing:\n</li></ul>\n\n<p></p><pre>\tThey absolutely require preemption style checkpointing for\n\ta significant majority of their stduniv usage. They have one\n\tuser, though, who has been running a 68+ day job and relies on\n\tperiodic checkpoints.\n</pre>\n\n<p></p><ul>\n<li>On choice of where to write the checkpoints:\n</li></ul>\n\n<p></p><pre>\tThey currently run a checkpoint server on each compute node.\n\tWhen asked the question if they would want their checkpoint images\n\twritten to the shared partition that all their machines use, they\n\tsaid they fear 4000 or 8000 jobs under a single user suddenly bursting\n\ttheir checkpoints to the shared file system. They are tempted by the\n\tsiren call of ease of use, but fear the consequences.\n</pre>\n\n<p></p><ul>\n<li>On versioned checkpoints:\n</li></ul>\n\n<p></p><pre>\tThey never had a need for it and wonder about expiration dates for\n\tolder checkpoints. They didn't mention it, but forking the checkpoint\n\tlineage has to be thought about too. This isn't important to them.\n</pre>\n\n<p></p><ul>\n<li>On checkpoint/restart policy (and the fact we don't let you specify it):\n</li></ul>\n\n<p></p><pre>\tIt has bitten them a few times, usually with the schedd blocking on a\n\t\"broken\" checkpoint server which isn't responding. They can easily fix\n\tfor the few times it happens. They don't consider this an issue.\n</pre>\n\n<p></p><ul>\n<li>On condor_ssh_to_job and CCB:\n</li></ul>\n\n<p></p><pre>\tThey require this behavior.\n</pre>\n\n<p></p><ul>\n<li>On other topics (what else do you need in this feature?):\n</li></ul>\n\n<p></p><pre>\tAs quoted from Casten:\n</pre>\n\n<p></p><pre>\t\"Not to my knowledge, but (our) users are very creative,\n\tthus together with dynamic slots expect users to start looking\n\theavily into multi-core programming and/or using \"CPU-external\"\n\tprocessing. For example, one of the largest stduniv pipelines\n\twe currently have is being reworked to use gstreamer(?) as\n\ta way to move data hence and forth between different tasks\n\t(could be threads - possibly p-threads, processes, processes\n\twith GPU parts).  If we needed more on that, we would need to\n\ttalk to the designer/programmers from that project. Currently,\n\tthey are aiming for generic vanilla jobs AFAIK.\"\n</pre>\n\n<p><span class=\"section\"></span></p><h2>Milestones </h2>\n\n<p></p><ul>\n<li>Fix condor_ckpt_probe to accept the \"--classad\" option and emit the proper\nclassad to use Condor's standalone checkpointer as the first third party\ncheckpointing system.\n\n<p></p></li><li>Fix condor_startd to understand CKPT_SIGNATURE_PROBES_BIN_DIRECTORY, find\nand run all programs contained therein, deal with the usual erroneous\nsituations, and ensure the attributes show up in the slot ad. Give a\ngood default for this knob.\n</li></ul>\n\n<p>XXX Maybe that config knob should just list full paths to\nexecutables vis $(SBIN) or something instead. Mostly because\nthe permission the code runs under needs to be non-priviledged\nand if an attacker succeeded placing a new binary there, could\nget Condor to run it as some other user, which is bad.\n\n</p><p></p><ul>\n<li>Ensure our build system and RPMS place the condor_ckpt_probe executable\nin the right place if needed.\n\n<p></p></li><li>Fix condor_submit to accept:\n</li></ul>\n\n<p></p><pre>\tUseCheckpointer = XXX_AAABBBCCC\n\tCheckpointVolatileAssets = &lt;list of regexes&gt;\n\tCheckpointStorageAssets = &lt;list of regexes&gt;\n\tckpt_sig = &lt;integer&gt;\n</pre>\n\n<p>and to adjust the requirements expression properly.\n\n</p><p></p><ul>\n<li>When the starter runs the job, have it notice if it is a checkpointable\njob and have it insert the appropriate\n<code>LastCheckpointerSignature_XXX_AAABBBCCC</code> attribute into the\njobad regardless if the job actually completes or not.\n\n<p></p></li><li>Implement the behavior <code>condor_checkpoint_job</code> into the schedd such that\nultimately the user job gets the checkpoint signal.\n</li></ul>\n\n<p>TBD\n\n</p><p></p><hr/>\n<span class=\"section\"><h2>The simpler version</h2></span>\n\n<p>For a very first pass, just to implement what ligo needs, we'll do this:\n\n</p><p><span class=\"subsection\"></span></p><h3>Goals </h3>\n<ul>\n<li>We will initially suppose LIGO's needs.\n</li><li>LIGO only desires condor_ssh_to_job, ccb, and the richer job policy\nmechanisms of vanilla universe.\n</li></ul>\n\n<p><span class=\"subsection\"></span></p><h3>Assumptions </h3>\n<ul>\n<li>Homogeneous pool wrt <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CheckpointPlatform\" title=\"Checkpoint Platform\">CheckpointPlatform</a></span>.\n</li><li>It'll only work with Condor's Checkpointer.\n</li></ul>\n\n<p><span class=\"subsection\"></span></p><h3>The Plan</h3>\n<ul>\n<li>We write a tool to act as a client to a Condor checkpoint server. This tool will move checkpoints to and from the checkpointer server and has the ability to rename them and delete them as well. We will implement this tool with the current client libaries that already embody this functionality.\n\n<p></p></li><li>We will write a wrapper script which will start the user job ala the dmtcp_shim script. This will look into the jobad, find out if it had previously checkpointed, and if so, retrienve the checkpoint image and restart the job.\n\n<p></p></li><li>The pool admin should specify in the machine ad the location on the local machine in which user checkpoints may be written. This must be writable by the uid of the job. The wrapper script will pick this location out of the .machine_ad file and start the user job with it.\n\n<p></p></li><li>When it comes time to checkpoint at vacate time, the wrapper script will transfer the checkpoint as a temporary file to the checkpoint server, rename it as the correct checkpoint file, then using chirp, update the job ad with the correct <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=LastCkptServer\" title=\"Last Ckpt Server\">LastCkptServer</a></span> information. [There may be races here, but just look to see how we do it in stduniv and copy that algorithm.]\n\n<p></p></li><li>The user job must specify +WantIOProxy = TRUE in their submit file in order\nto be able to use chirp.</li></ul>\n</blockquote>", "remarks": "<blockquote>\n<em>2011-Mar-30 11:14:30 by psilord:</em> <br/>\n\nAssigned to tannenba for review to see what more he'd like.\n\n<p></p><hr/>\n<em>2011-Apr-22 16:48:43 by psilord:</em> <br/>\n\nI spoke with tannenba, and he mentioned what he'd like. So I'll be writing it shortly.\n\n<p></p><hr/>\n<em>2011-Apr-26 15:50:23 by psilord:</em> <br/>\n\nI'm doing my testing again to see what needs to be implemented.\n\n<p></p><hr/>\n<em>2011-Apr-29 12:42:44 by psilord:</em> <br/>\n\nOk, here is the first draft. Ask any questions and I'll update the document with their answers.\n\n<p></p><hr/>\n<em>2011-Sep-09 16:46:00 by psilord:</em> <br/>\n\nMeh, the New Design portion is maybe 80% done. It doesn't talk about file management very well yet and I haven't incorporated some of your comments into the document either.\n\n<p>If what is here is enough, fine, if not, let me know and I'll continue writing.\n\n</p><p></p><hr/>\n<em>2011-Sep-13 16:22:05 by psilord:</em> <br/>\n\nOk, this is around 90% of the finished rough draft. I need another round of commentary and a second set of eyes on it before it can be moved to a status worthy of discussion by a larger group of people.\n\n<p></p><hr/>\n<em>2020-Sep-11 14:24:40 by tim:</em> <br/>\n\nWe have user level checkpointing in vanilla universe.</blockquote>", "derived_tickets": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">\n<span class=\"ticket\"><a class=\"abandoned\" href=\"/wiki-archive/tickets/?ticket=3138\" onclick=\"get_ticket_and_populate_wrapper('3138'); return false;\" title=\"Periodic evicts/fast restart in vanilla universe (checkpoints)\">#3138</a></span></td>\n<td align=\"center\" valign=\"center\" width=\"30\">\n<span class=\"icon ptr1\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\">\nPeriodic evicts/fast restart in vanilla universe (checkpoints)</td></tr>\n</tbody></table>", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "todo", "last_change": "2020-Sep-11 14:24", "status": "abandoned", "created": "2011-Mar-29 16:46", "fixed_version": "2011-Mar-29 16:46", "broken_version": "", "priority": "5", "subsystem": "Std", "assigned_to": "adesmet", "derived_from": "#1956", "creator": "psilord", "rust": "", "customer_group": "ligo", "visibility": "public", "notify": "tannenba@cs.wisc.edu,pcouvare@caltech.edu", "due_date": "20110429"}