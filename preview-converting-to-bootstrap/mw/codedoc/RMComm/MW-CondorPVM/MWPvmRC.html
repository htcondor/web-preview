<html><head><TITLE>MWPvmRC</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  MWPvmRC : public MWRMComm </H2><BLOCKQUOTE>

A Resource Management and Communication class that uses PVM 
for underlying support of inter-process communication and 
resource management
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="MMWRMComm,M,CMWPvmRC,MMWPvmRC.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.2.5"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>MWPvmRC</B>() </B>
 <DD><I>Constructor...</I>
<DT><A HREF="#DOC.2.6"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>~MWPvmRC</B>() </B>
 <DD><I>Destructor...</I>
</DL><DL>
<DT><h3>Public</h3><DD><DT><A HREF="#DOC.2.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>A. Resource Management Routines</B> </B>
 <DD><I></I>

<DL>
<DT><A HREF="#DOC.2.1.1"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>exit</B>( int exitval ) </B>
 <DD><I>Shut down</I>
<DT><A HREF="#DOC.2.1.2"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>setup</B>( int argc, char *argv[], int *my_id, int *master_id ) </B>
 <DD><I>Initialization</I>
<DT><A HREF="#DOC.2.1.3"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>config</B>( int *nhosts, int *narches, MWWorkerID ***workers ) </B>
 <DD><I>Does a pvm_config, and stuffs the returned hostinfo
struct information into a lot of MWWorkerID's</I>
<DT><A HREF="#DOC.2.1.4"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>start_worker</B>( MWWorkerID *w ) </B>
 <DD><I>Basically do a pvm_spawn</I>
<DT><A HREF="#DOC.2.1.5"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>init_beginning_workers</B>( int *nworkers, MWWorkerID ***workers ) </B>
 <DD><I>Start up the workers that are given to us at the beginning</I>
<DT><A HREF="#DOC.2.1.9"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>restart_beginning_workers</B>( int *nworkers, MWWorkerID ***workers, MWmessages msg ) </B>
 <DD><I>Called at the time of restart </I>
<DT><A HREF="#DOC.2.1.6"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>removeWorker</B>( MWWorkerID *w ) </B>
 <DD><I>Remove a worker</I>
<DT><A HREF="#DOC.2.1.7"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>read_RMstate</B>( FILE *fp ) </B>
 <DD><I>Read some state</I>
<DT><A HREF="#DOC.2.1.8"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>write_RMstate</B>( FILE *fp ) </B>
 <DD><I>Write some state</I>

</DL>
<DT><A HREF="#DOC.2.3"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>C. Communication Routines</B> </B>
 <DD><I></I>

<DL>
<DT><A HREF="#DOC.2.3.1"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>initsend</B>( int encoding = PvmDataDefault) </B>
 <DD><I></I>
<DT><A HREF="#DOC.2.3.2"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>send</B>( int to_whom, int msgtag ) </B>
 <DD><I></I>
<DT><A HREF="#DOC.2.3.3"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>recv</B>( int from_whom, int msgtag ) </B>
 <DD><I></I>
<DT><A HREF="#DOC.2.3.4"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>bufinfo</B>( int buf_id, int *len, int *tag, int *from ) </B>
 <DD><I>Provide info on the message just received </I>
<DT><A HREF="#DOC.2.3.5"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>who</B>( int *id ) </B>
 <DD><I>Tells the affected party </I>
<DT><A HREF="#DOC.2.3.6"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>pack</B>( char *bytes, int nitem, int stride = 1 ) </B>
 <DD><I>Pack some bytes</I>
<DT><A HREF="#DOC.2.3.7"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>pack</B>( float *f, int nitem, int stride = 1 ) </B>
 <DD><I>float</I>
<DT><A HREF="#DOC.2.3.8"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>pack</B>( double *d, int nitem, int stride = 1 ) </B>
 <DD><I>double</I>
<DT><A HREF="#DOC.2.3.9"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>pack</B>( int *i, int nitem, int stride = 1 ) </B>
 <DD><I>int</I>
<DT><A HREF="#DOC.2.3.10"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>pack</B>( unsigned int *ui, int nitem, int stride = 1 ) </B>
 <DD><I>unsigned int</I>
<DT><A HREF="#DOC.2.3.11"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>pack</B>( short *sh, int nitem, int stride = 1 ) </B>
 <DD><I>short</I>
<DT><A HREF="#DOC.2.3.12"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>pack</B>( unsigned short *ush, int nitem, int stride = 1 ) </B>
 <DD><I>unsigned short</I>
<DT><A HREF="#DOC.2.3.13"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>pack</B>( long *l, int nitem, int stride = 1 ) </B>
 <DD><I>long</I>
<DT><A HREF="#DOC.2.3.14"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>pack</B>( unsigned long *ul, int nitem, int stride = 1 ) </B>
 <DD><I>unsigned long</I>
<DT><A HREF="#DOC.2.3.15"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>pack</B>( char *str ) </B>
 <DD><I>Pack a NULL-terminated string</I>
<DT><A HREF="#DOC.2.3.16"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>unpack</B>( char *bytes, int nitem, int stride = 1 ) </B>
 <DD><I>Unpack some bytes</I>
<DT><A HREF="#DOC.2.3.17"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>unpack</B>( float *f, int nitem, int stride = 1 ) </B>
 <DD><I>float</I>
<DT><A HREF="#DOC.2.3.18"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>unpack</B>( double *d, int nitem, int stride = 1 ) </B>
 <DD><I>double</I>
<DT><A HREF="#DOC.2.3.19"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>unpack</B>( int *i, int nitem, int stride = 1 ) </B>
 <DD><I>int</I>
<DT><A HREF="#DOC.2.3.20"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>unpack</B>( unsigned int *ui, int nitem, int stride = 1 ) </B>
 <DD><I>unsigned int</I>
<DT><A HREF="#DOC.2.3.21"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>unpack</B>( short *sh, int nitem, int stride = 1 ) </B>
 <DD><I>short</I>
<DT><A HREF="#DOC.2.3.22"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>unpack</B>( unsigned short *ush, int nitem, int stride = 1 ) </B>
 <DD><I>unsigned short</I>
<DT><A HREF="#DOC.2.3.23"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>unpack</B>( long *l, int nitem, int stride = 1 ) </B>
 <DD><I>long</I>
<DT><A HREF="#DOC.2.3.24"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>unpack</B>( unsigned long *ul, int nitem, int stride = 1 ) </B>
 <DD><I>unsigned long</I>
<DT><A HREF="#DOC.2.3.25"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>unpack</B>( char *str ) </B>
 <DD><I>Unpack a NULL-terminated string</I>

</DL>
</DL><DL>
<DT><h3>Private Fields</h3><DD><DT><A HREF="#DOC.2.7"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>is_master</B> </B>
 <DD><I>Am I the master process or not? </I>
</DL><DL>
<DT><h3>Private</h3><DD><DT><A HREF="#DOC.2.4"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>C. Some Misc Helper functions</B> </B>
 <DD><I></I>

<DL>
<DT><A HREF="#DOC.2.4.1"> <IMG BORDER=0 SRC=icon1.gif></A>  struct  condorpvm_submit_element* find_exec_class int <B>arch</B> </B>
 <DD><I>Find a suitable executable_class for a particular arch_class</I>
<DT><A HREF="#DOC.2.4.2"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>choose_exec_class</B>( int *tempi ) </B>
 <DD><I>In the beginning, find a exec_class to an already
acquired arch_class </I>
<DT><A HREF="#DOC.2.4.3"> <IMG BORDER=0 SRC=icon1.gif></A> char*  <B>find_executable</B>( int ex_cl, int ar_cl ) </B>
 <DD><I>Find the appropriate executable name that belongs to exec_class ex_cl and
arch_class ar_cl </I>
<DT><A HREF="#DOC.2.4.4"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>sort_exec_class_ratio</B>( int *temp ) </B>
 <DD><I>Sort the array temp based on the ratio of current/desired
number of workers of each exec_class </I>
<DT><A HREF="#DOC.2.4.5"> <IMG BORDER=0 SRC=icon1.gif></A> char*  <B>exists_executable</B>( int ex_cl, int ar_cl ) </B>
 <DD><I>Find if there is an executable that belongs to exec_class ex_cl and
arch_class ar_cl and if it exists return the executable name </I>

</DL>
<DT><A HREF="#DOC.2.2"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Other Functions to be implemented </B> </B>
 <DD><I></I>

<DL>
<DT><A HREF="#DOC.2.2.1"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>hostaddlogic</B>( int *num_workers ) </B>
 <DD><I>Figure out wether or not to ask for hosts, and how many</I>
<DT><A HREF="#DOC.2.2.5"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>do_spawn</B>( MWWorkerID *w ) </B>
 <DD><I>Do the pvm_spawn and associated stuff </I>
<DT><A HREF="#DOC.2.2.6"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>setup_notifies</B>( int task_tid ) </B>
 <DD><I>Set up the proper notifies for a task &amp; host tid </I>
<DT><A HREF="#DOC.2.2.2"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>ask_for_host</B>( int howmany, int archnum ) </B>
 <DD><I>This function says to pvm: "I would like another machine, 
please"</I>
<DT><A HREF="#DOC.2.2.3"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>conf</B>() </B>
 <DD><I>Shows the pvm virtual machine according to pvm</I>
<DT><A HREF="#DOC.2.2.4"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>min</B>( int *array, int len ) </B>
 <DD><I>Helper for hostaddlogic()</I>
<DT><A HREF="#DOC.2.2.7"> <IMG BORDER=0 SRC=icon1.gif></A>  <B></B> </B>
 <DD><I>The number of outstanding requests for a particular 
arch</I>
<DT><A HREF="#DOC.2.2.8"> <IMG BORDER=0 SRC=icon1.gif></A> int**  <B>hostadd_reqs</B> </B>
 <DD><I>The requests per exec_classes </I>

</DL>
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

A Resource Management and Communication class that uses PVM 
for underlying support of inter-process communication and 
resource management.<P>We *could* do cool things here...like keep track of amount of
data sent, to whom, etc.  We could also MWprintf ( 99, "..." )
everything that gets sent for heaps and heaps of debugging.


</BLOCKQUOTE>
<DL>

<A NAME="MWPvmRC">
<A NAME ="DOC.2.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  MWPvmRC()</B></TT>
<DD>Constructor...
<DL></DL><P>
<A NAME="~MWPvmRC">
<A NAME ="DOC.2.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  ~MWPvmRC()</B></TT>
<DD>Destructor...
<DL></DL><P>
<A NAME="A. Resource Management Routines">
<A NAME ="DOC.2.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  A. Resource Management Routines</B></TT>
<DD>
Here we implement the pure virtual functions found in 
ur parent class, MWRMComm.
<DL></DL><P><DL>

<A NAME="exit">
<A NAME ="DOC.2.1.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  exit( int exitval )</B></TT>
<DD>Shut down.  Calls pvm_exit(), then ::exit(exitval). 
<DL></DL><P>
<A NAME="setup">
<A NAME ="DOC.2.1.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  setup( int argc, char *argv[], int *my_id, int *master_id )</B></TT>
<DD>Initialization.  Does pvm_catchout(), pvm_parent(), 
and pvm_notifies(). 
<DL></DL><P>
<A NAME="config">
<A NAME ="DOC.2.1.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  config( int *nhosts, int *narches, MWWorkerID ***workers )</B></TT>
<DD>Does a pvm_config, and stuffs the returned hostinfo
struct information into a lot of MWWorkerID's.  See
the parent class for return details.  
<DL></DL><P>
<A NAME="start_worker">
<A NAME ="DOC.2.1.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  start_worker( MWWorkerID *w )</B></TT>
<DD>Basically do a pvm_spawn.  We also put some information
into w upon return.

<DL><DT><B>Returns:</B><DD>The tid spawned.  Negative number on error.
</DL><P>
<A NAME="init_beginning_workers">
<A NAME ="DOC.2.1.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  init_beginning_workers( int *nworkers, MWWorkerID ***workers )</B></TT>
<DD>Start up the workers that are given to us at the beginning. 
See base class comments for more details.

<DL><DT><B>Parameters:</B><DD><B>nworkers</B> -  The number of workers at start
<br><B>workers</B> -  A pointer to an array of pointers to 
MWWorkerID classes.  This call will new() memory 
for the MWWorkerIDs.  Also, if (*w)[n]-&gt;id2 is
-1, that means that the spawn failed for 
worker number n.<br></DL><P>
<A NAME="restart_beginning_workers">
<A NAME ="DOC.2.1.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  restart_beginning_workers( int *nworkers, MWWorkerID ***workers, MWmessages msg )</B></TT>
<DD>Called at the time of restart 
<DL></DL><P>
<A NAME="removeWorker">
<A NAME ="DOC.2.1.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  removeWorker( MWWorkerID *w )</B></TT>
<DD>Remove a worker.  Basically, call pvm_delhosts(). 
<DL></DL><P>
<A NAME="read_RMstate">
<A NAME ="DOC.2.1.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  read_RMstate( FILE *fp )</B></TT>
<DD>Read some state. A null function 
<DL></DL><P>
<A NAME="write_RMstate">
<A NAME ="DOC.2.1.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  write_RMstate( FILE *fp )</B></TT>
<DD>Write some state. A null function 
<DL></DL><P></DL>

<A NAME="Other Functions to be implemented ">
<A NAME ="DOC.2.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Other Functions to be implemented </B></TT>
<DL></DL><P><DL>

<A NAME="hostaddlogic">
<A NAME ="DOC.2.2.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  hostaddlogic( int *num_workers )</B></TT>
<DD>Figure out wether or not to ask for hosts, and how many... 

<DL><DT><B>Parameters:</B><DD><B>num_workers</B> -  An array of size num_arches that contains
the number of workers in each arch class.<br></DL><P>
<A NAME="do_spawn">
<A NAME ="DOC.2.2.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  do_spawn( MWWorkerID *w )</B></TT>
<DD>Do the pvm_spawn and associated stuff 
<DL></DL><P>
<A NAME="setup_notifies">
<A NAME ="DOC.2.2.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  setup_notifies( int task_tid )</B></TT>
<DD>Set up the proper notifies for a task &amp; host tid 
<DL></DL><P>
<A NAME="ask_for_host">
<A NAME ="DOC.2.2.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  ask_for_host( int howmany, int archnum )</B></TT>
<DD>This function says to pvm: "I would like another machine, 
please"
<DL><DT><B>Parameters:</B><DD><B>howmany</B> -  The number of machines to request
<br><B>archnum</B> -  The arch class number to ask for. <br></DL><P>
<A NAME="conf">
<A NAME ="DOC.2.2.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  conf()</B></TT>
<DD>Shows the pvm virtual machine according to pvm.  Used
for debugging purposes; not normally called. 
<DL></DL><P>
<A NAME="min">
<A NAME ="DOC.2.2.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  min( int *array, int len )</B></TT>
<DD>Helper for hostaddlogic().  Returns the index of the min
element in array, which is of length len 
<DL></DL><P>
<A NAME="">
<A NAME ="DOC.2.2.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  </B></TT>
<DD>The number of outstanding requests for a particular 
arch
<DL></DL><P>
<A NAME="hostadd_reqs">
<A NAME ="DOC.2.2.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int**  hostadd_reqs</B></TT>
<DD>The requests per exec_classes 
<DL></DL><P></DL>

<A NAME="is_master">
<A NAME ="DOC.2.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  is_master</B></TT>
<DD>Am I the master process or not? 
<DL></DL><P>
<A NAME="C. Communication Routines">
<A NAME ="DOC.2.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  C. Communication Routines</B></TT>
<DD>
These are essentially thin wrappers of PVM calls.
<DL></DL><P><DL>

<A NAME="initsend">
<A NAME ="DOC.2.3.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  initsend( int encoding = PvmDataDefault)</B></TT>
<DL></DL><P>
<A NAME="send">
<A NAME ="DOC.2.3.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  send( int to_whom, int msgtag )</B></TT>
<DL></DL><P>
<A NAME="recv">
<A NAME ="DOC.2.3.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  recv( int from_whom, int msgtag )</B></TT>
<DL></DL><P>
<A NAME="bufinfo">
<A NAME ="DOC.2.3.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  bufinfo( int buf_id, int *len, int *tag, int *from )</B></TT>
<DD>Provide info on the message just received 
<DL></DL><P>
<A NAME="who">
<A NAME ="DOC.2.3.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  who( int *id )</B></TT>
<DD>Tells the affected party 
<DL></DL><P>
<A NAME="pack">
<A NAME ="DOC.2.3.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  pack( char *bytes, int nitem, int stride = 1 )</B></TT>
<DD>Pack some bytes
<DL></DL><P>
<A NAME="pack">
<A NAME ="DOC.2.3.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  pack( float *f, int nitem, int stride = 1 )</B></TT>
<DD>float
<DL></DL><P>
<A NAME="pack">
<A NAME ="DOC.2.3.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  pack( double *d, int nitem, int stride = 1 )</B></TT>
<DD>double
<DL></DL><P>
<A NAME="pack">
<A NAME ="DOC.2.3.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  pack( int *i, int nitem, int stride = 1 )</B></TT>
<DD>int
<DL></DL><P>
<A NAME="pack">
<A NAME ="DOC.2.3.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  pack( unsigned int *ui, int nitem, int stride = 1 )</B></TT>
<DD>unsigned int
<DL></DL><P>
<A NAME="pack">
<A NAME ="DOC.2.3.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  pack( short *sh, int nitem, int stride = 1 )</B></TT>
<DD>short
<DL></DL><P>
<A NAME="pack">
<A NAME ="DOC.2.3.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  pack( unsigned short *ush, int nitem, int stride = 1 )</B></TT>
<DD>unsigned short
<DL></DL><P>
<A NAME="pack">
<A NAME ="DOC.2.3.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  pack( long *l, int nitem, int stride = 1 )</B></TT>
<DD>long
<DL></DL><P>
<A NAME="pack">
<A NAME ="DOC.2.3.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  pack( unsigned long *ul, int nitem, int stride = 1 )</B></TT>
<DD>unsigned long
<DL></DL><P>
<A NAME="pack">
<A NAME ="DOC.2.3.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  pack( char *str )</B></TT>
<DD>Pack a NULL-terminated string
<DL></DL><P>
<A NAME="unpack">
<A NAME ="DOC.2.3.16">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  unpack( char *bytes, int nitem, int stride = 1 )</B></TT>
<DD>Unpack some bytes
<DL></DL><P>
<A NAME="unpack">
<A NAME ="DOC.2.3.17">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  unpack( float *f, int nitem, int stride = 1 )</B></TT>
<DD>float
<DL></DL><P>
<A NAME="unpack">
<A NAME ="DOC.2.3.18">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  unpack( double *d, int nitem, int stride = 1 )</B></TT>
<DD>double
<DL></DL><P>
<A NAME="unpack">
<A NAME ="DOC.2.3.19">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  unpack( int *i, int nitem, int stride = 1 )</B></TT>
<DD>int
<DL></DL><P>
<A NAME="unpack">
<A NAME ="DOC.2.3.20">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  unpack( unsigned int *ui, int nitem, int stride = 1 )</B></TT>
<DD>unsigned int
<DL></DL><P>
<A NAME="unpack">
<A NAME ="DOC.2.3.21">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  unpack( short *sh, int nitem, int stride = 1 )</B></TT>
<DD>short
<DL></DL><P>
<A NAME="unpack">
<A NAME ="DOC.2.3.22">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  unpack( unsigned short *ush, int nitem, int stride = 1 )</B></TT>
<DD>unsigned short
<DL></DL><P>
<A NAME="unpack">
<A NAME ="DOC.2.3.23">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  unpack( long *l, int nitem, int stride = 1 )</B></TT>
<DD>long
<DL></DL><P>
<A NAME="unpack">
<A NAME ="DOC.2.3.24">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  unpack( unsigned long *ul, int nitem, int stride = 1 )</B></TT>
<DD>unsigned long
<DL></DL><P>
<A NAME="unpack">
<A NAME ="DOC.2.3.25">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  unpack( char *str )</B></TT>
<DD>Unpack a NULL-terminated string
<DL></DL><P></DL>

<A NAME="C. Some Misc Helper functions">
<A NAME ="DOC.2.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  C. Some Misc Helper functions</B></TT>
<DL></DL><P><DL>

<A NAME="arch">
<A NAME ="DOC.2.4.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  struct  condorpvm_submit_element* find_exec_class int arch</B></TT>
<DD>Find a suitable executable_class for a particular arch_class.
This function is useful to pick up the executable 
<DL></DL><P>
<A NAME="choose_exec_class">
<A NAME ="DOC.2.4.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int  choose_exec_class( int *tempi )</B></TT>
<DD>In the beginning, find a exec_class to an already
acquired arch_class 
<DL></DL><P>
<A NAME="find_executable">
<A NAME ="DOC.2.4.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> char*  find_executable( int ex_cl, int ar_cl )</B></TT>
<DD>Find the appropriate executable name that belongs to exec_class ex_cl and
arch_class ar_cl 
<DL></DL><P>
<A NAME="sort_exec_class_ratio">
<A NAME ="DOC.2.4.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  sort_exec_class_ratio( int *temp )</B></TT>
<DD>Sort the array temp based on the ratio of current/desired
number of workers of each exec_class 
<DL></DL><P>
<A NAME="exists_executable">
<A NAME ="DOC.2.4.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> char*  exists_executable( int ex_cl, int ar_cl )</B></TT>
<DD>Find if there is an executable that belongs to exec_class ex_cl and
arch_class ar_cl and if it exists return the executable name 
<DL></DL><P></DL>
</DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P></BODY><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++
<P Align=Center>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&oumlckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de </a>