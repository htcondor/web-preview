{"id": 7849, "title": "Ticket #7849: AES non-negotiated session backwards compatibility", "description": "<blockquote>\nThis work was moved to <a class=\"external\" href=\"https://opensciencegrid.atlassian.net/browse/HTCONDOR-233\">https://opensciencegrid.atlassian.net/browse/HTCONDOR-233</a>\n\n<p><span class=\"subsection\"></span></p><h3>Previous ticket content below break</h3>\n\n<p>I'm adding some content here to capture a Zoom meeting between Zach, ToddT, and BrianB on Nov 12, 2020.\n\n</p><p>On the call, we were discussing that there may not be a need for (all) the below mechanism(s) to implement backwards compatibility when using AES in non-negotiated sessions.  However, see in the discussion, I believe parts of the solution in this ticket are still necessary.\n\n</p><p>In versions of condor 8.9.10 and earlier:\n</p><ul>\n<li>When a startd creates it's private ad that it sends to the collector, it is including the list of supported crypto methods.  It creates a non-negotiated session using the private capability as the session key and with the method that is listed first in the list of SEC_*_CRYPTO_METHODS.\n</li><li>The Schedd also looks at just <strong>THE FIRST CHARACTER</strong> of this list, and creates an out-going non-negotiated session using the capability and crypto method associated with that character, either 'B'lowfish or '3'des.\n</li></ul>\n\n<p>In versions of condor 8.9.11 and later:\n</p><ul>\n<li>The startd will append \"B,\" to the list of methods that it includes in its ad sent to the collector\n</li><li>The schedd will take the first entry in the list that is a <strong>VALID</strong> name of a method.  \"BLOWFISH\" and \"AESGCM\" are the valid names.  \"B\" is not.\n</li></ul>\n\n<p>An old schedd will see \"B,AESGCM\" and will select BLOWFISH due to the first letter being 'B'.  A new schedd will see the \"B\" method, disregard the invalid name, and then select \"AESGCM'.\n\n</p><p><span class=\"subsubsection\"></span></p><h4>Discussion </h4>\nI believe this on its own is not suffecient.  The startd still needs to know which method the client is using when it is \"resuming\" the non-negotiated session.  So, as proposed below, new <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=SchedDs\" title=\"Sched Ds\">SchedDs</a></span> should add an attribute in the resume classad that indicates what method they are trying to use.  In that case, the startd still needs to either: 1) Create a session of both Blowfish and AES, so it is ready when a resume command comes in for either, or 2) Delay binding of the crypto type to the session until the command comes in.\n\n<p>I think I'm still in favor of the startd creating multiple sessions, one for each type of allowable crypto type.  To distinguish between which Either there should be an additional attribute in the resume classad, or new schedds could attach \"-AES\" to the session name, or something similar.\n\n</p><p></p><hr/>\n<span class=\"subsection\"><h3>Older Content</h3></span>\n\n<p>For non-negotiated sessions, how can we start using AES but maintain backwards compatibility?  In this ticket we'll brainstorm approaches with pros/cons.\n\n</p><p>Here's one rough crazy idea:\n\n</p><p>The startd creates two non-negotiated sessions to receive claims.  One uses 3DES and the private claim ID as the key.  The other uses AES.  Maybe they have different names.  The startd would have a knob to only use AES. (Avoiding an old TLS-style exploit involving forced selection of an older protocol).\n\n</p><p>The negotiator could put something in the match that it gives to the schedd depending on whether the match is given to a new or old schedd and whether its an old startd since it knowns the versions of both.  New schedds would then resume the AES session when talking to new startds, and everything else would use the 3DES one.  This requires the CM to be running an AES-supported negotiator.\n\n</p><p>Or, maybe better, the startd adds a special new attribute to its ad that new schedds then notice, and new schedds then do something in the resume session classad to indicate that they are resuming an AES session instead of a 3des one.  Old schedds would ignore the new startd attribute and resume the session without the special attribute.  New schedds can look at the version of the StartD they are claiming and not use it on old startds.\n\n</p><p>Something like that.\n\n</p><p>Other ideas?</p></blockquote>", "remarks": "<blockquote>\n<em>2020-Sep-09 22:55:55 by jfrey:</em> <br/>\n\nHere's a variation on your initial ideas: The startd puts a new attribute in the security policy ad of the claim id indicating it supports AES in addition to the stated crypto method for the session (3DES or BLOWFISH). A new schedd will recognize this attribute and put a new attribute in the resume session ad that indicates it wants to use AES. Old schedds would ignore the new attribute in the claim id and resume the session without the use-AES attribute. The negotiator doesn't need to do anything. And this can be used for any non-negotiated session, like the ones the schedd can now send to the negotiator and collector. If the startd only wants to support AES, then it just gives AES as the crypto method in the claim id.\n\n<p></p><hr/>\n<em>2020-Sep-10 09:07:08 by zmiller:</em> <br/>\n\nYeah, perfect.  That's kind of what I was thinking with my last paragraph but didn't quite have it spelled out.  I think that will work!\n\n<p></p><hr/>\n<em>2020-Sep-10 09:07:55 by zmiller:</em> <br/>\n\nThe question now is: how do we future-proof this mechanism for when we add &lt;ZKM65536&gt; encryption down the road?  Perhaps the startd advertises all of the methods it supports, the schedd can pick any one it likes and send that in the \"session resume\" and the startd does some kind of \"late binding session creation\" or \"late crypto method instantiation\" where it can resume a session that is known and pre-registered but with different crypto methods (as long as they are supported by the startd... i.e. the schedd can't pick one the startd has purposely disabled).\n\n<p></p><hr/>\n<em>2020-Sep-10 09:18:17 by jfrey:</em> <br/>\n\nThe new attribute in the claimid session info could be a list of all additional crypto methods the startd is willing to use. If the schedd wants to use a method other than the primary one in <code>CryptoMethods</code>, it can say which one in the resume session ad. This same idea could be applied to introducing new integrity algorithms.\n\n<p></p><hr/>\n<em>2020-Sep-10 09:20:27 by zmiller:</em> <br/>\n\nSlightly off-topic:  I think we could also use this trick to eliminate a round trip in normal (negotiated) session negotiation.  Likely an optimization for 9.1.X and it doesn't have as much gain now that the session resume is non-blocking, and more and more things are using pre-existing non-negotiated sessions, but here it is anyway:\n\n<p>If the client has the ad of the daemon it wants to connect to (e.g. because it got it from the collector, as most things do) then it could already know the list of methods that daemon supports.  It picks anything that it knows the server supports and in the initial resume message it just informs the server which methods they will be using and it immediately goes to authenticate.  This eliminates the [client-&gt;server: here are my methods ; server-&gt;client: okay, here's what we'll do] round trip.  The server of course still needs to enforce that whatever the client requests is allowable.  But otherwise I think this will work.\n\n</p><p></p><hr/>\n<em>2020-Sep-10 09:31:07 by jfrey:</em> <br/>\n\nI like the security negotiation optimization idea. We'd have to add the security policy stuff to the daemon ads and include the new attribute(s) in the locate projection. If the server doesn't like what the client says, it'd have to slam the door and send an out-of-band message, like with a rejected session resumption.\n\n<p></p><hr/>\n<em>2020-Jan-11 11:47:35 by zmiller:</em> <br/>\n\nDue date pushed back because of dependency on <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=6226\" onclick=\"get_ticket_and_populate_wrapper('6226'); return false;\" title=\"Use modern security encryption methods (AES supplied by openssl)\">#6226</a></span>.</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "enhance", "last_change": "2021-May-11 16:39", "status": "resolved", "created": "2020-Sep-09 10:30", "fixed_version": "2020-Sep-09 10:30", "broken_version": "", "priority": "2", "subsystem": "Security", "assigned_to": "zmiller", "derived_from": "#7850", "creator": "zmiller", "rust": "", "customer_group": "chtc", "visibility": "public", "notify": "zmiller@cs.wisc.edu, jfrey@cs.wisc.edu, tannenba@cs.wisc.edu", "due_date": "20210114"}