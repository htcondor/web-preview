diff -rNup condor-7.4.1.orig/src/condor_negotiator.V6/matchmaker.cpp condor-7.4.1/src/condor_negotiator.V6/matchmaker.cpp
--- condor-7.4.1.orig/src/condor_negotiator.V6/matchmaker.cpp	2010-03-25 13:49:30.000000000 -0400
+++ condor-7.4.1/src/condor_negotiator.V6/matchmaker.cpp	2010-06-03 14:13:37.000000000 -0400
@@ -36,6 +36,11 @@
 #include "condor_claimid_parser.h"
 #include "misc_utils.h"
 #include "ConcurrencyLimitUtils.h"
+#include "MyString.h"
+
+#include <vector>
+#include <string>
+
 
 #if HAVE_DLOPEN
 #include "NegotiatorPlugin.h"
@@ -48,6 +53,8 @@
 static int comparisonFunction (AttrList *, AttrList *, void *);
 #include "matchmaker.h"
 
+using namespace std;
+
 /* This extracts the machine name from the global job ID user@machine.name#timestamp#cluster.proc*/
 static int get_scheddname_from_gjid(const char * globaljobid, char * scheddname );
 
@@ -834,9 +841,9 @@ negotiationTime ()
 	ClaimIdHash claimIds(MyStringHash);
 	ClassAdList scheddAds;
 	ClassAdList allAds;
-	int unclaimedquota=0; 
-	int staticquota=0;
-	/**
+
+
+/**
 		Check if we just finished a cycle less than NEGOTIATOR_CYCLE_DELAY 
 		seconds ago.  If we did, reset our timer so at least 
 		NEGOTIATOR_CYCLE_DELAY seconds will elapse between cycles.  We do 
@@ -845,16 +852,15 @@ negotiationTime ()
 		the same resource twice).  Note: we must do this check _before_ we 
 		reset GotRescheduledCmd to false to prevent postponing a new 
 		cycle indefinitely.
-	**/
+**/
 	int elapsed = time(NULL) - completedLastCycleTime;
 	int cycle_delay = param_integer("NEGOTIATOR_CYCLE_DELAY",20,0);
 	if ( elapsed < cycle_delay ) {
-		daemonCore->Reset_Timer(negotiation_timerID,
-							cycle_delay - elapsed,
+		daemonCore->Reset_Timer(negotiation_timerID,cycle_delay - elapsed,
 							NegotiatorInterval);
 		dprintf(D_FULLDEBUG,
 			"New cycle requested but just finished one -- delaying %u secs\n",
-			cycle_delay - elapsed);
+				cycle_delay - elapsed);
 		return FALSE;
 	}
 
@@ -864,18 +870,17 @@ negotiationTime ()
 
 	// We need to nuke our MatchList from the previous negotiation cycle,
 	// since a different set of machines may now be available.
+
 	if (MatchList) delete MatchList;
 	MatchList = NULL;
 
 	// ----- Get all required ads from the collector
 	dprintf( D_ALWAYS, "Phase 1:  Obtaining ads from collector ...\n" );
-	if( !obtainAdsFromCollector( allAds, startdAds, scheddAds,
-		claimIds ) )
-	{
+	if( !obtainAdsFromCollector( allAds, startdAds, scheddAds, claimIds ) ) {
 		dprintf( D_ALWAYS, "Aborting negotiation cycle\n" );
 		// should send email here
 		return FALSE;
-	}
+		}
 
 	// Save this for future use.
 	// This _must_ come before trimming the startd ads.
@@ -883,16 +888,17 @@ negotiationTime ()
 	int numDynGroupSlots = untrimmed_num_startds;
 	double minSlotWeight = 0;
 	double untrimmedSlotWeightTotal = sumSlotWeights(startdAds,&minSlotWeight);
-	float unclaimed = 0;
-	
+
+	dprintf( D_ALWAYS, "Phase 1: numDynGroupSlots %d  untrimmedSlotWeightTotal %f \n" ,numDynGroupSlots,untrimmedSlotWeightTotal  );
 	// Register a lookup function that passes through the list of all ads.
 	// ClassAdLookupRegister( lookup_global, &allAds );
 
 	// Compute the significant attributes to pass to the schedd, so
 	// the schedd can do autoclustering to speed up the negotiation cycles.
+
 	if ( job_attr_references ) {
 		free(job_attr_references);
-	}
+		}
 	job_attr_references = compute_significant_attrs(startdAds);
 
 	// ----- Recalculate priorities for schedds
@@ -905,381 +911,600 @@ negotiationTime ()
 	// any of the claimed machines!).
 	int num_trimmed = trimStartdAds(startdAds);
 	if ( num_trimmed > 0 ) {
-		dprintf(D_FULLDEBUG,
-			"Trimmed out %d startd ads not Unclaimed\n",num_trimmed);
+		dprintf(D_FULLDEBUG, "Trimmed out %d startd ads not Unclaimed\n",num_trimmed);
 	}
 
-		// We insert NegotiatorMatchExprXXX attributes into the
-		// "matched ad".  In the negotiator, this means the machine ad.
-		// The schedd will later propogate these attributes into the
-		// matched job ad that is sent to the startd.  So in different
-		// matching contexts, the negotiator match exprs are in different
-		// ads, but they should always be in at least one.
+	// We insert NegotiatorMatchExprXXX attributes into the
+	// "matched ad".  In the negotiator, this means the machine ad.
+	// The schedd will later propogate these attributes into the
+	// matched job ad that is sent to the startd.  So in different
+	// matching contexts, the negotiator match exprs are in different
+	// ads, but they should always be in at least one.
 	insertNegotiatorMatchExprs( startdAds );
 
 	if ( !groupQuotasHash ) {
 		groupQuotasHash = new groupQuotasHashType(100,HashFunc);
 		ASSERT(groupQuotasHash);
-	}
-
-	char *groups = param("GROUP_NAMES");
-	if ( groups ) {
+		}
+	
+	// need to construct group structure
+	// groups is list of group names
+       // in form group.subgroup group.subgroup.subgroup etc
+	
+	char *groupnames = param("GROUP_NAMES"); // need to  change over to std:string at some point
+	string groups;
+	if ( groupnames ) {
 
-		// HANDLE GROUPS (as desired by CDF)
+	// HANDLE GROUPS (as desired by CDF)
 
-		// Populate the groupArray, which contains an entry for
-		// each group.
-		SimpleGroupEntry* groupArray;
-		int i;
-		StringList groupList;		
-		strlwr(groups); // the accountant will want lower case!!!
-		groupList.initializeFromString(groups);
-		free(groups);		
-		groupArray = new SimpleGroupEntry[ groupList.number()+1 ];
-		ASSERT(groupArray);
-		int* numsubmits = new int[groupList.number()+1];
-		ASSERT(numsubmits);
+	// Populate the groupArray, which contains an entry for
+	// each group.
+	
+	unsigned i; //a reused counter
+			
+	strlwr(groupnames); // the accountant will want lower case!!!	
+	string groupList(groupnames);
+	free(groupnames);	
+	std::vector<SimpleGroupEntry> groupArray(1);
+	SimpleGroupEntry tempentry;
+	// first step is to build top tier group
+	// name is null for now to avoid overlap between group names in the config
+	
+	groupArray[0].groupName.assign("\0");
+	groupArray[0].maxAllowed = (float)numDynGroupSlots;  
+	groupArray[0].quota = 1;  
+	groupArray[0].usage = 0;
+	groupArray[0].parent = -1;
+	groupArray[0].child = -1; 
+	groupArray[0].left =-1;
+	groupArray[0].right = -1;
+	groupArray[0].numsubmits=0; 
+	groupArray[0].nodequota=0;
+	groupArray[0].nodemaxAllowed=0;
+	groupArray[0].unused=0;
+	groupArray[0].autoregroup=true;
+	
+	
         // Restrict number of slots available for dynamic quotas.
         if ( numDynGroupSlots && DynQuotaMachConstraint ) {
-            int matchedSlots = startdAds.Count( DynQuotaMachConstraint );
-            if ( matchedSlots ) {
-                dprintf(D_FULLDEBUG,
-                    "GROUP_DYNAMIC_MACH_CONSTRAINT constraint reduces machine "
-                    "count from %d to %d\n", numDynGroupSlots, matchedSlots);
-                numDynGroupSlots = matchedSlots;
-            } else {
-                dprintf(D_ALWAYS, "warning: 0 out of %d machines match "
-                        "GROUP_DYNAMIC_MACH_CONSTRAINT for dynamic quotas\n",
-                        numDynGroupSlots);
-                numDynGroupSlots = 0;
-            }
+		int matchedSlots = startdAds.Count( DynQuotaMachConstraint );
+            	if ( matchedSlots ) {
+                	dprintf(D_ALWAYS,"GROUP_DYNAMIC_MACH_CONSTRAINT constraint reduces machine "
+                		"count from %d to %d\n", numDynGroupSlots, matchedSlots);
+                	numDynGroupSlots = matchedSlots;
+            	} else {
+                	dprintf(D_ALWAYS, "warning: 0 out of %d machines match "
+                        	"GROUP_DYNAMIC_MACH_CONSTRAINT for dynamic quotas\n",
+                        	numDynGroupSlots);
+                	numDynGroupSlots = 0;
+            	}
         }
 
-		MyString tmpstr;
-		i = 0;
-		groupQuotasHash->clear();		
-		int unusedslots=0;
-		double quota_fraction;
-		float totalgroupquota=0;
-		groupList.rewind();
-		while ((groups = groupList.next ()))
-		{
-			tmpstr.sprintf("GROUP_QUOTA_%s",groups);
-			float quota = param_double(tmpstr.Value(), -1.0 );
-			if ( quota >= 0.0 ) {
-                // Static groups quotas take priority over any dynamic quota
-                dprintf(D_FULLDEBUG, "group %s static quota = %.3f\n",
-                        groups, quota);
-		staticquota=1;	
-            } else {
-                // Next look for a floating point dynamic quota.
-                tmpstr.sprintf("GROUP_QUOTA_DYNAMIC_%s", groups);
-                double quota_fraction =
-                    param_double(
-                        tmpstr.Value(),     // name
-                        0.0,                // default value
-                        0.0,                // min value
-                        1.0                 // max value
-                    );
-                if (quota_fraction != 0.0) {
-                    // use specified dynamic quota
-                    quota = rint(quota_fraction * numDynGroupSlots);
-                    dprintf(D_FULLDEBUG,
-                        "group %s dynamic quota for %d slots = %.3f\n",
-                            groups, numDynGroupSlots, quota);
-                } else {
-                    // neither a static nor dynamic quota was defined
-                    dprintf(D_ALWAYS,
-                        "ERROR - no quota specified for group %s, ignoring\n",
-                        groups);
-                    continue;
-                }
-            }
-            if ( quota <= 0 ) {
-                // Quota for group may have been set to zero by admin.
-                dprintf(D_ALWAYS,
-                    "zero quota for group %s, ignoring\n",
-                    groups);
-                continue;
-            }
-
-			// store this groups quota into our groupQuotas hash so we 
-			// can easily retrieve the quota for this group elsewhere in 
-			// this class.
-			MyString groupQuotaKey(groups);
-			groupQuotasHash->insert(groupQuotaKey,quota);
-
-			// fill in the info into the groupArray, so we can sort
-			// the groups into the order we want to negotiate them.
-			float usage = accountant.GetWeightedResourcesUsed(groups);
-			groupArray[i].groupName = groups;  // don't free this! (in groupList)
-			groupArray[i].maxAllowed = quota;
-			groupArray[i].usage = usage;
-				// the 'prio' field is used to sort the group array, i.e. to
-				// decide which groups get to negotiate first.  
-				// we sort groups based upon the percentage of their quota
-				// currently being used, so that groups using the least 
-				// percentage amount of their quota get to negotiate first.
-			groupArray[i].prio = ( 100 * usage ) / quota;
-			dprintf(D_FULLDEBUG,
-				"Group Table : group %s quota %.3f usage %.3f prio %2.2f\n",
-					groups,quota,usage,groupArray[i].prio);
-		if (!staticquota){
+	MyString tmpstr; // need to change this over to std:string at some point	
+	double quota_fraction;		
+	size_t found;
+
+	//group names should be a comma delimied list
+	//we clean white space from the string
+	found=groupList.find_first_of(" ");
+	while(found!=string::npos){	
+		groupList.erase(found,1);
+		found=groupList.find_first_of(" ");
+	}
+	
+
+	while (!groupList.empty()) {
+		unsigned delim=groupList.find_first_of(",");
+		if (delim==-1) { 
+			groups=groupList;
+			groupList.erase();
+		} else {
+			groups=groupList.substr(0,delim);
+			if (delim+1<groupList.length()) groupList=groupList.substr(delim+1,groupList.length());
+		}
+		tmpstr.sprintf("GROUP_QUOTA_%s",groups.c_str());
+		quota_fraction = param_double(tmpstr.Value(), -1.0 );
+		if ( quota_fraction >= 0.0 ) {
+                	// Static groups quotas take priority over any dynamic quota
+                	dprintf(D_FULLDEBUG, "group %s static quota = %.3f\n", groups.c_str(), quota_fraction);
+			tempentry.staticquota=true;			
+		} else {
+                	// Next look for a floating point dynamic quota.
+                	tmpstr.sprintf("GROUP_QUOTA_DYNAMIC_%s", groups.c_str());
+                	quota_fraction =
+                    		param_double(
+                        		tmpstr.Value(),     // name
+                        		0.0,                // default value
+                        		0.0,                // min value
+                        		1.0                 // max value
+                    			);
+                	if (quota_fraction != 0.0) {
+                    		// use specified dynamic quota
+                    		//quota = rint(quota_fraction * numDynGroupSlots);
+                    		dprintf(D_FULLDEBUG, "group %s dynamic quota for %d slots = %.3f\n",
+                            		groups.c_str(), numDynGroupSlots, quota_fraction);
+                	} else {
+                    		// neither a static nor dynamic quota was defined
+                    		dprintf(D_ALWAYS, "ERROR - no quota specified for group %s - ignoring\n",
+                        		groups.c_str());
+                    		continue;
+                 	}
+			tempentry.staticquota=false;
+            	}
+
+		// fill in the info into the groupArray, so we can sort
+		// the groups into the order we want to negotiate them.
+		
+		float usage = accountant.GetWeightedResourcesUsed(groups.c_str());
+
+		tempentry.groupName=groups;
+		tempentry.maxAllowed = 0;  
+		tempentry.quota = quota_fraction;  
+		tempentry.nodequota=0;
+		tempentry.nodemaxAllowed=0;
+		tempentry.usage = usage;
+		tempentry.parent = -1;
+		tempentry.child = -1; 
+		tempentry.left =-1;
+		tempentry.right = -1;
+		tempentry.unused = 0;
+		tempentry.numsubmits=0;
+		tempentry.autoregroup = false;
+		
+		// the 'prio' field is used to sort the group array, i.e. to
+		// decide which groups get to negotiate first.  
+		// we sort groups based upon the percentage of their quota
+		// currently being used, so that groups using the least 
+		// percentage amount of their quota get to negotiate first.
+		
+		tempentry.prio = ( 100 * usage ) / quota_fraction;
+		dprintf(D_ALWAYS,"Group Table : group %s quota %.3f usage %.3f prio %2.2f\n",
+					groups.c_str(),quota_fraction,usage,tempentry.prio);
+
 			//now count total number of group submitters  and fix up quota
                 	int numrunning=0;
 			int numidle=0;
 			ClassAd *ad = NULL;
-			char scheddName[80];
-			numsubmits[i]=0;
+			//char scheddName[80];
+			string  scheddName;
 			scheddAds.Open();
+			size_t pos;
 			while( (ad=scheddAds.Next()) ) {
-				if (!ad->LookupString(ATTR_NAME, scheddName, sizeof(scheddName))) {
+				MyString temp;
+				string temp2,temp3;
+				if (!ad->LookupString(ATTR_NAME, temp)) {
 					continue;
 				}
-				scheddName[79] = '\0'; // make certain we have a terminating NULL
-				char *sep = strchr(scheddName,'.');	// is there a group seperator?
-				if ( !sep ) {
+				scheddName.assign(temp.Value());
+				// is there a username seperator?
+				pos= scheddName.find_last_of("@");
+				//look for last group seperator
+				//this should separate group from user
+				if ( pos==string::npos) {
 					continue;
 				};
-				 *sep = '\0'; 
-				if ( strcasecmp(scheddName,groups)==0 ) { 
+				temp2=scheddName.substr(0,pos);
+				pos= temp2.find_last_of(".");
+				// is there a group/user seperator? 
+				if ( pos==string::npos) { //assuming here that the last delimited item is a username
+					continue;        //if the user leaves this off, the subitters will appear as users
+					}                //at the parent level
+
+				temp3=temp2.substr(0,pos);
+				if ( temp3.compare(groups)==0 ) { 
 					numidle=0;
 					numrunning=0;
 					ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
 					ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
-		        		numsubmits[i]=numsubmits[i]+numrunning+numidle;
-            			}
-			} 		   
-		   	if( numsubmits[i]==0){
-		   		unusedslots=unusedslots+(int)groupArray[i].maxAllowed;		   
-		   	} else if(numsubmits[i]<quota ) {
-			 	unusedslots=unusedslots+(int)groupArray[i].maxAllowed-numsubmits[i];
-			}
-			totalgroupquota=totalgroupquota+quota;	
-			dprintf(D_FULLDEBUG, "group %s numgroupsubmits=%d quota=%f totalgroupquota=%f unusedslots=%d\n",groups, numsubmits[i], quota,totalgroupquota, unusedslots);
-		
-			} //if notstaticquota
-			i++;
-		} //while groups
-		int groupArrayLen = i;
-		
-
-			// pull out the submitter ads that specify a group from the
-			// scheddAds list, and insert them into a list specific to 
-			// the specified group.
-		ClassAd *ad = NULL;
-		char scheddName[80];
-		scheddAds.Open();
-		while( (ad=scheddAds.Next()) ) {
-			if (!ad->LookupString(ATTR_NAME, scheddName, sizeof(scheddName))) {
-				continue;
-			}
-			scheddName[79] = '\0'; // make certain we have a terminating NULL
-			char *sep = strchr(scheddName,'.');	// is there a group seperator?
-			if ( !sep ) {
-				continue;
+            				tempentry.numsubmits=tempentry.numsubmits+numrunning+numidle;					 
+					}
+           			
 			}
-			*sep = '\0';
-			for (i=0; i<groupArrayLen; i++) {
-				if ( strcasecmp(scheddName,groupArray[i].groupName)==0 ) {
-					groupArray[i].submitterAds.Insert(ad);
-					scheddAds.Delete(ad);
-					break;
+			
+		bool default_autoregroup = param_boolean("GROUP_AUTOREGROUP",false);
+		MyString autoregroup_param;
+		autoregroup_param.sprintf("GROUP_AUTOREGROUP_%s",tempentry.groupName.c_str());	
+		if(param_boolean(autoregroup_param.Value(),default_autoregroup))
+			tempentry.autoregroup=true;
+		else 
+			tempentry.autoregroup=false;
+			
+		dprintf(D_FULLDEBUG,"negotiationtime: slots %d group %s autoregroup %s\n",
+			numDynGroupSlots, tempentry.groupName.c_str(),(tempentry.autoregroup)?"true":"false");
+		//add the entry to the vector
+		groupArray.push_back(tempentry);	
+	
+	} //while ((groups = groupList.next ()))
+	// At this point all groups are in the group array and
+	// the group array has the number of submitters for each group at each level
+	// i will be the length of the group array	
+		
+	//groupArray[0] is top of the tree and is a group created so that we can put all users
+	//into some place in the tree
+	//leave the name null for now so it doesn't trip up the sort 
+	
+
+	// sort the list here
+	// leave non group users at end of array
+	dprintf(D_FULLDEBUG,"negotiationtime:sorting\n");
+	sort(groupArray,groupArray.size());
+
+	
+	for (i=0;i<groupArray.size();i++) {
+		dprintf(D_FULLDEBUG,"negotiationtime: finished sort - slots %d group %s auto %s quota %f maxAllowed %f numsubmits %d parent %d child %d  left %d right %d i %d\n",
+			numDynGroupSlots, groupArray[i].groupName.c_str(),(groupArray[i].autoregroup)?"true":"false", groupArray[i].quota, groupArray[i].maxAllowed,groupArray[i].numsubmits, 
+			groupArray[i].parent, groupArray[i].child, groupArray[i].left, groupArray[i].right ,i);
+     	}	
+
+	// pull out the submitter ads that specify a group from the
+	// scheddAds list, and insert them into a list specific to 
+	// the specified group.
+	ClassAd *ad = NULL;
+	string scheddName;
+	scheddAds.Open();
+	while( (ad=scheddAds.Next()) ) {
+		MyString temp;
+		string temp2, temp3;
+		if (!ad->LookupString(ATTR_NAME, temp)) {
+					continue;
 				}
+		scheddName.assign(temp.Value());
+		// have to assume there is username attached to accounting group name in job submission
+		// go put 0 at last seperator
+		// chop off hostname
+		size_t pos= scheddName.find_last_of("@");
+		if ( pos==string::npos ) {
+			continue;
+		}
+
+		temp2=scheddName.substr(0,pos);
+		pos= temp2.find_last_of(".");
+		;	
+		if ( pos==string::npos ) {  //assuming here that the last delimited item is a username
+			continue;        //if the user leaves this off, the subitters will appear as groupless users
+		}                     //at the parent level
+;
+		temp3=temp2.substr(0,pos);
+		for (i=1; i<groupArray.size(); i++) {
+			if ( temp3.compare(groupArray[i].groupName)==0 ) {
+				groupArray[i].submitterAds.Insert(ad);
+				scheddAds.Delete(ad);
+				break;
 			}
 		}
+	}//while( (ad=scheddAds.Next()) )
+	
+	for ( i=0;i<groupArray.size();i++) {
+		dprintf(D_FULLDEBUG,"negotiationtime: finished inserting submitters - slots %d group %s quota %f maxAllowed %f numsubmits %d  i %d\n",
+		numDynGroupSlots, groupArray[i].groupName.c_str(), groupArray[i].quota, groupArray[i].maxAllowed,groupArray[i].numsubmits, i);
+     	}
+     
+	//now we need to convert the quota_fraction to an actual slot count
+	//which means walking down the tree
+	for (unsigned pos=1;pos<groupArray.size();pos++){
+		if (groupArray[pos].staticquota){
+			if (groupArray[groupArray[pos].parent].maxAllowed<=0){
+				groupArray[pos].quota=0;
+				groupArray[pos].maxAllowed=0;
+			} else {
+				if (groupArray[groupArray[pos].parent].maxAllowed <groupArray[pos].quota) { //this would be a config error if true
+					groupArray[pos].maxAllowed =groupArray[groupArray[pos].parent].maxAllowed;
+					dprintf(D_ALWAYS,"negotiationtime: Error in config. Subgroup %s static quota larger than parent group %s. Setting quota to match parent. \n",
+						groupArray[pos].groupName.c_str(), groupArray[groupArray[pos].parent].groupName.c_str());	
+				}		
+				else groupArray[pos].maxAllowed=groupArray[pos].quota;
+				groupArray[pos].quota=(double)groupArray[pos].maxAllowed/(double)groupArray[groupArray[pos].parent].maxAllowed;
+			}
+		} else {
+			groupArray[pos].maxAllowed=(double)groupArray[pos].quota*(double)groupArray[groupArray[pos].parent].maxAllowed;	
+		}	
+		groupArray[pos].unused=0;
+	}//for (int pos=0;pos<groupArrayLen;pos++)
+	
+	//now we compute each non leaf node's quota for users not in a subgroup
+	for ( unsigned pos=groupArray.size()-1;pos>0;pos--){ 
+		float grouptotal=0; 		//the sum of the quota for all subgroups 
+		int currentparent=groupArray[pos].parent; 
+		while (currentparent==groupArray[pos].parent){		
+			grouptotal=groupArray[pos].quota+grouptotal; 
+			pos--;
+		} 
+		pos++;			
+     		groupArray[groupArray[pos].parent].nodequota=1.0-(double)grouptotal; // users get the remaining quota
+			
+	 	if (groupArray[groupArray[pos].parent].nodequota<0)
+			groupArray[groupArray[pos].parent].nodequota=0; //check for negative
+			
+		groupArray[groupArray[pos].parent].nodemaxAllowed=
+			(double)groupArray[groupArray[pos].parent].nodequota*(double)groupArray[groupArray[pos].parent].maxAllowed;	 	
+	}
+	
+	
+	for (i=0;i<groupArray.size();i++) {
+		dprintf(D_FULLDEBUG,"negotiationtime: finished maxallowed calc -  slots %d group %s quota %f nodequota %f maxAllowed %f nodemaxAllowed %f numsubmits %d  i %d\n",
+			numDynGroupSlots, groupArray[i].groupName.c_str(), groupArray[i].quota, groupArray[i].nodequota,
+			groupArray[i].maxAllowed,groupArray[i].nodemaxAllowed,groupArray[i].numsubmits,i);
+     	}
+	
+	//now we know number of submitters and max number of slots allowed at each group level
+	scheddAds.Open();
 		
-		if (!staticquota){
+	// here we check for submitters that are not in a group at all or a group with no quota
+	int nongroupusers=scheddAds.Length();
+					
+	// if we have users not in a group, we attach them to groupArray[0]
+	// they get to negotiate for any slots not used by subgroups
+	//groupArray[0].autoregroup is always true
+	if (nongroupusers){
+		scheddAds.Open();
+		int numrunning=0;
+		int numidle=0;
+			
+		groupArray[0].numsubmits=0;
+		//int totalsubmits=0;
+		float schedusagetotal=0;
+		float scheddUsage=0;
+		while( (ad=scheddAds.Next()) ) {
+			ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
+			ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
+			groupArray[0].numsubmits=groupArray[0].numsubmits+numrunning+numidle;
+			MyString username;
+			if (ad->LookupString(ATTR_NAME, username) ){
+				//scheddName[79] = '\0'; // make certain we have a terminating NULL
+				scheddUsage = accountant.GetWeightedResourcesUsed(username);
+				schedusagetotal=scheddUsage+schedusagetotal;
+				groupArray[0].submitterAds.Insert(ad);
+				scheddAds.Delete(ad);
+			}
+		}
+		//safe to change the name now. We need a valid name because negotiate uses groupname as a flag.
 		
-		// totalgroupquota is num slots claimed in config for groups
-		// unclamedquota is quota not claimed in config..could be for user jobs
-		// unusedslots is number of totalgroupquota that goes unused due to lack of submitters
+		groupArray[0].groupName.assign("none\0");	
+		groupArray[0].usage = schedusagetotal;
+		groupArray[0].prio = 100;		
 
-		unclaimed=numDynGroupSlots-totalgroupquota;
-		unclaimedquota=numDynGroupSlots-(int)totalgroupquota;
+	} //if (nongroupusers)
 		
-		// to fix up roundoff
-		if (unclaimed<1) unclaimedquota=0;
+	// now need to fix up quotas for groups
+	// every group should have a quota description
+	// have to have quota declarations at all levels to enforce hfs at different levels
+	// what we have to do is at bottom level calc quota and unused quota
+	// we reassign unused quota to other subgroups at this level
+	// if no reassignment, we add this unused quota to the unused quota level above.
+	// we then attempt to assign this unused quota to groups below
+	// if we can't, we add it to the group level above.
 		
-		dprintf(D_FULLDEBUG, " numDynGroupSlots=%d totalgroupquota=%f unclaimedquota=%d\n",numDynGroupSlots,totalgroupquota,unclaimedquota);
-			
-		scheddAds.Open();
-		// here we check for submitters that are not in a group with quota
-		int nongroupusers=scheddAds.Length();
-		dprintf(D_FULLDEBUG, " nongroupusers=%d totalgroupquota=%f\n",nongroupusers,totalgroupquota);
-		if (nongroupusers){
-			scheddAds.Open();
-			int numrunning=0;
-			int numidle=0;
+	//assigns maxAllowed to be numsubmits if numsubmits is less than quota
+	//otherwise maxAllowed  is the amount of quota not used
+	// we also generate the total number of unused slots
+	// these are slots that can be given to users and groups that have more
+	//submits than quota
+		
+	// Array should be sorted tree
+	// We start at the very end of the array which should be greatest depth
+
+	for (i=groupArray.size()-1; i>=1; i--) {
+		int currentparent=groupArray[i].parent;
+		float unused=0;
+		float parentunused=0;
+		unsigned j;	
+		
+		groupArray[currentparent].unused=0;
 			
-			numsubmits[groupArrayLen]=0;
-			int totalsubmits=0;
-			float schedusagetotal=0;
-			float scheddUsage=0;
-			while( (ad=scheddAds.Next()) ) {
-				ad->LookupInteger(ATTR_RUNNING_JOBS, numrunning);
-				ad->LookupInteger(ATTR_IDLE_JOBS, numidle);
-				numsubmits[groupArrayLen]=numsubmits[groupArrayLen]+numrunning+numidle;
-				if (ad->LookupString(ATTR_NAME, scheddName, sizeof(scheddName))) {
-					scheddName[79] = '\0'; // make certain we have a terminating NULL
-					scheddUsage = accountant.GetWeightedResourcesUsed(scheddName);
-					schedusagetotal=scheddUsage+schedusagetotal;
-					dprintf(D_FULLDEBUG, " nongroupusers=%d schedusagetotal=%f\n",nongroupusers,schedusagetotal);	
-					groupArray[groupArrayLen].submitterAds.Insert(ad);
-					scheddAds.Delete(ad);
-				}
-			}
-			groupArray[groupArrayLen].groupName = "none\0"; 
-			groupArray[groupArrayLen].maxAllowed = unclaimedquota;			
-			groupArray[groupArrayLen].usage = schedusagetotal;
-			groupArray[groupArrayLen].prio = 100;		
-			if(numsubmits[groupArrayLen] ==0 ){
-		 		  unusedslots=unusedslots+(int)groupArray[groupArrayLen].maxAllowed;
-		   	} else if(numsubmits[groupArrayLen]<(int)groupArray[groupArrayLen].maxAllowed ) {
-			 	unusedslots=unusedslots+(int)groupArray[groupArrayLen].maxAllowed-numsubmits[groupArrayLen];
+		// we iterate backwards until the parent changes
+		// this gets us the number of unused slots in our peer groups
+		//and total number of submitters in our peer groups
+		for (j=i; j>=1 && currentparent==groupArray[j].parent; j--) {
+			if (groupArray[j].child==-1) { //leaf
+				unused=groupArray[j].maxAllowed-groupArray[j].numsubmits;	  
+			if (unused>0){
+				groupArray[j].unused=unused;
+				groupArray[j].maxAllowed=groupArray[j].numsubmits;
+			} else {
+				if  (unused==groupArray[j].maxAllowed)groupArray[j].maxAllowed=0; //no submitters
+				groupArray[j].unused=0;
+				unused=0;
+			}
+			groupArray[groupArray[j].parent].unused=groupArray[groupArray[j].parent].unused+unused;
+			} else { //not a leaf
+				if (groupArray[j].unused>0) 
+					groupArray[groupArray[j].parent].unused=groupArray[groupArray[j].parent].unused+groupArray[j].unused;
 			}
-			groupArrayLen=groupArrayLen+1;
-		} else {
-			unusedslots=unusedslots+unclaimedquota;
 		}
-		dprintf(D_FULLDEBUG, " built array totalgroupquota=%f unusedslots=%d\n",totalgroupquota,unusedslots);
+		i=j+1;
 		
-		// now we reassign unused slots for autogroup groups based upon percent group quota is of total slots
-		// this keeps fair share percentages the same as unused slots are spread around
-		float quotatotal=0;
-		float* oldquota = new float[groupArrayLen]; 
-		for (i=0;i<groupArrayLen;i++) { 
-			oldquota[i]=groupArray[i].maxAllowed;
-			quotatotal=quotatotal+oldquota[i];
-		}
-		//we know total unusedslots
-		int saveunusedslots=unusedslots;		
-		int unusedslotstotal=unusedslots;
-		int slotflag=1; 
-		int given=0;
-                
-		while (unusedslots>0 && slotflag){
-		 	int myshare=0;
-		  	slotflag=0;
-			int leftoverpie=unusedslots;
-			for (i=0; (i<groupArrayLen && unusedslots>0); i++){
-				double percentofunused=0;
-				dprintf(D_ALWAYS,"Group %s - unusedslots to give=%d maxallowed=%f \n",groupArray[i].groupName, unusedslots,groupArray[i].maxAllowed);
-		 		if (numsubmits[i]>groupArray[i].maxAllowed) {
-					// hand out unused slots to non group users if they had quota
-					if((i==groupArrayLen-1)&&nongroupusers&&groupArray[i].maxAllowed>0){
-						double piefraction=(double) leftoverpie*(double)oldquota[i]/(double)numDynGroupSlots;
-						if (piefraction>0 && piefraction<1) {
-							myshare=1;
-						} else {
-							myshare=rint((double)leftoverpie*(double)oldquota[i]/(double)numDynGroupSlots);
-						}
-						if (unusedslots<myshare) myshare=unusedslots;
-						groupArray[i].maxAllowed=groupArray[i].maxAllowed+myshare;
-						given=given+myshare;
-						slotflag=1;
-						unusedslots=unusedslots-myshare;
-					} else {
-						// hand out unused slots to group users with autoregroup
-						bool default_autoregroup = param_boolean("GROUP_AUTOREGROUP",false);
-						MyString autoregroup_param;
-						autoregroup_param.sprintf("GROUP_AUTOREGROUP_%s",groupArray[i].groupName);
-						if(param_boolean(autoregroup_param.Value(),default_autoregroup)){			
-							double piefraction=(double) leftoverpie*(double)oldquota[i]/(double)numDynGroupSlots;
-							if (piefraction>0 && piefraction<1) {
-								myshare=1;
-							} else {
-								myshare=rint((double)leftoverpie*(double)oldquota[i]/(double)numDynGroupSlots);
-							}
-							if (unusedslots<myshare) myshare=unusedslots;
-							groupArray[i].maxAllowed=groupArray[i].maxAllowed+myshare;
-							given=given+myshare;
-							slotflag=1;
-							unusedslots=unusedslots-myshare;
-						}
-					} 
-			    } else {
-				groupArray[i].maxAllowed=(float)numsubmits[i];}
-		 	
-		 	}
-			dprintf(D_ALWAYS,"totalunusedslots=%d given=%d \n", unusedslotstotal,given); 
-			if(given==0)slotflag=0;
-		}
-		dprintf(D_ALWAYS,"totalunusedslots=%d given=%d \n", unusedslotstotal,given);
-		
-		delete [] oldquota;
-		oldquota = NULL;
-		} //if notstaticquota
+		if (groupArray[groupArray[i].parent].nodemaxAllowed>0){ 
+			parentunused=groupArray[groupArray[i].parent].nodemaxAllowed-groupArray[groupArray[i].parent].numsubmits;
+			if (parentunused>0)
+				groupArray[groupArray[i].parent].unused=groupArray[groupArray[i].parent].unused+parentunused;		
+		}
+		if (groupArray[currentparent].autoregroup==true)				
+			groupArray[currentparent].unused=fairshare(groupArray,currentparent,groupArray[currentparent].unused);
+		else {
+			groupArray[currentparent].autoregroup=true;
+			groupArray[currentparent].unused=fairshare(groupArray,currentparent,groupArray[currentparent].unused);
+			groupArray[currentparent].autoregroup=false;
+		
+		}
+		dprintf(D_FULLDEBUG,"negotiationtime: after fairshare setting parent unused ->group %s auto %s quota %f maxallowed %f  unused %f\n",
+			groupArray[currentparent].groupName.c_str(), (groupArray[currentparent].autoregroup)?"true":"false", groupArray[currentparent].quota, 
+		 	groupArray[currentparent].maxAllowed, groupArray[currentparent].unused);			
+	} //for
+	
+	dprintf(D_FULLDEBUG,"negotiationtime: finished fairshare unable to use %f slots\n",groupArray[0].unused);
 
-			// now sort the group array
-		qsort(groupArray,groupArrayLen,sizeof(SimpleGroupEntry),groupSortCompare);		
+	for (i=0;i<groupArray.size();i++) {
+		dprintf(D_FULLDEBUG,"negotiationtime: finished fairshare - slots %d group %s auto %s quota %f maxAllowed %f nodemaxAllowed %f numsubmits %d i %d\n",
+			numDynGroupSlots, groupArray[i].groupName.c_str(),(groupArray[i].autoregroup)?"true":"false",groupArray[i].quota, groupArray[i].maxAllowed, groupArray[i].nodemaxAllowed, groupArray[i].numsubmits, 
+			 i);
+     	}
+	for (i=0;i<groupArray.size();i++) groupArray[i].unused=0;
+	
+	for (i=0;i<groupArray.size();i++) {	
+		float unused=0;	
+		
+		if (groupArray[i].child!=-1&&groupArray[i].numsubmits>0&&groupArray[i].nodemaxAllowed>0){
+			if (groupArray[i].unused>0){
+				float nodeshare=groupArray[i].nodequota*groupArray[i].unused;
+				groupArray[i].nodemaxAllowed=groupArray[i].nodemaxAllowed+nodeshare;
+				groupArray[i].unused=groupArray[i].unused-nodeshare; 
+			}
+		
+			unused=groupArray[i].nodemaxAllowed-floorf(groupArray[i].nodemaxAllowed)+groupArray[i].unused;			
+			groupArray[i].nodemaxAllowed=floorf(groupArray[i].nodemaxAllowed);
+			//hand out unused to our children
+			int currentchild=groupArray[i].child;
+			float childshare=0;
+
+		  	//now we iterate across children handing out pie
+			while (currentchild!=-1){ 
+				childshare=unused*groupArray[currentchild].quota; 
+ 				groupArray[currentchild].unused=childshare;
+				currentchild=groupArray[currentchild].left;
+			}				
+			groupArray[i].unused=0;				
+													
+		} else if (groupArray[i].child!=-1)  {
+			int currentchild=groupArray[i].child;
+			float childshare=0;
+		  	//now we iterate across children handing out pie
+			while (currentchild!=-1){ 
+				childshare=groupArray[i].unused*groupArray[currentchild].quota; 
+ 				groupArray[currentchild].unused=childshare;
+				currentchild=groupArray[currentchild].left;
+			}
+			groupArray[i].unused=0;
+		
+		} 
 
-			// and negotiate for each group
-		for (i=0;i<groupArrayLen;i++) {
+	}
+	
+	
+	for (i=0;i<groupArray.size();i++) {
+		dprintf(D_FULLDEBUG,"negotiationtime: mid roundoff - slots %d group %s auto %s quota %f maxAllowed %f nodemaxAllowed %f unused %f numsubmits %d i %d\n",
+			numDynGroupSlots, groupArray[i].groupName.c_str(),(groupArray[i].autoregroup)?"true":"false",groupArray[i].quota, groupArray[i].maxAllowed,
+			groupArray[i].nodemaxAllowed, groupArray[i].unused,  groupArray[i].numsubmits, 
+			 i);
+     	}
+	//at this point we focus on leaves
+	//roundoff that needs to be fixed is within maxAllowed
+	
+	float totalroundoff=0;
+	for (i=groupArray.size()-1; i>=1; i--) {
+		int currentparent=groupArray[i].parent;
+		float roundoff;
+		unsigned j;	
+		//this gathers all partial slots for this family of groups
+		for (j=i; j>=1 && currentparent==groupArray[j].parent; j--) {			
+			if (groupArray[j].child==-1) { //leaf
+				if (groupArray[j].maxAllowed==0){
+					totalroundoff=totalroundoff+groupArray[j].unused;
+				
+				} else {
+					groupArray[j].maxAllowed=groupArray[j].maxAllowed+groupArray[j].unused;
+					roundoff =groupArray[j].maxAllowed-floor(groupArray[j].maxAllowed);
+					groupArray[j].maxAllowed=floor(groupArray[j].maxAllowed);
+					totalroundoff=totalroundoff+roundoff;
+				}
+	  
+			}
+		}
+		//This distributes round robin the slots as integers
+		//if we end up with a fraction of a slot, that partial slot is handed to the next family
+		//we want to ensure that all slots get used
+		//its possible that they all will and we will still have a fraction of a slot left over
+		//this is simply due to roundoff errors compounded 
+		int endofgroup=j+1;
+		bool gavesome=true;
+		while (gavesome&&totalroundoff>=1){
+		gavesome=false;
+		for (j=i; j>=1 &&totalroundoff>=1&& currentparent==groupArray[j].parent; j--) {
+			if (groupArray[j].child==-1&&groupArray[j].maxAllowed>0) { //leaf
+				groupArray[j].maxAllowed=groupArray[j].maxAllowed+1;
+				totalroundoff=totalroundoff-1;
+				gavesome=true;
+			}
+		}
+		}
+		i=endofgroup;
+	//get to this point and totalroundoff is handed to next family
+	}
+	
+	dprintf(D_ALWAYS,"negotiationtime: finished roundoff - unable to use %f\n",totalroundoff); int totalusedslots=0;
+	
+	// This section is determines how many slots we are off due to roundoff
+	// and then assigns them in a round robin fashion
+	// roundoff error should be small (i.e. b1 slot) in a flat tree with many groups having submitters
+	// roundoff error seems to be larger in deep trees with few submitters
+	// round robin seems
+	for (i=0;i<groupArray.size(); i++){ 
+		if (groupArray[i].nodemaxAllowed>0&&groupArray[i].numsubmits>0) {
+			totalusedslots=totalusedslots+groupArray[i].nodemaxAllowed;
+		} else if (groupArray[i].child==-1){
+			totalusedslots=totalusedslots+groupArray[i].maxAllowed;
+		}
+	}
+		
+	int totalunusedslots=numDynGroupSlots-totalusedslots;
+	dprintf(D_FULLDEBUG,"negotiationtime: total used %d unused slots %d\n",totalusedslots,totalunusedslots);
+	bool gaveroundoff=true;
+	while (totalunusedslots>0&&gaveroundoff){
+		gaveroundoff=false;
+		for (i=0;i<groupArray.size()&&totalunusedslots>0; i++){
+			 if (groupArray[i].nodemaxAllowed>0&&groupArray[i].numsubmits>0){
+		 		groupArray[i].nodemaxAllowed=groupArray[i].nodemaxAllowed+1;
+				totalunusedslots--;
+				gaveroundoff=true;
+			} else if (groupArray[i].maxAllowed>0&&groupArray[i].child==-1&&groupArray[i].autoregroup==true) { 
+				groupArray[i].maxAllowed=groupArray[i].maxAllowed+1; 
+				totalunusedslots--; 
+				gaveroundoff=true;
+			}
+		}
+	}
+	
+	for (i=0;i<groupArray.size();i++) {
+		dprintf(D_FULLDEBUG,"negotiationtime: finished roundoff - slots %d group %s auto %s quota %f maxAllowed %f nodemaxAllowed %f numsubmits %d i %d\n",
+			numDynGroupSlots, groupArray[i].groupName.c_str(),(groupArray[i].autoregroup)?"true":"false",groupArray[i].quota, groupArray[i].maxAllowed, groupArray[i].nodemaxAllowed, groupArray[i].numsubmits, 
+			 i);
+     	}
+		
+		// negotiate for each group
+		for (i=0;i<groupArray.size();i++) {
 			if ( groupArray[i].submitterAds.MyLength() == 0 ) {
-				dprintf(D_ALWAYS,
-					"Group %s - skipping, no submitters\n",
-					groupArray[i].groupName);
+				dprintf(D_ALWAYS,"Group %s - skipping, no submitters\n",groupArray[i].groupName.c_str());
 				continue;
 			}
-			if ( groupArray[i].usage >= groupArray[i].maxAllowed  &&
-				 !ConsiderPreemption ) 
-			{
-				dprintf(D_ALWAYS,
-						"Group %s - skipping, at or over quota (usage=%.3f)\n",
-						groupArray[i].groupName,groupArray[i].usage);
+			if ( groupArray[i].usage >= groupArray[i].maxAllowed  && !ConsiderPreemption ) {
+				dprintf(D_ALWAYS, "Group %s - skipping, at or over quota (usage=%.3f)\n", groupArray[i].groupName.c_str(),groupArray[i].usage);
 				continue;
 			}
-			dprintf(D_ALWAYS,
-				"Group %s - negotiating\n",groupArray[i].groupName);
-			negotiateWithGroup( untrimmed_num_startds,untrimmedSlotWeightTotal, minSlotWeight, 
+			if (groupArray[i].child==-1) {
+				dprintf(D_ALWAYS,
+					"Group %s - negotiating\n",groupArray[i].groupName.c_str());
+				negotiateWithGroup( untrimmed_num_startds,untrimmedSlotWeightTotal, minSlotWeight, 
 					startdAds, claimIds, groupArray[i].submitterAds, 
-					groupArray[i].maxAllowed, groupArray[i].usage,groupArray[i].groupName );
-		}
-		if (staticquota){
-		
-			// if GROUP_AUTOREGROUP is set to true, then for any submitter
-			// assigned to a group that did match, insert the submitter
-			// ad back into the main scheddAds list.  this way, we will
-			// try to match it again below .
-		bool default_autoregroup = param_boolean("GROUP_AUTOREGROUP",false);
-		for (i=0; i<groupArrayLen; i++) {
-			ad = NULL;
-			MyString autoregroup_param;
-			autoregroup_param.sprintf("GROUP_AUTOREGROUP_%s",groupArray[i].groupName);
-			if(param_boolean(autoregroup_param.Value(),default_autoregroup)) {
+					groupArray[i].maxAllowed, groupArray[i].usage,groupArray[i].groupName.c_str() );
+			} else {
 				dprintf(D_ALWAYS,
-						"Group %s - autoregroup inserting %d submitters\n",
-						groupArray[i].groupName,
-						groupArray[i].submitterAds.MyLength());
+					"Group node %s - negotiating\n",groupArray[i].groupName.c_str());
+				negotiateWithGroup( untrimmed_num_startds,untrimmedSlotWeightTotal, minSlotWeight, 
+					startdAds, claimIds, groupArray[i].submitterAds, 
+					groupArray[i].nodemaxAllowed, groupArray[i].usage,groupArray[i].groupName.c_str() );
 
-				groupArray[i].submitterAds.Open();
-				while( (ad=groupArray[i].submitterAds.Next()) ) {
-					scheddAds.Insert(ad);				
-				}
+			
 			}
-		}
-		
-		
-		
-		
-		
-		} //if notstaticquota
+		} //for (i=0;i<groupArrayLen;i++) {
 
-			// finally, cleanup 
-		delete []  groupArray;
-		groupArray = NULL;
-		delete [] numsubmits;
-		numsubmits = NULL;
+	//	delete []  groupArray;
+	//	groupArray = NULL;
 
-			// print out a message stating we are about to negotiate below w/
-			// all users who did not specify a group
-		dprintf(D_ALWAYS,"Group *none* - negotiating\n");
 
 	} // if (groups)
-	
+	else {
 		// negotiate w/ all users who do not belong to a group.
 	negotiateWithGroup(untrimmed_num_startds, untrimmedSlotWeightTotal, minSlotWeight, startdAds, claimIds, scheddAds);
+	}
 	
 	// ----- Done with the negotiation cycle
 	dprintf( D_ALWAYS, "---------- Finished Negotiation Cycle ----------\n" );
@@ -1289,20 +1514,365 @@ negotiationTime ()
 	return TRUE;
 }
 
+
+
+float Matchmaker::fairshare( std::vector<SimpleGroupEntry> &groupArray, int index, float unused)
+{
+	int child=groupArray[index].child;
+
+    	dprintf(D_FULLDEBUG,"fairshare called on  %s auto %s index %d maxallowed %f numsubmits %d group unused %f called with unused %f \n",
+    		groupArray[index].groupName.c_str(),(groupArray[index].autoregroup)?"true":"false", index, groupArray[index].maxAllowed, 
+    		groupArray[index].numsubmits,groupArray[index].unused,unused);
+
+	if (groupArray[index].autoregroup) { //if we have unused, we can't use them
+		if (child==-1) { //we are leaf and see if we can use the unused
+  			float canonlyuse=(float)groupArray[index].numsubmits-groupArray[index].maxAllowed;
+ 
+  			dprintf(D_FULLDEBUG,"fairshare leaf %s maxallowed %f numsubmits %d unused %f canonlyuse %f\n",
+   				groupArray[index].groupName.c_str(), groupArray[index].maxAllowed, groupArray[index].numsubmits,unused,canonlyuse);
+  		if (canonlyuse>0) {
+     			if (unused>=canonlyuse){
+  				groupArray[index].maxAllowed=groupArray[index].maxAllowed+canonlyuse;	
+				return unused-canonlyuse;
+  			} else {//we can use more but are only offered unused amount return 0 because we took them all
+  				groupArray[index].maxAllowed=groupArray[index].maxAllowed+unused; 
+  				return 0;
+
+  			}
+  		}//canonlyuse is 0 or less..can't use any
+  		return unused;
+	} else { //not a leaf
+
+  		dprintf(D_FULLDEBUG,"fairshare not a leaf node  %s maxallowed %f numsubmits %d unused %f \n", 
+  			groupArray[index].groupName.c_str(), groupArray[index].maxAllowed, groupArray[index].numsubmits,unused);
+
+		// we dish out a fairshare to all our children
+		// child will point at rightmost child
+		float remaining=unused; //what we use to calculate share with
+		bool gavesome=true; 
+		while (gavesome&&remaining>0){   
+			gavesome=false; //reset gavesome flag each iteration across children
+			int currentchild=child;
+			float childshare=0;
+			float totalgiven=0; //count of what was given away this round
+			float notgiven=0;
+			//we first check to see if we have submitters and give a share to them if they have quota	
+			if ( groupArray[index].autoregroup==true&&groupArray[index].nodequota>0&&groupArray[index].numsubmits>0) {
+				childshare=remaining*groupArray[index].nodequota;
+				//A childshare could be a small percent of a node but that could mean the difference between getting
+				//another slot or not
+				//Eventually we will get to a state where remaining is really small and we are handing out very small
+				//childshare. There is no point iterating giving out 1/100 of a slot, so we handout what is remaining.
+				if (remaining<0.5) {
+					childshare=remaining; 
+					remaining=0;
+				}
+				float canonlyuse=(float)groupArray[index].numsubmits-groupArray[index].nodemaxAllowed;
+ 				if (childshare>0&&canonlyuse>0) {
+    		 			if (childshare>=canonlyuse){
+  						groupArray[index].nodemaxAllowed=groupArray[index].nodemaxAllowed+canonlyuse;
+						//remaining=remaining-canonlyuse;
+						totalgiven=canonlyuse;
+  					} else {//we can use more but are only offered unused amount return 0 because we took them all
+  						groupArray[index].nodemaxAllowed=groupArray[index].nodemaxAllowed+childshare; 
+						//remaining=remaining-childshare;
+						totalgiven=childshare;
+					}
+				gavesome=true;
+  				}
+				if (gavesome) 	
+					dprintf(D_FULLDEBUG,"fairshare gave some to non group user %s maxallowed=%f nodemaxAllowed=%f remaining %f\n",
+						groupArray[index].groupName.c_str(),groupArray[index].maxAllowed,groupArray[index].nodemaxAllowed,remaining);
+	
+			}
+			
+			//now we iterate across children handing out pie
+			while (currentchild!=-1){ 
+				if (groupArray[currentchild].autoregroup==true){
+ 		 			if (remaining<0.5) {
+						childshare=remaining;
+						remaining=0;
+					} else {
+						childshare=remaining*groupArray[currentchild].quota; 
+					}
+					dprintf(D_FULLDEBUG,"fairshare %s index %d maxallowed %f numsubmits %d childshare %f unused %f\n",
+						groupArray[currentchild].groupName.c_str(),index,groupArray[currentchild].maxAllowed , groupArray[currentchild].numsubmits,
+						childshare, unused);
+ 		
+                			notgiven=0;
+		 			if (childshare>0) {
+		  				if (groupArray[currentchild].unused==0){
+		  					notgiven=fairshare(groupArray,currentchild,childshare);
+		  					if (notgiven<childshare){ //we gave some or all
+								gavesome=1; 
+								totalgiven=totalgiven+(childshare-notgiven);
+							
+							}
+	
+						} 
+					}
+
+	
+				dprintf(D_FULLDEBUG,"after fairshare  %s index %d maxallowed %f numsubmits %d childshare %f unused %f remaining %f notgiven %f totalgiven %f\n",
+		 			groupArray[currentchild].groupName.c_str(),index, groupArray[currentchild].maxAllowed, groupArray[currentchild].
+		 			numsubmits,childshare, unused, remaining, notgiven, totalgiven);
+			}
+				currentchild=groupArray[currentchild].left;
+			}
+	
+			remaining=remaining-totalgiven;
+			if (remaining<0) remaining=0; //precaution against roundoff
+			
+			dprintf(D_FULLDEBUG,"fairshare  group %s index %d maxallowed %f numsubmits %d unused %f remaining %f gavesome %d\n",
+			groupArray[index].groupName.c_str(),index, groupArray[index].maxAllowed, groupArray[index].numsubmits, unused, remaining, (int)gavesome);
+	
+		}
+		return remaining; 
+		}
+	} else { //no autoregroup so return unused
+
+		return unused;
+
+	}
+}
+
+
+void Matchmaker::sort(std::vector<SimpleGroupEntry>  &groupArray, int length)
+{
+	// sort groups into a tree within an array
+	// walk thru current group array
+	// each group must specify a quota at every level
+	int level=0;
+	int position=1;
+	int index=0;
+	int newlength=length-1;
+
+	dprintf(D_ALWAYS,"Sort : sorting group vector\n");
+	
+	std::vector<SimpleGroupEntry> groupArraytemp(length);
+	
+	groupArraytemp[0]=groupArray[0];
+	// could use an iterator and erase, but no sense in breaking down the vector
+	// since we would build it again
+	for (int j=1;j<length;j++){
+		groupArray[j-1]=groupArray [j];				
+	}
+
+	// level can't be greater than length because there can't be more subgroups than the number of groups in the array
+	while (level<=length&&newlength>0){
+        	bool found=false; 		
+		for (index=0;!found&&index<newlength;index++){	      
+			int mylevel=0;
+			string tempname2;
+			
+			//start at bottom top of tree so front of array is filled with top nodes
+			// and tail of array is filled with lower nodes or leaves.	
+			// put the name of current group in tempname
+			size_t pos= groupArray[index].groupName.find_first_of(".");		
+			while (pos!=string::npos){         // count the seperators which tells us number of subgroups
+					mylevel++;
+					pos= groupArray[index].groupName.find_first_of(".",pos+1);
+							
+			}
+			
+			// mylevel is count of subgroups in this particular group
+			// if it the same as our current level then we add it to the new array
+			if (mylevel==level){
+				found=true;;
+				groupArraytemp [position]=groupArray[index];
+				if (mylevel==0){ //deal with top level groups. an unusual case because they have no parent
+					if (position>1){
+				 		groupArraytemp[position].left=position-1;
+						groupArraytemp[position-1].right=position;	
+					} else { //else position is 1..special case
+					 	groupArraytemp[position].left=-1;	
+					 
+					}
+					groupArraytemp[position].parent=0;
+					groupArraytemp[0].child=position;
+				} else {// if this is a subgroup then assign the parent field
+					if (mylevel>0){ //cut off last subgroup leaving the parent group string
+						size_t last=groupArray[index].groupName.find_last_of(".");
+						if (last !=string::npos) tempname2=groupArray[index].groupName.substr(0,last);
+						else tempname2=groupArray[index].groupName;
+						
+						bool foundsibling=false;
+						bool foundparent=false;
+						for (int len = position-1; len>=0;len--){
+							//if our parent string matches a group name we found our parent
+
+							if (!foundparent&&(groupArraytemp[len].groupName.compare(tempname2)==0)){
+								groupArraytemp [position].parent=len;
+								groupArraytemp [len].child=position; //child will be left most sibling
+								foundparent=true;
+							}
+							
+							//if our parent string matches the parent string of another element
+							//we found a sibling
+							
+							string tempname4;	
+							size_t lastdel=groupArraytemp[len].groupName.find_last_of(".");
+							if (lastdel !=string::npos) tempname4=groupArraytemp[len].groupName.substr(0,lastdel);
+							else tempname4=groupArraytemp [len].groupName;
+							//top most groups are dealt with above
+
+							if (!foundsibling&&lastdel !=string::npos&&(tempname2.compare(tempname4)==0)){
+								groupArraytemp [position].left=len;
+								groupArraytemp [len].right=position;	
+								foundsibling=true;
+							}
+
+						}
+					}
+				} 
+				//remove the just found entry from the array
+				for (int j=index+1;j<newlength;j++)
+	 				groupArray[j-1]=groupArray [j];
+				
+				newlength--; 
+				for (int i=0;i<newlength;i++) {
+					dprintf(D_FULLDEBUG,"Sorting : grouparray group %s parent %d child %d  left %d right %d i %d\n",
+					groupArray[i].groupName.c_str(),  groupArray[i].parent, groupArray[i].child,groupArray[i].left,
+		 			groupArray[i].right ,i);
+				}					
+				
+				position++;
+			} // if (mylevel==level)
+		
+		} //for
+		if (!found) level++;
+	} //while
+	//copy the array back to original array
+	for (int i=0;i<length;i++) groupArray[i]=groupArraytemp [i];
+	
+	dprintf(D_FULLDEBUG,"Sort : stage two\n");		
+	for (int i=0;i<length;i++) {
+		dprintf(D_FULLDEBUG,"midsort : grouparray group %s parent %d child %d  left %d right %d i %d\n",
+			groupArray[i].groupName.c_str(),  groupArray[i].parent, groupArray[i].child,groupArray[i].left,
+			 groupArray[i].right ,i);
+	}
+	
+
+	for (int i=length-1;i>1;i--){
+		if (i-1!=groupArray[i].left) {//if not equal immediateleft is not left node		
+	 		if (groupArray[i].left!=-1){ //there is a left sibling
+			
+				//fix the links for the i-1 node we're moving
+				if (groupArray[i-1].left!=-1) groupArray[groupArray[i-1].left].right=groupArray[i].left;
+				if (groupArray[i-1].right!=-1)groupArray[groupArray[i-1].right].left=groupArray[i].left;
+				
+				//fix our own  links		
+				if (groupArray[groupArray[i].left].left!=-1)groupArray[groupArray[groupArray[i].left].left].right=i-1;
+				groupArray[i].left=i-1;
+				groupArraytemp [0]=groupArray[i-1];
+				groupArray [i-1]=groupArray[groupArray[i].left];
+				groupArray [groupArray[i].left]=groupArraytemp[0];
+				
+				if (groupArray[i].parent!=-1)groupArray[i-1].parent=groupArray[i].parent;
+		
+     			} else if (groupArray[i-1].right!=-1){ 
+				//there isn't a left sibling but the next one is already rightmost if -1
+		
+     		    		//we have to find the rightmost sibling under a new parent
+      				 // if no left node we are a single group with no peers or 
+       				// we walked all peer subgroups and are now at left most node
+           			int rightmost=i-1;
+				while(rightmost>0&&groupArray[rightmost].right!=-1) 
+					rightmost=groupArray[rightmost].right;
+			
+				if (groupArray[i-1].left!=-1) groupArray[groupArray[i-1].left].right=rightmost;
+				if (groupArray[i-1].right!=-1)groupArray[groupArray[i-1].right].left=rightmost;
+				if (groupArray[rightmost].left!=-1)groupArray[groupArray[rightmost].left].right=i-1;
+				groupArraytemp [0]=groupArray[i-1];
+				groupArray [i-1]=groupArray[rightmost];
+				groupArray [rightmost]=groupArraytemp[0];
+				
+		
+			}
+	
+		}
+	
+	}
+
+	for (int i=0;i<length;i++) {
+		dprintf(D_FULLDEBUG,"Sorted : grouparray group %s parent %d child %d  left %d right %d i %d\n",
+			groupArray[i].groupName.c_str(),  groupArray[i].parent, groupArray[i].child,groupArray[i].left,
+		 	groupArray[i].right ,i);
+	}
+   
+
+	dprintf(D_FULLDEBUG,"Sort : leaving\n");
+}
+
+
+
 Matchmaker::SimpleGroupEntry::
 SimpleGroupEntry()
 {
-	groupName = NULL;
+	groupName.assign("\0");
 	prio = 0;
+	parent = -1;
+	left = -1;
+	right = -1;
 	maxAllowed = (float) INT_MAX;
 }
 
 Matchmaker::SimpleGroupEntry::
+SimpleGroupEntry(const Matchmaker::SimpleGroupEntry& entry)
+{
+	groupName=entry.groupName;
+
+	prio=entry.prio;
+	maxAllowed=entry.maxAllowed;
+	nodemaxAllowed=entry.nodemaxAllowed;
+	quota=entry.quota;
+	usage=entry.usage;
+	parent=entry.parent;
+	left=entry.left;
+	nodequota=entry.nodequota;
+	right=entry.right;
+	autoregroup=entry.autoregroup;
+	numsubmits=entry.numsubmits;
+	child=entry.child;
+	staticquota=entry.staticquota;
+	unused=entry.unused;
+	//don't need to do submitter ads
+	//if this is used elsewhere that capability will need to be added
+}
+
+Matchmaker::SimpleGroupEntry::
 ~SimpleGroupEntry()
 {
-	// Note: don't free groupName!  See comment above.
+	
+}
+
+	
+Matchmaker::SimpleGroupEntry & Matchmaker::SimpleGroupEntry::operator = (const SimpleGroupEntry  & entry) {
+	
+		
+	groupName=entry.groupName;
+
+	prio=entry.prio;
+	maxAllowed=entry.maxAllowed;
+	nodemaxAllowed=entry.nodemaxAllowed;
+	quota=entry.quota;
+	usage=entry.usage;
+	parent=entry.parent;
+	left=entry.left;
+	nodequota=entry.nodequota;
+	right=entry.right;
+	autoregroup=entry.autoregroup;
+	numsubmits=entry.numsubmits;
+	child=entry.child;
+	staticquota=entry.staticquota;
+	unused=entry.unused;
+	//don't need to do submitter ads
+	//if this is used elsewhere that capability will need to be added
+	
+	return *this;
 }
 
+
 int Matchmaker::
 negotiateWithGroup ( int untrimmed_num_startds,
 					 double untrimmedSlotWeightTotal,
diff -rNup condor-7.4.1.orig/src/condor_negotiator.V6/matchmaker.h condor-7.4.1/src/condor_negotiator.V6/matchmaker.h
--- condor-7.4.1.orig/src/condor_negotiator.V6/matchmaker.h	2010-03-25 13:49:30.000000000 -0400
+++ condor-7.4.1/src/condor_negotiator.V6/matchmaker.h	2010-06-03 14:13:54.000000000 -0400
@@ -27,6 +27,9 @@
 #include "string_list.h"
 #include "dc_collector.h"
 #include "condor_ver_info.h"
+#include <string>
+
+using namespace std;
 
 /* FILESQL include */
 #include "file_sql.h"
@@ -196,7 +199,7 @@ class Matchmaker : public Service
 		                       double slotWeightTotal,
 		                            /* result parameters: */
 		                       double &pieLeft);
-
+	
 		void MakeClaimIdHash(ClassAdList &startdPvtAdList, ClaimIdHash &claimIds);
 		char const *getClaimId (const char *, const char *, ClaimIdHash &, MyString &);
 		void addRemoteUserPrios( ClassAd* ad );
@@ -380,7 +383,7 @@ class Matchmaker : public Service
 			int m_rejPreemptForRank;    //   - startd RANKs new job lower?
 			int m_rejForSubmitterLimit;     //  - not enough group quota?
 			float m_submitterLimit;
-			
+		 	
 			
 		};
 		MatchListType* MatchList;
@@ -395,15 +398,33 @@ class Matchmaker : public Service
 		{
 		public:
 			SimpleGroupEntry();
+			SimpleGroupEntry(const Matchmaker::SimpleGroupEntry& entry);
 			~SimpleGroupEntry();
-			char *groupName;
+			string groupName;
 			float prio;
 			float maxAllowed;
+			float nodequota;
+			float nodemaxAllowed;
+			float quota;
 			float usage;
-			ClassAdList submitterAds;			
+			float unused;
+			bool autoregroup;
+			int parent;
+			int left;
+			int right;
+			int child;
+			int numsubmits;
+			bool staticquota;
+			ClassAdList submitterAds;
+			void sort(int length);
+			
+		SimpleGroupEntry & operator = (const SimpleGroupEntry  & entry);
+				
 		};
 		static int groupSortCompare(const void*, const void*);
-		
+		float fairshare( std::vector<SimpleGroupEntry> &groupArray, int index, float unused);
+		void sort( std::vector<SimpleGroupEntry> &groupArray,int length);
+
 		char RejectsTable[40];
 		char MatchesTable[40];
 		int prevLHF;
