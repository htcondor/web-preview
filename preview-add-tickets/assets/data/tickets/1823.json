{"id": 1823, "title": "Ticket #1823: management of many child heartbeat timers doesn't scale well", "description": "<blockquote>\nWhen the schedd has 40k-50k running jobs, we observe that it spends a large fraction of its time handling heartbeats from the shadows.  A typical call stack looks like this:\n\n<p></p><div class=\"verbatim\">\n<pre>#0  0x000000000059b35c in TimerManager::InsertTimer(tagTimer*) ()\n#1  0x000000000059bd90 in TimerManager::ResetTimer(int, unsigned int, unsigned int, bool, Timeslice const*) ()\n#2  0x0000000000585ac1 in DaemonCore::HandleChildAliveCommand(int, Stream*) ()\n#3  0x00000000005803e2 in DaemonCore::CallCommandHandler(int, Stream*, bool) ()\n#4  0x000000000058df57 in DaemonCore::HandleReq(Stream*, Stream*) ()\n#5  0x0000000000590740 in DaemonCore::HandleReqSocketHandler(Stream*) ()\n#6  0x0000000000590235 in DaemonCore::CallSocketHandler_worker(int, bool, Stream*) ()\n#7  0x00000000005906da in DaemonCore::CallSocketHandler_worker_demarshall(void*) ()\n#8  0x0000000000651458 in CondorThreads::pool_add(void (*)(void*), void*, int*, char const*) ()\n#9  0x00000000005897b9 in DaemonCore::CallSocketHandler(int&amp;, bool) ()\n#10 0x000000000058b6b5 in DaemonCore::Driver() ()\n#11 0x000000000057e860 in main ()\n</pre></div>\n\n\n<p>The problem is that <code>InsertTimer()</code> is expensive because it does a linear search through existing timers to find the appropriate place to insert the timer that enforces NOT_RESPONDING_TIMEOUT for the shadow that has just sent a heartbeat.\n\n</p><p>The workaround is to set SHADOW_NOT_RESPONDING_TIMEOUT higher.\n\n</p><p><span class=\"section\"></span></p><h2>Proposed Solution</h2>\n\n<p>The timers could be stored in a std::multimap with the firing time as the key.  This would allow efficient insertion.  However, removal or resetting of a timer would still be expensive, because it involves a linear search for a timer with the specified id.  This could be solved by having a map of id to timer.  When there are many timers registered to fire at the same time, removal or resetting of a timer from the multimap would still be expensive.  This would need to be studied.  If it is a problem, we could use std::map instead and create our own doubly linked list to handle collisions.  Removal of timer objects (given a pointer) from the doubly linked list would be fast.\n\n</p><p>An alternative solution is to not have one timer per child.  Instead, periodically do a sweep over all children to see if any have stalled.  This would sacrifice accuracy of enforcement of NOT_RESPONDING_TIMEOUT.  The parent process could be late by as much as the sweeping interval to notice that a child is not responding.  That seems perfectly acceptable.\n\n</p><p>Making timer management scale has the advantage that it could benefit other situations in condor where there are large numbers of timers.  However, it is a more complicated change than simply having a single timer to check for hung children.</p></blockquote>", "remarks": "<blockquote>\n<hr/>\n<em>2011-Feb-01 16:20:02 by tannenba:</em> <br/>\n\nBulk change of target version from v070506 to NULL using ./ticket-target-mover.\n\n<p></p><hr/>\n<em>2014-Jul-28 13:13:32 by bbockelm:</em> <br/>\n\nIs there still any interest in this ticket?\n\n<p></p><hr/>\n<em>2014-Jul-28 13:16:55 by sfiligoi:</em> <br/>\n\nUnless it was fixed by other means, I think we still need this fix.\n\n<p>While we currently hit the wall well below 40k for other reason, we will hopefully solve those problems eventually, so this will become very relevant at that point.</p></blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "", "type": "enhance", "last_change": "2014-Jul-28 13:16", "status": "new", "created": "2010-Dec-23 11:05", "fixed_version": "2010-Dec-23 11:05", "broken_version": "v070506", "priority": "3", "subsystem": "", "assigned_to": "", "derived_from": "", "creator": "danb", "rust": "", "customer_group": "cms", "visibility": "public", "notify": "dan@hep.wisc.edu, sfiligoi@fnal.gov, tstclair@redhat.com", "due_date": ""}