{"id": 4847, "title": "Ticket #4847: Collector doesn't listen on UDP 9618 with shared_port, IPv6, and IPv4", "description": "<blockquote>\n(This ticket was split off from <span class=\"ticket\"><a class=\"abandoned\" href=\"/tickets?ticket=4833\" onclick=\"get_ticket_and_populate_wrapper('4833'); return false;\" title=\"IPv6 bugfixes for 8.3.2\">#4833</a></span>.)\n\n<p>If shared_port, IPv6, and IPv4 are enabled, then the collector does not listen on IPv6 UDP 9618.\n\n</p><p>This is because DaemonCore::InitCommandSockets assumes that TCP and UDP sockets are on the same port. In the case of the collector using shared port, the collector listens on UDP port 9618 and the shared_port listens on TCP 9618 - breaking the code's assumption.</p></blockquote>", "remarks": "<blockquote>\n<em>2015-Jan-16 11:21 by tlmiller:</em>\n\n<p>As far as I can tell, it's a bug that the collector is trying to bind to a UDP port when shared port is enabled at all. The port should never be used. (Who would the collector ever tell about it? I guess maybe a collector tree, but it seems like this shouldn't generally be happening.)\n\n</p><p>That being said, I think you've misidentified the code's assumption. The target ports can only differ from the requested ports if the requested ports were dynamically assigned. If they are, then we assume that InitCommandSocket() (singular) will do what it's supposed to and fail if it can't bind both the TCP and the UDP port.\n\n</p><p>In point of actual fact, I don't think it does -- neither TJ nor I could find where, if InitCommandSocket() were given fixed port numbers, it actually binds the TCP port. Our best guess as to why it actually works right now is that the master uses a different method when it creates sockets for people to inherit, and nobody ever actually asks for an extra command socket on a specified port. This would tend to imply the master isn't doing the right thing here, but I need to investigate further.\n\n</p><p></p><hr/>\n<em>2015-Jan-17 07:48:35 by bbockelm:</em>\n\n<p>When the collector and shared_port are enabled (and if COLLECTOR_USES_SHARED_PORT is left to the default of true), then the shared_port will listen on TCP 9618 (forwarding non-shared-port requests to the collector).  Then, the collector will bind to UDP 9618 and a dynamic TCP port (this is because the remote daemons will still try to update via UDP).  Hence, for the case where the collector host is using shared port, <code>port=-1</code> and <code>udp_port=9618</code>.  However, the code </p><div class=\"verbatim\">\n<pre>targetTCPPort = targetUDPPort = rs-&gt;get_port();</pre></div>\n make an invalid assumption that <code>port = udp_port</code>. This causes the collector to break when shared_port is enabled in master.\n\n<p></p><hr/>\n<em>2015-Jan-26 10:56:25 by adesmet:</em> <br/>\n\nBased on discussion with ToddM, I believe this is how <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=InitCommandSockets\" title=\"Init Command Sockets\">InitCommandSockets</a></span> should work:\n\n<p>If <code>udp_port==1</code>: Bind to a v4 TCP port as specified by <code>port</code>, all other ports (v4 UDP, v6 TCP, v6 UDP) should match the v4 TCP.\n\n</p><p>If <code>udp_port==port</code>: As if <code>udp_port==1</code>\n\n</p><p>If <code>udp_port!=1 &amp;&amp; udp_port !=port</code>: v4 TCP should get same port as v6 TCP, v4 UD should get same port as v6 UDP, but TCP and UDP don't need to match.\n\n</p><p></p><hr/>\n<em>2015-Jan-26 13:29:26 by tlmiller:</em> <br/>\n\nProvisional patch.  I think we want to get this fixed for 8.3.3.\n\n<p></p><div class=\"code\">\n<pre class=\"code\">diff --git a/src/condor_daemon_core.V6/daemon_core.cpp b/src/condor_daemon_core.V6/daemon_core.cpp\nindex 89e0ff3..9786963 100644\n--- a/src/condor_daemon_core.V6/daemon_core.cpp\n+++ b/src/condor_daemon_core.V6/daemon_core.cpp\n@@ -9855,20 +9855,33 @@ InitCommandSocket(condor_protocol proto, int port, int udp_port, DaemonCore::Soc\n }\n\n bool\n-InitCommandSockets(int port, int udp_port, DaemonCore::SockPairVec &amp; socks, bool want_udp, bool fatal)\n+InitCommandSockets(int tcp_port, int udp_port, DaemonCore::SockPairVec &amp; socks, bool want_udp, bool fatal)\n {\n        // For historic reasons, port==0 is invalid, while port==-1 or port==1 means \"any port.\"\n-       ASSERT(port != 0);\n+       ASSERT(tcp_port != 0);\n\n        DaemonCore::SockPairVec new_socks;\n\n+       //\n+       // We need the IPv4 and IPv6 port numbers to match so that we can do\n+       // address rewriting.  We need the TCP and UDP port numbers within a\n+       // given protocol to match, because various other part of HTCondor\n+       // assume they do.  When using shared port, only the collector\n+       // will request a UDP port (for the collector ad and for collector\n+       // trees), which will have a different port number than the requested\n+       // TCP port (because the desired TCP port is already taken).  For now,\n+       // just permit this to occur and bind a useless TCP port.  In the future,\n+       // allow a UDP command socket to be requested and bound without involving\n+       // TCP at all.\n+       //\n+\n        // Arbitrary constant, borrowed from bindAnyCommandPort().\n        int retries = 1000;\n        do {\n\n                if(param_boolean(\"ENABLE_IPV4\", true)) {\n                        DaemonCore::SockPair sock_pair;\n-                       if( ! InitCommandSocket(CP_IPV4, port, udp_port, sock_pair, want_udp, fatal)) {\n+                       if( ! InitCommandSocket(CP_IPV4, tcp_port, udp_port, sock_pair, want_udp, fatal)) {\n                                dprintf(D_ALWAYS | D_FAILURE, \"Warning: Failed to create IPv4 command socket.\\n\");\n                                return false;\n                        }\n@@ -9879,15 +9892,17 @@ InitCommandSockets(int port, int udp_port, DaemonCore::SockPairVec &amp; socks, bool\n                // the port numbers match.  Mixed-mode shared port has no chance of\n                // working, otherwise, until we switch an address representation that\n                // can include both protocols' address(es).\n-               int targetTCPPort = port;\n+               int targetTCPPort = tcp_port;\n                int targetUDPPort = udp_port;\n                if( param_boolean( \"ENABLE_IPV4\", true ) &amp;&amp; param_boolean(\"ENABLE_IPV6\", true ) ) {\n                        // If port and udp_port are both static, we don't have to do anything.\n-                       if( port &lt;= 1 || udp_port &lt;= 1 ) {\n-                               // Determine which port IPv4 got, and try to get that port for IPv6.\n+                       if( tcp_port &lt;= 1 || udp_port &lt;= 1 ) {\n+                               // Determine which ports IPv4 got, and try to get that port for IPv6.\n                                DaemonCore::SockPair ipv4_socks = new_socks[0];\n                                counted_ptr&lt;ReliSock&gt; rs = ipv4_socks.rsock();\n-                               targetTCPPort = targetUDPPort = rs-&gt;get_port();\n+                               targetTCPPort = rs-&gt;get_port();\n+                               counted_ptr&lt;SafeSock&gt; ss = ipv4_socks.ssock();\n+                               targetUDPPort = ss-&gt;get_port();\n                        }\n                }\n\n@@ -9901,13 +9916,19 @@ InitCommandSockets(int port, int udp_port, DaemonCore::SockPairVec &amp; socks, bool\n                }\n\n         -                       if( targetTCPPort != port &amp;&amp; targetUDPPort != udp_port ) {\n+                       if( targetTCPPort != tcp_port &amp;&amp; targetUDPPort != udp_port ) {\n                                DaemonCore::SockPair ipv6_socks = new_socks[1];\n                                counted_ptr&lt;ReliSock&gt; rs = ipv6_socks.rsock();\n-                               int ipv6Port = rs-&gt;get_port();\n+                               int ipv6TCPPort = rs-&gt;get_port();\n+                               counted_ptr&lt;SafeSock&gt; ss = ipv6_socks.ssock();\n+                               int ipv6UDPPort = ss-&gt;get_port();\n\n-                               if( ipv6Port != targetTCPPort ) {\n-                                       dprintf( D_FULLDEBUG, \"Bound to IPv4 port %d, but then bound to IPv6 command port %d.\\n\", targetTCPPort, ipv6Port );\n+                               if( ipv6TCPPort != targetTCPPort ) {\n+                                       dprintf( D_FULLDEBUG, \"Bound to IPv4 TCP port %d, but then bound to IPv6 TCP port %d.\\n\", targetTCPPort, ipv6TCPPort );\n+                                       new_socks.clear();\n+                                       --retries;\n+                               } else if( ipv6UDPPort != targetUDPPort ) {\n+                                       dprintf( D_FULLDEBUG, \"Bound to IPv4 UDP port %d, but then bound to IPv6 UDP port %d.\\n\", targetUDPPort, ipv6UDPPort );\n                                        new_socks.clear();\n                                        --retries;\n                                } else {\n       if( param_boolean( \"ENABLE_IPV4\", true ) &amp;&amp; param_boolean(\"ENABLE_IPV6\", true ) ) {\n</pre></div>\n\n\n<p></p><hr/>\n<em>2015-Jan-26 14:49:03 by adesmet:</em> <br/>\n\n<strong>CODE REVIEW</strong> Needs a change:\n\n<p></p><div class=\"code\">\n<pre class=\"code\">+                               counted_ptr&lt;SafeSock&gt; ss = ipv4_socks.ssock();\n+                               targetUDPPort = ss-&gt;get_port();\n</pre></div>\n\n\n<p>If want_udp=false, ipv4_socks.ssock() will return NULL.  counted_ptr might blow up, ss-&gt;get_port() definitely will\n\n</p><p></p><hr/>\n<em>2015-Jan-26 16:38:28 by adesmet:</em> <br/>\n\nProposed patch attached: <a class=\"external\" href=\"https://htcondor-wiki.cs.wisc.edu/index.cgi/attach_get/863/4847.patch\">https://htcondor-wiki.cs.wisc.edu/index.cgi/attach_get/863/4847.patch</a>\n\n<p></p><hr/>\n<em>2015-Jan-26 17:19:27 by adesmet:</em> <br/>\n\nMy work pushed to main repo as V8_3_3-4847-branch .See <span class=\"chng\"><a href=\"chngview?cn=42398\">[42398]</a></span> and <span class=\"chng\"><a href=\"chngview?cn=42399\">[42399]</a></span>.\n\n<p></p><hr/>\n<em>2015-Jan-28 11:28:45 by tlmiller:</em> <br/>\n\n<strong>Code Review</strong>\n\n<p>Looks good.\n\n</p><p></p><hr/>\n<em>2015-Jan-28 11:37:51 by adesmet:</em> <br/>\n\nIf the collector is on a fixed port (COLLECTOR_HOST does not end with \":0\"), the collector will listen on UDP 9618 for all supported protocols.\n\n<p>If the collector is on a dynamic port (COLLECTOR_HOST ends with \":0\"), IPv6 may not be listened to at all. This is known and not a regression.\n\n</p><p>Confirmed: even after the change, the shadows do not listen on UDP, as desired.\n\n</p><p></p><hr/>\n<em>2015-Jan-28 15:10:12 by adesmet:</em> <br/>\n\nBroken code never shipped. 8.3.2 is fine. So no version history change needed.\n\n<p></p><hr/>\n<em>2015-Jan-28 15:10:25 by adesmet:</em> <br/>\n\nReviewed, merged, no documentation needed. Closing.</blockquote>", "derived_tickets": "", "attachments": "<blockquote>\n<ul>\n<li><a href=\"attach_get/863/4847.patch\">4847.patch</a>\n6823 bytes added by adesmet on 2015-Jan-26 22:34:54 UTC.\n<br/>\nRevised attempt at a patch.<br/>\n</li></ul>\n</blockquote>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2015-Jan-28 13:11</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=42435\">[42435]</a></span>: Merged <span class=\"chng\"><a href=\"chngview?cn=42398\">[42398]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=42399\">[42399]</a></span>, Merge branch 'V8_3_3-4847-branch' into V8_3_3-branch <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=4847\" onclick=\"get_ticket_and_populate_wrapper('4847'); return false;\" title=\"Collector doesn't listen on UDP 9618 with shared_port, IPv6, and IPv4\">#4847</a></span>  (By Alan De Smet )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2015-Jan-26 17:14</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=42399\">[42399]</a></span>: Revisions for <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=4847\" onclick=\"get_ticket_and_populate_wrapper('4847'); return false;\" title=\"Collector doesn't listen on UDP 9618 with shared_port, IPv6, and IPv4\">#4847</a></span> per tlmiller's review.  (By Alan De Smet )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2015-Jan-26 16:30</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=42398\">[42398]</a></span>: <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=InitCommandSockets\" title=\"Init Command Sockets\">InitCommandSockets</a></span>: support static UDP, dynamic TCP ports Overhauled <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=InitCommandSockets\" title=\"Init Command Sockets\">InitCommandSockets</a></span>. <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=InitCommandSockets\" title=\"Init Command Sockets\">InitCommandSockets</a></span> now supports specifying a static UDP port and a dynamic TCP port when both IPv6 and IPv4 are enabled. Previously it would fail to create the IPv6 static UDP socket. Also: Some cleanup, eliminated\u00a0[...]\n (By Alan De Smet )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2015-Jan-14 22:08</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=42222\">[42222]</a></span>: Fix various IPv6 issues. <span class=\"ticket\"><a class=\"abandoned\" href=\"/tickets?ticket=4833\" onclick=\"get_ticket_and_populate_wrapper('4833'); return false;\" title=\"IPv6 bugfixes for 8.3.2\">#4833</a></span> In particular: 1) Make sure the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=InitCommandSockets\" title=\"Init Command Sockets\">InitCommandSockets</a></span> code does not rely on the TCP port and UDP port being the same. In the case of the collector- behind-shared-port, the collector listens on UDP 9618 and a random TCP port. Previously, the code caused the collector to listen\u00a0[...]\n (By Brian Bockelman )</td></tr>\n</tbody></table>", "type": "defect", "last_change": "2015-Jan-28 15:11", "status": "resolved", "created": "2015-Jan-23 14:27", "fixed_version": "2015-Jan-23 14:27", "broken_version": "v080303", "priority": "4", "subsystem": "Daemons", "assigned_to": "adesmet", "derived_from": "#4492", "creator": "bbockelm", "rust": "", "customer_group": "other", "visibility": "public", "notify": "bbockelm@cse.unl.edu, tlmiller@cs.wisc.edu,adesmet@cs.wisc.edu", "due_date": ""}