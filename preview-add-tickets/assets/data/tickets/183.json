{"id": 183, "title": "Ticket #183: on linux an abort in glibc causes infinite loop with google coredumper", "description": "<blockquote>\nRunning the debian 4.0 binaries on debian 5.0 have shown a really good bug:\n\n<p>Imagine this cycle, repeating for tens of thousands of stack frames until\nyou run out of stack to allocate:\n\n</p><p></p><div class=\"verbatim\">\n<pre>#14 0x083c5a51 in kill ()\n#15 0x083c587e in raise ()\n#16 0x083c5cfb in abort ()\n#17 0x083c1156 in __assert_fail ()\n#18 0x084088da in __nscd_getgrouplist ()\n#19 0x083f876f in internal_getgrouplist ()\n#20 0x083f8878 in initgroups ()\n#21 0x0811206e in passwd_cache::cache_groups (this=0x9e86b48,\n    user=0x9ebe0e0 \"sl2-user\") at passwd_cache.C:109\n#22 0x08112474 in passwd_cache::num_groups (this=0x9e86b48,\n    user=0x9ebe0e0 \"sl2-user\") at passwd_cache.C:236\n#23 0x081124d2 in passwd_cache::init_groups (this=0x9e86b48,\n    user=0x9ebe0e0 \"sl2-user\", additional_gid=0) at passwd_cache.C:386\n#24 0x0811078a in set_user_egid () at uids.C:1364\n#25 0x0811164f in _set_priv (s=PRIV_USER, file=0x843e0cc \"dprintf.c\",\n    line=1187, dologging=0) at uids.C:1148\n#26 0x080ab569 in dprintf_dump_stack () at dprintf.c:1187\n#27 0x0809ceaa in linux_sig_coredump (signum=6) at daemon_core_main.C:631\n#28 &lt;signal handler called&gt;\n</pre></div>\n\n\n<p>Cool eh? Apparently, while trying to printf the stack trace, we fault\nagain and go right back into the loop. Funny thing is, <strong>glibc</strong> is calling\nabort() since initgroups() is a call into glibc.\n\n</p><p>The fix appears to be to set the default signal handler in linux_sig_coredump()\n<strong>before</strong> calling a lot of code which could result in another signal, instead of\nafter.</p></blockquote>", "remarks": "<blockquote>\n<em>2009-Feb-03 20:56:51 by psilord:</em> <br/>\n\nHere is the initial stack trace which caused the loop:\n\n<p></p><div class=\"verbatim\">\n<pre>#441508 &lt;signal handler called&gt;\n#441509 0x083c5a51 in kill ()\n#441510 0x083c587e in raise ()\n#441511 0x083c5cfb in abort ()\n#441512 0x083c1156 in __assert_fail ()\n#441513 0x084088da in __nscd_getgrouplist ()\n#441514 0x083f876f in internal_getgrouplist ()\n#441515 0x083f8878 in initgroups ()\n#441516 0x0811206e in passwd_cache::cache_groups (this=0x9e86b48,\n    user=0x9ebe0e0 \"sl2-user\") at passwd_cache.C:109\n#441517 0x08112474 in passwd_cache::num_groups (this=0x9e86b48,\n    user=0x9ebe0e0 \"sl2-user\") at passwd_cache.C:236\n#441518 0x081124d2 in passwd_cache::init_groups (this=0x9e86b48,\n    user=0x9ebe0e0 \"sl2-user\", additional_gid=0) at passwd_cache.C:386\n#441519 0x0811078a in set_user_egid () at uids.C:1364\n#441520 0x0811164f in _set_priv (s=PRIV_USER, file=0x842ce71 \"starter.C\",\n    line=580, dologging=1) at uids.C:1148\n#441521 0x0804d320 in CStarter::createTempExecuteDir (this=0x8533180)\n    at starter.C:580\n#441522 0x08066fa1 in JICShadow::init (this=0x9eafea8) at jic_shadow.C:187\n#441523 0x0804dbf0 in CStarter::Init (this=0x8533180, my_jic=0x9eafea8,\n    original_cwd=0x9e78ca8 \"/home/condor/log\", is_gsh=false, stdin_fd=3,\n    stdout_fd=4, stderr_fd=5) at starter.C:191\n#441524 0x080496b0 in main_init (argc=2, argv=0xbfb0ceb0)\n    at starter_v61_main.C:299\n#441525 0x0809ef5d in main (argc=2, argv=0xbfb0ceb0) at daemon_core_main.C:2056\n</pre></div>\n\n\n<p></p><hr/>\n<em>2009-Feb-04 10:08:02 by psilord:</em> <br/>\n\nIt seems the details on the ground was that the <strong>static</strong> binaries for deb 4.0 were used on the deb 5.0 machine because of a broken dependancy with libssp not existing on the deb 5.0 machine. So, does this mean there is a protocol error or whatever between how glibc talks to ncsd on deb 4.0 and how glibc talks to ncsd on deb 5.0 and the glibc from deb 4.0 will internally abort if it doesn't understand the protocol over the pipe to the ncsd?\n\n<p></p><hr/>\n<em>2009-Feb-04 11:07:21 by adesmet:</em> <br/>\n\nThe call to dprintf_dump_stack is new since I wrote linux_sig_coredump, but as best I can tell:\n\n<p>Moving resetting the signal to default to the start seems like a good idea.  Crashes should not loop.  However, this glosses over another problem: If we're deep in the passwd_cache, are we really in signal-safe code?\n\n</p><p></p><hr/>\n<em>2009-Feb-04 11:08:56 by psilord:</em> <br/>\n\nYeah, linux_sig_coredumper calls dprintf_dump_stack, which also isn't async-signal-safe because it uses sprintf and calls into safe_open_wrapper, which I don't think is async-signal-safe either. This aspect is a stumbleon, I presume.\n\n<p></p><hr/>\n<em>2009-Feb-04 11:22:07 by psilord:</em> <br/>\n\nMan, there are all kinds of things that are async-signal-unsafe in the linux_sig_coredump() codepath. Eeewww.....\n\n<p></p><hr/>\n<em>2009-Feb-04 11:51:25 by psilord:</em> <br/>\n\nIn carefully inspecting the code path for how linux_sig_coredump() gets installed as a signal handler, it appears that all signals should be blocked during installation if the handler, so, how does the code end up in an infinite loop?\n\n<p></p><hr/>\n<em>2009-Feb-04 14:45:52 by psilord:</em> <br/>\n\nOk, I found out why the handler went into an infinite loop and it is ugly.\n\n<p>The deal is that we had gotten inside of the handler because abort() had been called by glibc initially. Inside the handler, which we had set up to block the signals, but ended up calling abort() again. abort() directly called the handler, regardless of the signal block state, causing the infinite loop since\nin the net invocation of the handler, it simply called abort again.\n\n</p><p>Here is a test program which shows it. You can play with the raise()/abort()\ncalls to learn of the surprising difference of abort() form it:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;string.h&gt;\n\nextern void foo(void);\n\ntypedef void (*SIG_HANDLER)(int);\n\nvoid install_sig_handler_with_mask(int sig, sigset_t* set, SIG_HANDLER handler);\nvoid linux_sig_coredump(int signum);\n\nvoid\ninstall_sig_handler_with_mask( int sig, sigset_t* set, SIG_HANDLER handler )\n{\n    struct sigaction act;\n\n    act.sa_handler = handler;\n    act.sa_mask = *set;\n    act.sa_flags = 0;\n\n    if( sigaction(sig,&amp;act,0) &lt; 0 ) {\n        perror( \"sigaction\" );\n    }\n}\n\nvoid\nlinux_sig_coredump(int signum)\n{\n    char *a = NULL;\n    char *msg = NULL;\n\n        // Just in case we're running as condor or a user.\n    setuid(0);\n    setgid(0);\n\n    msg = \"Got a signal!\\n\";\n    write(STDOUT_FILENO, msg, strlen(msg));\n    fsync(STDOUT_FILENO);\n\n    msg = \"Comitting secondary SIGABRT\\n\";\n    write(STDOUT_FILENO, msg, strlen(msg));\n    fsync(STDOUT_FILENO);\n\n/*  raise(SIGABRT);*/\n    abort();\n\n        // It would be idea to actually terminate for the same reason.\n    struct sigaction sa;\n    sa.sa_handler = SIG_DFL;\n    sigemptyset(&amp;sa.sa_mask);\n    sa.sa_flags = 0;\n    sigaction(signum, &amp;sa, NULL);\n    sigprocmask(SIG_SETMASK, &amp;sa.sa_mask, NULL);\n\n    raise(signum);\n\n    exit(1);\n}\n\nint main(void)\n{\n    sigset_t fullset;\n    char *a = NULL;\n\n    printf(\"Installing handlers, blocking all signals in the handler\\n\");\n\n    sigfillset( &amp;fullset );\n    install_sig_handler_with_mask(SIGSEGV, &amp;fullset, linux_sig_coredump);\n    install_sig_handler_with_mask(SIGABRT, &amp;fullset, linux_sig_coredump);\n    install_sig_handler_with_mask(SIGILL, &amp;fullset, linux_sig_coredump);\n    install_sig_handler_with_mask(SIGFPE, &amp;fullset, linux_sig_coredump);\n    install_sig_handler_with_mask(SIGBUS, &amp;fullset, linux_sig_coredump);\n\n    printf(\"Comitting initial SIGABRT\\n\");\n\n/*  raise(SIGABRT);*/\n    abort();\n\n    return 0;\n}\n</pre></div>\n\n\n<p>The solution is to add this block of code to the top of the handler:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">    static int foo = 0;\n    if (foo) { return; }\n    foo = 1;\n</pre></div>\n\n\n<p>This prevents the secondary abort() from reentering the handler. It sucks because it is reminiscent of the stupid SYSV signal() semantics, which sucked.\n\n</p><p>As evidence that abort() and raise(SIGABRT) do different things. I submit an excerpt of the linux man page for abort():\n\n</p><p>\"If the SIGABRT signal is blocked or ignored, the abort() function  will still override it.\"\n\n</p><p>The ramifications of this is that every signal handler we write in Condor needs the static guard variable (and possibly to reset it back to zero just before the handler returns if it is not meant to exit()).\n\n</p><p></p><hr/>\n<em>2009-Feb-04 14:59:55 by psilord:</em> <br/>\n\nAnd, more evidence to back it up, in case people <strong>still</strong> don't believe me. This strace shows plain as day the abort() call unblocking the SIGABRT signal:\n\n<p></p><div class=\"verbatim\">\n<pre>rt_sigaction(SIGSEGV, {0x804859c, ~[RTMIN RT_1], 0}, NULL, 8) = 0\nrt_sigaction(SIGABRT, {0x804859c, ~[RTMIN RT_1], 0}, NULL, 8) = 0\nrt_sigaction(SIGILL, {0x804859c, ~[RTMIN RT_1], 0}, NULL, 8) = 0\nrt_sigaction(SIGFPE, {0x804859c, ~[RTMIN RT_1], 0}, NULL, 8) = 0\nrt_sigaction(SIGBUS, {0x804859c, ~[RTMIN RT_1], 0}, NULL, 8) = 0\nrt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0\nwrite(1, \"Installing handlers, blocking al\"..., 83Installing handlers, blocking\nall signals in the handler\nComitting initial SIGABRT\n) = 83\ngettid()                                = 27118\ntgkill(27118, 27118, SIGABRT)           = 0\n--- SIGABRT (Aborted) @ 0 (0) ---\nsetuid32(0)                             = -1 EPERM (Operation not permitted)\nsetgid32(0)                             = -1 EPERM (Operation not permitted)\nwrite(1, \"Got a signal!\\n\", 14Got a signal!\n)         = 14\nfsync(1)                                = -1 EINVAL (Invalid argument)\nwrite(1, \"Comitting secondary SIGABRT\\n\", 28Comitting secondary SIGABRT\n) = 28\nfsync(1)                                = -1 EINVAL (Invalid argument)\nrt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0\ntgkill(27118, 27118, SIGABRT)           = 0\n--- SIGABRT (Aborted) @ 0 (0) ---\nsetuid32(0)                             = -1 EPERM (Operation not permitted)\nsetgid32(0)                             = -1 EPERM (Operation not permitted)\nwrite(1, \"Got a signal!\\n\", 14Got a signal!\n)         = 14\nfsync(1)                                = -1 EINVAL (Invalid argument)\nwrite(1, \"Comitting secondary SIGABRT\\n\", 28Comitting secondary SIGABRT\n) = 28\nfsync(1)                                = -1 EINVAL (Invalid argument)\nrt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0\ntgkill(27118, 27118, SIGABRT)           = 0\n--- SIGABRT (Aborted) @ 0 (0) ---\nsetuid32(0)                             = -1 EPERM (Operation not permitted)\nsetgid32(0)                             = -1 EPERM (Operation not permitted)\nwrite(1, \"Got a signal!\\n\", 14Got a signal!\n)         = 14\nfsync(1)                                = -1 EINVAL (Invalid argument)\nwrite(1, \"Comitting secondary SIGABRT\\n\", 28Comitting secondary SIGABRT\n) = 28\nfsync(1)                                = -1 EINVAL (Invalid argument)\nrt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0\ntgkill(27118, 27118, SIGABRT)           = 0\n--- SIGABRT (Aborted) @ 0 (0) ---\n</pre></div>\n\n\n<p></p><hr/>\n<em>2009-Feb-04 15:21:17 by psilord:</em> <br/>\n\n<span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DanBradley\" title=\"Dan Bradley\">DanBradley</a></span> is fixing the dprintf_dump_stack() call graph to only call asynch-signal-safe functions as defined by POSIX.\n\n<p></p><hr/>\n<em>2009-Feb-04 15:30:00 by danb:</em> <br/>\n\nHere's my proposed patch:\n\n<p></p><div class=\"code\">\n<pre class=\"code\">diff --git a/src/condor_util_lib/dprintf.c b/src/condor_util_lib/dprintf.c\nindex 591686c..0747871 100644\n--- a/src/condor_util_lib/dprintf.c\n+++ b/src/condor_util_lib/dprintf.c\n@@ -1161,16 +1161,55 @@ dprintf_wrapup_fork_child( ) {\n }\n\n #if HAVE_BACKTRACE\n+\n+static void\n+safe_async_simple_fwrite_fd(int fd,char const *msg,unsigned int *args,unsigned int num_args)\n+{\n+       unsigned int arg_index;\n+       unsigned int digit,arg;\n+       char intbuf[50];\n+       char *intbuf_pos;\n+\n+       for(;*msg;msg++) {\n+               if( *msg != '%' ) {\n+                       write(fd,msg,1);\n+               }\n+               else {\n+                               // format is % followed by index of argument in args array\n+                       arg_index = *(++msg)-'0';\n+                       if( arg_index &gt;= num_args || !*msg ) {\n+                               write(fd,\" INVALID! \",10);\n+                               break;\n+                       }\n+                       arg = args[arg_index];\n+                       intbuf_pos=intbuf;\n+                       do {\n+                               digit = arg % 10;\n+                               *(intbuf_pos++) = digit + '0';\n+                               arg /= 10;\n+                       } while( arg );\n+\n+                               // intbuf now contains the base-10 digits of arg\n+                               // in order of least to most significant\n+                       while( intbuf_pos-- &gt; intbuf ) {\n+                               write(fd,intbuf_pos,1);\n+                       }\n+               }\n+       }\n+}\n+\n void\n dprintf_dump_stack(void) {\n-       priv_state      priv;\n+       priv_state      orig_priv_state;\n+       int orig_euid;\n+       int orig_egid;\n        int fd;\n        void *trace[50];\n        int trace_size;\n-       char notice[100];\n+       unsigned int args[3];\n\n                /* In case we are dumping stack in the segfault handler, we\n-                  want this to be a simple as possible.  Calling malloc()\n+                  want this to be as simple as possible.  Calling malloc()\n                   could be fatal, since the heap may be trashed.  Therefore,\n                   we dispense with some of the formalities... */\n\n@@ -1184,9 +1223,28 @@ dprintf_dump_stack(void) {\n                fd = 2;\n        }\n        else {\n-               priv = _set_priv(PRIV_CONDOR, __FILE__, __LINE__, 0);\n+                       // set_priv() is unsafe, because it may call into\n+                       // the password cache, which may call unsafe functions\n+                       // such as getpwuid() or initgroups() or malloc().\n+               orig_euid = geteuid();\n+               orig_egid = getegid();\n+               orig_priv_state = get_priv_state();\n+               if( orig_priv_state != PRIV_CONDOR ) {\n+                               // To keep things simple, rather than trying to become\n+                               // the correct condor id, just switch to our real\n+                               // user id, which is probably either the same as\n+                               // our effective id (no-op) or root.\n+                       setegid(getgid());\n+                       seteuid(getuid());\n+               }\n+\n                fd = safe_open_wrapper(DebugFile[0],O_APPEND|O_WRONLY|O_CREAT,0644);\n-               _set_priv(priv, __FILE__, __LINE__, 0);\n+\n+               if( orig_priv_state != PRIV_CONDOR ) {\n+                       setegid(orig_egid);\n+                       seteuid(orig_euid);\n+               }\n+\n                if( fd==-1 ) {\n                        fd=2;\n                }\n@@ -1194,8 +1252,12 @@ dprintf_dump_stack(void) {\n\n        trace_size = backtrace(trace,50);\n\n-       sprintf(notice,\"Stack dump for process %d at timestamp %ld (%d frames)\\n\",getpid(),(long)time(NULL),trace_size);\n-       write(fd,notice,strlen(notice));\n+               // sprintf() and other convenient string-handling functions\n+               // are not officially async-signal safe, so use a crude replacement\n+       args[0] = (unsigned int)getpid();\n+       args[1] = (unsigned int)time(NULL);\n+       args[2] = (unsigned int)trace_size;\n+       safe_async_simple_fwrite_fd(fd,\"Stack dump for process %0 at timestamp %1 (%2 frames)\\n\",args,3);\n\n        backtrace_symbols_fd(trace,trace_size,fd);\n</pre></div>\n\n\n<p></p><hr/>\n<em>2009-Feb-04 15:34:49 by psilord:</em> <br/>\n\nHere is my patch to fix the reentrancy problem:\n\n<p></p><div class=\"code\">\n<pre class=\"code\">diff --git a/src/condor_daemon_core.V6/daemon_core_main.cpp b/src/condor_daemon_\nindex 6c638bb..876e4e2 100644\n--- a/src/condor_daemon_core.V6/daemon_core_main.cpp\n+++ b/src/condor_daemon_core.V6/daemon_core_main.cpp\n@@ -632,9 +632,30 @@ static char *core_dir = NULL;\n void\n linux_sig_coredump(int signum)\n {\n+   struct sigaction sa;\n+   static bool down = false;\n+\n+   /* It turns out that the abort() call will unblock the sig\n+       abort signal and allow the handler to be called again. So,\n+       in a real world case, which led me to write this test,\n+       glibc decided something was wrong and called abort(),\n+       then, in this signal handler, we tickled the exact\n+       thing glibc didn't like in the first place and so it\n+       called abort() again, leading back to this handler. A\n+       segmentation fault happened finally when the stack was\n+       exhausted. This guard is here to prevent that type of\n+       scenario from happening again with this handler.  NOTE:\n+       We never set down to false again, because this handler\n+       is meant to exit() and not return. */\n+\n+   if (down == true) {\n+       return;\n+   }\n+   down = true;\n+\n    dprintf_dump_stack();\n\n-       // Just in case we're running as condor or a user.\n+   // Just in case we're running as condor or a user.\n    setuid(0);\n    setgid(0);\n\n@@ -644,8 +665,7 @@ linux_sig_coredump(int signum)\n\n    WriteCoreDump(\"core\");\n\n-       // It would be idea to actually terminate for the same reason.\n-   struct sigaction sa;\n+   // It would be a good idea to actually terminate for the same reason.\n    sa.sa_handler = SIG_DFL;\n    sigemptyset(&amp;sa.sa_mask);\n    sa.sa_flags = 0;\n@@ -654,7 +674,10 @@ linux_sig_coredump(int signum)\n\n    raise(signum);\n\n-   exit(1); // Just in case.\n+   // If for whatever reason the second raise doesn't kill us properly,\n+   // we shall exit with a non-zero code so if anything depends on us,\n+   // at least they know there was a problem.\n+   exit(1);\n }\n #endif\n</pre></div>\n\n\n<p></p><hr/>\n<em>2009-Feb-04 15:40:17 by psilord:</em> <br/>\n\nI noticed something funny that is in the context around your patch, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DanBradley\" title=\"Dan Bradley\">DanBradley</a></span>.\n\n<p></p><div class=\"code\">\n<pre class=\"code\">if (fd == -1) {\n     fd = 2;\n}\n</pre></div>\n\n\n<p>That seems hilariously bad, because 2 is guaranteed to be stdout anymore in a daemoncore process. Basically 2 could be anything, so in this case, when a daemon dies in this handler, it could spew garbage to a different daemon. No good. :)\n\n</p><p></p><hr/>\n<em>2009-Feb-04 16:03:12 by danb:</em> <br/>\n\nIn what case would fd 2 not be stderr in a daemoncore process?  There's a big comment in daemon_core_main() tagged \"NRL 2006-08-10\" that indicates to me that we decided it was a bad idea for fd 2 to be used for other purposes.\n\n<p></p><hr/>\n<em>2009-Feb-04 16:12:52 by psilord:</em> <br/>\n\nSo there is. I guess my knowledge on that topic is old.\n\n<p></p><hr/>\n<em>2009-Feb-04 16:18:02 by psilord:</em> <br/>\n\nI'd comment that you are using integer truncation to terminate the mod-div loop and that this will silently convert all args given to it into positive integers. Then you can check it in.\n\n<p></p><hr/>\n<em>2009-Feb-04 16:54:31 by psilord:</em> <br/>\n\nI think, once <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DanBradley\" title=\"Dan Bradley\">DanBradley</a></span> checks his code in, I'm going to resolve this ticket and make a new one specifically about the glibc failure.</blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2021-Aug-27 15:04</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=64225\">[64225]</a></span>: HTCONDOR-572: Fix up Dave Dykstra's pull request <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=183\" onclick=\"get_ticket_and_populate_wrapper('183'); return false;\" title=\"on linux an abort in glibc causes infinite loop with google coredumper\">#183</a></span>  (By Tim Theisen )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2009-Feb-04 17:35</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=13752\">[13752]</a></span>: Made dprintf_dump_stack() async-signal-safe. The main problem was the call to set_priv(), which can call passwd_cache stuff, which calls things that are not safe. See ticket <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=183\" onclick=\"get_ticket_and_populate_wrapper('183'); return false;\" title=\"on linux an abort in glibc causes infinite loop with google coredumper\">#183</a></span>.  (By Dan Bradley )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2009-Feb-04 16:47</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=24587\">[24587]</a></span>: Documented fix for ticket <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=183\" onclick=\"get_ticket_and_populate_wrapper('183'); return false;\" title=\"on linux an abort in glibc causes infinite loop with google coredumper\">#183</a></span>.  (By Peter Keller )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2009-Feb-04 16:40</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=13750\">[13750]</a></span>: This fixes a bug found in ticket <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=183\" onclick=\"get_ticket_and_populate_wrapper('183'); return false;\" title=\"on linux an abort in glibc causes infinite loop with google coredumper\">#183</a></span>. Under certain conditions, linux_sig_coredump() became reentrant, and recursed itself to death.\u00a0[...]\n (By Peter Keller )</td></tr>\n</tbody></table>", "type": "defect", "last_change": "2009-Dec-26 20:18", "status": "resolved", "created": "2009-Feb-03 20:53", "fixed_version": "2009-Feb-03 20:53", "broken_version": "v070200", "priority": "2", "subsystem": "Libs", "assigned_to": "psilord", "derived_from": "#24", "creator": "psilord", "rust": "", "customer_group": "other", "visibility": "public", "notify": "", "due_date": ""}