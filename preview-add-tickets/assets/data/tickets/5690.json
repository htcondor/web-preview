{"id": 5690, "title": "Ticket #5690: systemd socket activation causes host-based security grief", "description": "<blockquote>\nWhen HTCondor is \"using passed TCP socket from systemd,\" and CONDOR_HOST is set to $(FULL_HOSTNAME), then 'use security : host_based' will cause condor_reconfig (and condor_off, etc) to fail, saying something like\n\n<p></p><div class=\"verbatim\">\n<pre>ERROR SECMAN:2010:Received \"DENIED\" from server for user unauthenticated@unmapped using no authentication method, which may imply host-based security.  Our address was '::1', and server's address was '::1'.  Check your ALLOW settings and IP protocols.\n</pre></div>\n\n\n<p>This error message is expected, in one sense, because $(FULL_HOSTNAME) almost never resolves to the IPv6 loopback address; and unexpected the other sense, because why is the client connecting from that address to that address.\n\n</p><p>I speculate that this has to do with some combination of only getting a single socket from systemd -- on a mixed-mode system HTCondor would normally have one for each protocol version -- and systemd binding the same socket simultaneously to IPv6 and IPv4 (probably all interfaces as well).  This may cause weird code problems, although I haven't investigated.  (Having one socket is generally OK, but potentially unexpected in mixed mode; having a socket which doesn't have a well-defined protocol may be a little upsetting; and I'm not sure how we'd handle accept()ing on the same socket and getting different protocol sockets back, which is how I expect this randomness (is supposed to) works.)\n\n</p><p>Additionally, there may be a serious meta-problem where the socket (and listening address(es) handed to us from systemd is (and is/are) completely independent of HTCondor's configuration.  For instance, it's possible to configure HTCondor to listen to one address and systemd to another.  I assume things would break horribly, but I'm not sure of precisely how.  It seems reasonable to at least investigate how hard it would be to determine what address(es) and protocol(s) our shared port socket is actually listening to and compare that to its configured/expected value(s).\n\n</p><p>It seems like this should be investigated, even if we decide to solve the problem with an alternate approach (e.g., a magic 'self' identifier or config variable and/or cleverness dealing advertising for local vs remote clients*, versus advertising a GUID so the client can make that decision).\n\n</p><p>* : If the AddressV2 stuff were available, we could just advertise the loopback addresses as a private network.  We'd need to name the private network with some globally-unique identifier; it could be a GUID or maybe the global address of the daemon in question (if available).  IIRC, our preference sorting checks for private networks first already; we may need additional tweaking to prefer this type of private network.</p></blockquote>", "remarks": "<blockquote>\n</blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "", "type": "defect", "last_change": "2016-May-24 18:17", "status": "new", "created": "2016-May-24 18:00", "fixed_version": "2016-May-24 18:00", "broken_version": "v080505", "priority": "4", "subsystem": "DaemonMaster", "assigned_to": "", "derived_from": "#4144", "creator": "tlmiller", "rust": "", "customer_group": "other", "visibility": "public", "notify": "tlmiller@cs.wisc.edu, tim@cs.wisc.edu, bbockelm@cse.unl.edu", "due_date": ""}