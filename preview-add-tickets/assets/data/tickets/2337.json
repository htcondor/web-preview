{"id": 2337, "title": "Ticket #2337: Implement 64-bit support for file i/o in stduniv", "description": "<blockquote>\nLIGO would like that stduniv file i/o can break the 32-bit boundary. It is currently a hard restriction that this is true even on 64-bit machines.\n\n<p><span class=\"subsection\"></span></p><h3>Milestones </h3>\n<ul>\n<li><strong>[DONE]</strong> Write a test to show 64-bit files not working.\n</li><li><strong>[DONE]</strong> Figure out why 64-bit file stduniv test fails.\n</li><li><strong>[DONE]</strong> Fix the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=FileTab\" title=\"File Tab\">FileTab</a></span> to honor the off_t type instead of int for lseek().\n</li><li><strong>[DONE]</strong> Fix the stub generator to produce stubs that are congnizant of the return types of syscalls instead of them just being all 'int' return types, which is provably wrong. Also, the fixing of the lseek() member function on the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=FileTab\" title=\"File Tab\">FileTab</a></span> requires the stub generator to be fixed since the stub generator generates calls to members of the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=FileTab\" title=\"File Tab\">FileTab</a></span> which have different return types.\n</li><li><strong>[DONE]</strong> Fix any ramifications from the previous step, things like fixing system call return value checks to be cognoscente of pointers, stopping handling undefined return values from system calls that returned void (but weren't handled properly), etc, etc, etc\n</li><li><strong>[DONE]</strong> Analyze the changes in the protocols from before my change to after my change to determine if I introduced protocol incompatibilities. I'm writing a document which records the steps I did and the problems found and solutions performed. (Two problems found which break compatibility.)\n</li><li><strong>[DONE]</strong> Run through the test suite on all machines, fix any missed problems. <strong>Unfortunately, the getdirentries syscall is fragile, and this feature breaks it the rest of the way in an unknown manner. It will be fixed after this feature gets checked in.</strong>\n</li><li><strong>[DONE]</strong> Polish the large file test and put it into the test suite.\n</li><li><strong>[IGNORING]</strong> Check and possibly fix the llseek() system call, since it was defined <strong>very</strong> poorly in the stduniv and needs some thinking to figure out.\n</li><li><strong>[DONE]</strong> Final check and committing into master.</li></ul>\n</blockquote>", "remarks": "<blockquote>\n<em>2011-Aug-01 14:35:43 by psilord:</em> <br/>\n\nOk, after some inspection, and some hacking. I have preliminary support working for a standalone stduniv job. I need to expand my test programs to be much more precise in what they check to ensure I can read, write, seek, get the seek position, etc properly over the 2, 4, and 8 (for good measure) GB range for files.\n\n<p>I am now going to check to see if the support functions for remote I/O too.\n\n</p><p>I know, though, that I need to fix the llseek() call since it seems to have been\nbroken for a very long time wrt 32/64 bit file offsets.\n\n</p><p></p><hr/>\n<em>2011-Aug-02 10:45:13 by psilord:</em> <br/>\n\nAfter some more debugging, I found this:\n\n<p></p><div class=\"code\">\n<pre class=\"code\">#undef lseek\n#if defined( SYS_lseek )\nextern \"C\" int REMOTE_CONDOR_lseek( int   , off_t   , int  );\noff_t   lseek ( int fd, off_t offset, int whence )\n{\n    int rval,do_local=0;\n    errno = 0;\n\n    sigset_t condor_omask = _condor_signals_disable();\n\n    if( MappingFileDescriptors() ) {\n        _condor_file_table_init();\n        rval = FileTab -&gt; lseek ( fd , offset , whence );\n    } else {\n        if( LocalSysCalls() || do_local ) {\n            rval = syscall( SYS_lseek, fd , offset , whence );\n        } else {\n            rval = REMOTE_CONDOR_lseek( fd , offset , whence );\n        }\n\n    }\n    _condor_signals_enable( condor_omask );\n\n    return (off_t  ) rval;\n}\n</pre></div>\n\n\n<p>Notice how the return type of the lseek got squashed into an int and then expanded again. This means I need to edit the stub generator to use the same return type for <code>rval</code> as for the function being stubbed.\n\n</p><p></p><hr/>\n<em>2011-Aug-04 14:10:42 by psilord:</em> <br/>\n\nI beat the stub generator with a baseball bat. Now it emits the return types\nof the senders/switches/receivers to be the correct type associated with the\nsyscall instead of just \"int\" all the time like it used to. I also fixed the stub generator to know when some return types are pointers and to use the correct check of the returned value from the syscall. More work needs to be done\nfor return value verification, but it is a helluva lot better now than what it was.\n\n<p>I went and found all (well, all that I found, at any rate) of the places we were dealing with an int that was supposed to be an off_t when dealing with file offsets and fixed them. No on a 64-bit machine, at least standalone mode will deal with file sizes larger than 32-bits now. This is a conspicuous improvement.\n\n</p><p></p><hr/>\n<em>2011-Aug-10 16:31:30 by psilord:</em> <br/>\n\nAfter much more serious work in the stub generator in order to fix random assumptions the original authors made because everything was an 'int' return type, it is now more type correct than ever.\n\n<p>The stub for getwd() the hardest one to figure out. It already is a special switch, but the sender and receiver used a pseudo call. The pseudo call was of a different type than the function itself, which caused numerous problems. I fixed it by creating another system call which had the right prototype. The whole way we deal with pseudo_calls of real syscalls is pretty wrong.\n\n</p><p>Also, the full prototype for getwd() is 'char* getwd(char *buf)' which is problematic since it means that the rval and the buf both have to proprocessed properly and memory accounted for in the rpc call. I avoided the issue with the new rpc call called getwd_special() which type correctly calls the pseudo call.\n\n</p><p></p><hr/>\n<em>2011-Aug-11 14:53:52 by psilord:</em> <br/>\n\nIt seems that I seriously broke getdirentries() as a result of all of my changes. I am unsure why and at least the rest of the stduniv test suite passes. I checked the senders/switches/receivers for that call explicitly against a revision of condor which does not have my changes and, while there were some surface differences which were intended, the functionality was identical.\n\n<p>I'm now testing to see how that call functions without my changes. Maybe it was\nbroken before I started.\n\n</p><p>Also, I need to fix another small interface in the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CondorFileTable\" title=\"Condor File Table\">CondorFileTable</a></span> object to handle 64-bit file size properly.\n\n</p><p></p><hr/>\n<em>2011-Aug-12 11:07:20 by psilord:</em> <br/>\n\nIt turns out getdirentries() <strong>is</strong> broken before any of my changes happened.\n\n<p>If I revert all of my changes, getdirentries() works with remote i/o but fails\nin standalone mode. With my changes, it fails in both instances.\n\n</p><p>So, I will continue my work on this ticket until it is finished, commit it, then fix getdirentries() to function properly again.\n\n</p><p></p><hr/>\n<em>2011-Aug-15 12:28:13 by psilord:</em> <br/>\n\nIt had a couple rounds of failing to build in the NMI, but I fixed those.\nHowever, the test suite blew up in an undebuggable way (time out errors) for non\nstduniv tests. So I have to do some more iterations of pushing it through NMI to see what is going wrong.\n\n<p></p><hr/>\n<em>2011-Aug-15 13:58:07 by tannenba:</em> <br/>\n\nTest program needs to call ckpt(), e.g. we need to test that 64bit support works across a standalone checkpoint/restart cycle.\n\n<p></p><hr/>\n<em>2011-Aug-22 12:15:03 by psilord:</em> <br/>\n\nToday I'm meeting with nwp to help debug the failing getdirentries/getdents syscall.\n\n<p></p><hr/>\n<em>2011-Aug-22 16:41:29 by psilord:</em> <br/>\n\nOk, it seems that the condor file buffer for stduniv uses an 'int' to record the size of the file, I need to explore this and figure out if this is where the type narrowing is happening for the lfs test in remote i/o mode to condor.\n\n<p></p><hr/>\n<em>2011-Aug-24 14:46:30 by psilord:</em> <br/>\n\nOk, the condor file buffer code was indeed narrowing the offset values into\nlarge files. It did this because the \"chunks\" in the file buffer knew what offset into the file they represented--but the variable it kept it in was an int, not an off_t. I have now found and fixed this issue. The large file test now\npasses with a 7GB file in standalone mode and remote I/O mode.\n\n<p>It turns out though, that the receiver code emits an %d for the file offset. This rolls over and outputs negative numbers in the shadow log for file sizes larger than 2GB. This is less than useful. So I have to fix up the code generator to be knowledgeable of this situation and use some other format conversion form instead.\n\n</p><p></p><hr/>\n<em>2011-Aug-25 13:17:59 by psilord:</em> <br/>\n\nOk, I found a limitation in the codebase concerning the 64-bit file offsets.\n\n<p>The crux of the issue is that Condor is (generally) compiled <strong>without</strong>\n_LARGEFILE_SOURCE and _FILE_OFFSET_BITS=64. This means that on 32 bit\nmachines, by default, the syscall library's definition off off_t will be\n4 bytes wide. So, if a user compiles a 32 bit application with those two\nthings defined, intending to want &gt;2GB files, the off_t in the application\nwill be 8 bytes wide, but the off_t in the syscall library will be 4 bytes\nwide. There doesn't seem to be a good way to automatically figure out\nthis binary incompatibility between the type sizes. So, we'll just document\nwhat works.\n\n</p><p>It seems that on 64-bit machines, those two flags don't affect the size of\noff_t.\n\n</p><p>I will call the compilations of Condor that do not use the two\n#defines as 32CN 64CN. This is the only way Condor is compiled today.\n\n</p><p>Now, an application can be compiled 32-bit or 64 bit, and either have the above constants defined for it or not. I will call these 32AN 32AY 64AN 64AY.\n\n</p><p>Then here is a chart which describes if an application doing 64-bit file offsets with remote i/o will work with a specific type of Condor:\n\n</p><p><table border=\"1\" cellspacing=\"0\">\n<tbody><tr>\n<td>\n<strong>Application Type</strong></td>\n<td>\n<strong>Condor Shadow</strong></td>\n<td>\n<strong>64-bit File Offsets Supported</strong></td>\n</tr>\n\n<tr>\n<td>\n32AN</td>\n<td>\n32CN</td>\n<td>\nNO</td>\n</tr>\n\n<tr>\n<td>\n32AN</td>\n<td>\n64CN</td>\n<td>\nNO</td>\n</tr>\n\n<tr>\n<td>\n32AY</td>\n<td>\n32CN</td>\n<td>\nNO</td>\n</tr>\n\n<tr>\n<td>\n32AY</td>\n<td>\n64CN</td>\n<td>\nMAYBE</td>\n</tr>\n\n<tr>\n<td>\n64AN</td>\n<td>\n32CN</td>\n<td>\nNO</td>\n</tr>\n\n<tr>\n<td>\n64AN</td>\n<td>\n64CN</td>\n<td>\nYES</td>\n</tr>\n\n<tr>\n<td>\n64AY</td>\n<td>\n32CN</td>\n<td>\nNO</td>\n</tr>\n\n<tr>\n<td>\n64AY</td>\n<td>\n64CN</td>\n<td>\nYES</td>\n</tr>\n\n</tbody></table>\n</p><p>So, tell users that 64-bit condor with 64-bit stduniv applications function\nwrt 64-bit file sizes--anything else doesn't work.\n\n</p><p></p><hr/>\n<em>2011-Oct-10 14:59:21 by psilord:</em> <br/>\n\nDocumented, resolved.</blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2011-Oct-10 15:41</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=27755\">[27755]</a></span>: quick and very minor edit ===GT=== <span class=\"ticket\"><a class=\"defer\" href=\"/tickets?ticket=2337\" onclick=\"get_ticket_and_populate_wrapper('2337'); return false;\" title=\"Implement 64-bit support for file i/o in stduniv\">#2337</a></span>  (By Karen Miller )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2011-Oct-10 14:57</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=27751\">[27751]</a></span>: ===GT=== <span class=\"ticket\"><a class=\"defer\" href=\"/tickets?ticket=2337\" onclick=\"get_ticket_and_populate_wrapper('2337'); return false;\" title=\"Implement 64-bit support for file i/o in stduniv\">#2337</a></span> ===VersionHistory:Complete=== ===UpgradeNote=== Documented new feature about 64-bit offset support for stduniv jobs.  (By Peter Keller )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2011-Sep-01 15:45</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=27066\">[27066]</a></span>: ===GT=== <span class=\"ticket\"><a class=\"defer\" href=\"/tickets?ticket=2337\" onclick=\"get_ticket_and_populate_wrapper('2337'); return false;\" title=\"Implement 64-bit support for file i/o in stduniv\">#2337</a></span> ===GT:Fixed=== <span class=\"ticket\"><a class=\"defer\" href=\"/tickets?ticket=2337\" onclick=\"get_ticket_and_populate_wrapper('2337'); return false;\" title=\"Implement 64-bit support for file i/o in stduniv\">#2337</a></span> The purpose of this commit is to allow standard universe's file I/O, both remote and local, to read and write files larger than 2GB.\u00a0[...]\n (By Peter Keller )</td></tr>\n</tbody></table>", "type": "enhance", "last_change": "2011-Oct-10 14:59", "status": "defer", "created": "2011-Jul-29 11:09", "fixed_version": "2011-Jul-29 11:09", "broken_version": "v050000", "priority": "5", "subsystem": "Std", "assigned_to": "psilord", "derived_from": "", "creator": "psilord", "rust": "", "customer_group": "ligo", "visibility": "public", "notify": "psilord@cs.wisc.edu,pcouvare@caltech.edu", "due_date": "20110824"}