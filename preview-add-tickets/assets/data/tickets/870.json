{"id": 870, "title": "Ticket #870: 100 Dagman splices causes dagman to exit badly", "description": "<blockquote>\nJust fired off a small test of dag splicing on submit.chtc.wisc.edu\n\n<p>100 splices of a versy simple dag(1 node)\n\n</p><p>Got this result. 1 splice ran fine......\n\n</p><p></p><div class=\"verbatim\">\n<pre>10/16 22:12:53 Parsing Splice datasetpoly2-1706 in directory . with file datasetpoly2-1706/datasetpoly2-1706_dag\n10/16 22:12:53 Parsing Splice datasetpoly2-1306 in directory . with file datasetpoly2-1306/datasetpoly2-1306_dag\n10/16 22:12:53 Parsing Splice datasetpoly2-1389 in directory . with file datasetpoly2-1389/datasetpoly2-1389_dag\n10/16 22:12:53 Parsing Splice datasetpoly2-1008 in directory . with file datasetpoly2-1008/datasetpoly2-1008_dag\n10/16 22:12:53 Parsing Splice datasetpoly2-1335 in directory . with file datasetpoly2-1335/datasetpoly2-1335_dag\n10/16 22:12:53 Parsing Splice datasetpoly2-1795 in directory . with file datasetpoly2-1795/datasetpoly2-1795_dag\n10/16 22:12:53 Parsing Splice datasetpoly2-1177 in directory . with file datasetpoly2-1177/datasetpoly2-1177_dag\n10/16 22:12:53 Parsing Splice datasetpoly2-1067 in directory . with file datasetpoly2-1067/datasetpoly2-1067_dag\n10/16 22:12:53 ERROR \"# of reaper handlers exceeded specified maximum\" at line 2196 in file daemon_core.cpp\n</pre></div>\n\n\n<p>bt</p></blockquote>", "remarks": "<blockquote>\n<em>2009-Oct-20 10:45:26 by psilord:</em> <br/>\n\nBasically, the hacky way we parse a splice is by instantiating a new Dag object per splice.  The new dag object registers reapers with daemoncore to handle pre and post scripts. So, if you include enough splices, you hit the reaper registration limit currently set to 100. The fix is to not allocate those objects which register the reapers (since I believe they aren't even used) when we are parsing a known splice.\n\n<p>To stop this entire class of problems in the manipulation of the dag code, we would have to separate the parsing of the dag files away from the analysis and in memory dag generation. Right now the parsing to in memory representation for a dag file is a one pass deal, and so it is easy to break stuff as the code evolves.\n\n</p><p></p><hr/>\n<em>2009-Oct-20 16:47:24 by psilord:</em> <br/>\n\nI'm testing a patch I have, but still need to write a test suite entry for it.\n\n<p></p><hr/>\n<em>2009-Oct-21 13:39:09 by psilord:</em> <br/>\n\nThe test program is written, and I've seen 10,000 splices loaded into an in memory dag. Load times were not too bad for 10,000 splices and the test program will have that number associated with it.\n\n<p>I'm testing 100,000 splices and the load time has definitely hit a slump (probably open/read/close the splice file), but I'm doing it to see if there is a next limit that we hit other than memory. LIGO routinely does dags with 500,000 nodes and they are starting to use splices in production. It'll be nice to know how far this scales. It seems 100,000 splices (where each one is one job) takes about 260Megs of ram to process. I'm sure it could be made better if need be...\n\n</p><p></p><hr/>\n<em>2009-Oct-21 14:32:16 by psilord:</em> <br/>\n\n100,000 splices were parsed correctly, though it took forever. I don't have good numbers but it was on the order of 45-60 minutes. It looks like it was spending its time opening and closing the test splice file I used, but of course profiling tools need to be run against it to really figure it out.\n\n<p> I think this is good enough for now.\n\n</p><p></p><hr/>\n<em>2009-Oct-21 16:26:35 by psilord:</em> <br/>\n\nMy patch and test was code reviewed by Kent. I have committed and pushed it into the V7_4-branch and merged it to master.\n\n<p></p><hr/>\n<em>2009-Oct-22 12:47:32 by psilord:</em> <br/>\n\nIt is also documented in the version history.</blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2009-Oct-22 12:46</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=25063\">[25063]</a></span>: Documented fix for <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=870\" onclick=\"get_ticket_and_populate_wrapper('870'); return false;\" title=\"100 Dagman splices causes dagman to exit badly\">#870</a></span>.  (By Peter Keller )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2009-Oct-21 16:18</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=16148\">[16148]</a></span>: Fix the dagman splicing scaling problem as described in <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=870\" onclick=\"get_ticket_and_populate_wrapper('870'); return false;\" title=\"100 Dagman splices causes dagman to exit badly\">#870</a></span>. Made the Dag constructor not allocate the ScriptQ object, which registered a daemon core reaper, when the Dag object is being used to parse a splice. Added ASSERTS and other defensive coding to functions which we know we shouldn't be calling\u00a0[...]\n (By Peter Keller )</td></tr>\n</tbody></table>", "type": "defect", "last_change": "2010-Jan-31 13:41", "status": "resolved", "created": "2009-Oct-20 10:26", "fixed_version": "2009-Oct-20 10:26", "broken_version": "v070400", "priority": "2", "subsystem": "Dag", "assigned_to": "psilord", "derived_from": "", "creator": "bt", "rust": "", "customer_group": "chtc", "visibility": "public", "notify": "psilord@cs.wisc.edu", "due_date": ""}