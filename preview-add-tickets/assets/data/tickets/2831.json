{"id": 2831, "title": "Ticket #2831: Be able to \"manually\" retry nodes during a DAG run", "description": "<blockquote>\nEarlier this week Bill ran into a problem where a node failed during a large DAG (but other paths in the DAG still continued to run).  He was able to fix the problem that caused the node to fail, but there's no way to get DAGMan to retry the node at that point without condor_rm'ing the DAG and resubmitting it (which he didn't want to do because that would have caused a lot of badput).\n\n<p>So it would be nice to be able to tell DAGMan <em>during a run</em>, \"go back and retry a certain node\" or \"retry all failed nodes\" or something like that.  If we build the command-line tool (see <span class=\"ticket\"><a class=\"defer\" href=\"/tickets?ticket=2616\" onclick=\"get_ticket_and_populate_wrapper('2616'); return false;\" title=\"Create a command-line tool to communicate with DAGMan\">#2616</a></span>) it seems like this would be a good function for it to implement.  It's also possible that we could implement it in a different way.</p></blockquote>", "remarks": "<blockquote>\n<em>2013-Mar-05 10:09:57 by pfc:</em> <br/>\n\nFWIW, this would be useful for LIGO as well.  Our users are constantly resubmitting DAGs to rerun jobs that failed due to external factors (e.g., NFS server issues), but it would save them time if they could do it for individual jobs while the initial DAG is still running.\n\n<p></p><hr/>\n<em>2013-Nov-06 16:18:51 by wenger:</em> <br/>\n\nBrian Bockelman would like this, as well.\n\n<p></p><hr/>\n<em>2014-Aug-11 10:29:42 by wenger:</em> <br/>\n\nA few things to think about with this:\n<ul>\n<li>How does the user communicate which node(s) they want to retry?\n</li><li>How do we handle errors (e.g., the user attempts to retry a node that doesn't exist or has succeeded)?\n</li><li>If a node has retries already, and they're all used up, does a \"manual\" retry just give us one more retry, or does it essentially reset the retry count to zero?\n</li><li>What if we have a node with retries, and the user specifies a \"manual\" retry on that node before all of the specified retries are used up?\n</li><li>How would this get implemented?\n</li></ul>\n\n<p>My initial thought on how the user would specify this is that they could create a file called something like foo.dag.retry, which would contain lines specifying the node names to retry.  DAGMan would read this file and then delete it or rename it after reading it, so that it wouldn't get into a cycle of retrying the nodes multiple times, unless the user specifies multiple manual retries.\n\n</p><p></p><hr/>\n<em>2014-Aug-11 10:41:06 by wenger:</em> <br/>\n\nHmm -- something else to think about is this:  how will this work with recovery mode?  If a node fails, you do a manual retry, the node runs, and then you go into recovery mode, I'll bet DAGMan will be unhappy...  Do we need to put something into the workflow log about the manual retry?  Hmm -- have to think about this.  (If we do need to put something into the workflow log, we'd have to require DAGMan to use the workflow log -- I can't remember whether we already do that or not.  Also, if we go that route, I think the \"real\" code should just write the event, and then the actual retry should happen as a result of DAGMan reading and processing the event.)\n\n<p></p><hr/>\n<em>2014-Aug-11 10:51:48 by bbockelm:</em> <br/>\n\nHi Kent,\n\n<p>Sorry - we can only use it if it is remotely queryable; no filesystem operations.\n\n</p><p>As part of the \"shared port default\" work, I think we'll end up having a client class that would allow authenticated clients to get a command socket from the schedd.  Would that work here?\n\n</p><p>Brian\n\n</p><p></p><hr/>\n<em>2014-Aug-11 11:05:18 by wenger:</em> <br/>\n\nHmm -- a socket to the schedd would only do you any good if the schedd then communicated to DAGMan.\n\n<p>We've talked for quite a while about having a command-line tool to communicate with DAGMan -- maybe this is the time for that?\n\n</p><p></p><hr/>\n<em>2014-Aug-11 11:15:36 by wenger:</em> <br/>\n\nNote:  See <span class=\"ticket\"><a class=\"defer\" href=\"/tickets?ticket=2616\" onclick=\"get_ticket_and_populate_wrapper('2616'); return false;\" title=\"Create a command-line tool to communicate with DAGMan\">#2616</a></span> for notes about the command-line tool.</blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "", "type": "enhance", "last_change": "2017-May-16 13:37", "status": "new", "created": "2012-Feb-16 16:50", "fixed_version": "2012-Feb-16 16:50", "broken_version": "v070705", "priority": "3", "subsystem": "Dag", "assigned_to": "coatsworth", "derived_from": "#2616", "creator": "wenger", "rust": "", "customer_group": "chtc", "visibility": "public", "notify": "wenger@cs.wisc.edu, bt@cs.wisc.edu, coatsworth@cs.wisc.edu", "due_date": ""}