{"id": 7013, "title": "Ticket #7013: Make the main branch of HTCondor FIPS compliant", "description": "<blockquote>\nUpdate HTCondor so it is FIPS-compliant without needing to do a special custom build.\n\n<p><span class=\"subsection\"></span></p><h3>New Plan</h3>\nSwitching to AESGCM will remove the need for MD5 integrity checks on network traffic.  Using SHA256 for checksums in HAD will be another step towards getting us into FIPS compliance (for now).  This ticket is essentially dead, but if you want to follow the removal of MD5 and related commits, see JIRA ticket &lt;HTCONDOR-XYZ&gt;.\n\n<p><span class=\"subsection\"></span></p><h3>Old Plan</h3>\nThere are some major milestones:\n<ol>\n<li>Create diagram showing types of TCP traffic, how it is packetized, where the checksums and headers are, etc.\n</li><li>Analyze and create Milestones for non-negotiated sessions\n</li><li>Allow negotiation for Integrity methods (currently only encryption methods are negotiatied)\n</li><li>Add SHA(X) as a new Integrity method\n</li><li>Change UDP to not use MD5 (or perhaps any crypto) when talking to local processes.\n</li><li>Change UDP to throw a big noticable error if trying to use MD5 for non-local traffic.\n</li><li>Make MD5 libraries explicitly dlopened() so as not to trigger the FIPS bailout code when no MD5 is actually used.\n</li><li>After some period of MD5 and SHA coexisting for a long-enough time, we can eliminate MD5 completely in a future release.\n</li></ol>\n\n<p><span class=\"section\"></span></p><h2>Header Formats and Notes</h2>\n\n<p>The basic structure of the TCP header is:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">ReliSock (CEDAR TCP) Header if Integrity is enabled:\n\nByte Offset   Size (in bytes)   Descrip\n0             1                 1 if last packet in msg, else 0\n1             4                 Length of packet as integer (network order)\n5             16, or 32 if FIPS Message Digest\n&lt;data&gt;\n\nReliSock (CEDAR TCP) Header if Integrity is NOT enabled:\n\nByte Offset   Size (in bytes)   Descrip\n0             1                 1 if last packet in msg, else 0\n1             4                 Length of packet as integer (network order)\n&lt;data&gt;\n</pre></div>\n\n\n<p><span class=\"subsection\"></span></p><h3>Questions and Notes</h3>\n\n<p><span class=\"subsubsection\"></span></p><h4>What is the higher-level protocol for establishing a key and enabling Integrity on a brand-new connection with a new session?</h4>\n<ol>\n<li>Header size is 5 bytes initially.  (flag for last packet, size of packet)\n</li><li>\"Security Negotiation\" is done in the clear using classads.  (One round trip)\n</li><li>Authentication is performed (X round trips) and key is exchanged.\n</li><li>Send/receive buffers are now empty.\n</li><li>If requested, INTEGRITY is now enabled for sender and receiver.\n</li><li>Header size is now 21 bytes (or 37 in FIPS) (additional 16 or 32 bytes for checksum)\n</li></ol>\n\n<p><span class=\"subsubsection\"></span></p><h4>What is the higher-level protocol for establishing a key and enabling Integrity on resuming a session?</h4>\n<ol>\n<li>Header size is 5 bytes initially.\n</li><li>\"Security Resume\" is done in the clear using classads and includes the session ID. (receive only, no response)\n</li><li>EOM is called after sending/receiving message in the clear. (i.e. the resume message is one packet by itself)\n</li><li>Send/receive buffers are now empty.\n</li><li>If requested, INTEGRITY is now enabled for sender and receiver, using the key from the session we looked up.\n</li><li>Header size is now 21 bytes (or 37 in FIPS) (additional 16 or 32 bytes for checksum)\n</li></ol>\n\n<p><span class=\"subsubsection\"></span></p><h4>Are checksums computed over the entire packet or only the bytes for which an MD was enabled when doing a put()?</h4>\nThe MD is computed over the whole packet.  Calling init_MD in the middle of a message is not supported and will in fact return failure to avoid any accidental use outside of this mode.\n\n<p><span class=\"subsubsection\"></span></p><h4>How do we know if Integrity is enabled (i.e. whether there is a checksum in the header) ?</h4>\nWhether or not Integrity is enabled is state within the socket object.  It is enabled when establishing or resuming a session (see 1 and 2 above) and from there on out we know how to interpret additional incoming packets.\n\n<p><span class=\"subsubsection\"></span></p><h4>If Integrity is enabled, how do we know how big it is or what method was used?</h4>\nCurrently there is no state saying \"what type\" of Integrity check we are using, and therefore if there are different header sizes or interpretations.  This is state we will need to add to the socket object that can be reference inside the message object when interpreting headers.\n\n<p><span class=\"subsubsection\"></span></p><h4>How is put_bytes_nobuffer() handled?</h4>\n<ol>\n<li>All buffers are flushed before sending bytes_nobuffer.  If integrity is enabled those packets will have checksums in the headers.\n</li><li>The data is then encrypted (if enabled), but no checksum is computed.\n</li><li>The packets are then pushed out using condor_write() which does no explicit packetizing and does not compute any checksums or integrity checks.\n</li></ol>\n\n<p><span class=\"subsubsection\"></span></p><h4>How are non-negotiated sessions handled?  What methods do they use?  Can those be disabled by admin if needed?</h4>\n\n<p>In Progress...</p></blockquote>", "remarks": "<blockquote>\n<em>2019-May-08 09:52:23 by zmiller:</em> <br/>\n\nNo significant progress was made on Milestone 2 up to now due to additional code reviews and discussions before the code freeze.\n<hr/>\n<em>2020-Apr-10 07:46:13 by tim:</em> <br/>\n\nBulk change of target version from v080906 to v080907 using ticket-target-mover.</blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "", "type": "enhance", "last_change": "2020-Dec-11 11:58", "status": "active", "created": "2019-Apr-23 15:54", "fixed_version": "2019-Apr-23 15:54", "broken_version": "v080900", "priority": "3", "subsystem": "Security", "assigned_to": "zmiller", "derived_from": "", "creator": "zmiller", "rust": "", "customer_group": "support", "visibility": "public", "notify": "zmiller@cs.wisc.edu, tannenba@cs.wisc.edu, johnkn@cs.wisc.edu", "due_date": ""}