{"id": 2082, "title": "Ticket #2082: IPv6: SafeSock includes ipv4 addr in header", "description": "<blockquote>\n<span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=SafeSock\" title=\"Safe Sock\">SafeSock</a></span> reassembles a stream of packets from UDP.  Inbound streams of packets may come from multiple multiple daemons, multiple machines, or some combination.  Conceivably multiple streams may even come from a single source daemon.  For reassembly it's necessary to identify which stream a given packet is for.  To do this, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=SafeSock\" title=\"Safe Sock\">SafeSock</a></span> adds an identifying header.\n\n<p>The header is written in _condorPacket::makeHeader (<a class=\"file\" href=\"rlog?f=src/condor_io/SafeMsg.cpp\">/src/condor_io/SafeMsg.cpp</a> line 532).  It's read in _condorPacket::getHeader (src/condor_io/SafeMsg.cpp line 214) and used to identify the correct stream in SafeSock::handle_incoming_packet (<a class=\"file\" href=\"rlog?f=src/condor_io/safe_sock.cpp\">/src/condor_io/safe_sock.cpp</a> line 625).  To determine if two identifiers are from the same, SafeSock::same is used (<a class=\"file\" href=\"rlog?f=src/condor_includes/safe_sock.h\">/src/condor_includes/safe_sock.h</a> line 142).\n\n</p><p>The identifier is a _condorMsgID struct (<a class=\"file\" href=\"rlog?f=src/condor_includes/SafeMsg.h\">/src/condor_includes/SafeMsg.h</a> line 28).  The members are:\n\n</p><p><table border=\"1\" cellspacing=\"0\">\n<tbody><tr>\n<td>\nName</td>\n<td>\nType</td>\n<td>\nBytes<br/>\non wire</td>\n<td>\nMeaning</td>\n<td>\nHow created</td>\n</tr>\n\n<tr>\n<td>\nip_addr</td>\n<td>\nlong</td>\n<td>\n 4 </td>\n<td>\nSource IPv4 address</td>\n<td>\n my_ip_addr()</td>\n</tr>\n\n<tr>\n<td>\npid    </td>\n<td>\nint </td>\n<td>\n 2 </td>\n<td>\nSource PID</td>\n<td>\n getpid()</td>\n</tr>\n\n<tr>\n<td>\ntime   </td>\n<td>\nlong</td>\n<td>\n 4 </td>\n<td>\nTime source <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=SafeSock\" title=\"Safe Sock\">SafeSock</a></span> created</td>\n<td>\ntime(NULL)</td>\n</tr>\n\n<tr>\n<td>\nmsgNo  </td>\n<td>\nint </td>\n<td>\n 2 </td>\n<td>\nRandom number, incremented</td>\n<td>\n Windows: rand(); Elsewhere: lrand48()</td>\n</tr>\n\n</tbody></table>\n</p><p>To verify: these are <em>only</em> used to identify streams, and are treated strictly opaquely.\n\n</p><p>Problem 1: Two different machines with the same IP address (because they're using private network addresses behind two different NATs) can theoretically collide today.  As pools scale up, the chances increase.\n\n</p><p>Problem 2: An IPv6 address won't fit in ip_addr.\n\n</p><p><span class=\"section\"></span></p><h2>Potential problems to investigate</h2>\n\n<p></p><ul>\n<li>You may be able to denial of service a Condor daemon by sending a stream of UDP packets purportedly from actual daemons in the pool with bogus sequence numbers, causing  Can make a bit harder by adding the source IP address (as seen in recvfrom or equivalent) to the hash/identifier for the message (meaning you'd need to start spoofing IP packets).\n</li></ul>\n\n<p><span class=\"section\"></span></p><h2>Current plan</h2>\n\n<p>Hijack ip_addr, pid, and time (10 bytes).  They're just used as opaque integers anyway.  Generate 10 reasonably random bytes of data.  Maybe md5(concatenate(ipv4/6_addr, pid, time to the microsecond, weak random number))?  Maybe just 10 bytes from /dev/random?  Shove those 10 bytes into ip_addr, pid, and time.  This should drop out chances of collision on any given pair of packets down to 1 in 2^80.\n\n</p><p>Note that using MD5 or SHA1 might require OpenSSL, which is not(?) currently a requirement for building Condor.  If we go down that route, we might as well just use OpenSSL's ability to generate cryptographically secure random numbers.  Another option would be to drag in a small hash implementation.  Another option is to have some platform specific code to acquire a random number is a suitable way (/dev/urandom on many Unixes, /dev/random where that doesn't work.  Something unknown on Windows.)\n\n</p><p>Assume a collector serving 1,000,000 nodes.  Each node has 10 daemons.  Each daemon is sending an update (and thus a message) once per minute.  So every minute, there are about 10,000,000 messages received.  Assume that we're worried about re-assembling only 10,000,000 potential streams at a time (true if a given stream is 6 or fewer packets given the 10-second timeout in <a class=\"file\" href=\"rlog?f=src/condor_includes/safe_sock.h\">/src/condor_includes/safe_sock.h</a> line 37 \"SAFE_SOCK_MAX_BTW_PKT_ARVL\".).  Given those assumptions, the chances at a collision are 0.00000000004135902731 in any given window.  If we consider a 1 in a 1,000,000 chance of collision acceptable, we can be reassembling up to about 1,554,944,645 streams at once.  Given that UDP streams are lossy to start, I believe that level of risk is acceptable.  (Math behind the above calculations is attached as collision_probability.xls.)\n\n</p><p><span class=\"section\"></span></p><h2>Idea brainstorming</h2>\n\n<p></p><ul>\n<li>Set it to 0x00000000 in all cases: highly likely to cause UDP streams to erroneously mix.\n</li><li>Set it to a subset of the IPv6 address: chance of collisions, possibly a large chance depending on how we pick the subset.\n</li><li>Set it to a hash of the IPv6 address: chance of collisions.\n</li><li>Extend it 16-bytes: breaks backward compatibility\n</li><li>Modify code to ignore it and use the source of the UDP packet.  May collide things if a NAT is forwarding UDP packets for several machines behind it.\n</li><li>Modify code to ignore it and extend protocol with \"real\" information.  Can this be done in a backward compatible way?\n</li><li>Hash the IPv6 address, but stuff the hash across all of ip_addr, pid, and time. Maybe msgNo except 1 bit. Gives us 10 or more bytes to distinguish connections.  Needs investigation for safety.  Still some risk of collision.\n</li><li>Have two code paths: IPv4 and IPv6, where if the socket is from an IPv6 source, we use a variant supporting 16-bit addresses.  Risk: what about IPv6 &lt;-&gt; IPv4 gateways?  Can we end up in the wrong code path.  Also, duplicate code paths are a recipe for unintentional future divergence.  Also, necessitates teaching this layer about the source of a packet; something it doesn't currently do.\n</li></ul>\n\n<p>Note that in all cases where we put an invalid/fake value in ip_addr field, we could pick a \"safe\" or \"invalid\" area of the address space. That loses bits to distinguish sources (increase collision chance) at the benefit of eliminating the possibility of a collision with an IPv4 address. The traditional private network (especially 10.x.x.x) is problematic since we have using using such spaces, but invalid or nonsensical addresses might work.\n\n</p><p>Note that\n\n</p><p><span class=\"section\"></span></p><h2>Random notes</h2>\n<ul>\n<li>Is there a risk today of collisions?  What if two different NATted, private networks both have a 192.168.0.1 machine, and both such machines contact us.\n</li><li>We could have <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=SafeSock\" title=\"Safe Sock\">SafeSock</a></span> know if it's dealing with IPv4 or IPv6 and have different code paths.  Essentially the IPv6 path would be a new revision of the protocol.  Down side: duplicated code paths to keep in sync, not obvious what to do when IPv9 comes out or if we use non-TCP protocols with <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=SafeSock\" title=\"Safe Sock\">SafeSock</a></span>.\n</li></ul>\n\n<p><span class=\"section\"></span></p><h2>Status </h2>\n<ul>\n<li>Decision made. Minjae will be implementing. Talking with Minjae to ensure we've handled all necessary cases.</li></ul>\n</blockquote>", "remarks": "<blockquote>\n<em>2011-Apr-21 17:41:48 by m:</em> <br/>\n\ncheckpointing server also stores IP address in its header. ( line 429 at <a class=\"file\" href=\"rlog?f=src/condor_ckpt_server/protocol.cpp\">/src/condor_ckpt_server/protocol.cpp</a> )\n\n<p>However, it does not seem to utilize the IP address. In RequestService() at <a class=\"file\" href=\"rlog?f=src/condor_ckpt_server/server_interface.cpp\">/src/condor_ckpt_server/server_interface.cpp</a>, it returns the IP address if the function caller provides non-null parameter for IP address. Nobody calls RequestService() with non-null parameter.\n\n</p><p></p><hr/>\n<em>2011-Apr-21 18:26:27 by m:</em> <br/>\n\nIt seems the ip address in checkpoint server packets is not used for locating the server. Only use case that I can see is to print out logs. You can see these at <a class=\"file\" href=\"rlog?f=src/condor_shadow.std/pseudo_ops.cpp\">/src/condor_shadow.std/pseudo_ops.cpp</a>. Try to find <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=RequestStore\" title=\"Request Store\">RequestStore</a></span> and <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=RequestRestore\" title=\"Request Restore\">RequestRestore</a></span>.\n\n<p></p><hr/>\n<em>2011-Apr-23 10:23:52 by matt:</em> <br/>\n\nSounds like a shot at a UUID. Consider taking IP out of the equation completely. At the time using an IPv4 address was likely convenient in size and consistency. A random, well seeded (not with pid + time), 32 bit number may be sufficient.\n\n<p></p><hr/>\n<em>2015-May-28 12:59:42 by tlmiller:</em> <br/>\n\nHas this since been resolved?\n\n<p></p><hr/>\n<em>2018-Jan-16 16:43:38 by jfrey:</em> <br/>\n\nThe decision was to fill the ip_addr, pid, and time fields with random data. This was done in 7.7.0.</blockquote>", "derived_tickets": "", "attachments": "<blockquote>\n<ul>\n<li><a href=\"attach_get/333/collision_probability.xls\">collision_probability.xls</a>\n8192 bytes added by adesmet on 2011-Apr-26 19:32:13 UTC.\n<br/>\nCalculations for risk of collisions.<br/>\n</li></ul>\n</blockquote>", "check_ins": "", "type": "enhance", "last_change": "2018-Jan-16 16:43", "status": "resolved", "created": "2011-Apr-21 16:06", "fixed_version": "2011-Apr-21 16:06", "broken_version": "v060000", "priority": "2", "subsystem": "", "assigned_to": "adesmet", "derived_from": "#4492", "creator": "adesmet", "rust": "", "customer_group": "other", "visibility": "public", "notify": "adesmet@cs.wisc.edu", "due_date": ""}