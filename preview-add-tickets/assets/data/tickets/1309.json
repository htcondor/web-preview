{"id": 1309, "title": "Ticket #1309: DAGMan: retry subset of a DAG", "description": "<blockquote>\nGoal: the ability to have a DAG node fail, and in doing so cause previously successful nodes to be considered to fail, including possibly RETRYing.\n\n<p>Take this simple DAG consisting of many separate chains of jobs.  (This is based on the \"Use case\" described in <span class=\"ticket\"><a class=\"new\" href=\"/tickets?ticket=1308\" onclick=\"get_ticket_and_populate_wrapper('1308'); return false;\" title=\"Do-it-yourself meta-scheduler toolkit\">#1308</a></span>, but this example should be self-contained.)\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">JOB tar_1 tar_1.sub\nJOB scp_1 scp_1.sub\nJOB validate_1 validate_1.sub\nPARENT tar_1 CHILD scp_1\nPARENT scp_1 CHILD validate_1\n\nJOB tar_2 tar_2.sub\nJOB scp_2 scp_2.sub\nJOB validate_2 validate_2.sub\nPARENT tar_2 CHILD scp_2\nPARENT scp_2 CHILD validate_2\n\nCATEGORY tar_1 TAR\nCATEGORY tar_2 TAR\nMAXJOBS TAR 2\nCATEGORY scp_1 SCP\nCATEGORY scp_2 SCP\nMAXJOBS SCP 2\nCATEGORY validate_1 VALIDATE\nCATEGORY validate_2 VALIDATE\nMAXJOBS VALIDATE 2\n</pre></div>\n\n\n<p>There are only two chains listed above, but picture them going up to say tar_100, scp_100, validate_100.\n\n</p><p>The complication is that if any step fails, I want to try again, going all of the way back to the TAR step.  This is not currently possible with DAGMan.  The most obvious option is nested DAGs, one per chain.  DAGMan will helpfully try to continue using the rescue sub-DAG, but that's easy to override by using a POST script to reset the sub-DAG.  The more serious problem is that using sub-DAGs, the CATEGORYs are no longer respected.\n\n</p><p>One possibility is to press something like categories into service:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">LINKFAILURE tar_1 scp_1 validate_1 RETRY 5\nLINKFAILURE tar_2 scp_2 validate_2 RETRY 5\n</pre></div>\n\n\n<p>However, that lets you cherry pick random nodes, which might be problematic if they're disconnected.  Another possibility is to use DAG splicing, and to retry the entire splice.  This ensures that all of the nodes are connected with a clear \"single\" entry point and exit point.  This might look like:\n\n</p><p>D1.dag:\n</p><div class=\"code\">\n<pre class=\"code\">JOB tar tar_1.sub\nJOB scp scp_1.sub\nJOB validate validate_1.sub\nPARENT tar CHILD scp\nPARENT scp CHILD validate\nCATEGORY tar TAR\nCATEGORY scp SCP\nCATEGORY validate VALIDATE\n</pre></div>\n\n\n<p>D2.dag:\n</p><div class=\"code\">\n<pre class=\"code\">JOB tar tar_2.sub\nJOB scp scp_2.sub\nJOB validate validate_2.sub\nPARENT tar CHILD scp\nPARENT scp CHILD validate\nCATEGORY tar TAR\nCATEGORY scp SCP\nCATEGORY validate VALIDATE\n</pre></div>\n\n\n<p>Top level DAG:\n</p><div class=\"code\">\n<pre class=\"code\">SPLICE D1 D1.dag RETRY 5\nSPLICE D2 D2.dag RETRY 5\nMAXJOBS TAR 2\nMAXJOBS SCP 2\nMAXJOBS VALIDATE 2\n</pre></div>\n\n\n<p>This was a real problem encountered, see the \"Use case\" described in <span class=\"ticket\"><a class=\"new\" href=\"/tickets?ticket=1308\" onclick=\"get_ticket_and_populate_wrapper('1308'); return false;\" title=\"Do-it-yourself meta-scheduler toolkit\">#1308</a></span> for more information.  <em>However</em>, it turns out that that use case is even more complicated, and this addition wouldn't be enough.  It may be that any problem that needs such functionality might also require other problematic functionality, which might be an argument against implementing this.  <span class=\"ticket\"><a class=\"new\" href=\"/tickets?ticket=1308\" onclick=\"get_ticket_and_populate_wrapper('1308'); return false;\" title=\"Do-it-yourself meta-scheduler toolkit\">#1308</a></span> offers a more general solution at the cost of much more work for the end user.</p></blockquote>", "remarks": "<blockquote>\n<hr/>\n<em>2010-Oct-20 16:03:30 by jfrey:</em> <br/>\n\nBulk change of target version from v070504 to v070505 using ./ticket-target-mover.\n<hr/>\n<em>2011-Jan-27 14:46:04 by danb:</em> <br/>\n\nBulk change of target version from v070505 to v070506 using ./ticket-target-mover.\n<hr/>\n<em>2011-Feb-01 16:01:00 by tannenba:</em> <br/>\n\nBulk change of target version from v070506 to NULL using ./ticket-target-mover.\n\n<p></p><hr/>\n<em>2014-Mar-19 15:47:17 by wenger:</em> <br/>\n\nI just talked to Karan from the Pegasus team, and a special case of this is a fairly high priority for them:  they want the capability for a node failure to force a retry of the failed node's immediate parent; furthermore, that parent would only have a single child.\n\n<p>(The use case for Pegasus is that they want to move the planning function from the PRE script of a sub-DAG to a separate node, for the sake of throttling.  But if the sub-DAG fails they want to re-do the planning as well as the actual sub-DAG.)\n\n</p><p>So one thing I need to think about is this:  if we implement some kind of multi-node retry, is it worth just implementing the immediate parent retry, or is it worth implementing a general capability of \"backing up\" through any linear subset of the DAG?  In other words, is the \"immediate parent retry\" significantly simpler to implement?\n\n</p><p>Also, for a semi-general case of this, one of the things I was wondering about was how to specify the subset of the DAG to be retried.  But if we only allow retrying linear sections of the DAG, we could just specify the node name at which to start the retry in the retry command.\n\n</p><p>Hmm -- I was just thinking that the really tricky aspect of this might be getting it to work with recovery mode...\n\n</p><p></p><hr/>\n<em>2014-Mar-20 11:27:06 by wenger:</em> <br/>\n\nMaybe we could have a syntax like this:\n\n<p></p><pre>  RETRY &lt;JobName&gt; &lt;NumberOfRetries&gt; [UNLESS-EXIT &lt;value&gt;] [JOB &lt;retry job&gt;]\n</pre>\n\n<p>where &lt;retry job&gt; would be the job we would start the retry at.  (So the current single-node retry implementation would be the same as having &lt;retr job&gt; == &lt;JobName&gt;.\n\n</p><p></p><hr/>\n<em>2014-Apr-28 09:19:58 by wenger:</em> <br/>\n\nI just talked to Brian Bockelman about this at Condor Week.  He'd really like to see this, because it would solve a problem he has with POST scripts.  (If we implement a simple case of more flexible retry it would essentially allow one job to act as the POST script for another job.)\n\n<p>So if we implement this, <span class=\"ticket\"><a class=\"new\" href=\"/tickets?ticket=1111\" onclick=\"get_ticket_and_populate_wrapper('1111'); return false;\" title=\"Run DAGMan PRE and POST scripts as Condor jobs\">#1111</a></span> and <span class=\"ticket\"><a class=\"new\" href=\"/tickets?ticket=186\" onclick=\"get_ticket_and_populate_wrapper('186'); return false;\" title=\"Allow a job to act as a POST script to another job\">#186</a></span> are probably lower-priority.</p></blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "", "type": "enhance", "last_change": "2015-Jul-29 11:05", "status": "new", "created": "2010-Mar-25 17:21", "fixed_version": "2010-Mar-25 17:21", "broken_version": "v070500", "priority": "4", "subsystem": "Dag", "assigned_to": "", "derived_from": "#4198", "creator": "adesmet", "rust": "", "customer_group": "other", "visibility": "public", "notify": "wenger@cs.wisc.edu, vahi@isi.edu, bbockelm@cse.unl.edu", "due_date": ""}