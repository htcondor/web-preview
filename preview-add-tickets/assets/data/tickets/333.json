{"id": 333, "title": "Ticket #333: Condor_submit fails on filesystem with 64-bit timestamps", "description": "<blockquote>\nAn OSG user installed a Compute Element that uses Condor to manage fork jobs. Unfortunately, he was unable to submit jobs from any NFS directory, because condor_submit failed. There is no easy workaround, because Globus uses a user's home directory, and these are on NFS.\n\n<p>The error that is reported looks like this:\n\n</p><p>% condor_submit submit<br/>\n\nSubmitting job(s)<br/>\n\nERROR: No such directory: /home/VCELL/aroy<br/>\n\n\n</p><p>===== Problem 1 (The easy problem) =====<br/>\n\nThat error message is totally wrong. The directory exists, but Condor thinks it is inaccessible. This is a low severity, low priority thing, but it should be fixed to report a more accurate message.\n\n</p><p>===== Problem 2 (The hard problem) =====<br/>\n\nThe error occurs in condor_submit.v6/submit.C in ComputeRootDir(). The code looks like this:\n\n</p><p></p><pre>        if( access(rootdir, F_OK|X_OK) &lt; 0 ) {\n            fprintf( stderr, \"\\nERROR: No such directory: %s\\n\",\n                     rootdir );\n            DoCleanup(0,0,NULL);\n            exit( 1 );\n</pre>\n\n<p>The access() function call is actually access_euid(), which is our implementation of access() in condor_util_lib. The call fails here:\n\n</p><p></p><pre>    if ((F_OK == 0) || (mode &amp; F_OK)) {\n        if (stat(path, &amp;buf) &lt; 0) {\n            if( ! errno ) {\n                    /* evil!  stat() failed but there's no errno! */\n                dprintf( D_ALWAYS, \"WARNING: stat() failed, but \"\n                         \"errno is still 0!  Beware of misleading \"\n                         \"error messages\\n\" );\n            }\n            return -1;\n        }\n        already_stated = 1;\n    }\n</pre>\n\n<p>stat() fails and provides an errno of 75 (Value too large for defined data type).\n\n</p><p>This isn't specific to Condor: I wrote a simple program that just calls stat(), and it gets the same error. It only gets this error on NFS, and not for local disks.\n\n</p><p>I figured that this was a problem with the filesystem, so I passed it back to the user. Fix your filesystem! I cried. Unfortunately, they passed the buck back to me. Here is their response:\n\n</p><p></p><div class=\"verbatim\">\n<pre>&gt; Ah, but this makes perfect sense...  There is no \"problem\" with the\n&gt; shared file system...\n&gt;\n&gt; The reason for failing with EOVERFLOW error (errno 75 - Value too\n&gt; large...) is 64bit file support of the shared filesystem.  Alain, if you\n&gt; compile your program with large file support it will not fail:\n&gt;\n&gt; [moraru@vdgateway Wed Mar 18 19:01:01 /tmp/stat2] $ gcc\n&gt; -D_FILE_OFFSET_BITS=64 -o stat stat.c\n&gt; [moraru@vdgateway Wed Mar 18 19:02:13 /tmp/stat2] $ ./stat /home/VCELL/\n&gt; name = /home/VCELL/\n&gt; rc = 0\n&gt; errno = 0\n&gt;\n&gt; OK - so now you may ask: why did it fail before, even though it didn't\n&gt; actually encounter any file &gt; 2GB?\n&gt;\n&gt; The reason is that our shared file system not only supports large files\n&gt; using 64 bits, but also supports 64bit timestamps... This is required\n&gt; for proper synching with NTFS file systems (that always use 64bit\n&gt; timestamps).  See below a comparison between the timestamps on the\n&gt; shared filesystem and the plain vanilla local Linux filesystem:\n&gt;\n&gt; [moraru@vdgateway Wed Mar 18 19:02:21 /tmp/stat2] $ stat /tmp\n&gt;  File: `/tmp'\n&gt;  Size: 4096            Blocks: 16         IO Block: 4096   directory\n&gt; Device: fd00h/64768d    Inode: 491521      Links: 14\n&gt; Access: (1777/drwxrwxrwt)  Uid: (    0/    root)   Gid: (    0/    root)\n&gt; Access: 2009-03-18 18:50:41.000000000 -0400\n&gt; Modify: 2009-03-18 19:02:13.000000000 -0400\n&gt; Change: 2009-03-18 19:02:13.000000000 -0400\n&gt; [moraru@vdgateway Wed Mar 18 19:02:41 /tmp/stat2] $ stat /home/VCELL/\n&gt;  File: `/home/VCELL/'\n&gt;  Size: 1134            Blocks: 34         IO Block: 4096   directory\n&gt; Device: 1eh/30d Inode: 4329963743  Links: 45\n&gt; Access: (0755/drwxr-xr-x)  Uid: (    0/    root)   Gid: (10000/Domain\n&gt; Users)\n&gt; Access: 2009-03-18 13:26:34.914135705 -0400\n&gt; Modify: 2009-03-18 13:26:34.914135705 -0400\n&gt; Change: 2009-03-18 13:26:34.914135705 -0400\n&gt;\n&gt; So, basically a stat() call to **any** path on the shared filesystem\n&gt; will **always** return 64bit timestamps (atime, ctime, mtime) and\n&gt; generate EOVERFLOW errors if #define _FILE_OFFSET_BITS=64 was not used.\n</pre></div>\n\n\n<p>Indeed, I rebuilt my simple stat() program with -D_FILE_OFFSET_BITS=64, and it worked.\n\n</p><p>So the claim is that Condor is in the wrong here. Frankly, I find it weird that every program that runs on their filesystem may need to be recompiled. But what can I do?\n\n</p><p>I talked to Nick about this, and he thinks that if access_euid() used his stat wrapper class, the problem might go away. I don't know if that's the correct solution or not. (Should we have built with this flag?) Also, this problem might be all over Condor: if we fix this call site, will there be others that exhibit the same problem? I don't know.\n\n</p><p>I'll try to keep access to this site. If I can, I'll be happy to work with someone to test potential bug fixes by deploying a personal (non-root) Condor and running tests.\n\n</p><p>Thanks,\n-alain, on behalf of an OSG site.</p></blockquote>", "remarks": "<blockquote>\n<em>2009-Mar-19 11:03:38 by adesmet:</em> <br/>\n\ngcc freaks out when trying to run a compile on the filesystem in question.  gdb works, but complains that the executable disappeared out from under it.\n\n<p></p><hr/>\n<em>2009-Mar-19 11:29:05 by roy:</em> <br/>\n\nThe filesystem in question is:\n\n<p></p><div class=\"verbatim\">\n<pre>&gt; The file server is an Isilon IQ 200 cluster with 14 nodes.  It runs the\n&gt; Isilon OneFS operating system.\n&gt;\n&gt; http://www.isilon.com/products/index.php?page=software_OneFS\n</pre></div>\n\n\n<p>Todd suggested we use \"condor_submit -disable\" to skip the permissions checks. However, it doesn't skip the check in question.\n\n</p><p></p><hr/>\n<em>2009-Mar-19 12:10:16 by matt:</em> <br/>\n\nYou should check what version of Condor they are running. I had to resolve a similar issue with access() (sadly #define'd to be access_euid()) encountered in the VM Universe. There's a thread on condor-fw about this as well, including information that using Nick's stat wrapper is not an easy solution because it's C++ and the access_euid(), and friends, are C.\n\n<p>Also, globally compiling Condor with 64-bit fs support causes headaches in condor_common.h, so beware.\n\n</p><p></p><hr/>\n<em>2009-Mar-19 12:13:47 by roy:</em> <br/>\n\nThey are using Condor 7.0.5:\n\n<p></p><div class=\"verbatim\">\n<pre>% condor_version\n$CondorVersion: 7.0.5 Sep 20 2008 BuildID: 105846 $\n$CondorPlatform: I386-LINUX_RHEL5 $\n</pre></div>\n\n\n<p></p><hr/>\n<em>2009-Mar-19 12:39:52 by matt:</em> <br/>\n\nThe fix, 852ef5f3, went in Fri Nov 14 18:04:57 2008 -0600, and is probably only in the 7.2 series.\n\n<p></p><hr/>\n<em>2009-Mar-23 17:03:04 by roy:</em> <br/>\n\nMore details from the folks experiencing this problem.\n\n<p>&gt; From: \"Moraru,Ion\" &lt;Moraru@neuron.uchc.edu&gt;\n&gt; Date: March 23, 2009 6:42:03 AM CDT\n&gt; To: \"Alain Roy\" &lt;roy@cs.wisc.edu&gt;\n&gt; Cc: \"Dutton,Jeff\" &lt;jdutton@neuron.uchc.edu&gt;, \"Abhishek Singh Rana\" &lt;rana@fnal.gov&gt;, \"Suchandra Thapa\" &lt;sthapa@ci.uchicago\\\n.edu&gt;, &lt;rquick@iupui.edu&gt;, \"Chander Sehgal\" &lt;cssehgal@fnal.gov&gt;\n&gt; Subject: RE: An update on the UCHC_CBG site\n&gt;\n&gt; Alain, here's more detailed info.\n&gt;\n&gt; The root cause of the problem is the &gt; 2^32 values of\n&gt; Inodes (st_ino) for the files on our shared file system.  I\n&gt; initially thought the issue was caused by 64-bit (nanosecond)\n&gt; timestamps - but then I remembered that those are being stored as\n&gt; 2 separate 32-bit uints: theres one int for each atime, ctime,\n&gt; mtime seconds past epoch value, and another one for the\n&gt; nanoseconds (hijacked from the former timespec microsec), and\n&gt; they have to be put together for the full timestamp (therefore\n&gt; these can never cause such problem).\n&gt;\n&gt; Anyway, the fact is that <strong>all</strong> files, and therefore all\n&gt; directories, on the shared file system have large Inode values.\n&gt; Why we were not aware of this before, and why this has not been a\n&gt; problem before, is due to bug in glibc as follows:\n&gt;\n&gt; 1. In previous 32bit versions of RHE-based Linux that we've\n&gt;    used (Rocks 4.3, SL 4.3 <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CentOs\" title=\"Cent Os\">CentOs</a></span> 4.7), calls to stat() do not\n&gt;    fail (as they should) on large Inodes, but instead return a\n&gt;    wrong value (truncated 32bit unsigned int + 1).  This is true\n&gt;    also for the command line version of stat.  Also, compiling\n&gt;    with LFS support gives wrong value.  Booh!\n&gt;\n&gt; 2. In 64bit versions of RHE-based Linux that we are currently\n&gt;    using (Rocks 5, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CentOs\" title=\"Cent Os\">CentOs</a></span> 5.1), everything is groovy - as it\n&gt;    should be.\n&gt;\n&gt; 3. The only <strong>other</strong> version of Linux that we've used, but only\n&gt;    for the OSG site-dedicated cluster and related machines, is\n&gt;    32bit CentOS 5, where the call to stat() returns (incorrectly)\n&gt;    a truncated 32bit uint, but it does (correctly) return the\n&gt;    proper failure error code... - also, BTW, command line stat in\n&gt;    this case is correct, it falls back to stat64() and returns\n&gt;    the correct 64bit uint value.\n&gt;\n&gt; Anyway, from the standpoint of Condor: I believe it should be\n&gt; considered a bug to some extent.  Condor should, as a 32bit\n&gt; install:\n&gt; - either declare it does not support LFS\n&gt; - or be compiled with proper LFS support and not choke on large values of either st_size, st_ino, or st_blocks\n&gt;\n&gt; That's it for now.\n&gt;\n&gt; Ion\n\n</p><p></p><hr/>\n<em>2009-Mar-23 17:03:46 by roy:</em> <br/>\n\nReappending remarks. I forgot it's a wiki and not a Unix text file.\n\n<p></p><div class=\"verbatim\">\n<pre>&gt; From: \"Moraru,Ion\" &lt;Moraru@neuron.uchc.edu&gt;\n&gt; Date: March 23, 2009 6:42:03 AM CDT\n&gt; To: \"Alain Roy\" &lt;roy@cs.wisc.edu&gt;\n&gt; Cc: \"Dutton,Jeff\" &lt;jdutton@neuron.uchc.edu&gt;, \"Abhishek Singh Rana\" &lt;rana@fnal.gov&gt;, \"Suchandra Thapa\" &lt;sthapa@ci.uchicago\\\n.edu&gt;, &lt;rquick@iupui.edu&gt;, \"Chander Sehgal\" &lt;cssehgal@fnal.gov&gt;\n&gt; Subject: RE: An update on the UCHC_CBG site\n&gt;\n&gt; Alain, here's more detailed info.\n&gt;\n&gt; The root cause of the problem is the &gt; 2^32 values of\n&gt; Inodes (st_ino) for the files on our shared file system.  I\n&gt; initially thought the issue was caused by 64-bit (nanosecond)\n&gt; timestamps - but then I remembered that those are being stored as\n&gt; 2 separate 32-bit uints: theres one int for each atime, ctime,\n&gt; mtime seconds past epoch value, and another one for the\n&gt; nanoseconds (hijacked from the former timespec microsec), and\n&gt; they have to be put together for the full timestamp (therefore\n&gt; these can never cause such problem).\n&gt;\n&gt; Anyway, the fact is that *all* files, and therefore all\n&gt; directories, on the shared file system have large Inode values.\n&gt; Why we were not aware of this before, and why this has not been a\n&gt; problem before, is due to bug in glibc as follows:\n&gt;\n&gt; 1. In previous 32bit versions of RHE-based Linux that we've\n&gt;    used (Rocks 4.3, SL 4.3 CentOs 4.7), calls to stat() do not\n&gt;    fail (as they should) on large Inodes, but instead return a\n&gt;    wrong value (truncated 32bit unsigned int + 1).  This is true\n&gt;    also for the command line version of stat.  Also, compiling\n&gt;    with LFS support gives wrong value.  Booh!\n&gt;\n&gt; 2. In 64bit versions of RHE-based Linux that we are currently\n&gt;    using (Rocks 5, CentOs 5.1), everything is groovy - as it\n&gt;    should be.\n&gt;\n&gt; 3. The only *other* version of Linux that we've used, but only\n&gt;    for the OSG site-dedicated cluster and related machines, is\n&gt;    32bit CentOS 5, where the call to stat() returns (incorrectly)\n&gt;    a truncated 32bit uint, but it does (correctly) return the\n&gt;    proper failure error code... - also, BTW, command line stat in\n&gt;    this case is correct, it falls back to stat64() and returns\n&gt;    the correct 64bit uint value.\n&gt;\n&gt; Anyway, from the standpoint of Condor: I believe it should be\n&gt; considered a bug to some extent.  Condor should, as a 32bit\n&gt; install:\n&gt; - either declare it does not support LFS\n&gt; - or be compiled with proper LFS support and not choke on large values of either st_size, st_ino, or st_blocks\n&gt;\n&gt; That's it for now.\n&gt;\n&gt; Ion\n</pre></div>\n\n\n<p></p><hr/>\n<em>2009-Dec-26 20:40:12 by matt:</em> <br/>\n\nAlain, is this resolved? If so, please mark it so.\n\n<p></p><hr/>\n<em>2020-Jun-29 14:22:56 by blin:</em> <br/>\n\nGRAM is no longer relevant, abandoning.</blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "", "type": "incident", "last_change": "2020-Jun-29 14:22", "status": "abandoned", "created": "2009-Mar-19 10:06", "fixed_version": "2009-Mar-19 10:06", "broken_version": "v070005", "priority": "2", "subsystem": "Tools", "assigned_to": "nleroy", "derived_from": "", "creator": "roy", "rust": "", "customer_group": "osg", "visibility": "public", "notify": "roy@cs.wisc.edu", "due_date": ""}