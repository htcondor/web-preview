{"id": 7862, "title": "Ticket #7862: Issues configuring a \"local issuer\" SciTokens credmon", "description": "<blockquote>\nIn order for a SchedD to run jobs on execute machines that might be version 8.9.6 or earlier and also 8.9.7 or later (as seems to be the case with OSG-Connect submit nodes) we need to upgrade the SchedD binaries to 8.9.9 and update the following:\n\n<p><span class=\"section\"></span></p><h2>Config SchedD version 8.9.9 or later</h2>\n\n<p></p><div class=\"code\">\n<pre class=\"code\"># Job transform that:\n# 0) Only applies to Vanilla universe (5) jobs\n# 1) Adds the scitokens credentials\n# 2) Conditionally sets SendCredential based on execute version\n#    (Note: This expression evaluates versionLT() on the SchedD, so the SchedD\n#     must be version 8.9.9 or later, but the execute nodes do not matter.)\n#\nJOB_TRANSFORM_AddSciToken @=end\n[\n  Requirements = (JobUniverse == 5);\n  Eval_Set_OAuthServicesNeeded = strcat( \"scitokens \", OAuthServicesNeeded ?: \"\");\n  Set_ZZZ_ExecuteVersion = \"\\$\\$([split(TARGET.CondorVersion)[1]])\";\n  Set_ZZZ_SendCredentialStr = \"\\$\\$([versionLT(split(TARGET.CondorVersion)[1], \\\"8.9.7\\\")])\";\n  Set_SendCredential = ZZZ_SendCredentialStr == \"true\";\n]\n@end\n\n# Point both credential directories to same spot.\n# This directory should be owned by root:condor and chmod 2770\nSEC_CREDENTIAL_DIRECTORY_OAUTH = /var/lib/condor/oauth_credentials\nSEC_CREDENTIAL_DIRECTORY_KRB = $(SEC_CREDENTIAL_DIRECTORY_OAUTH)\n\n# Flag to new code to operate in local issuer mode\nLOCAL_CREDMON_PROVIDER_NAME = scitokens\n\n# For some reason, 8.9.9 has the SciTokens credmon in $(BIN) and not $(SBIN)\nCREDMON_OAUTH = $(BIN)/condor_credmon_oauth\n\n# This is where the python credmon is putting the log and it won't start if this isn't defined:\nSEC_CREDENTIAL_MONITOR_OAUTH_LOG = $(LOG)/CredMonOAuthLog\n\n</pre></div>\n\n\n<p><span class=\"subsection\"></span></p><h3>OLD -- Workaround for 8.9.8 -- SUGGEST UPGRADE TO 8.9.9 INSTEAD</h3>\n\n<p>Edit condor config:\n</p><div class=\"code\">\n<pre class=\"code\"># Point both credential directories to same spot.\n# This directory should be owned by root:condor and chmod 2770\nSEC_CREDENTIAL_DIRECTORY_KRB = $(SEC_CREDENTIAL_DIRECTORY_OAUTH)\n\n# Flag to new credmon code to look for krb-style filename but still generate oauth-style token.\nLOCAL_CREDMON_KRB_MODE = TRUE\n\n# *DO* define the sec credential producer\nSEC_CREDENTIAL_PRODUCER = /usr/bin/scitokens_credential_producer\n</pre></div>\n\n\n<p>Edit credmon library files:\nIn <code>/usr/lib/python2.7/site-packages/credmon/CredentialMonitors</code> modify <code>LocalCredmon.py</code> and <code>OAuthCredmon.py</code> as so:\n\n</p><p>(This patch file is also at the bottom of the ticket as an attachment, <code>scitokens.patch</code>)\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">--- a/LocalCredmon.py\n+++ b/LocalCredmon.py\n@@ -1,5 +1,6 @@\n\n import os\n+import shutil\n import glob\n\n import scitokens\n@@ -75,13 +76,20 @@ class LocalCredmon(OAuthCredmon):\n         &lt;cred_dir&gt; / &lt;username&gt; / &lt;provider&gt;.top\n         \"\"\"\n         # Take the cred_dir out of the cred_path\n-        base, _ = os.path.split(cred_fname)\n+        if htcondor.param.get(\"LOCAL_CREDMON_KRB_MODE\", False):\n+            base = os.path.splitext(cred_fname)[0]\n+            if not os.path.isdir(base):\n+                os.makedirs(base, mode=0o2755)\n+        else:\n+            base, _ = os.path.split(cred_fname)\n         username = os.path.basename(base)\n\n-        if self.should_renew(base, username):\n+        if self.should_renew(username, self.provider):\n             self.log.info('Found %s, acquiring SciToken and .use file', cred_fname)\n             success = self.refresh_access_token(username, self.provider)\n             if success:\n+                if htcondor.param.get(\"LOCAL_CREDMON_KRB_MODE\", False):\n+                    shutil.copy(os.path.join(base, self.provider + '.use'), base + '.cc')\n                 self.log.info(\"Successfully renewed SciToken for user: %s\", username)\n             else:\n                 self.log.error(\"Failed to renew SciToken for user: %s\", username)\n@@ -96,6 +104,9 @@ class LocalCredmon(OAuthCredmon):\n         \"\"\"\n\n         provider_glob = os.path.join(self.cred_dir, \"*\", \"{}.top\".format(self.provider))\n+        if htcondor.param.get(\"LOCAL_CREDMON_KRB_MODE\", False):\n+            provider_glob = os.path.join(self.cred_dir, \"*.cred\")\n+            self.log.info(\"Looking for *.cred files since LOCAL_CREDMON_KRB_MODE is set, found {} files\".format(len(glob.glob(provider_glob))))\n\n         for file_name in glob.glob(provider_glob):\n             self.process_cred_file(file_name)\n\n\n--- a/OAuthCredmon.py\n+++ b/OAuthCredmon.py\n@@ -55,11 +55,13 @@ class OAuthCredmon(AbstractCredentialMonitor):\n                 if 'use_refresh_token' in token_metadata:\n                     if token_metadata['use_refresh_token'] == False:\n                         return False\n+            lifetime_fraction = api_endpoints.token_lifetime_fraction(token_metadata['token_url'])\n+        else:\n+            lifetime_fraction = 0.5\n\n         # compute token refresh time\n         create_time = os.path.getctime(access_token_path)\n-        refresh_time = create_time + (float(access_token['expires_in']) *\n-            api_endpoints.token_lifetime_fraction(token_metadata['token_url']))\n+        refresh_time = create_time + (float(access_token['expires_in']) * lifetime_fraction)\n\n         # check if token is past its refresh time\n         if time.time() &gt; refresh_time:\n</pre></div>\n\n\n<p>Now, condor_submit will generate a <code>{username}.cred</code> file in <code>/var/lib/condor/oauth_credentials</code> and the credmon is signaled to create <code>/var/lib/condor/oauth_credentials/{username}/scitokens.use</code>\n\n</p><p></p><hr/>\n<span class=\"section\"><h2>Description of problem and possible solutions</h2></span>\n\n<p>The way that Derek at OSG was using their <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=SciTokens\" title=\"Sci Tokens\">SciTokens</a></span> credmon doesn't seem to be supported any longer since 8.9.7 due to changes in the credential management framework.\n\n</p><p>Previously, submit would invoke the <code>SEC_CREDENTIAL_PRODUCER</code>, which would produce a dummy cred file that got written as <code>scitokens.top</code> in the SEC_CREDENTIAL_DIRECTORY.  This is more like \"Kerberos mode\" in that it is just passing a credential directly, as opposed to \"OAuth mode\" which prompts the user to obtain credentials via web.\n\n</p><p>However, in modern versions, we have split the credential directory into one <code>SEC_CREDENTIAL_DIRECTORY_KRB</code> and <code>SEC_CREDENTIAL_DIRECTORY_OAUTH</code>.  Using the <code>SEC_CREDENTIAL_PRODUCER</code> triggers a \"kerberos mode\" store cred, which goes in the KRB directory which would be managed by a krb credmon.  However, the OAuth credmon does not monitor that directory and is not looking for files name for that directory's convention (&lt;username&gt;.top for krb, as opposed to &lt;username&gt;/scitokens.top for the oauth directory).\n\n</p><p>The currently shipping oauth credmon is meant to monitor the OAUTH cred directory, and also has a split personality: one part is for \"local issuer\" and is hard-coded to look for \"scitokens.top\" and the other is for normal oauth processing and looks for general &lt;service&gt;.top filenames with their associated .meta files.\n\n</p><p>All this combined means that there is no mechanism for a job wanting \"locally issued\" tokens to just create a \"scitokens.top\" file in the OAuth directory and have the OAuth credmon create a signed token for that user as that was basically relying on hacky behavior when HTCondor only supported one mode or the other, and that behavior is different now that we support both.\n\n</p><p>We need to have a config knob that says something like \"scitokens_LOCAL_ISSUER = true\" so htcondor knows to handle that type of oauth request differently.  It's also not clear that having essentially two oauth credmons (local and normal) monitoring the same directory is a good idea unless they can figure out how not to step on each other.  It seems like if they are going to operate on two different subsets of files, or different directories, and behave in different ways, then maybe their codebase should be split and they should be two separate daemons.\n\n</p><p>(Further discussion on solutions is in the Remarks below and will be summarized here once a consensus is reached.)</p></blockquote>", "remarks": "<blockquote>\n<em>2020-Sep-22 15:48:31 by jpatton:</em> <br/>\n\nSome thoughts:\n\n<p></p><ol>\n<li>The <code>LocalCredmon</code> is not quite hard-coded to look for <code>{cred_dir}/{username}/scitokens.top</code>, though that is the default it fallsback to. It actually first looks at the condor_config for <code>LOCAL_CREDMON_PROVIDER_NAME</code> and looks for <code>{cred_dir}/{username}/$(LOCAL_CREDMON_PROVIDER_NAME).top</code>.\n</li><li>The <code>LocalCredmon</code> <code>{cred_dir}</code> currently inherits its value from the <code>OAuthCredmon</code> which will get its value from <code>SEC_CREDENTIAL_DIRECTORY_OAUTH</code> (via <code>utils.get_cred_dir()</code>). Changing the <code>LocalCredmon</code> to look in <code>SEC_CREDENTIAL_DIRECTORY_KRB</code> would require a little bit of refactoring, but not an unfathomable amount.\n</li><li>The way the <code>LocalCredmon</code> works to generate a <code>$(LOCAL_CREDMON_PROVIDER_NAME).use</code> token file is if it finds the <code>.top</code> file (contents <strong>do not matter</strong>) or finds that the <code>.use</code> token is about to expire, it uses <code>LOCAL_CREDMON_PRIVATE_KEY</code> and <code>LOCAL_CREDMON_KEY_ID</code> (default: <code>\"local\"</code>) from the condor_config to generate a new <code>.use</code> file via a <code>scitokens.SciToken</code> object.\n</li></ol>\n\n<p>My two cents: Without knowing how the credd side of things works exactly, I think the easiest solution is having <code>condor_submit</code> invoke some kind of \"producer\" to always create <code>$(SEC_CREDENTIAL_DIRECTORY_OAUTH)/{username}/$(LOCAL_CREDMON_PROVIDER_NAME).top</code> <em>if</em> <code>LOCAL_CREDMON_PROVIDER_NAME</code> is defined in the condor_config and <em>if</em> the <code>.top</code> file doesn't already exist, along with sending the <code>$(CREDMON_OAUTH)</code> a SIGHUP on submit to make sure the <code>.use</code> file is generated.\n\n</p><p></p><hr/>\n<em>2020-Sep-23 07:13:23 by bbockelm:</em> <br/>\n\nThis really was designed to use the \"kerberos mode\".  It doesn't seem very well suited to use the OAuth mode.\n\n<p>I mean, we can make the OAuth mode act like Kerberos mode - but is that really the right way to go?\n\n</p><p></p><hr/>\n<em>2020-Sep-23 07:50:14 by zmiller:</em> <br/>\n\nI really think we do want to make it work in OAuth mode.\n<ul>\n<li><div class=\"restricted\">It is <strike>an OAuth ticket</strike> a JWT</div>\n</li><li>It is managed by the same daemon that watches the OAuth directory\n</li><li>Kerberos mode stores things in \"username.top\" format in a flat directory.\n</li><li>As such, in Kerberos mode you can only store one credential\n</li><li>Which also means people using this mode of <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=SciTokens\" title=\"Sci Tokens\">SciTokens</a></span> can never use Kerberos (maybe not a big deal)\n</li><li>The wire mechanics for retriving an OAuth and Kerberos cred are different\n</li><li>How they are inserted into the job (filename and env variable) are different\n</li><li>If you want to query your cred users should run \"<code>condor_store_cred query-oauth</code>\" and not \"<code>condor_store_cred query-krb</code>\"\n</li></ul>\n\n<p>It's a choice between making OAuth behave like Kerberos, or to make Kerberos behave like OAuth and although either could be done I think for the above reasons I would rather do the former.\n\n</p><p></p><hr/>\n<em>2020-Sep-23 08:19:21 by bbockelm:</em> <br/>\n\nThere's no such thing as an \"OAuth ticket\".  OAuth is framework for acquiring and moving opaque tokens to an entity.\n\n<p>Accordingly, the local issuer scitokens-credmon most certainly doesn't do OAuth.\n\n</p><p>With respect to wire changes -- right now, all the OSG pilots are configured to do OAuth-mode and all the schedds are configured to do Kerberos-mode.  Are you saying the 8.9.7 changes break backward compatibility on the schedd&lt;-&gt;starter interaction?  If so, what are the upgrade concerns?\n\n</p><p></p><hr/>\n<em>2020-Sep-23 08:58:45 by zmiller:</em> <br/>\n\nSorry, I meant \"token\" and not \"ticket\".  You are right that local issuer isn't doing OAuth, but certainly someone could obtain a scitoken with OAuth.  It seems weird that how you obtained a token would then change where it was stored, how you query it, how it ends up in the job.\n\n<p>The local issuer mode is similar to kerberos in many ways for sure, and it worked at the time to use kerberos mode for this, especially because the old code in \"<code>OAUTH_MODE</code>\" was a hybrid of some behaviors of both modes.  But now that we've (more) cleanly separated the modes this model doesn't work.  The fact that local issuer could be grafted on top of kerberos mode at the time was a happy accident, and it did also require scitokens-specific hacks to the HTCondor code itself to make it work.  (e.g. see condor_utils/store_cred.cpp:350). If this is a mode of operation we want to support (it is), I'd like to remove hard-coded special cases for service names and support this in general via configuration.\n\n</p><p>Regarding compatibility: I will need to look at the compatibility for this hybrid local issuer approach but I suspect there are problems which is what this ticket is all about.  (For example, when the Starter asks for the job creds the SchedD might look in the wrong place.)  I'll add my findings here...\n\n</p><p></p><hr/>\n<em>2020-Sep-23 09:14:28 by zmiller:</em> <br/>\n\nRandom thought:  Maybe there should be a <code>SEC_CREDENTIAL_DIRECTORY_LOCAL</code> since this type of token is neither KRB nor OAUTH...  It could have its own credmon to watch that directory.  Other than sharing a little bit of python code I don't see a compelling reason for having the existing OAuth credmon also manage local tokens.  This is in fact complicating the issue since it's looking for both in the same directory, and it needs to act differently in each case base on a list of special (soft-coded) service names.  Just a thought...\n\n<p></p><hr/>\n<em>2020-Sep-23 14:12:28 by jpatton:</em> <br/>\n\nWorkaround added to ticket description, will be making some commits for 8.9.9 and attaching them to this ticket shortly.\n\n<p></p><hr/>\n<em>2020-Sep-23 14:20:19 by jpatton:</em> <br/>\n\nOn second thought, I won't commit the hacks here but there were some bugs encountered and fixed, and I'll add those to the credmon merge ticket.\n\n<p></p><hr/>\n<em>2020-Sep-23 15:47:10 by zmiller:</em> <br/>\n\nGood news, workaround was found/created (See <strong>WORKAROUND</strong> section above).  All changes are submit/schedd machine only.  Execute machine have no issue pulling the scitoken.use file and setting the environment correctly.\n\n<p>This is fine for now but not how I think we should solve this problem \"for real\" in the code.  I think I'm leaning towards a third type of credential.  (KRB, OAUTH, now add LOCAL).  But if not I also think I'm still in favor of lumping this into the OAuth side and not the KRB side.  It's definitely some of both and not exactly either.  Let's discuss more next week when presentations are over and everyone has had a chance to think about it and weigh in.</p></blockquote>", "derived_tickets": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">\n<span class=\"ticket\"><a class=\"active\" href=\"tktview?tn=7885\" title=\"SciTokens local-issuer credmon support\">#7885</a></span></td>\n<td align=\"center\" valign=\"center\" width=\"30\">\n<span class=\"icon ptr1\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\">\n<span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=SciTokens\" title=\"Sci Tokens\">SciTokens</a></span> local-issuer credmon support</td></tr>\n</tbody></table>", "attachments": "<blockquote>\n<ul>\n<li><a href=\"attach_get/1055/gt7862-0.patch\">gt7862-0.patch</a>\n2691 bytes added by zmiller on 2020-Sep-24 03:38:58 UTC.\n<br/>\nPatch to credmon python modules to enable support for local-issuer mode.<br/>\n</li></ul>\n</blockquote>", "check_ins": "", "type": "incident", "last_change": "2020-Nov-19 12:27", "status": "active", "created": "2020-Sep-22 10:15", "fixed_version": "2020-Sep-22 10:15", "broken_version": "v080908", "priority": "1", "subsystem": "Security", "assigned_to": "zmiller", "derived_from": "", "creator": "zmiller", "rust": "", "customer_group": "osg", "visibility": "public", "notify": "zmiller@cs.wisc.edu, tannenba@cs.wisc.edu, jpatton@cs.wisc.edu, bbockelman@morgridge.org, dweitzel@unl.edu", "due_date": ""}