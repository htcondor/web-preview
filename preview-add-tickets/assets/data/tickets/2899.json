{"id": 2899, "title": "Ticket #2899: classad lex/parse uses up to 50% of the compute time for daemons", "description": "<blockquote>\nClassads go over the wire using an unparse -&gt; wire -&gt; lex -&gt; parse sequence.  Lexing and parsing (and especially lexing) tend to be expensive operations.\n\n<p>Since sending classads around between daemons is a major activity in condor, I profiled a \"busy\" collector and verified that up to 50% of its computation is in lex/parse (and mostly lex, which is typical of lexers).\n\n</p><p>I believe that the lexer can be usefully streamlined without a total overhaul of the libraries.  That change would be fairly localized, since the lexer and its output are not visible to most of the system.  (In principle I also think the classad libs could be more generally redesigned for improved efficiency, at the expense of higher impact to the code).\n\n</p><p>Streamlining the lexer would positively impact all classad communication between condor daemons, and also improve performance of condor history parsing.</p></blockquote>", "remarks": "<blockquote>\n<em>2012-Mar-19 17:48:36 by eje:</em> <br/>\n\nAnother option would be to alter the wire protocol for classads so that the internal expression tree is sent over, and reconstructed directly on the receiving end, which side-steps the need to do lexing and parsing.\n\n<p>This could also be localized, to the routines that to the put/get on classads.  It would be a bit more development, kind of like a version of unparse that pushes internal expr tree nodes across the wire, and the inverse that reassembles them.\n\n</p><p>This has the potential to reduce the cycles by a lot more than just a lexer overhaul, although it also would not make any improvement to reading history file, which <strong>has</strong> to be lexed/parsed.\n\n</p><p></p><hr/>\n<em>2012-Mar-20 12:56:58 by tannenba:</em> <br/>\n\nYet another option, that may be very simple to implement, is to cache expression parse trees at the classad library level.  The cache could just be a hashtable mapping strings to parse-tree counted-pointers. So if the classad library is about to parse the expression\n<div class=\"code\">\n<pre class=\"code\">   Start = LoadAvg &lt; 1.5\n</pre></div>\n\nit would first do a simple hash lookup with they key being the un-parsed expression (aka just a string). So if the collector receives 1M ads with the same Start expression, it is only parsed once.  This change would be localized, have a large impact, and would not need to change anything about the wire format (that is a good thing for backwards compatibility). Only possible complication is how new classads \"nest\" expressions to deal with nested ads etc, but I have not looked at the new classad code much - maybe it is not a concern.\n\n<p>I really think this is the way to go here.... it is something I've wanted to do for a long time.  In fact, I was going to do it a couple years back, but decided against it because we were using old classads at the time... figured I'd wait until new classads were in place so I didn't have to make this change twice.\n\n</p><p></p><hr/>\n<em>2012-Mar-20 12:58:27 by tannenba:</em> <br/>\n\nHow is this related to the classad library caching work that Tim has been working on?  (don't have the ticket num handy, Tim?)\n\n<p></p><hr/>\n<em>2012-Mar-21 14:59:20 by eje:</em> <br/>\n\nFWIW: I hotrodded the lexer on an experimental branch.   I got it to run 40% faster (without making any high-impact changes).  It made condor_history 15% faster in my sandbox testing.\n\n<p>I'd want to do more local testing and run it thru batlab, etc, but it looks reasonable.\n\n</p><p></p><hr/>\n<em>2012-May-01 11:40:44 by tstclair:</em> <br/>\n\nSo ideally I think updating the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAdParser\" title=\"Class Ad Parser\">ClassAdParser</a></span> with the caching mechanism would yield massive gains.\n\n<p></p><div class=\"code\">\n<pre class=\"code\">ClassAdParser::parseClassAd ()\n{\n\n...\nif (!cache_hit(key, val, tree&amp; ))\n{\n    parseExpression(tree&amp;)\n}\n\n...\n}\n</pre></div>\n\n\n<p>circumvent lexing if there is a cache hit on a string match.\n\n</p><p>That is all fine and dandy \"in theory\" but from what I see, there is no easy way to get \"val\" without lexing.. :-(.\n\n</p><p></p><hr/>\n<em>2012-May-01 13:02:50 by eje:</em> <br/>\n\nIn practice, I think a slightly simpler slant <strong>would</strong> work, and cover the large majority of cases for a major speedup.\n\n<p></p><div class=\"code\">\n<pre class=\"code\">bool ClassAdParser::ParseExpression( const string &amp;buffer, ExprTree *&amp;tree, bool full ) {\n\n    if (expr_cache.defined(buffer)) {\n       tree = expr_cache[buffer];\n       return;\n    }\n\n    // otherwise do the existing logic to get (tree)\n\n    if (!tree_contains_assignment_op(tree)) {\n        // I believe we can safely store any expr not involving assignment\n        expr_cache[buffer] = tree;\n    }\n}\n\n\n</pre></div>\n\n\n<p></p><hr/>\n<em>2012-May-07 15:27:03 by tannenba:</em> <br/>\n\nAbandoning this ticket, as the work in <span class=\"ticket\"><a class=\"resolved\" href=\"tktview?tn=2541\" title=\"Memory utilization of classads (revised)\">#2541</a></span> eliminates the need to worry about this...\n\n<p></p><hr/>\n<em>2012-Jun-21 08:20:07 by tstclair:</em> <br/>\n\nI'm reopening b/c this is still a code path for optimization.\n\n<p>A lot of parsing still takes place even though caching is enabled.  Tackle both and it's like chocolate &amp; peanut butter combo.\n\n</p><p></p><hr/>\n<em>2012-Sep-25 14:31:49 by tstclair:</em> <br/>\n\nSo I may repurpose this and close this one out in preference for sparse adds over the wire, requires some tinkering 1st.\n<hr/>\n<em>2013-Jan-22 10:54:51 by johnkn:</em> <br/>\n\nBulk change of target version from v070903 to v070904 using ./ticket-target-mover.\n<hr/>\n<em>2013-Mar-05 10:58:27 by johnkn:</em> <br/>\n\nBulk change of target version from v070904 to v070905 using ./ticket-target-mover.\n<hr/>\n<em>2013-Apr-22 11:10:10 by johnkn:</em> <br/>\n\nBulk change of target version from v070905 to v070906 using ./ticket-target-mover.</blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "", "type": "enhance", "last_change": "2013-Apr-22 11:10", "status": "stalled", "created": "2012-Mar-19 17:35", "fixed_version": "2012-Mar-19 17:35", "broken_version": "v070706", "priority": "4", "subsystem": "Libs", "assigned_to": "eje", "derived_from": "#2541", "creator": "eje", "rust": "", "customer_group": "other", "visibility": "public", "notify": "eje@cs.wisc.edu, tstclair@redhat.com, gthain@cs.wisc.edu, tannenba@cs.wisc.edu, bbockelm@cse.unl.edu", "due_date": ""}