{"id": 6155, "title": "Ticket #6155: Check collector connectivity before starting annex", "description": "<blockquote>\nWe should also consider attempting to verify connectivity. The idea is here is that <code>condor_annex -setup</code> would create a Lambda function in the user's account, and then call it with the IP and port of the collector. The function would attempt to connect to that IP and port, and having done so, do whatever works best to generate an permission-denied error in the collector's log (e.g., issues a DC_NOP command without doing negotiation). The hope is that the connect-and-command sequence can be done for this particular command without involving CEDAR or the HTCondor libraries, keeping the Lambda function small and light. I think Lambda functions can't be called by anyone but the account owner by default, but as long as we make sure of that, the Lambda function can trust the caller, and we don't need to worry about security (e.g., rate-limiting and the like). condor_annex could then grovel the collector log to make sure the connection happened to the collector in question. (The trusted lambda function could say, yes or no, I connected, but couldn't verify that the address matched the collector in question.)</blockquote>", "remarks": "<blockquote>\n<em>2017-Feb-17 13:16:47 by tlmiller:</em> <br/>\n\nZach wrote:\n\n<p></p><div class=\"verbatim\">\n<pre>Okay, here's a string of 13 bytes you can use to send a legitimate DC_NOP:\n\n\"\\x01\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\xea\\x6b\"\n</pre></div>\n\n\n<p>We'll need to make sure that D_COMMAND is set for the shared port daemon and/or the collector (the shared port daemon should forward DC_NOP to the collector but might not; we'll have to check), possibly depending on if shared port is enabled; but this shouldn't be hard to do in the context of either an automated set-up tool or assuming the default instructions.\n\n</p><p></p><hr/>\n<em>2017-Feb-17 13:18:11 by tlmiller:</em> <br/>\n\nJason's assignment is to write the Lambda function, not for the rest of this ticket.\n\n<p></p><hr/>\n<em>2017-Feb-17 13:25:47 by jpatton:</em> <br/>\n\nAs added motivation for using the AWS Lambda method, at least for now, \"The [AWS] Lambda free tier includes 1M free requests per month and 400,000 GB-seconds of compute time per month.\" It would take a ridiculous amount of annex setups in a month to reach this limit, so this solution should be \"free.\"\n\n<p></p><hr/>\n<em>2017-Feb-23 12:12:49 by tlmiller:</em> <br/>\n\nJaime had a(t least one) clever idea yesterday.  We'd been thinking the daemon could generate a random number on start-up and reply to a new (entirely unauthenticated) daemon core command with that, as a way of making sure the Lambda function and condor_annex were talking to the same collector.  Jaime noted that this could be accomplished by condor_annex calling the same daemon core command from condor_annex, as well, and just comparing the result to the indirect (via Lambda) route's result.  This neatly avoids any need to figure out another path for reporting the data (e.g., condor_config_val -direct).</blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2017-Mar-31 16:19</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=50394\">[50394]</a></span>: (<span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=6155\" onclick=\"get_ticket_and_populate_wrapper('6155'); return false;\" title=\"Check collector connectivity before starting annex\">#6155</a></span>) Check connectivity before creating annex. Add connectivity bits to -setup.  (By Todd L Miller )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2017-Mar-30 13:48</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=50393\">[50393]</a></span>: (<span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=6155\" onclick=\"get_ticket_and_populate_wrapper('6155'); return false;\" title=\"Check collector connectivity before starting annex\">#6155</a></span>) Return the /same/ random number for each instance of the daemon.  (By Todd L Miller )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2017-Mar-01 09:32</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=50237\">[50237]</a></span>: for <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=6155\" onclick=\"get_ticket_and_populate_wrapper('6155'); return false;\" title=\"Check collector connectivity before starting annex\">#6155</a></span>, add new daemon core command DC_QUERY_INSTANCE which returns a randomly generated unique id for each instance of each daemon. the daemon client side code for this command has not yet been written ===VersionHistory:Pending=== also the documentation...  (By John (TJ) Knoeller )</td></tr>\n</tbody></table>", "type": "experimental", "last_change": "2017-Apr-04 17:38", "status": "resolved", "created": "2017-Feb-17 13:13", "fixed_version": "2017-Feb-17 13:13", "broken_version": "", "priority": "2", "subsystem": "Annex", "assigned_to": "tlmiller", "derived_from": "#6111", "creator": "tlmiller", "rust": "", "customer_group": "other", "visibility": "public", "notify": "tlmiller@cs.wisc.edu, jpatton@cs.wisc.edu", "due_date": ""}