{"id": 2746, "title": "Ticket #2746: Remote, no-DAGMan POST scripts (and maybe PRE)", "description": "<blockquote>\nIn the CHTC, we're frequently running jobs under DAGMan for a single purpose: to use a POST script to verify job success, and on failure RETRY the job.  This adds a lot of complexity to the process, making it harder to teach users, harder to debug, chews up scheduler universe slots, and is a general nuisance.\n\n<p>Instead of DAGMan and RETRY, you can use an on_exit_remove expression to gain much the same effect.  Unfortunately, on_exit_remove is limited to information in the job's classad.  Some programs (Matlab programs are a common culprit) will return 0 on success or failure, so the exit code isn't useful.  Thus, we use DAGMan to run a POST script that validates the output.\n\n</p><p>You could get the same effect by wrapping your executable in a script that runs your read executable then does the check.  However, this adds the various problems in writing a wrapper.  In particular, we're sharing one exit status for two executables.  If \"1\" is returned, did it come from your executable, or from the script?  Either one probably indicates a problem, but it's harder to track down the source.  Also, you co-mingle your output and error streams.  If you're hoping that the stdout from your program will be clean, your wrapper script can't print any debug messages there.\n\n</p><p>I'm tired of using DAGMan to handle retries and detecting if jobs failed.  I'm tired of wrappers complicating interpreting the output of a job.  I think Condor can do better.\n\n</p><p>Relatedly, one might want to run a script on the remote end to validate the machine before starting your real work.  Might also be useful for downloading input files from unusual locations on a machine where you can't install file transfer hooks.  Also, a remote post script would be a good opportunity to compress files, delete unneeded temporary files, or handle result upload to an unusual place.\n\n</p><p>Proposed:\n\n</p><p>Individual jobs gain the concept of a PRE and POST program.  In a submit file, it might look like this:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">pre_executable  = validate_machine\npre_arguments   = 1024MB input.txt\npre_output      = pre-output.txt\npre_error       = pre-error.txt\n\nexecutable     = my_job\narguments      = --obscure-argument=1 52 input.txt --output=output.txt\noutput         = main-output.txt\nerror          = main-error.txt\n\npost_executable = validate_output\npost_arguments  = output.txt\npost_output     = post-output.txt\npost_error      = post-error.txt\n\nuniverse       = vanilla\ntransfer_input_files = input.txt\nlog            = log.txt\nqueue\n</pre></div>\n\n\n<p>When a job starts up, if there is a pre_executable, it will be run.  If it returns non-zero, then <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitBySignal\" title=\"Exit By Signal\">ExitBySignal</a></span>, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitCode\" title=\"Exit Code\">ExitCode</a></span>, and <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitSignal\" title=\"Exit Signal\">ExitSignal</a></span> are set appropriately as though pre_executable was the executable.  <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=PreExitBySignal\" title=\"Pre Exit By Signal\">PreExitBySignal</a></span>, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=PreExitCode\" title=\"Pre Exit Code\">PreExitCode</a></span>, and <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=PreExitSignal\" title=\"Pre Exit Signal\">PreExitSignal</a></span> are set to match.  <em>The job then stops</em>, matching the behavior of a failed PRE script in DAGMan.  If the pre_executable returns 0, then PreExitBySignal=FALSE and PreExitCode=0.\n\n</p><p>If there is no pre_executable, or it returned 0, then run the actual executable.  When it exits, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitBySignal\" title=\"Exit By Signal\">ExitBySignal</a></span>, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitCode\" title=\"Exit Code\">ExitCode</a></span>, and <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitSignal\" title=\"Exit Signal\">ExitSignal</a></span> are set as normal.  <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=MainExitBySignal\" title=\"Main Exit By Signal\">MainExitBySignal</a></span>, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=MainExitCode\" title=\"Main Exit Code\">MainExitCode</a></span>, and <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=MainExitSignal\" title=\"Main Exit Signal\">MainExitSignal</a></span> are set to match.\n\n</p><p>Finally, the post_executable, is assigned, is run.  When it exits, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitBySignal\" title=\"Exit By Signal\">ExitBySignal</a></span>, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitCode\" title=\"Exit Code\">ExitCode</a></span>, and <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitSignal\" title=\"Exit Signal\">ExitSignal</a></span> are set as normal.  <em>This intentionally overwrites the output of the executable.</em>  <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=PostExitBySignal\" title=\"Post Exit By Signal\">PostExitBySignal</a></span>, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=PostExitCode\" title=\"Post Exit Code\">PostExitCode</a></span>, and <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=PostExitSignal\" title=\"Post Exit Signal\">PostExitSignal</a></span> are set to match.\n\n</p><p>The final values of <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitBySignal\" title=\"Exit By Signal\">ExitBySignal</a></span>, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitCode\" title=\"Exit Code\">ExitCode</a></span>, and <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitSignal\" title=\"Exit Signal\">ExitSignal</a></span> are what is written into the job log, and thus what a tool like DAGMan will use to decide if the job succeeded or failed.  at_exit_remote and other policies can make decisions based on the result of any of the pre, main, or post executables. Simpler policies can simply test all of them by looking at the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitBySignal\" title=\"Exit By Signal\">ExitBySignal</a></span>, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitCode\" title=\"Exit Code\">ExitCode</a></span>, and <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExitSignal\" title=\"Exit Signal\">ExitSignal</a></span> results.\n\n</p><p>The flow of exit codes roughly matches that of DAGMan are the moment: if the PRE fails, nothing else runs.  Is a POST runs, its result decides if the job succeeded or failed.\n\n</p><p>As yet unconsidered: We should pass the exit code from the main executable into the post_executable. DAGMan uses a special $RETURN in the arguments to the POST script; we could do something similar, but probably a different pattern since $RETURN will match attributes in the job ad.</p></blockquote>", "remarks": "<blockquote>\n<em>2012-Jan-13 14:07:39 by adesmet:</em> <br/>\n\nThis may exist, at least in partial, broken, undocumented form.  See <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=2379\" onclick=\"get_ticket_and_populate_wrapper('2379'); return false;\" title=\"Starter Pre and Post scripts are not documented\">#2379</a></span></blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "", "type": "enhance", "last_change": "2012-Jan-13 14:07", "status": "new", "created": "2012-Jan-05 16:47", "fixed_version": "2012-Jan-05 16:47", "broken_version": "v000000", "priority": "4", "subsystem": "", "assigned_to": "", "derived_from": "", "creator": "adesmet", "rust": "", "customer_group": "other", "visibility": "public", "notify": "", "due_date": ""}