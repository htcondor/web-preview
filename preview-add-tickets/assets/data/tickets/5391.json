{"id": 5391, "title": "Ticket #5391: HTCondor View: Cross-graph caching", "description": "<blockquote>\nWhen multiple graphs are on the same page, they should share parsed JSON data as much as possible, similarly to how the table-linked-graph does now.  Avoiding parsing a a big speed boost.\n\n<p>The naive solution (there is a global cache), means we're keeping around a copy of the raw data even if we'll never use it again.  Perhaps it doesn't matter and the memory cost is low enough to not be worth fixing.  If it does matter, the \"right\" solution is to track usage; non-linked graphs would drop a claim when done rendering; table-linked-graphs would hold it indefinitely. Might want to lag deleting a cache entry for a second or two so that a later loading graph can find it.\n\n</p><p>Either way, we'll need some clever to cope with multiple graphs issuing the load request \"simultaneously.\" Rough plan: When I decide to load some data, I check the cache; if it's present, use it.  If it's marked as \"incoming\", register our render function to be called when it arrives.  If it's neither, mark it as incoming and handle the load; when we get the data, toss it into the cache and callback any registered functions that were waiting.\n\n</p><p>Either way, probably want a \"flush cache\" option, perhaps both globally or for  a single file.  Useful for self-updating graphs.</p></blockquote>", "remarks": "<blockquote>\n</blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "", "type": "enhance", "last_change": "2015-Nov-11 15:01", "status": "new", "created": "2015-Nov-11 14:38", "fixed_version": "2015-Nov-11 14:38", "broken_version": "", "priority": "4", "subsystem": "", "assigned_to": "", "derived_from": "#5351", "creator": "adesmet", "rust": "", "customer_group": "other", "visibility": "public", "notify": "", "due_date": ""}