{"id": 4833, "title": "Ticket #4833: IPv6 bugfixes for 8.3.2", "description": "<blockquote>\nVery very sorry to keep on finding bugs in IPv6; I really hope this is the last one!\n\n<p></p><ol>\n<li>If shared_port, IPv6, and IPv4 are enabled, then the collector does not listen on IPv6 UDP 9618. <strong>Moved to Ticket <span class=\"ticket\"><a class=\"resolved\" href=\"tktview?tn=4847\" title=\"Collector doesn't listen on UDP 9618 with shared_port, IPv6, and IPv4\">#4847</a></span>: Collector doesn't listen on UDP 9618 with shared_port, IPv6, and IPv4</strong>\n<ul>\n<li>This is because DaemonCore::InitCommandSockets assumes that TCP and UDP sockets are on the same port.  In the case of the collector using shared port, the collector listens on UDP port 9618 and the shared_port listens on TCP 9618 - breaking the code's assumption.\n</li></ul>\n</li><li>If shared_port, IPv6, and IPv4 is enabled, address rewriting does not work. <strong>Moved to Ticket <span class=\"ticket\"><a class=\"resolved\" href=\"tktview?tn=4848\" title=\"Address rewriting only considers first command socket\">#4848</a></span>: Address rewriting only considers first command socket</strong>\n<ul>\n<li>The address rewriting code seems to have a somewhat-fatal flaw: instead of comparing the ad's address against all command sockets, it only compares the address against the <strong>first</strong> command socket.  So, if the initial command socket is IPv4, an IPv4 address may get bumped to IPv6; an IPv6 address will not get rewritten to IPv4.  This results in IPv4 connections getting told the IPv6 address; hilarity ensues.\n</li><li>The issue comes up is because we determine the command socket from the shared_port_ad; if the shared port advertises the IPv4 socket (the default!) but the ad in the collector is the IPv6 address (true if the IPv6 address is first in the DNS for the collector).  This affects the collector ad (assuming issue 1 is fixed).\n</li><li>I fix this by tracking <strong>all</strong> command socket sinful strings and try address rewriting for each.\n</li></ul>\n</li><li>(It's not really a bug, but an issue when using dual-stack for the HTCondor-CE - so important for the OSG.)  In the case where all daemons are on a single node, we can perform address rewriting for all ads leaving the collector. <strong>Moved to Ticket <span class=\"ticket\"><a class=\"resolved\" href=\"tktview?tn=4849\" title=\"Rewrite all ads leaving collector on single-node pool\">#4849</a></span>: Rewrite all ads leaving collector on single-node pool</strong>  We should loosen the IP address rewriting rules to only match the IP, not the whole sinful.\n<ul>\n<li>Less aggressive, but would still fix the HTCondor-CE case is only rewriting ads when the sinful strings match <strong>or</strong> the same shared_port server is used.\n</li></ul>\n</li></ol>\n\n<p>The issue fixed in <span class=\"ticket\"><a class=\"resolved\" href=\"tktview?tn=4830\" title=\"Bug: unnecessary socket creation\">#4830</a></span> hid the issues above.  However, since 8.3.2 does not support shared_port and dual stack anyway, this ticket can be considered internal.</p></blockquote>", "remarks": "<blockquote>\n1.  As far as I can tell, it's a bug that the collector is trying to bind to a UDP port when shared port is enabled at all.  The port should never be used.  (Who would the collector ever tell about it?  I guess maybe a collector tree, but it seems like this shouldn't generally be happening.)\n\n<p>That being said, I think you've misidentified the code's assumption.  The target ports can only differ from the requested ports if the requested ports were dynamically assigned.  If they are, then we assume that InitCommandSocket() (singular) will do what it's supposed to and fail if it can't bind both the TCP and the UDP port.\n\n</p><p>In point of actual fact, I don't think it does -- neither TJ nor I could find where, if InitCommandSocket() were given fixed port numbers, it actually binds the TCP port.  Our best guess as to why it actually works right now is that the master uses a different method when it creates sockets for people to inherit, and nobody ever actually asks for an extra command socket on a specified port.  This would tend to imply the master isn't doing the right thing here, but I need to investigate further.\n\n</p><p>2. I'm certain I tested this.  I may have missed something, but I'm sure I tested it -- so I'd like to know what, precisely, is broken.\n\n</p><p>The address rewriting code should never see an IP address other than the first command socket's -- we (should) never insert anything else.  I don't necessarily object to checking all of sinfuls, just to be safe, but I think something else is going on.\n\n</p><p>Have you verified that the on-disk shared port ad contains an IPv6 address?  The shared port daemon uses the initial command socket (as we would expect) to populate the ad, and address rewriting only occurs when sending <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAds\" title=\"Class Ads\">ClassAds</a></span> over the wire.  (And only when the address in question is the address of the sender, because we don't otherwise know what to substitute.)\n\n</p><p>More generally, yes, even an IPv4-only client is going to see IPv6 addresses in the collector.  There's nothing we can do about that; we plan to avoid the problem with matchmaking, in the future.\n\n</p><p>3. I don't recall it at the moment -- more later, possibly, or maybe on Tuesday when Alan gets back -- but there's a really good reason we can't rewrite based only on IP address; it may not apply in this special case.  I guess we could offer a knob to force the collector to rewrite other people's ads?\n\n</p><p></p><hr/>\n<em>2015-Jan-17 07:48:35 by bbockelm:</em> <br/>\n\nHi Todd,\n\n<p>Thanks for the review.  A few responses.\n\n</p><p></p><ol>\n<li>When the collector and shared_port are enabled (and if COLLECTOR_USES_SHARED_PORT is left to the default of true), then the shared_port will listen on TCP 9618 (forwarding non-shared-port requests to the collector).  Then, the collector will bind to UDP 9618 and a dynamic TCP port (this is because the remote daemons will still try to update via UDP).  Hence, for the case where the collector host is using shared port, <code>port=-1</code> and <code>udp_port=9618</code>.  However, the code <div class=\"verbatim\">\n<pre>targetTCPPort = targetUDPPort = rs-&gt;get_port();</pre></div>\n make an invalid assumption that <code>port = udp_port</code>. This causes the collector to break when shared_port is enabled in master.\n</li><li>Yes, when you tested it, this worked correctly.  However, when we fixed <span class=\"ticket\"><a class=\"resolved\" href=\"tktview?tn=4830\" title=\"Bug: unnecessary socket creation\">#4830</a></span>, the daemons started connecting to the collector using IPv6 (as designed) - including the collector itself!  This means the collector ad contained the collector's IPv6 address - no longer IPv4.  When subsequently serving the collector ad - which contains the IPv6 address, but the initial command socket is IPv4 - address rewriting breaks.\n</li><li>Yeah, I went back and forth whether to rewrite based on (IP address) or (IP address+port+using shared_port).  I picked the less conservative choice in the commit; however, rewriting only sinfuls on the same shared port server would be fine with me and fix this use case.\n</li></ol>\n\n<p></p><hr/>\n<em>2015-Jan-23 14:39:49 by adesmet:</em> <br/>\n\nBroken into three tickets:\n<ul>\n<li><span class=\"ticket\"><a class=\"resolved\" href=\"tktview?tn=4847\" title=\"Collector doesn't listen on UDP 9618 with shared_port, IPv6, and IPv4\">#4847</a></span>: Collector doesn't listen on UDP 9618 with shared_port, IPv6, and IPv4\n</li><li><span class=\"ticket\"><a class=\"resolved\" href=\"tktview?tn=4848\" title=\"Address rewriting only considers first command socket\">#4848</a></span>: Address rewriting only considers first command socket\n</li><li><span class=\"ticket\"><a class=\"resolved\" href=\"tktview?tn=4849\" title=\"Rewrite all ads leaving collector on single-node pool\">#4849</a></span>: Rewrite all ads leaving collector on single-node pool\n</li></ul>\n\n<p>This ticket is now obsolete.</p></blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2015-Jan-14 22:08</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=42222\">[42222]</a></span>: Fix various IPv6 issues. <span class=\"ticket\"><a class=\"abandoned\" href=\"tktview?tn=4833\" title=\"IPv6 bugfixes for 8.3.2\">#4833</a></span> In particular: 1) Make sure the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=InitCommandSockets\" title=\"Init Command Sockets\">InitCommandSockets</a></span> code does not rely on the TCP port and UDP port being the same. In the case of the collector- behind-shared-port, the collector listens on UDP 9618 and a random TCP port. Previously, the code caused the collector to listen\u00a0[...]\n (By Brian Bockelman )</td></tr>\n</tbody></table>", "type": "defect", "last_change": "2015-Jan-23 14:40", "status": "abandoned", "created": "2015-Jan-14 22:08", "fixed_version": "2015-Jan-14 22:08", "broken_version": "v080302", "priority": "2", "subsystem": "Daemons", "assigned_to": "adesmet", "derived_from": "#4492", "creator": "bbockelm", "rust": "", "customer_group": "cms", "visibility": "public", "notify": "bbockelm@cse.unl.edu, tlmiller@cs.wisc.edu", "due_date": ""}