{"id": 3277, "title": "Ticket #3277: ENABLE_IPV6 must be set in the main config file", "description": "<blockquote>\n<strong>Observed behavior:</strong> ENABLE_IPV6=TRUE is ignored if placed into a local configuration file.  It only works in the global configuration file.\n\n<p><strong>Expected behavior:</strong> ENABLE_IPV6=TRUE should work if placed into any configuration file, be it the global one, or a local one specified by LOCAL_CONFIG_FILE or LOCAL_CONFIG_DIR.\n\n</p><p><strong>Workaround:</strong>: Put ENABLE_IPV6=TRUE in your global configuration file.\n\n</p><p><strong>Why:</strong> As the configuration system is bootstrapping it needs to identify the machine's hostname so that LOCAL_CONFIG_FILE=condor_config.$(HOSTNAME) works.  This chases into the ipv6_getaddrinfo() (<a class=\"file\" href=\"rlog?f=src/condor_utils/ipv6_addrinfo.cpp\">/src/condor_utils/ipv6_addrinfo.cpp</a> ), using a default argument of get_default_hint() (<a class=\"file\" href=\"rlog?f=src/condor_utils/ipv6_addrinfo.cpp\">/src/condor_utils/ipv6_addrinfo.cpp</a> ) to identify which family (IPv4/6) to ask for.  That calls into _condor_is_ipv6_mode() (<a class=\"file\" href=\"rlog?f=src/condor_utils/condor_ipv6.cpp\">/src/condor_utils/condor_ipv6.cpp</a> ) to determine the family.  But we haven't yet loaded any local configuration files, just the main one.  ENABLE_IPV6 isn't set, it defaults to false, and away we go in IPv4 mode.  Future calls into _condor_is_ipv6_mode() use a cached result, so the real value is never noticed.\n\n</p><p>Why did it ever work?  Because the caching code in _condor_is_ipv6_mode() was buggy. Commit a5801a023f8390a40536b256af22a724b80a7d45 <span class=\"chng\"><a href=\"chngview?cn=33275\">[33275]</a></span> fixed the caching.\n\n</p><p>Why not just remove the caching?\n\n</p><p></p><ol>\n<li>I'm not confident that it's a deep fix.  That Condor briefly spends some time thinking its IPv4, then suddenly IPv6 seems dangerous.  For example, if you don't have IPv4 at all, attempts to figure out HOSTNAME may fail.\n\n<p></p></li><li>It would become subject to being changed by condor_reconfig.  The IPv6 is not currently prepared to change mode mid-run; the behavior would be undefined.\n</li></ol>\n\n<p><strong>Initial thoughts on fixing:</strong>  calls to ipv6_getaddrinfo can specify the addrinfo hints instead of relying on get_default_hint().  With a suitable addrinfo, you can request both IPv4 and IPv6 addresses (should just be a matter of setting addrinfo::ai_family to 0).  The bootstrapping code should do so.  If it only needs an IP address briefly, to figure out the HOSTNAME, either one should work.  If it actually cares, it may need to deal with the possibility of getting one of each and using both for a while until the configuration system has settled down.</p></blockquote>", "remarks": "<blockquote>\n<em>2015-Feb-03 11:52:46 by adesmet:</em> <br/>\n\nAbandoned in favor of <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=4829\" onclick=\"get_ticket_and_populate_wrapper('4829'); return false;\" title=\"ENABLE_IPV6 only works in top-level condor_config\">#4829</a></span>: ENABLE_IPV6 only works in top-level condor_config</blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "", "type": "defect", "last_change": "2015-Feb-03 11:53", "status": "abandoned", "created": "2012-Oct-17 16:23", "fixed_version": "2012-Oct-17 16:23", "broken_version": "v070804", "priority": "4", "subsystem": "", "assigned_to": "", "derived_from": "", "creator": "adesmet", "rust": "", "customer_group": "other", "visibility": "public", "notify": "", "due_date": ""}