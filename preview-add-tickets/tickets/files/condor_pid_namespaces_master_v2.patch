diff --git a/src/condor_daemon_core.V6/condor_daemon_core.h b/src/condor_daemon_core.V6/condor_daemon_core.h
index 4f9bd32..d949d23 100644
--- a/src/condor_daemon_core.V6/condor_daemon_core.h
+++ b/src/condor_daemon_core.V6/condor_daemon_core.h
@@ -273,11 +273,9 @@ class DaemonCore : public Service
 {
   friend class TimerManager; 
   friend class CreateProcessForkit;
-#ifdef WIN32
   friend int dc_main( int argc, char** argv );
+#ifdef WIN32
   friend unsigned pidWatcherThread(void*);
-#else
-  friend int main(int, char**);
 #endif
     
   public:
diff --git a/src/condor_daemon_core.V6/daemon_core.cpp b/src/condor_daemon_core.V6/daemon_core.cpp
index 251705e..3339ba5 100644
--- a/src/condor_daemon_core.V6/daemon_core.cpp
+++ b/src/condor_daemon_core.V6/daemon_core.cpp
@@ -5469,7 +5469,13 @@ void DaemonCore::Send_Signal(classy_counted_ptr<DCSignalMsg> msg, bool nonblocki
 	// sanity check on the pid.  we don't want to do something silly like
 	// kill pid -1 because the pid has not been initialized yet.
 	int signed_pid = (int) pid;
+	// TODO: when using namespaces, it's possible to be PID 1!
+	// How should we handle this?
+#if defined(LINUX)
+	if ( signed_pid > -10 && signed_pid < 1 ) {
+#else
 	if ( signed_pid > -10 && signed_pid < 3 ) {
+#endif
 		EXCEPT("Send_Signal: sent unsafe pid (%d)",signed_pid);
 	}
 
diff --git a/src/condor_daemon_core.V6/daemon_core_main.cpp b/src/condor_daemon_core.V6/daemon_core_main.cpp
index 47ee289..2ccbe16 100644
--- a/src/condor_daemon_core.V6/daemon_core_main.cpp
+++ b/src/condor_daemon_core.V6/daemon_core_main.cpp
@@ -56,6 +56,14 @@
 #include "google/coredumper.h"
 #endif
 
+#if defined(LINUX)
+#include <sys/mount.h>
+#endif
+
+#if !defined(CLONE_NEWPID)
+#define CLONE_NEWPID 0x20000000
+#endif
+
 // Externs to Globals
 extern DLL_IMPORT_MAGIC char **environ;
 
@@ -83,6 +91,7 @@ static char*	myFullName;		// set to the full path to ourselves
 DaemonCore*	daemonCore;
 char*	logDir = NULL;
 char*	pidFile = NULL;
+int errorPipe[2] = {0,0};
 char*	addrFile = NULL;
 static	char*	logAppend = NULL;
 
@@ -413,7 +422,7 @@ drop_addr_file()
 }
 
 void
-drop_pid_file() 
+drop_pid_file(pid_t newPid) 
 {
 	FILE	*PID_FILE;
 
@@ -422,9 +431,9 @@ drop_pid_file()
 		return;
 	}
 
+	pid_t mypid = newPid ? newPid : daemonCore->getpid();
 	if( (PID_FILE = safe_fopen_wrapper(pidFile, "w")) ) {
-		fprintf( PID_FILE, "%lu\n", 
-				 (unsigned long)daemonCore->getpid() ); 
+		fprintf( PID_FILE, "%lu\n", (unsigned long)mypid ); 
 		fclose( PID_FILE );
 	} else {
 		dprintf( D_ALWAYS,
@@ -1416,7 +1425,7 @@ dc_reconfig()
 
 		// Re-drop the pid file, if it's requested, just to be safe.
 	if( pidFile ) {
-		drop_pid_file();
+		drop_pid_file(0);
 	}
 
 		// If requested to do so in the config file, do a segv now.
@@ -1544,11 +1553,7 @@ gcb_recovery_failed_callback()
 // have a different, smaller main which checks if "-f" is ommitted from
 // the command line args of the condor_master, in which case it registers as 
 // an NT service.
-#ifdef WIN32
 int dc_main( int argc, char** argv )
-#else
-int main( int argc, char** argv )
-#endif
 {
 	char**	ptr;
 	int		command_port = -1;
@@ -1862,6 +1867,9 @@ int main( int argc, char** argv )
 			printf( "%s\n%s\n", CondorVersion(), CondorPlatform() );
 			exit(0);
 			break;
+		case 'n':		// Taken care of (if possible) in main wrapper.
+			dcargs++;
+			break;
 		default:
 			done = true;
 			break;	
@@ -1949,7 +1957,8 @@ int main( int argc, char** argv )
 		FreeConsole();
 #else	// UNIX
 		// on unix, background means just fork ourselves
-		if ( fork() ) {
+		// If we're a master, we already tried a fork in the wrapper.
+		if ( (!get_mySubSystem()->isType(SUBSYSTEM_TYPE_MASTER)) && fork() ) {
 			// parent
 			exit(0);
 		}
@@ -1986,6 +1995,8 @@ int main( int argc, char** argv )
 		// it seems safest to just leave them open but attached to
 		// /dev/null.
 
+		// Note: we do something similar down below in main_post_clone.
+		// If you are making modifications in this code, review that code too.
 		if ( get_mySubSystem()->isType( SUBSYSTEM_TYPE_MASTER ) ) {
 			int	fd_null = safe_open_wrapper( NULL_FILE, O_RDWR );
 			if ( fd_null < 0 ) {
@@ -2181,7 +2192,7 @@ int main( int argc, char** argv )
 		// Now that we have our pid, we could dump our pidfile, if we
 		// want it. 
 	if( pidFile ) {
-		drop_pid_file();
+		drop_pid_file(0);
 	}
 
 		// Avoid possibility of stale info sticking around from previous run.
@@ -2379,7 +2390,112 @@ int main( int argc, char** argv )
 	return FALSE;
 }	
 
-#ifdef WIN32
+#if defined(LINUX)
+typedef struct arg_info_s {
+	int argc;
+	char** argv;
+	char** argv2;
+} arg_info_t;
+
+char*
+getExecPath_nodprintf( void )
+{
+	int rval;
+	char* full_path;
+	char path_buf[MAXPATHLEN];
+	rval = readlink( "/proc/self/exe", path_buf, MAXPATHLEN );
+	if( rval < 0 ) {
+		return NULL;
+	}
+	if( rval == MAXPATHLEN ) {
+		return NULL;
+	}
+	path_buf[rval] = '\0';
+	full_path = strdup( path_buf );
+	return full_path;
+}
+
+int main_post_clone(void* arg_ptr) {
+	arg_info_t *arg = (arg_info_t*)arg_ptr;
+	if (!arg_ptr)
+		EXCEPT("PROGRAMMER ERROR - null pointer");
+
+	int i=0,j;
+	char **argv = arg->argv2;
+
+	ASSERT( arg->argc>0 );
+	argv[i++] = getExecPath_nodprintf();
+
+	char dash_f[] = "-f";
+
+		// insert "-f" argument so that new master does not fork
+	argv[i++] = dash_f;
+	for(j=1;j<arg->argc;j++) {
+		if( (strncmp(arg->argv[j],"-f",2)==0) ) {
+			i--; // do not need to insert -f, because it is already there
+			break;
+		}
+	}
+		// preserve other arguments except background and another new ns.
+	for(j=1;j<arg->argc;j++) {
+		if( strncmp(arg->argv[j],"-pi",3) == 0) {
+			j++; // Skip arg to -pidfile; if there wasn't one, we would have exited earlier.
+		} else if( (strncmp(arg->argv[j],"-b",2)!=0 ) &&
+				(strncmp(arg->argv[j],"-n",2)!=0) ){
+			argv[i++] = arg->argv[j];
+		}
+	}
+
+	argv[i++] = NULL;
+
+		// Mimic the detaching stuff as found above.
+	int     fd_null = safe_open_wrapper( NULL_FILE, O_RDWR );
+	if ( fd_null < 0 ) {
+		fprintf( stderr, "Unable to open %s: %s\n", NULL_FILE, strerror(errno) );
+		dprintf( D_ALWAYS, "Unable to open %s: %s\n", NULL_FILE, strerror(errno) );
+	}
+	int     fd;
+	for( fd=0;  fd<=2;  fd++ ) {
+		close( fd );
+		if ( ( fd_null >= 0 ) && ( fd_null != fd ) &&
+				( dup2( fd_null, fd ) < 0 )  ) {
+			dprintf( D_ALWAYS, "Error dup2()ing %s -> %d: %s\n",
+				NULL_FILE, fd, strerror(errno) );
+		}
+	}
+		// Close the /dev/null descriptor _IF_ it's not stdin/out/err
+	if ( fd_null > 2 ) {
+		close( fd_null );
+	}
+		// and detach from the controlling tty
+	detach();
+
+	if (mount("/proc", "/proc", "proc", 0, NULL) < 0) {
+		pidFile = NULL;
+		return errno;
+	}
+
+	execv(argv[0], argv);
+
+	pidFile = NULL;
+	return errno;
+}
+#endif
+
+enum {
+	STACK_GROWS_UP,
+	STACK_GROWS_DOWN
+};
+static int stack_direction(volatile int *ptr=NULL) {
+	volatile int location;
+	if(!ptr) return stack_direction(&location);
+	if (ptr < &location) {
+		return STACK_GROWS_UP;
+	}
+	return STACK_GROWS_DOWN;
+}
+
+
 int 
 main( int argc, char** argv)
 {
@@ -2389,7 +2505,7 @@ main( int argc, char** argv)
 	// Scan our command line arguments for a "-f".  If we don't find a "-f",
 	// or a "-v", then we want to register as an NT Service.
 	i = 0;
-	bool done = false;
+	bool done = false, new_ns = 0;
 	for( ptr = argv + 1; *ptr && (i < argc - 1); ptr++,i++)
 	{
 		if( ptr[0][0] != '-' ) {
@@ -2409,12 +2525,31 @@ main( int argc, char** argv)
 		case 'f':		// run in Foreground
 			Foreground = 1;
 			break;
+		case 'k':		// Kill PID specified in file
+			ptr++;
+			break;
 		case 'l':		// specify Log directory
 			 ptr++;
 			 break;
+		case 'n':		// Clone new PID namespace if possibl.e
+			 new_ns = 1;
+			 break;
 		case 'p':		// Use well-known Port for command socket.		
-			ptr++;		// Also used to specify a Pid file, but both
-			break;		// versions require a 2nd arg, so we're safe. 
+					// Also used to specify a Pid file, but both
+					// versions require a 2nd arg, so we're safe. 
+                                        // Specify a Pidfile
+			if( ptr[0][2] && ptr[0][2] == 'i' ) {
+				ptr++;
+				if( ptr && *ptr ) {
+					pidFile = *ptr;
+				} else {
+				fprintf( stderr,
+					"DaemonCore: ERROR: -pidfile needs another argument.\n" );
+				fprintf( stderr,
+					"   Please specify a filename to store the pid.\n" );
+				exit( 1 );
+				}
+			}
 		case 'q':		// Quiet output
 			break;
 		case 'r':		// Run for <arg> minutes, then gracefully exit
@@ -2435,11 +2570,62 @@ main( int argc, char** argv)
 		}
 	}
 	if ( (Foreground != 1) && get_mySubSystem()->isType(SUBSYSTEM_TYPE_MASTER) ) {
+#ifdef WIN32
 		main_init(-1,NULL);	// passing the master main_init a -1 will register as an NT service
 		return 1;
+#else
+#if defined(LINUX)
+		if (new_ns) {
+			const int stack_size = 16*1024;
+			char child_stack[stack_size];
+			char * child_stack_ptr = child_stack;
+			child_stack_ptr+= (stack_direction() == STACK_GROWS_DOWN) ? stack_size : 0;
+			int flags = (CLONE_VM|CLONE_VFORK|SIGCHLD|CLONE_NEWPID|CLONE_NEWNS);
+
+			arg_info_t arg;
+			arg.argc = argc;
+			arg.argv = argv;
+			arg.argv2 = (char **)malloc((argc+2)*sizeof(char *));
+			if (arg.argv2 == NULL)
+				EXCEPT("Unable to malloc memory for clone!");
+
+				// Create a pipe; child gets the other end and we wait on it.
+			if (pipe(errorPipe) < 0) {
+				EXCEPT("Unable to create a pipe for clone!");
+			}
+			fcntl(errorPipe[1], F_SETFD, FD_CLOEXEC);
+
+			struct pollfd fds[0];
+			int newpid = clone(main_post_clone, child_stack_ptr, flags, (void *)&arg);
+			if ((newpid == -1) && (errno != EINVAL)) { // Don't have NEWPID support; fork will do.
+				return errno;
+			} else if (newpid > 0) {
+				close(errorPipe[1]);
+				fds[0].fd = errorPipe[0];
+				fds[0].events = POLLIN;
+				// The child will either exec or exit
+				// As FD_CLOEXEC is set on the other end of this pipe,
+				// we will get a POLLHUP in either case.
+				poll(fds, 1, -1);
+				// pidFile is set to NULL if the child dies.
+				if (pidFile) {
+					drop_pid_file(newpid);
+				}
+				return 0;
+			}
+		}
+#endif
+		// POSIX or Linux without CLONE_NEWPID
+		int retval = fork();
+		if (retval < 0) {
+			return errno;
+		} else if (retval > 0) {
+			return 0;
+		}
+		return(dc_main(argc, argv));
+#endif
 	} else {
 		return(dc_main(argc,argv));
 	}
 }
-#endif // of ifdef WIN32
 
