diff --git a/src/condor_procd/CMakeLists.txt b/src/condor_procd/CMakeLists.txt
index dabfc0e..2aa792e 100644
--- a/src/condor_procd/CMakeLists.txt
+++ b/src/condor_procd/CMakeLists.txt
@@ -27,7 +27,7 @@ else(WINDOWS)
     condor_selective_glob( "proc_family_client*;proc_family_io*;local_client.*;named_pipe_reader*;named_pipe_writer*;named_pipe_util*;named_pipe_watchdog*" ProcClientElements )
 endif(WINDOWS)
 
-set( ProcdUtilsSrcs "${SAFE_OPEN_SRC};../condor_utils/condor_pidenvid.cpp;../condor_utils/condor_full_io.cpp;../condor_utils/condor_blkng_full_disk_io.cpp;../condor_procapi/procapi.cpp;../condor_procapi/processid.cpp;../condor_procapi/procapi_killfamily.cpp" )
+set( ProcdUtilsSrcs "${SAFE_OPEN_SRC};../condor_utils/condor_pidenvid.cpp;../condor_utils/condor_full_io.cpp;../condor_utils/condor_blkng_full_disk_io.cpp;../condor_procapi/procapi.cpp;../condor_procapi/processid.cpp;../condor_procapi/procapi_killfamily.cpp;../condor_starter.V6.1/cgroup.linux.cpp" )
 if (WINDOWS)
 	set( ProcdUtilsSrcs "${ProcdUtilsSrcs};../condor_utils/process_control.WINDOWS.cpp;../condor_utils/ntsysinfo.WINDOWS.cpp" )
 endif(WINDOWS)
diff --git a/src/condor_procd/proc_family.cpp b/src/condor_procd/proc_family.cpp
index ee17b60..a63f6b8 100644
--- a/src/condor_procd/proc_family.cpp
+++ b/src/condor_procd/proc_family.cpp
@@ -29,21 +29,11 @@
 
 #if defined(HAVE_EXT_LIBCGROUP)
 #include "libcgroup.h"
-#define MEMORY_CONTROLLER "memory"
-#define CPUACCT_CONTROLLER "cpuacct"
-#define FREEZE_CONTROLLER "freezer"
-#define BLOCK_CONTROLLER "blkio"
 
 #define FROZEN "FROZEN"
 #define THAWED "THAWED"
-
 #define BLOCK_STATS_LINE_MAX 64
 
-bool ProcFamily::m_cgroup_initialized = false;
-bool ProcFamily::m_cgroup_freezer_mounted = false;
-bool ProcFamily::m_cgroup_cpuacct_mounted = false;
-bool ProcFamily::m_cgroup_memory_mounted = false;
-bool ProcFamily::m_cgroup_block_mounted = false;
 #include <unistd.h>
 long ProcFamily::clock_tick = sysconf( _SC_CLK_TCK );
 #endif
@@ -62,15 +52,14 @@ ProcFamily::ProcFamily(ProcFamilyMonitor* monitor,
 	m_exited_sys_cpu_time(0),
 	m_max_image_size(0),
 	m_member_list(NULL)
+#if defined(HAVE_EXT_LIBCGROUP)
+	, m_cgroup_string(""),
+	m_cm(CgroupManager::getInstance())
+#endif
 {
 #if !defined(WIN32)
 	m_proxy = NULL;
 #endif
-#if defined(HAVE_EXT_LIBCGROUP)
-	m_cgroup_string = NULL;
-	m_cgroup = NULL;
-	m_created_cgroup = false;
-#endif
 }
 
 ProcFamily::~ProcFamily()
@@ -96,52 +85,19 @@ ProcFamily::~ProcFamily()
 		free(m_proxy);
 	}
 #endif
-#if defined(HAVE_EXT_LIBCGROUP)
-	if (m_cgroup && m_created_cgroup) {
-		delete_cgroup(m_cgroup_string);
-	}
-	if (m_cgroup != NULL) {
-		cgroup_free(&m_cgroup);
-	}
-	if (m_cgroup_string != NULL) {
-		free(m_cgroup_string);
-	}
-#endif
 }
 
 #if defined(HAVE_EXT_LIBCGROUP)
 
-void
-ProcFamily::delete_cgroup(const char * cg_string)
-{
-	int err;
-
-	struct cgroup* dcg = cgroup_new_cgroup(m_cgroup_string);
-	ASSERT (dcg != NULL);
-	if ((err = cgroup_get_cgroup(dcg))) {
-		dprintf(D_PROCFAMILY,
-			"Unable to read cgroup %s for deletion (ProcFamily %u): %u %s\n",
-			cg_string, m_root_pid, err, cgroup_strerror(err));
-	}
-	else if ((err = cgroup_delete_cgroup(dcg, CGFLAG_DELETE_RECURSIVE | CGFLAG_DELETE_IGNORE_MIGRATION))) {
-		dprintf(D_ALWAYS,
-			"Unable to completely remove cgroup %s for ProcFamily %u. %u %s\n",
-			cg_string, m_root_pid, err, cgroup_strerror(err)
-			);
-	} else {
-		dprintf(D_PROCFAMILY,
-			"Deleted cgroup %s for ProcFamily %u\n",
-			cg_string, m_root_pid);
-	}
-	cgroup_free(&dcg);
-}
-
 int
 ProcFamily::migrate_to_cgroup(pid_t pid)
 {
 	// Attempt to migrate a given process to a cgroup.
 	// This can be done without regards to whether the
 	// process is already in the cgroup
+	if (!m_cgroup.isValid()) {
+		return 1;
+	}
 
 	// We want to make sure task migration is turned on for the
 	// associated memory controller.  So, we get to look up the original cgroup.
@@ -153,7 +109,7 @@ ProcFamily::migrate_to_cgroup(pid_t pid)
 	char * orig_cgroup_string = NULL;
 	struct cgroup * orig_cgroup;
 	struct cgroup_controller * memory_controller;
-	if (m_cgroup_memory_mounted && (err = cgroup_get_current_controller_path(pid, MEMORY_CONTROLLER, &orig_cgroup_string))) {
+	if (m_cm.isMounted(CgroupManager::MEMORY_CONTROLLER) && (err = cgroup_get_current_controller_path(pid, MEMORY_CONTROLLER_STR, &orig_cgroup_string))) {
 		dprintf(D_PROCFAMILY,
 			"Unable to determine current memory cgroup for PID %u (ProcFamily %u): %u %s\n",
 			pid, m_root_pid, err, cgroup_strerror(err));
@@ -161,7 +117,7 @@ ProcFamily::migrate_to_cgroup(pid_t pid)
 	}
 	// We will migrate the PID to the new cgroup even if it is in the proper memory controller cgroup
 	// It is possible for the task to be in multiple cgroups.
-	if (m_cgroup_memory_mounted && (orig_cgroup_string != NULL) && (strcmp(m_cgroup_string, orig_cgroup_string))) {
+	if (m_cm.isMounted(CgroupManager::MEMORY_CONTROLLER) && (orig_cgroup_string != NULL) && (strcmp(m_cgroup_string.c_str(), orig_cgroup_string))) {
 		// Yes, there are race conditions here - can't really avoid this.
 		// Throughout this block, we can assume memory controller exists.
 		// Get original value of migrate.
@@ -173,7 +129,7 @@ ProcFamily::migrate_to_cgroup(pid_t pid)
 				orig_cgroup_string, m_root_pid, err, cgroup_strerror(err));
 			goto after_migrate;
 		}
-		if ((memory_controller = cgroup_get_controller(orig_cgroup, MEMORY_CONTROLLER)) == NULL) {
+		if ((memory_controller = cgroup_get_controller(orig_cgroup, MEMORY_CONTROLLER_STR)) == NULL) {
 			cgroup_free(&orig_cgroup);
 			goto after_migrate;
 		}
@@ -183,7 +139,7 @@ ProcFamily::migrate_to_cgroup(pid_t pid)
 				dprintf(D_PROCFAMILY,
 					"This kernel does not support memory usage migration; cgroup %s memory statistics"
 					" will be slightly incorrect (ProcFamily %u)\n",
-					m_cgroup_string, m_root_pid);
+					m_cgroup_string.c_str(), m_root_pid);
 			} else {
 				dprintf(D_PROCFAMILY,
 					"Unable to read cgroup %s memory controller settings for "
@@ -195,7 +151,7 @@ ProcFamily::migrate_to_cgroup(pid_t pid)
 		}
 		if (orig_migrate != 3) {
 			orig_cgroup = cgroup_new_cgroup(orig_cgroup_string);
-			memory_controller = cgroup_add_controller(orig_cgroup, MEMORY_CONTROLLER);
+			memory_controller = cgroup_add_controller(orig_cgroup, MEMORY_CONTROLLER_STR);
 			ASSERT (memory_controller != NULL); // Memory controller must already exist
 			cgroup_add_value_uint64(memory_controller, "memory.move_charge_at_immigrate", 3);
 			if ((err = cgroup_modify_cgroup(orig_cgroup))) {
@@ -214,19 +170,18 @@ ProcFamily::migrate_to_cgroup(pid_t pid)
 after_migrate:
 
 	orig_cgroup = NULL;
-	ASSERT (m_cgroup_string != NULL)
-	err = cgroup_attach_task_pid(m_cgroup, pid);
+	err = cgroup_attach_task_pid(& const_cast<struct cgroup &>(m_cgroup.getCgroup()), pid);
 	if (err) {
 		dprintf(D_PROCFAMILY,
 			"Cannot attach pid %u to cgroup %s for ProcFamily %u: %u %s\n",
-			pid, m_cgroup_string, m_root_pid, err, cgroup_strerror(err));
+			pid, m_cgroup_string.c_str(), m_root_pid, err, cgroup_strerror(err));
 	}
 
 	if (changed_orig) {
 		if ((orig_cgroup = cgroup_new_cgroup(orig_cgroup_string))) {
 			goto after_restore;
 		}
-		if (((memory_controller = cgroup_add_controller(orig_cgroup, MEMORY_CONTROLLER)) != NULL) &&
+		if (((memory_controller = cgroup_add_controller(orig_cgroup, MEMORY_CONTROLLER_STR)) != NULL) &&
 			(!cgroup_add_value_uint64(memory_controller, "memory.move_charge_at_immigrate", orig_migrate))) {
 			cgroup_modify_cgroup(orig_cgroup);
 		}
@@ -241,153 +196,32 @@ after_restore:
 }
 
 int
-ProcFamily::set_cgroup(const char * cgroup)
+ProcFamily::set_cgroup(const std::string &cgroup_string)
 {
-	int err;
-	bool has_cgroup = true, changed_cgroup = false;
-
-	if (!strcmp(cgroup, "/")) {
+	if (cgroup_string == "/") {
 		dprintf(D_ALWAYS,
 			"Cowardly refusing to monitor the root cgroup out "
 			"of security concerns.\n");
 		return 1;
 	}
 
-	// Initialize library and data structures
-	if (m_cgroup_initialized == false) {
-		dprintf(D_PROCFAMILY, "Initializing cgroup library.\n");
-		cgroup_init();
-		void *handle;
-		controller_data info;
-		int ret = cgroup_get_all_controller_begin(&handle, &info);
-		while (ret == 0) {
-			if (strcmp(info.name, MEMORY_CONTROLLER) == 0) {
-				m_cgroup_memory_mounted = (info.hierarchy != 0);
-			} else if (strcmp(info.name, CPUACCT_CONTROLLER) == 0) {
-				m_cgroup_cpuacct_mounted = (info.hierarchy != 0);
-			} else if (strcmp(info.name, FREEZE_CONTROLLER) == 0) {
-				m_cgroup_freezer_mounted = (info.hierarchy != 0);
-			} else if (strcmp(info.name, BLOCK_CONTROLLER) == 0) {
-				m_cgroup_block_mounted = (info.hierarchy != 0);
-			}
-			ret = cgroup_get_all_controller_next(&handle, &info);
-		}
-		cgroup_get_all_controller_end(&handle);
-		if (!m_cgroup_block_mounted) {
-			dprintf(D_ALWAYS, "Cgroup controller for I/O statistics is not mounted; accounting will be inaccurate.\n");
-		}
-		if (!m_cgroup_freezer_mounted) {
-			dprintf(D_ALWAYS, "Cgroup controller for process management is not mounted; process termination will be inaccurate.\n");
-		}
-		if (!m_cgroup_cpuacct_mounted) {
-			dprintf(D_ALWAYS, "Cgroup controller for CPU accounting is not mounted; cpu accounting will be inaccurate.\n");
-		}
-		if (!m_cgroup_memory_mounted) {
-			dprintf(D_ALWAYS, "Cgroup controller for memory accounting is not mounted; memory accounting will be inaccurate.\n");
-		}
-		if (ret != ECGEOF) {
-			dprintf(D_ALWAYS, "Error iterating through cgroups mount information: %s\n", cgroup_strerror(ret));
-		}
-
-	}
-
 	// Ignore this command if we've done this before.
-	if ((m_cgroup_string != NULL) && !strcmp(m_cgroup_string, cgroup)) {
-		return 0;
+	if (m_cgroup.isValid()) {
+		if (cgroup_string == m_cgroup.getCgroupString()) {
+			return 0;
+		} else {
+			m_cgroup.destroy();
+		}
 	}
 
 	dprintf(D_PROCFAMILY, "Setting cgroup to %s for ProcFamily %u.\n",
-		cgroup, m_root_pid);
-
-	if (m_cgroup_string) {
-		if (m_created_cgroup)
-			delete_cgroup(m_cgroup_string);
-		m_created_cgroup = false;
-		free(m_cgroup_string);
-	}
-	if (m_cgroup)
-		cgroup_free(&m_cgroup);
+		cgroup_string.c_str(), m_root_pid);
 
-	size_t cgroup_len = strlen(cgroup);
-	m_cgroup_string = (char *)malloc(sizeof(char)*(cgroup_len+1));
-	strcpy(m_cgroup_string, cgroup);
-	m_cgroup = cgroup_new_cgroup(m_cgroup_string);
-	ASSERT(m_cgroup != NULL);
-
-	if (ECGROUPNOTEXIST == cgroup_get_cgroup(m_cgroup)) {
-		has_cgroup = false;
-	}
+	m_cm.create(cgroup_string, m_cgroup, CgroupManager::ALL_CONTROLLERS, CgroupManager::NO_CONTROLLERS);
+	m_cgroup_string = m_cgroup.getCgroupString();
 
-	// Record if we don't have a particular subsystem, but it's not fatal.
-	// Add the controller if the cgroup didn't exist or it is not yet present.
-	if (m_cgroup_cpuacct_mounted && ((has_cgroup == false) || (cgroup_get_controller(m_cgroup, CPUACCT_CONTROLLER) == NULL))) {
-		changed_cgroup = true;
-		if (cgroup_add_controller(m_cgroup, CPUACCT_CONTROLLER) == NULL) {
-			dprintf(D_PROCFAMILY,
-				"Unable to initialize cgroup CPU accounting subsystem"
-				" for %s.\n",
-				m_cgroup_string);
-		}
-	}
-	if (m_cgroup_memory_mounted && ((has_cgroup == false) || (cgroup_get_controller(m_cgroup, MEMORY_CONTROLLER) == NULL))) {
-		changed_cgroup = true;
-		if (cgroup_add_controller(m_cgroup, MEMORY_CONTROLLER) == NULL) {
-			dprintf(D_PROCFAMILY,
-				"Unable to initialize cgroup memory accounting subsystem"
-				" for %s.\n",
-				cgroup);
-		}
-	}
-	if (m_cgroup_freezer_mounted && ((has_cgroup == false) || (cgroup_get_controller(m_cgroup, FREEZE_CONTROLLER) == NULL))) {
-		changed_cgroup = true;
-		if (cgroup_add_controller(m_cgroup, FREEZE_CONTROLLER) == NULL) {
-			dprintf(D_PROCFAMILY,
-				"Unable to initialize cgroup subsystem for killing "
-				"processes for %s.\n",
-				m_cgroup_string);
-		}
-	}
-	if (m_cgroup_block_mounted && ((has_cgroup == false) || (cgroup_get_controller(m_cgroup, BLOCK_CONTROLLER) == NULL))) {
-		changed_cgroup = true;
-		if (cgroup_add_controller(m_cgroup, BLOCK_CONTROLLER) == NULL) {
-			dprintf(D_PROCFAMILY,
-			"Unable to initialize cgroup subsystem for bloock "
-			"statistics for %s.\n",
-			m_cgroup_string);
-		}
-	}
-	// We don't consider failures fatal, as anything is better than nothing.
-	if (has_cgroup == false) {
-		if ((err = cgroup_create_cgroup(m_cgroup, 0))) {
-			dprintf(D_PROCFAMILY,
-				"Unable to create cgroup %s for ProcFamily %u."
-				"  Cgroup functionality will not work: %s\n",
-				m_cgroup_string, m_root_pid, cgroup_strerror(err));
-		} else {
-			m_created_cgroup = true;
-		}
-	} else if ((has_cgroup == true) && (changed_cgroup == true) && (err = cgroup_modify_cgroup(m_cgroup))) {
-		dprintf(D_PROCFAMILY,
-			"Unable to modify cgroup %s for ProcFamily %u."
-			"  Some cgroup functionality may not work: %u %s\n",
-			m_cgroup_string, m_root_pid, err, cgroup_strerror(err));
-	}
-
-	// Make sure hierarchical memory accounting is turned on.
-	struct cgroup_controller * mem_controller = cgroup_get_controller(m_cgroup, MEMORY_CONTROLLER);
-	if (m_cgroup_memory_mounted && m_created_cgroup && (mem_controller != NULL)) {
-		if ((err = cgroup_add_value_bool(mem_controller, "memory.use_hierarchy", true))) {
-			dprintf(D_PROCFAMILY,
-				"Unable to set hierarchical memory settings for %s (ProcFamily) %u: %u %s\n",
-				m_cgroup_string, m_root_pid, err, cgroup_strerror(err));
-		} else {
-			if ((err = cgroup_modify_cgroup(m_cgroup))) {
-				dprintf(D_PROCFAMILY,
-					"Unable to enable hierarchical memory accounting for %s "
-					"(ProcFamily %u): %u %s\n",
-					m_cgroup_string, m_root_pid, err, cgroup_strerror(err));
-			}
-		}
+	if (!m_cgroup.isValid()) {
+		return 1;
 	}
 
 	// Now that we have a cgroup, let's move all the existing processes to it
@@ -410,20 +244,20 @@ ProcFamily::freezer_cgroup(const char * state)
 	// or -EBUSY.
 	int err = 0;
 	struct cgroup_controller* freezer;
-	struct cgroup *cgroup = cgroup_new_cgroup(m_cgroup_string);
+	struct cgroup *cgroup = cgroup_new_cgroup(m_cgroup_string.c_str());
 	ASSERT (cgroup != NULL);
 
-	if (!m_cgroup_freezer_mounted) {
+	if (!m_cm.isMounted(CgroupManager::FREEZE_CONTROLLER)) {
 		err = 1;
 		goto ret;
 	}
 
-	freezer = cgroup_add_controller(cgroup, FREEZE_CONTROLLER);
+	freezer = cgroup_add_controller(cgroup, FREEZE_CONTROLLER_STR);
 	if (NULL == freezer) {
 		dprintf(D_ALWAYS,
 			"Unable to access the freezer subsystem for ProcFamily %u "
 			"for cgroup %s\n",
-			m_root_pid, m_cgroup_string);
+			m_root_pid, m_cgroup_string.c_str());
 		err = 2;
 		goto ret;
 	}
@@ -431,7 +265,7 @@ ProcFamily::freezer_cgroup(const char * state)
 	if ((err = cgroup_add_value_string(freezer, "freezer.state", state))) {
 		dprintf(D_ALWAYS,
 			"Unable to write %s to freezer for cgroup %s (ProcFamily %u). %u %s\n",
-			state, m_cgroup_string, m_root_pid, err, cgroup_strerror(err));
+			state, m_cgroup_string.c_str(), m_root_pid, err, cgroup_strerror(err));
 		err = 3;
 		goto ret;
 	}
@@ -440,16 +274,16 @@ ProcFamily::freezer_cgroup(const char * state)
 			dprintf(D_ALWAYS,
 				"Does not appear condor_procd is allowed to freeze"
 				" cgroup %s (ProcFamily %u).\n",
-				m_cgroup_string, m_root_pid);
+				m_cgroup_string.c_str(), m_root_pid);
 		} else if ((ECGOTHER == err) && (EBUSY == cgroup_get_last_errno())) {
 			dprintf(D_ALWAYS, "Kernel was unable to freeze cgroup %s "
 				"(ProcFamily %u) due to process state; signal delivery "
-				"won't be atomic\n", m_cgroup_string, m_root_pid);
+				"won't be atomic\n", m_cgroup_string.c_str(), m_root_pid);
 			err = -EBUSY;
 		} else {
 			dprintf(D_ALWAYS,
 				"Unable to commit freezer change %s for cgroup %s (ProcFamily %u). %u %s\n",
-				state, m_cgroup_string, m_root_pid, err, cgroup_strerror(err));
+				state, m_cgroup_string.c_str(), m_root_pid, err, cgroup_strerror(err));
 		}
 		err = 4;
 		goto ret;
@@ -474,21 +308,20 @@ ProcFamily::spree_cgroup(int sig)
 		return err;
 	}
 
-	ASSERT (m_cgroup != NULL);
-	cgroup_get_cgroup(m_cgroup);
+	ASSERT (m_cgroup.isValid());
+	cgroup_get_cgroup(&const_cast<struct cgroup&>(m_cgroup.getCgroup()));
 
 	void **handle = (void **)malloc(sizeof(void*));
 	ASSERT (handle != NULL);
 	pid_t pid;
-	ASSERT (m_cgroup_string != NULL);
-	err = cgroup_get_task_begin(m_cgroup_string, FREEZE_CONTROLLER, handle, &pid);
+	err = cgroup_get_task_begin(m_cgroup_string.c_str(), FREEZE_CONTROLLER_STR, handle, &pid);
 	if ((err > 0) && (err != ECGEOF))
 		handle = NULL;
 	while (err != ECGEOF) {
 		if (err > 0) {
 			dprintf(D_ALWAYS,
 				"Unable to iterate through cgroup %s (ProcFamily %u): %u %s\n",
-				m_cgroup_string, m_root_pid, err, cgroup_strerror(err));
+				m_cgroup_string.c_str(), m_root_pid, err, cgroup_strerror(err));
 			goto release;
 		}
 		send_signal(pid, sig);
@@ -510,8 +343,9 @@ ProcFamily::spree_cgroup(int sig)
 int
 ProcFamily::count_tasks_cgroup()
 {
-	if (!m_cgroup_cpuacct_mounted)
+	if (!m_cm.isMounted(CgroupManager::CPUACCT_CONTROLLER) || !m_cgroup.isValid()) {
 		return -1;
+	}
 
 	int tasks = 0, err = 0;
 	pid_t pid;
@@ -519,13 +353,12 @@ ProcFamily::count_tasks_cgroup()
 	ASSERT (handle != NULL)
 	*handle = NULL;
 
-	ASSERT (m_cgroup_string != NULL);
-	err = cgroup_get_task_begin(m_cgroup_string, CPUACCT_CONTROLLER, handle, &pid);
+	err = cgroup_get_task_begin(m_cgroup_string.c_str(), CPUACCT_CONTROLLER_STR, handle, &pid);
 	while (err != ECGEOF) {
 		if (err > 0) {
 			dprintf(D_PROCFAMILY,
 				"Unable to read cgroup %s memory stats (ProcFamily %u): %u %s.\n",
-				m_cgroup_string, m_root_pid, err, cgroup_strerror(err));
+				m_cgroup_string.c_str(), m_root_pid, err, cgroup_strerror(err));
 			break;
 		}
 		tasks ++;
@@ -570,50 +403,41 @@ _check_stat_uint64(const struct cgroup_stat &stats, const char* name, u_int64_t*
 void
 ProcFamily::update_max_image_size_cgroup()
 {
-	if (!m_cgroup_memory_mounted) {
+	if (!m_cm.isMounted(CgroupManager::MEMORY_CONTROLLER) || !m_cgroup.isValid()) {
 		return;
 	}
 
 	int err;
 	u_int64_t max_image;
-	struct cgroup *memcg;
 	struct cgroup_controller *memct;
-	if ((memcg = cgroup_new_cgroup(m_cgroup_string)) == NULL) {
-		dprintf(D_PROCFAMILY,
-			"Unable to allocate cgroup %s (ProcFamily %u).\n",
-			m_cgroup_string, m_root_pid);
-		return;
-	}
-	if ((err = cgroup_get_cgroup(memcg))) {
+	Cgroup memcg;
+	if (m_cm.create(m_cgroup_string, memcg, CgroupManager::MEMORY_CONTROLLER, CgroupManager::MEMORY_CONTROLLER) ||
+			!memcg.isValid()) {
 		dprintf(D_PROCFAMILY,
-			"Unable to load cgroup %s (ProcFamily %u).\n",
-			m_cgroup_string, m_root_pid);
-		cgroup_free(&memcg);
+			"Unable to create cgroup %s (ProcFamily %u).\n",
+			m_cgroup_string.c_str(), m_root_pid);
 		return;
 	}
-	if ((memct = cgroup_get_controller(memcg, MEMORY_CONTROLLER)) == NULL) {
+	if ((memct = cgroup_get_controller(&const_cast<struct cgroup &>(memcg.getCgroup()), MEMORY_CONTROLLER_STR)) == NULL) {
 		dprintf(D_PROCFAMILY,
 			"Unable to load memory controller for cgroup %s (ProcFamily %u).\n",
-			m_cgroup_string, m_root_pid);
-		cgroup_free(&memcg);
+			m_cgroup_string.c_str(), m_root_pid);
 		return;
 	}
 	if ((err = cgroup_get_value_uint64(memct, "memory.memsw.max_usage_in_bytes", &max_image))) {
 		dprintf(D_PROCFAMILY,
 			"Unable to load max memory usage for cgroup %s (ProcFamily %u): %u %s\n",
-			m_cgroup_string, m_root_pid, err, cgroup_strerror(err));
-		cgroup_free(&memcg);
+			m_cgroup_string.c_str(), m_root_pid, err, cgroup_strerror(err));
 		return;
 	}
 	m_max_image_size = max_image/1024;
-	cgroup_free(&memcg);
 }
 
 int
 ProcFamily::aggregate_usage_cgroup_blockio(ProcFamilyUsage* usage)
 {
 
-	if (!m_cgroup_block_mounted)
+	if (!m_cm.isMounted(CgroupManager::BLOCK_CONTROLLER) || !m_cgroup.isValid())
 		return 1;
 
 	int ret;
@@ -622,7 +446,7 @@ ProcFamily::aggregate_usage_cgroup_blockio(ProcFamilyUsage* usage)
 	char blkio_stats_name[] = "blkio.io_service_bytes";
 	short ctr;
 	long int read_bytes=0, write_bytes=0;
-	ret = cgroup_read_value_begin(BLOCK_CONTROLLER, m_cgroup_string,
+	ret = cgroup_read_value_begin(BLOCK_CONTROLLER_STR, m_cgroup_string.c_str(),
 	                              blkio_stats_name, &handle, line_contents, BLOCK_STATS_LINE_MAX);
 	while (ret == 0) {
 		ctr = 0;
@@ -647,6 +471,9 @@ ProcFamily::aggregate_usage_cgroup_blockio(ProcFamilyUsage* usage)
 		}
 		ret = cgroup_read_value_next(&handle, line_contents, BLOCK_STATS_LINE_MAX);
 	}
+	if (handle != NULL) {
+		cgroup_read_value_end(&handle);
+	}
 	if (ret != ECGEOF) {
 		dprintf(D_ALWAYS, "Internal cgroup error when retrieving block statistics: %s\n", cgroup_strerror(ret));
 		return 1;
@@ -661,7 +488,8 @@ ProcFamily::aggregate_usage_cgroup_blockio(ProcFamilyUsage* usage)
 int
 ProcFamily::aggregate_usage_cgroup(ProcFamilyUsage* usage)
 {
-	if (!m_cgroup_memory_mounted || !m_cgroup_cpuacct_mounted) {
+	if (!m_cm.isMounted(CgroupManager::MEMORY_CONTROLLER) || !m_cm.isMounted(CgroupManager::CPUACCT_CONTROLLER) 
+			|| !m_cgroup.isValid()) {
 		return -1;
 	}
 
@@ -676,12 +504,12 @@ ProcFamily::aggregate_usage_cgroup(ProcFamilyUsage* usage)
 	ASSERT (handle != NULL);
 	*handle = NULL;
 
-	err = cgroup_read_stats_begin(MEMORY_CONTROLLER, m_cgroup_string, handle, &stats);
+	err = cgroup_read_stats_begin(MEMORY_CONTROLLER_STR, m_cgroup_string.c_str(), handle, &stats);
 	while (err != ECGEOF) {
 		if (err > 0) {
 			dprintf(D_PROCFAMILY,
 				"Unable to read cgroup %s memory stats (ProcFamily %u): %u %s.\n",
-				m_cgroup_string, m_root_pid, err, cgroup_strerror(err));
+				m_cgroup_string.c_str(), m_root_pid, err, cgroup_strerror(err));
 			break;
 		}
 		if (_check_stat_uint64(stats, "total_rss", &tmp)) {
@@ -704,7 +532,7 @@ ProcFamily::aggregate_usage_cgroup(ProcFamilyUsage* usage)
 		dprintf(D_PROCFAMILY,
 			"Unable to find all necesary memory structures for cgroup %s"
 			" (ProcFamily %u)\n",
-			m_cgroup_string, m_root_pid);
+			m_cgroup_string.c_str(), m_root_pid);
 	}
 	// The poor man's way of updating the max image size.
 	if (image > m_max_image_size) {
@@ -715,12 +543,12 @@ ProcFamily::aggregate_usage_cgroup(ProcFamilyUsage* usage)
 
 	// Update CPU
 	*handle = NULL;
-	err = cgroup_read_stats_begin(CPUACCT_CONTROLLER, m_cgroup_string, handle, &stats);
+	err = cgroup_read_stats_begin(CPUACCT_CONTROLLER_STR, m_cgroup_string.c_str(), handle, &stats);
 	while (err != ECGEOF) {
 		if (err > 0) {
 			dprintf(D_PROCFAMILY,
 				"Unable to read cgroup %s cpuacct stats (ProcFamily %u): %s.\n",
-				m_cgroup_string, m_root_pid, cgroup_strerror(err));
+				m_cgroup_string.c_str(), m_root_pid, cgroup_strerror(err));
 			break;
 		}
 		if (_check_stat_uint64(stats, "user", &tmp)) {
@@ -828,9 +656,7 @@ ProcFamily::aggregate_usage(ProcFamilyUsage* usage)
 	usage->sys_cpu_time += m_exited_sys_cpu_time;
 
 #if defined(HAVE_EXT_LIBCGROUP)
-        if (m_cgroup != NULL) {
-		aggregate_usage_cgroup(usage);
-	}
+	aggregate_usage_cgroup(usage);
 #endif
 
 }
@@ -851,7 +677,7 @@ void
 ProcFamily::spree(int sig)
 {
 #if defined(HAVE_EXT_LIBCGROUP)
-	if ((NULL != m_cgroup_string) && (0 == spree_cgroup(sig))) {
+	if ((m_cgroup.isValid()) && (0 == spree_cgroup(sig))) {
 		return;
 	}
 #endif
@@ -889,9 +715,7 @@ ProcFamily::add_member(procInfo* pi)
 
 #if defined(HAVE_EXT_LIBCGROUP)
 	// Add to the associated cgroup
-	if (m_cgroup_string != NULL) {
-		migrate_to_cgroup(pi->pid);
-	}
+	migrate_to_cgroup(pi->pid);
 #endif
 
 	// keep our monitor's hash table up to date!
diff --git a/src/condor_procd/proc_family.h b/src/condor_procd/proc_family.h
index f648991..28a854c 100644
--- a/src/condor_procd/proc_family.h
+++ b/src/condor_procd/proc_family.h
@@ -26,7 +26,7 @@
 #include "proc_family_io.h"
 
 #if defined(HAVE_EXT_LIBCGROUP)
-#include "libcgroup.h"
+#include "../condor_starter.V6.1/cgroup.linux.h"
 #endif
 
 class ProcFamilyMonitor;
@@ -119,7 +119,7 @@ public:
 
 #if defined(HAVE_EXT_LIBCGROUP)
 	// Set the cgroup to use for this family
-	int set_cgroup(const char *);
+	int set_cgroup(const std::string&); 
 #endif
 
 	// dump info about all processes in this family
@@ -177,14 +177,9 @@ private:
 #endif
 
 #if defined(HAVE_EXT_LIBCGROUP)
-	static bool m_cgroup_initialized;
-	static bool m_cgroup_freezer_mounted;
-	static bool m_cgroup_cpuacct_mounted;
-	static bool m_cgroup_memory_mounted;
-	static bool m_cgroup_block_mounted;
-	char* m_cgroup_string;
-	struct cgroup* m_cgroup;
-	bool m_created_cgroup;
+	Cgroup m_cgroup;
+	std::string m_cgroup_string;
+	CgroupManager &m_cm;
 	static long clock_tick;
 
 	int count_tasks_cgroup();
@@ -193,7 +188,6 @@ private:
 	int freezer_cgroup(const char *);
 	int spree_cgroup(int);
 	int migrate_to_cgroup(pid_t);
-	void delete_cgroup(const char *);
 	void update_max_image_size_cgroup();
 #endif
 };
diff --git a/src/condor_starter.V6.1/CMakeLists.txt b/src/condor_starter.V6.1/CMakeLists.txt
index f55aec8..17f6e62 100644
--- a/src/condor_starter.V6.1/CMakeLists.txt
+++ b/src/condor_starter.V6.1/CMakeLists.txt
@@ -19,7 +19,7 @@
 
 file( GLOB starterRmvElements condor_rsh.cpp glexec_job_wrapper* )
 
-condor_daemon( starter "${starterRmvElements}" "${CONDOR_LIBS};${PCRE_FOUND};${OPENSSL_FOUND};${COREDUMPER_FOUND};${KRB5_FOUND}" "${C_SBIN}" OFF)
+condor_daemon( starter "${starterRmvElements}" "${CONDOR_LIBS};${PCRE_FOUND};${OPENSSL_FOUND};${COREDUMPER_FOUND};${KRB5_FOUND};${LIBCGROUP_FOUND}" "${C_SBIN}" OFF)
 
 if (HAVE_EXT_GLOBUS)
 	clone_install( condor_starter "${C_SBIN}" "condor_gridshell" "${C_SBIN}" )
diff --git a/src/condor_starter.V6.1/cgroup.linux.cpp b/src/condor_starter.V6.1/cgroup.linux.cpp
new file mode 100644
index 0000000..515d9b8
--- /dev/null
+++ b/src/condor_starter.V6.1/cgroup.linux.cpp
@@ -0,0 +1,339 @@
+
+/*
+ * Utility library for libcgroup initialization routines.
+ * 
+ */
+
+#include "cgroup.linux.h"
+
+#if defined(HAVE_EXT_LIBCGROUP)
+
+/*
+ * Helper functions for flag manipulation.
+ */
+CgroupManager::ControllerFlags operator|(CgroupManager::ControllerFlags left, CgroupManager::ControllerFlags right) {
+        return static_cast<CgroupManager::ControllerFlags>(static_cast<int>(left) | static_cast<int>(right));
+}
+
+CgroupManager::ControllerFlags operator|=(CgroupManager::ControllerFlags &left, const CgroupManager::ControllerFlags right) {
+        left = static_cast<CgroupManager::ControllerFlags>(static_cast<int>(left) | static_cast<int>(right));
+	return left;
+}
+
+CgroupManager *CgroupManager::m_singleton = NULL;
+
+/*
+ * Create a CgroupManager.  Note this is private - users of the CgroupManager
+ * may create an instance via CgroupManager::getInstance()
+ */
+
+CgroupManager::CgroupManager() :
+	m_cgroup_mounts(NO_CONTROLLERS)
+{
+	initialize();
+}
+
+CgroupManager& CgroupManager::getInstance()
+{
+	MutexGuard guard = CgroupManager::getGuard();
+
+	if (m_singleton == NULL) {
+		m_singleton = new CgroupManager;
+	}
+	return *m_singleton;
+}
+
+/*
+ * Initialize libcgroup and mount the controllers Condor will use (if possible)
+ *
+ * Returns 0 on success, -1 otherwise.
+ */
+int CgroupManager::initialize()
+{
+	// Initialize library and data structures
+	dprintf(D_FULLDEBUG, "Initializing cgroup library.\n");
+	cgroup_init();
+	void *handle;
+	controller_data info;
+	int ret = cgroup_get_all_controller_begin(&handle, &info);
+	while (ret == 0) {
+		//dprintf(D_FULLDEBUG, "Found controller for %s.\n", info.name); // Too noisy
+		if (strcmp(info.name, MEMORY_CONTROLLER_STR) == 0) {
+			m_cgroup_mounts |= (info.hierarchy != 0) ? MEMORY_CONTROLLER : NO_CONTROLLERS;
+		} else if (strcmp(info.name, CPUACCT_CONTROLLER_STR) == 0) {
+			m_cgroup_mounts |= (info.hierarchy != 0) ? CPUACCT_CONTROLLER : NO_CONTROLLERS;
+		} else if (strcmp(info.name, FREEZE_CONTROLLER_STR) == 0) {
+			m_cgroup_mounts |= (info.hierarchy != 0) ? FREEZE_CONTROLLER : NO_CONTROLLERS;
+		} else if (strcmp(info.name, BLOCK_CONTROLLER_STR) == 0) {
+			m_cgroup_mounts |= (info.hierarchy != 0) ? BLOCK_CONTROLLER : NO_CONTROLLERS;
+		} else if (strcmp(info.name, CPU_CONTROLLER_STR) == 0) {
+			m_cgroup_mounts |= (info.hierarchy != 0) ? CPU_CONTROLLER : NO_CONTROLLERS;
+		}
+		ret = cgroup_get_all_controller_next(&handle, &info);
+	}
+	cgroup_get_all_controller_end(&handle);
+	if (!isMounted(BLOCK_CONTROLLER)) {
+		dprintf(D_ALWAYS, "Cgroup controller for I/O statistics is not available.\n");
+	}
+	if (!isMounted(FREEZE_CONTROLLER)) {
+		dprintf(D_ALWAYS, "Cgroup controller for process management is not available.\n");
+	}
+	if (!isMounted(CPUACCT_CONTROLLER)) {
+		dprintf(D_ALWAYS, "Cgroup controller for CPU accounting is not available.\n");
+	}
+	if (!isMounted(MEMORY_CONTROLLER)) {
+		dprintf(D_ALWAYS, "Cgroup controller for memory accounting is not available.\n");
+	}
+	if (!isMounted(CPU_CONTROLLER)) {
+		dprintf(D_ALWAYS, "Cgroup controller for CPU is not available.\n");
+	}
+	if (ret != ECGEOF) {
+		dprintf(D_ALWAYS, "Error iterating through cgroups mount information: %s\n", cgroup_strerror(ret));
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * Initialize a controller for a given cgroup.
+ *
+ * Not designed for external users - extracted from CgroupManager::create to reduce code duplication.
+ */
+int CgroupManager::initialize_controller(struct cgroup& cgroup, const ControllerFlags controller,
+	const char * controller_str, const bool required, const bool has_cgroup,
+	bool & changed_cgroup)
+{
+	if (!isMounted(controller)) {
+		if (required) {
+			dprintf(D_ALWAYS, "Error - cgroup controller %s not mounted, but required.\n",
+				controller_str);
+			return 1;
+		} else {
+			dprintf(D_FULLDEBUG, "Warning - cgroup controller %s not mounted (but not required).\n", controller_str);
+			return 0;
+		}
+	}
+
+	if ((has_cgroup == false) || (cgroup_get_controller(&cgroup, controller_str) == NULL)) {
+                changed_cgroup = true;
+                if (cgroup_add_controller(&cgroup, controller_str) == NULL) {
+                        dprintf(required ? D_ALWAYS : D_FULLDEBUG,
+                                "Unable to initialize cgroup %s controller.\n",
+                                controller_str);
+			return required ? 1 : 0;
+                }
+        }
+
+	return 0;
+}
+
+/*
+ * Create a new cgroup.
+ * Parameters:
+ *   - cgroup: reference to a Cgroup object to create/initialize.
+ *   - preferred_controllers: Bitset of the controllers we would prefer.
+ *   - required_controllers: Bitset of the controllers which are required.
+ * Return values:
+ *   - 0 on success if the cgroup is pre-existing.
+ *   - -1 on error
+ * On failure, the state of cgroup is undefined.
+ */
+int CgroupManager::create(const std::string &cgroup_string, Cgroup &cgroup,
+	CgroupManager::ControllerFlags preferred_controllers,
+	CgroupManager::ControllerFlags required_controllers,
+	bool own, bool retrieve)
+{
+
+	MutexGuard guard = getGuard();
+
+	bool created_cgroup = false, changed_cgroup = false;
+	struct cgroup *cgroupp = cgroup_new_cgroup(cgroup_string.c_str());
+	if (cgroupp == NULL) {
+		dprintf(D_ALWAYS, "Unable to construct new cgroup object.\n");
+		return -1;
+	}
+
+	// Make sure all required controllers are in preferred controllers:
+	preferred_controllers |= required_controllers;
+
+	// Try to fill in the struct cgroup from /proc, if it exists.
+	bool has_cgroup = retrieve ? true : false;
+	if (retrieve && (ECGROUPNOTEXIST == cgroup_get_cgroup(cgroupp))) {
+		has_cgroup = false;
+	}
+
+	// Work through the various controllers.
+	if ((preferred_controllers & CPUACCT_CONTROLLER) &&
+		initialize_controller(*cgroupp, CPUACCT_CONTROLLER,
+			CPUACCT_CONTROLLER_STR,
+			required_controllers & CPUACCT_CONTROLLER,
+			has_cgroup, changed_cgroup)) {
+		return -1;
+	}
+	if ((preferred_controllers & MEMORY_CONTROLLER) &&
+		initialize_controller(*cgroupp, MEMORY_CONTROLLER,
+			MEMORY_CONTROLLER_STR,
+			required_controllers & MEMORY_CONTROLLER,
+			has_cgroup, changed_cgroup)) {
+		return -1;
+	}
+	if ((preferred_controllers & FREEZE_CONTROLLER) &&
+		initialize_controller(*cgroupp, FREEZE_CONTROLLER,
+			FREEZE_CONTROLLER_STR,
+			required_controllers & FREEZE_CONTROLLER,
+			has_cgroup, changed_cgroup)) {
+		return -1;
+	}
+        if ((preferred_controllers & CPUACCT_CONTROLLER) &&
+                initialize_controller(*cgroupp, CPUACCT_CONTROLLER,
+                        CPUACCT_CONTROLLER_STR,
+                        required_controllers & CPUACCT_CONTROLLER,
+                        has_cgroup, changed_cgroup)) {
+		return -1;
+        }
+	if ((preferred_controllers & BLOCK_CONTROLLER) &&
+		initialize_controller(*cgroupp, BLOCK_CONTROLLER,
+			BLOCK_CONTROLLER_STR,
+			required_controllers & BLOCK_CONTROLLER,
+			has_cgroup, changed_cgroup)) {
+		return -1;
+	}
+	if ((preferred_controllers & CPU_CONTROLLER) &&
+		initialize_controller(*cgroupp, CPU_CONTROLLER,
+			CPU_CONTROLLER_STR,
+			required_controllers & CPU_CONTROLLER,
+			has_cgroup, changed_cgroup)) {
+		return -1;
+	}
+
+	int err;
+	if (has_cgroup == false) {
+		if ((err = cgroup_create_cgroup(cgroupp, 0))) {
+			// Only record at D_ALWAYS if any cgroup mounts are available.
+			dprintf(m_cgroup_mounts ? D_ALWAYS : D_FULLDEBUG,
+				"Unable to create cgroup %s."
+				"  Cgroup functionality will not work: %s\n",
+				cgroup_string.c_str(), cgroup_strerror(err));
+			return -1;
+		} else {
+			created_cgroup = true;
+		}
+	} else if (has_cgroup && changed_cgroup && (err = cgroup_modify_cgroup(cgroupp))) {
+		dprintf(D_ALWAYS,
+			"Unable to modify cgroup %s."
+			"  Some cgroup functionality may not work: %u %s\n",
+			cgroup_string.c_str(), err, cgroup_strerror(err));
+	}
+
+	// Try to turn on hierarchical memory accounting.
+	struct cgroup_controller * mem_controller = cgroup_get_controller(cgroupp, MEMORY_CONTROLLER_STR);
+	if (retrieve && isMounted(MEMORY_CONTROLLER) && created_cgroup && (mem_controller != NULL)) {
+		if ((err = cgroup_add_value_bool(mem_controller, "memory.use_hierarchy", true))) {
+			dprintf(D_ALWAYS,
+				"Unable to set hierarchical memory settings for %s: %u %s\n",
+				cgroup_string.c_str(), err, cgroup_strerror(err));
+		} else {
+			if ((err = cgroup_modify_cgroup(cgroupp))) {
+				dprintf(D_ALWAYS,
+					"Unable to enable hierarchical memory accounting for %s "
+					": %u %s\n",
+					cgroup_string.c_str(), err, cgroup_strerror(err));
+			}
+		}
+	}
+
+	// Finally, fill in the Cgroup object's state:
+	cgroup.setCgroupString(cgroup_string);
+	cgroup.setCgroup(*cgroupp);
+
+	// Do our ref-counting
+	hash_map<std::string, int>::iterator it = cgroup_refs.find(cgroup_string);
+	if (it != cgroup_refs.end()) {
+		it->second += 1;
+	} else {
+		cgroup_refs[cgroup_string] = 1;
+		cgroup_created[cgroup_string] = own ? created_cgroup : false;
+	}
+
+	return 0;
+}
+
+/*
+ * Delete the cgroup in the OS.
+ * Returns 0 on success, -1 on failure;
+ */
+int
+CgroupManager::destroy(Cgroup &cgroup)
+{
+	MutexGuard guard = getGuard();
+
+	if (!cgroup.isValid()) {
+		return 0;
+	}
+	const std::string &cgroup_string = cgroup.getCgroupString();
+
+	hash_map<std::string, int>::iterator it = cgroup_refs.find(cgroup_string);
+	if (it == cgroup_refs.end()) {
+		EXCEPT("Destroying an unknown cgroup.");
+	}
+	it->second--;
+
+	// Only delete if this is the last ref and we originally created it.
+	if ((it->second == 0) && (cgroup_created[cgroup_string] )) {
+		int err;
+		// Must re-initialize the cgroup structure before deletion.
+		struct cgroup* dcg = cgroup_new_cgroup(cgroup_string.c_str());
+		ASSERT (dcg != NULL);
+		if ((err = cgroup_get_cgroup(dcg))) {
+			dprintf(D_ALWAYS,
+				"Unable to read cgroup %s for deletion: %u %s\n",
+				cgroup_string.c_str(), err, cgroup_strerror(err));
+			return -1;
+		}
+		else if ((err = cgroup_delete_cgroup(dcg, CGFLAG_DELETE_RECURSIVE | CGFLAG_DELETE_IGNORE_MIGRATION)))
+		{
+			dprintf(D_ALWAYS,
+				"Unable to completely remove cgroup %s for. %u %s\n",
+				cgroup_string.c_str(), err, cgroup_strerror(err));
+			return -1;
+		} else {
+			dprintf(D_FULLDEBUG,
+				"Deleted cgroup %s.\n",
+				cgroup_string.c_str());
+			return -1;
+		}
+		cgroup_free(&dcg);
+	}
+
+	return 0;
+}
+
+/*
+ * Cleanup cgroup.
+ * If the cgroup was created by us in the OS, remove it..
+ */
+Cgroup::~Cgroup()
+{
+	destroy();
+}
+
+void Cgroup::setCgroup(struct cgroup &cgroup)
+{ 
+	if (m_cgroup) {
+		destroy();
+	}
+	m_cgroup = &cgroup;
+}
+
+void Cgroup::destroy()
+{
+	if (m_cgroup) {
+		CgroupManager::getInstance().destroy(*this);
+		cgroup_free(&m_cgroup);
+		m_cgroup = NULL;
+	}
+}
+
+#endif
+
diff --git a/src/condor_starter.V6.1/cgroup.linux.h b/src/condor_starter.V6.1/cgroup.linux.h
new file mode 100644
index 0000000..dda1b30
--- /dev/null
+++ b/src/condor_starter.V6.1/cgroup.linux.h
@@ -0,0 +1,129 @@
+
+/*
+ * Utility functions for dealing with libcgroup.
+ *
+ * This is not meant to replace direct interaction with libcgroup, however
+ * it provides some simple initialization and RAII wrappers.
+ *
+ */
+
+#include "condor_common.h"
+
+#if defined(HAVE_EXT_LIBCGROUP)
+
+#include "condor_debug.h"
+
+#ifdef HAVE_PTHREADS
+#include <pthread.h>
+static pthread_mutex_t g_cgroups_mutex = PTHREAD_MUTEX_INITIALIZER;
+#endif
+
+#include "libcgroup.h"
+
+#define MEMORY_CONTROLLER_STR "memory"
+#define CPUACCT_CONTROLLER_STR "cpuacct"
+#define FREEZE_CONTROLLER_STR "freezer"
+#define BLOCK_CONTROLLER_STR "blkio"
+#define CPU_CONTROLLER_STR "cpu"
+
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ > 2)
+#include <tr1/unordered_map>
+#define hash_map std::tr1::unordered_map
+#else
+#include <ext/hash_map>
+#define hash_map __gnu_cxx::hash_map
+#endif
+
+
+class Cgroup; //Forward decl
+
+class CgroupManager {
+
+public:
+
+	enum ControllerFlags {
+		NO_CONTROLLERS = 0,
+		MEMORY_CONTROLLER = 1,
+		CPUACCT_CONTROLLER = 2,
+		FREEZE_CONTROLLER = 4,
+		BLOCK_CONTROLLER = 8,
+		CPU_CONTROLLER = 16,
+		// Each time you add a new controller, increase ALL_CONTROLLERS accordingly
+		ALL_CONTROLLERS = 32-1,
+	};
+
+	static CgroupManager &getInstance();
+
+	bool isMounted(ControllerFlags cf) const {return cf & m_cgroup_mounts;}
+
+	int create(const std::string& cgroup_string, Cgroup &cgroup,
+		ControllerFlags preferred_controllers, ControllerFlags required_controllers,
+		bool own=true, bool retrieve=true);
+	int destroy(Cgroup&);
+
+private:
+
+	CgroupManager();
+	CgroupManager(const CgroupManager&);
+	CgroupManager& operator=(const CgroupManager&);
+
+	int initialize();
+
+	int initialize_controller(struct cgroup& cgroup, ControllerFlags controller, const char * controller_str, const bool required, const bool has_cgroup, bool &changed_cgroup);
+
+	ControllerFlags m_cgroup_mounts;
+
+	static CgroupManager *m_singleton;
+
+	// Ref-counting
+	hash_map<std::string, int> cgroup_refs;
+	hash_map<std::string, bool> cgroup_created;
+
+#ifdef HAVE_PTHREADS
+	class MutexGuard {
+
+	public:
+		MutexGuard(pthread_mutex_t &mutex) : m_mutex(mutex) { pthread_mutex_lock(&m_mutex); }
+		~MutexGuard() {pthread_mutex_unlock(&m_mutex); }
+
+	private:
+		pthread_mutex_t &m_mutex;
+	};
+
+	static MutexGuard getGuard() { return MutexGuard(g_cgroups_mutex);}
+#else
+	class MutexGuard {};
+	MutexGuard getGuard() { return MutexGuard;};
+#endif
+
+};
+
+class Cgroup {
+
+public:
+	Cgroup() : m_cgroup(NULL) {}
+	~Cgroup();
+
+	// Using the zombie object pattern as exceptions are not available.
+	bool isValid() {return m_cgroup != NULL;}
+	void destroy();
+
+	struct cgroup& getCgroup() { if (isValid()) {return *m_cgroup;} EXCEPT("Accessing invalid cgroup."); return *m_cgroup;}
+	const std::string &getCgroupString() {return m_cgroup_string;};
+private:
+	std::string m_cgroup_string;
+	struct cgroup *m_cgroup;
+
+protected:
+	void setCgroupString(const std::string &cgroup_string) {m_cgroup_string = cgroup_string;};
+	void setCgroup(struct cgroup &cgroup);
+
+	friend class CgroupManager;
+};
+
+CgroupManager::ControllerFlags operator|(CgroupManager::ControllerFlags left, CgroupManager::ControllerFlags right);
+
+CgroupManager::ControllerFlags operator|=(CgroupManager::ControllerFlags &left, const CgroupManager::ControllerFlags right);
+
+#endif
+
diff --git a/src/condor_starter.V6.1/cgroup_limits.cpp b/src/condor_starter.V6.1/cgroup_limits.cpp
new file mode 100644
index 0000000..71830a5
--- /dev/null
+++ b/src/condor_starter.V6.1/cgroup_limits.cpp
@@ -0,0 +1,123 @@
+
+#include "cgroup_limits.h"
+
+#if defined(HAVE_EXT_LIBCGROUP)
+
+#include "condor_uid.h"
+
+const char * mem_hard_limit = "memory.limit_in_bytes";
+const char * mem_soft_limit = "memory.soft_limit_in_bytes";
+
+CgroupLimits::CgroupLimits(std::string &cgroup) : m_cgroup_string(cgroup)
+{
+	TemporaryPrivSentry sentry(PRIV_ROOT);
+	CgroupManager::getInstance().create(m_cgroup_string, m_cgroup,
+		CgroupManager::MEMORY_CONTROLLER | CgroupManager::CPU_CONTROLLER | CgroupManager::BLOCK_CONTROLLER,
+		CgroupManager::NO_CONTROLLERS,
+		false, false);
+}
+
+int CgroupLimits::set_memory_limit_bytes(uint64_t mem_bytes, bool soft)
+{
+	if (!m_cgroup.isValid() || !CgroupManager::getInstance().isMounted(CgroupManager::MEMORY_CONTROLLER)) {
+		dprintf(D_ALWAYS, "Unable to set memory limit because cgroup is invalid.");
+		return 1;
+	}
+
+	int err;
+	struct cgroup_controller * mem_controller;
+	const char * limit = soft ? mem_soft_limit : mem_hard_limit;
+
+	struct cgroup *memcg = &m_cgroup.getCgroup();
+	if ((mem_controller = cgroup_get_controller(memcg, MEMORY_CONTROLLER_STR)) == NULL) {
+		dprintf(D_ALWAYS,
+			"Unable to get cgroup memory controller for %s.\n",
+			m_cgroup_string.c_str());
+		return 1;
+	} else if ((err = cgroup_set_value_uint64(mem_controller, limit, mem_bytes))) {
+		dprintf(D_ALWAYS,
+			"Unable to set memory soft limit for %s: %u %s\n",
+			m_cgroup_string.c_str(), err, cgroup_strerror(err));
+		return 1;
+	} else {
+		TemporaryPrivSentry sentry(PRIV_ROOT);
+		if ((err = cgroup_modify_cgroup(memcg))) {
+			dprintf(D_ALWAYS,
+				"Unable to commit memory soft limit for %s "
+				": %u %s\n",
+				m_cgroup_string.c_str(), err, cgroup_strerror(err));
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int CgroupLimits::set_cpu_shares(uint64_t shares)
+{
+	if (!m_cgroup.isValid() || !CgroupManager::getInstance().isMounted(CgroupManager::CPU_CONTROLLER)) {
+		dprintf(D_ALWAYS, "Unable to set CPU shares because cgroup is invalid.");
+		return 1;
+	}
+
+	int err;
+	struct cgroup *cpucg = &m_cgroup.getCgroup();
+	struct cgroup_controller *cpu_controller;
+
+	if ((cpu_controller = cgroup_get_controller(cpucg, CPU_CONTROLLER_STR)) == NULL) {
+		dprintf(D_ALWAYS,
+			"Unable to add cgroup CPU controller for %s.\n",
+			m_cgroup_string.c_str());
+			return 1;
+	} else if ((err = cgroup_set_value_uint64(cpu_controller, "cpu.shares", shares))) {
+		dprintf(D_ALWAYS,
+			"Unable to set CPU shares for %s: %u %s\n",
+			m_cgroup_string.c_str(), err, cgroup_strerror(err));
+			return 1;
+	} else {
+		TemporaryPrivSentry sentry(PRIV_ROOT);
+		if ((err = cgroup_modify_cgroup(cpucg))) {
+			dprintf(D_ALWAYS,
+				"Unable to commit CPU shares for %s"
+				": %u %s\n",
+				m_cgroup_string.c_str(), err, cgroup_strerror(err));
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int CgroupLimits::set_blockio_weight(uint64_t weight)
+{
+	if (!m_cgroup.isValid() || !CgroupManager::getInstance().isMounted(CgroupManager::BLOCK_CONTROLLER)) {
+		dprintf(D_ALWAYS, "Unable to set blockio weight because cgroup is invalid.");
+		return 1;
+	}
+
+	int err;
+	struct cgroup *blkiocg = &m_cgroup.getCgroup();
+	struct cgroup_controller *blkio_controller;
+	if ((blkio_controller = cgroup_get_controller(blkiocg, BLOCK_CONTROLLER_STR)) == NULL) {
+		dprintf(D_ALWAYS,
+			"Unable to get cgroup block IO controller for %s.\n",
+			m_cgroup_string.c_str());
+			return 1;
+	} else if ((err = cgroup_set_value_uint64(blkio_controller, "blkio.weight", weight))) {
+		dprintf(D_ALWAYS,
+			"Unable to set block IO weight for %s: %u %s\n",
+			m_cgroup_string.c_str(), err, cgroup_strerror(err));
+		return 1;
+	} else {
+		TemporaryPrivSentry sentry(PRIV_ROOT);
+		if ((err = cgroup_modify_cgroup(blkiocg))) {
+			dprintf(D_ALWAYS,
+				"Unable to commit block IO weight for %s"
+				": %u %s\n",
+				m_cgroup_string.c_str(), err, cgroup_strerror(err));
+			return 1;
+		}
+	}
+	return 0;
+}
+
+#endif
+
diff --git a/src/condor_starter.V6.1/cgroup_limits.h b/src/condor_starter.V6.1/cgroup_limits.h
new file mode 100644
index 0000000..e444d98
--- /dev/null
+++ b/src/condor_starter.V6.1/cgroup_limits.h
@@ -0,0 +1,28 @@
+
+/*
+ * This class creates and configures libcgroups-based limits for the
+ * starter.
+ *
+ */
+
+#include "cgroup.linux.h"
+
+#if defined(HAVE_EXT_LIBCGROUP)
+
+class CgroupLimits {
+
+public:
+	CgroupLimits(std::string &cgroup);
+
+	int set_memory_limit_bytes(uint64_t memory_bytes, bool soft=true);
+	int set_cpu_shares(uint64_t share);
+	int set_blockio_weight(uint64_t weight);
+
+private:
+	const std::string m_cgroup_string;
+	Cgroup m_cgroup;
+
+};
+
+#endif
+
diff --git a/src/condor_starter.V6.1/vanilla_proc.cpp b/src/condor_starter.V6.1/vanilla_proc.cpp
index 044cb10..4a15677 100644
--- a/src/condor_starter.V6.1/vanilla_proc.cpp
+++ b/src/condor_starter.V6.1/vanilla_proc.cpp
@@ -34,6 +34,8 @@
 #include "classad_helpers.h"
 #include "filesystem_remap.h"
 #include "directory.h"
+#include "subsystem_info.h"
+#include "cgroup_limits.h"
 
 #ifdef WIN32
 #include "executable_scripts.WINDOWS.h"
@@ -217,23 +219,28 @@ VanillaProc::StartJob()
 
 #if defined(HAVE_EXT_LIBCGROUP)
 	// Determine the cgroup
-	char* cgroup_base = param("BASE_CGROUP"), *cgroup = NULL;
-	int cluster, proc, bufpos=0, buflen=0;
-	if (cgroup_base && JobAd->LookupInteger(ATTR_CLUSTER_ID, cluster) &&
-			JobAd->LookupInteger(ATTR_PROC_ID, proc)) {
-		cgroup = (char *)malloc(sizeof(char)*80);
+	std::string cgroup_base;
+	param(cgroup_base, "BASE_CGROUP", "");
+	MyString cgroup_str;
+	const char *cgroup = NULL;
+	if (cgroup_base.length()) {
+		MyString cgroup_uniq;
+		std::string starter_name, execute_str;
+		param(execute_str, "EXECUTE", "EXECUTE_UNKNOWN");
+			// Note: Starter is a global variable from os_proc.cpp
+		Starter->jic->machClassAd()->EvalString(ATTR_NAME, NULL, starter_name);
+		ASSERT (starter_name.size());
+		cgroup_uniq.sprintf("%s_%s", execute_str.c_str(), starter_name.c_str());
+		const char dir_delim[2] = {DIR_DELIM_CHAR, '\0'};
+		cgroup_uniq.replaceString(dir_delim, "_");
+		cgroup_str.sprintf("%s%ccondor%s", cgroup_base.c_str(), DIR_DELIM_CHAR,
+			cgroup_uniq.Value());
+		cgroup = cgroup_str.Value();
 		ASSERT (cgroup != NULL);
-		int rc = sprintf_realloc(&cgroup,&bufpos,&buflen,"%s%c%s%d%c%d",
-			cgroup_base, DIR_DELIM_CHAR, "job_",
-			cluster, '_', proc);
-		if (rc < 0) {
-			EXCEPT("Unable to determine the cgroup to use.");
-		} else {
-			fi.cgroup = cgroup;
-			dprintf(D_FULLDEBUG, "Requesting cgroup %s for job %d.%d.\n",
-				cgroup, cluster, proc);
-		}
+		fi.cgroup = cgroup;
+		dprintf(D_FULLDEBUG, "Requesting cgroup %s for job.\n", cgroup);
 	}
+
 #endif
 
 	{
@@ -369,8 +376,40 @@ VanillaProc::StartJob()
 	}
 
 #if defined(HAVE_EXT_LIBCGROUP)
-	if (cgroup != NULL)
-		free(cgroup);
+
+	// Set fairshare limits.  Note that retval == 1 indicates success, 0 is failure.
+	if (cgroup && retval) {
+		std::string mem_limit;
+		param(mem_limit, "MEMORY_LIMIT", "soft");
+		bool mem_is_soft = mem_limit == "soft";
+		std::string cgroup_string = cgroup;
+		CgroupLimits climits(cgroup_string);
+		if (mem_is_soft || (mem_limit == "hard")) {
+			ClassAd * MachineAd = Starter->jic->machClassAd();
+			int MemMb;
+			if (MachineAd->LookupInteger(ATTR_MEMORY, MemMb)) {
+				uint64_t MemMb_big = MemMb;
+				climits.set_memory_limit_bytes(1024*1024*MemMb_big, mem_is_soft);
+			} else {
+				dprintf(D_ALWAYS, "Not setting memory soft limit in cgroup because "
+					"Memory attribute missing in machine ad.\n");
+			}
+		} else if (mem_limit == "none") {
+			dprintf(D_FULLDEBUG, "Not enforcing memory soft limit.\n");
+		} else {
+			dprintf(D_ALWAYS, "Invalid value of MEMORY_LIMIT: %s.  Ignoring.\n", mem_limit.c_str());
+		}
+
+		// Now, set the CPU shares
+		ClassAd * MachineAd = Starter->jic->machClassAd();
+		int slotWeight;
+		if (MachineAd->LookupInteger(ATTR_SLOT_WEIGHT, slotWeight)) {
+			climits.set_cpu_shares(slotWeight*100);
+		} else {
+			dprintf(D_FULLDEBUG, "Invalid value of SlotWeight in machine ClassAd; ignoring.\n");
+		}
+	}
+
 #endif
 
 	return retval;
