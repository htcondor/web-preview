diff --git a/nmi_tools/nmi-build-platforms b/nmi_tools/nmi-build-platforms
index 89c2187..51610c2 100644
--- a/nmi_tools/nmi-build-platforms
+++ b/nmi_tools/nmi-build-platforms
@@ -18,6 +18,7 @@ x86_RedHat6
 # Not yet officially supported.
 
 # We want to build all branches on Fedora because it is our "warning check" platform
+x86_64_Fedora22
 x86_64_Fedora23
 
 # We might as well build on SL
diff --git a/src/condor_dagman/dag.cpp b/src/condor_dagman/dag.cpp
index aa3d8a2..d0eba04 100644
--- a/src/condor_dagman/dag.cpp
+++ b/src/condor_dagman/dag.cpp
@@ -136,6 +136,7 @@ Dag::Dag( /* const */ StringList &dagFiles,
 	_defaultPriority	  (0),
 	_metrics			  (NULL)
 {
+	debug_printf( DEBUG_DEBUG_1, "Dag(%s)::Dag()\n", _spliceScope.Value() );
 
 	// If this dag is a splice, then it may have been specified with a DIR
 	// directive. If so, then this records what it was so we can later
@@ -215,6 +216,8 @@ Dag::Dag( /* const */ StringList &dagFiles,
 //-------------------------------------------------------------------------
 Dag::~Dag()
 {
+	debug_printf( DEBUG_DEBUG_1, "Dag(%s)::~Dag()\n", _spliceScope.Value() );
+
 	if ( _condorLogRdr.activeLogFileCount() > 0 ) {
 		(void) UnmonitorLogFile();
 	}
@@ -225,7 +228,6 @@ Dag::~Dag()
     Job *job = NULL;
     _jobs.Rewind();
     while( (job = _jobs.Next()) ) {
-      ASSERT( job != NULL );
       delete job;
       _jobs.DeleteCurrent();
     }
@@ -242,6 +244,9 @@ Dag::~Dag()
 
 	delete _metrics;
 
+	DeletePinList( _pinIns );
+	DeletePinList( _pinOuts );
+
     return;
 }
 
@@ -3546,7 +3551,6 @@ Dag::RemoveNode( const char *name, MyString &whynot )
 	removed = false;
 	_jobs.Rewind();
 	while( _jobs.Next( candidate ) ) {
-		ASSERT( candidate );
         if( candidate == node ) {
 			_jobs.DeleteCurrent();
 			removed = true;
@@ -4144,7 +4148,7 @@ Dag::SetDirectory(char *dir)
 
 //---------------------------------------------------------------------------
 void
-Dag::PropogateDirectoryToAllNodes(void)
+Dag::PropagateDirectoryToAllNodes(void)
 {
 	Job *job = NULL;
 	MyString key;
@@ -4153,10 +4157,9 @@ Dag::PropogateDirectoryToAllNodes(void)
 		return;
 	}
 
-	// Propogate the directory setting to all nodes in the DAG.
+	// Propagate the directory setting to all nodes in the DAG.
 	_jobs.Rewind();
 	while( (job = _jobs.Next()) ) {
-		ASSERT( job != NULL );
 		job->PrefixDirectory(m_directory);
 	}
 
@@ -4167,6 +4170,213 @@ Dag::PropogateDirectoryToAllNodes(void)
 	m_directory = ".";
 }
 
+//-------------------------------------------------------------------------
+bool
+Dag::SetPinInOut( bool isPinIn, const char *nodeName, int pinNum )
+{
+	debug_printf( DEBUG_DEBUG_1, "Dag(%s)::SetPinInOut(%d, %s, %d)\n",
+				_spliceScope.Value(), isPinIn, nodeName, pinNum );
+
+	ASSERT( pinNum > 0 );
+
+	Job *node = FindNodeByName( nodeName );
+	if ( !node ) {
+		debug_printf( DEBUG_QUIET, "ERROR: node %s not found!\n", nodeName );
+		return false;
+	}
+
+	bool result = false;
+	if ( isPinIn ) {
+		result = SetPinInOut( _pinIns, node, pinNum );
+	} else {
+		result = SetPinInOut( _pinOuts, node, pinNum );
+	}
+
+	return result;
+}
+
+//---------------------------------------------------------------------------
+bool
+Dag::SetPinInOut( PinList &pinList, Job *node, int pinNum )
+{
+	--pinNum; // Pin numbers start with 1
+	if ( pinNum >= static_cast<int>( pinList.size() ) ) {
+		pinList.resize( pinNum+1, NULL );
+	}
+	PinNodes *pn = pinList[pinNum];
+	if ( !pn ) {
+		pinList[pinNum] = new PinNodes();
+		pn = pinList[pinNum];
+	}
+	pn->push_back( node );
+
+	return true;
+}
+
+//---------------------------------------------------------------------------
+const Dag::PinNodes *
+Dag::GetPinInOut( bool isPinIn, int pinNum ) const
+{
+	debug_printf( DEBUG_DEBUG_1, "Dag(%s)::GetPinInOut(%d, %d)\n",
+				_spliceScope.Value(), isPinIn, pinNum );
+
+	ASSERT( pinNum > 0 );
+
+	const PinNodes *pn;
+	if ( isPinIn ) {
+		pn = GetPinInOut( _pinIns, "in", pinNum );
+	} else {
+		pn = GetPinInOut( _pinOuts, "out", pinNum );
+	}
+
+	return pn;
+}
+
+//---------------------------------------------------------------------------
+const Dag::PinNodes *
+Dag::GetPinInOut( const PinList &pinList, const char *inOutStr,
+			int pinNum )
+{
+	--pinNum; // Pin numbers start with 1
+	if ( pinNum >= static_cast<int>( pinList.size() ) ) {
+		debug_printf( DEBUG_QUIET,
+					"ERROR: pin %s number %d specified; max is %d\n",
+					inOutStr, pinNum+1, static_cast<int>( pinList.size() ) );
+		return NULL;
+	} else {
+		return pinList[pinNum];
+	}
+}
+
+//---------------------------------------------------------------------------
+int
+Dag::GetPinCount( bool isPinIn )
+{
+	if ( isPinIn ) {
+		return _pinIns.size();
+	} else {
+		return _pinOuts.size();
+	}
+}
+
+//---------------------------------------------------------------------------
+bool
+Dag::ConnectSplices( Dag *parentSplice, Dag *childSplice )
+{
+	debug_printf( DEBUG_DEBUG_1, "Dag::ConnectSplices(%s, %s)\n",
+				parentSplice->_spliceScope.Value(),
+				childSplice->_spliceScope.Value() );
+
+	MyString parentName = parentSplice->_spliceScope;
+		// Trim trailing '+' from parentName.
+	int last = parentName.Length() - 1;
+	ASSERT( last >= 0 );
+	if ( parentName[last] == '+' ) {
+		parentName.setChar( last, '\0' );
+	}
+
+	MyString childName = childSplice->_spliceScope;
+		// Trim trailing '+' from childName.
+	last = childName.Length() - 1;
+	ASSERT( last >= 0 );
+	if ( childName[last] == '+' ) {
+		childName.setChar( last, '\0' );
+	}
+
+		// Make sure the parent and child splices have pin_ins/pin_outs
+		// as appropriate, and that the number of pin_ins and pin_outs
+		// matches.
+	int pinOutCount = parentSplice->GetPinCount( false );
+	if ( pinOutCount <= 0 ) {
+		debug_printf( DEBUG_QUIET,
+					"ERROR: parent splice %s has 0 pin_outs\n",
+					parentName.Value() );
+		return false;
+	}
+
+	int pinInCount = childSplice->GetPinCount( true );
+	if ( pinInCount <= 0 ) {
+		debug_printf( DEBUG_QUIET,
+					"ERROR: child splice %s has 0 pin_ins\n",
+					childName.Value() );
+		return false;
+	}
+
+	if ( pinOutCount != pinInCount ) {
+		debug_printf( DEBUG_QUIET,
+					"ERROR: pin_in/out mismatch:  parent splice %s has %d pin_outs; child splice %s has %d pin_ins\n",
+					parentName.Value(), pinOutCount,
+					childName.Value(), pinInCount );
+		return false;
+	}
+
+		// Go thru the pin_in/pin_out lists, and add parent/child
+		// dependencies between splices as appropriate.  (Note that
+		// we will catch any missing pin_in/pin_out numbers here.)
+	for (int pinNum = 1; pinNum <= pinOutCount; ++pinNum ) {
+		const PinNodes *parentPNs = parentSplice->GetPinInOut( false, pinNum );
+		if ( !parentPNs ) {
+			debug_printf( DEBUG_QUIET,
+						"ERROR: parent splice %s has no node for pin_out %d\n",
+						parentName.Value(), pinNum );
+			return false;
+		}
+
+		const PinNodes *childPNs = childSplice->GetPinInOut( true, pinNum );
+		if ( !childPNs ) {
+			debug_printf( DEBUG_QUIET,
+						"ERROR: child splice %s has no node for pin_in %d\n",
+						childName.Value(), pinNum );
+			return false;
+		}
+
+		for ( int parentNodeNum = 0;
+					parentNodeNum < static_cast<int>( parentPNs->size() );
+					++parentNodeNum ) {
+			Job *parentNode = parentPNs->at(parentNodeNum);
+			for ( int childNodeNum = 0;
+						childNodeNum < static_cast<int>( childPNs->size() );
+						++childNodeNum ) {
+				Job *childNode = childPNs->at(childNodeNum);
+
+				if ( !AddDependency( parentNode, childNode ) ) {
+					debug_printf( DEBUG_QUIET,
+								"ERROR: unable to add parent/child dependency for pin %d\n", pinNum );
+		
+					return false;
+				}
+			}
+		}
+	}
+
+		// Check for "orphan" nodes in the child splice -- nodes that
+		// don't have either a parent within the splice or a pin_in
+		// connection.
+	Job *childNode;
+	childSplice->_jobs.Rewind();
+	while( (childNode = childSplice->_jobs.Next()) ) {
+		if ( childNode->NumParents() < 1 ) {
+			debug_printf( DEBUG_QUIET,
+						"ERROR: child splice node %s has no parents after making pin connections; add pin_in or parent\n",
+						childNode->GetJobName() );
+			return false;
+		}
+	}
+
+	return true;
+}
+
+//---------------------------------------------------------------------------
+void
+Dag::DeletePinList( PinList &pinList )
+{
+	for ( int pinNum = 0; pinNum < static_cast<int>( pinList.size() );
+				++pinNum ) {
+		PinNodes *pn = pinList[pinNum];
+		delete pn;
+	}
+}
+
 //---------------------------------------------------------------------------
 void
 Dag::PrefixAllNodeNames(const MyString &prefix)
@@ -4179,7 +4389,6 @@ Dag::PrefixAllNodeNames(const MyString &prefix)
 
 	_jobs.Rewind();
 	while( (job = _jobs.Next()) ) {
-		ASSERT( job != NULL );
 		job->PrefixName(prefix);
 	}
 
@@ -4195,7 +4404,6 @@ Dag::PrefixAllNodeNames(const MyString &prefix)
 	// Then, reindex all the jobs keyed by their new name
 	_jobs.Rewind();
 	while( (job = _jobs.Next()) ) {
-		ASSERT( job != NULL );
 		key = job->GetJobName();
 		if (_nodeNameHash.insert(key, job) != 0) {
 			// I'm reinserting everything newly, so this should never happen
@@ -4324,7 +4532,7 @@ Dag::LiftSplices(SpliceLayer layer)
 	}
 
 	// and prefix them if there was a DIR for the dag.
-	PropogateDirectoryToAllNodes();
+	PropagateDirectoryToAllNodes();
 
 	// base case is above.
 	return NULL;
diff --git a/src/condor_dagman/dag.h b/src/condor_dagman/dag.h
index edae678..90a9430 100644
--- a/src/condor_dagman/dag.h
+++ b/src/condor_dagman/dag.h
@@ -169,13 +169,14 @@ class Dag {
 
     /// Add a job to the collection of jobs managed by this Dag.
     bool Add( Job& job );
+
     /** Specify a dependency between two jobs. The child job will only
         run after the parent job has finished.
         @param parent The parent job
         @param child The child job (depends on the parent)
         @return true: successful, false: failure
     */
-    bool AddDependency (Job * parent, Job * child);
+    static bool AddDependency (Job * parent, Job * child);
 
 	/** Run waiting/deferred scripts that are ready to run.  Note: scripts
 	    are also limited by halt status and maxpre/maxpost.
@@ -706,7 +707,26 @@ class Dag {
 	// After the nodes in the dag have been made, we take our DIR setting,
 	// and if it isn't ".", we prefix it to the directory setting for each
 	// node, unless it is an absolute path, in which case we ignore it.
-	void PropogateDirectoryToAllNodes(void);
+	void PropagateDirectoryToAllNodes(void);
+
+	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+	// Splice connections.
+
+	/** Set a pin in or pin out connection for this DAG.
+		@param isPinIn: true if this is for a pin in, false for pin out
+		@param nodeName: the name of the node we're connecting
+		@param pinNum: the number of the pin we're connecting
+		@return: true on success, false otherwise
+	*/
+	bool SetPinInOut( bool isPinIn, const char *nodeName, int pinNum );
+
+	/** Connect two splices via pin outs/pin ins
+		@param parentSplice: the splice connected via its pin outs
+		@param childSplice: the splice connected via its pin ins
+		@return: true on success, false otherwise
+	*/
+	static bool ConnectSplices( Dag *parentSplice, Dag *childSplice );
+	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/** Set the maximum number of job holds before a node is declared
 		a failure.
@@ -1207,6 +1227,59 @@ private:
 	
 		// Object to deal with reporting DAGMan metrics (to Pegasus).
 	DagmanMetrics *_metrics;
+
+	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+	// Splice connections.
+
+		// This is the list of nodes connected to a given pin (in or out).
+	typedef std::vector<Job *> PinNodes;
+
+		// This is a list of pin ins or pin outs.
+	typedef std::vector<PinNodes *> PinList;
+
+		// The pin ins for this DAG.
+	PinList _pinIns;
+
+		// The pin outs for this DAG.
+	PinList _pinOuts;
+
+	/** Get the list of nodes connected to a pin in or pin out
+		@param isPinIn: true if this is for a pin in, false for pin out
+		@param pinNum: the number of the pin for which we're getting
+			nodes
+		@return: a list of nodes connected to this pin
+	*/
+	const PinNodes *GetPinInOut( bool isPinIn, int pinNum ) const;
+
+	/** Get the number of pin ins or pin outs we have in this DAG
+		@param isPinIn: true if this is for pin ins, false for pin outs
+		@return: the number of pin ins or pin outs
+	*/
+	int GetPinCount( bool isPinIn );
+
+	/** Set a pin in or pin out connection for this DAG.
+		@param pinList: the pin list to update
+		@param node: the node to connect
+		@param pinNum: the number of the pin we're connecting
+		@return: true on success, false otherwise
+	*/
+	bool SetPinInOut( PinList &pinList, Job *node, int pinNum );
+
+	/** Get the list of nodes connected to a pin in or pin out
+		@param pinList: the pin list to access
+		@param inOutStr: "in" or "out" as appropriate
+		@param pinNum: the number of the pin for which we're getting
+			nodes
+		@return: a list of nodes connected to this pin
+	*/
+	const static PinNodes *GetPinInOut( const PinList &pinList,
+				const char *inOutStr, int pinNum );
+
+	/** Delete memory allocated as part of this pin list
+		@param pinList: the pin list to delete
+	*/
+	static void DeletePinList( PinList &pinList );
+	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 };
 
 #endif /* #ifndef DAG_H */
diff --git a/src/condor_dagman/parse.cpp b/src/condor_dagman/parse.cpp
index 7535c36..befde7f 100644
--- a/src/condor_dagman/parse.cpp
+++ b/src/condor_dagman/parse.cpp
@@ -49,6 +49,8 @@ static const char * DELIMITERS = " \t";
 static ExtArray<char*> _spliceScope;
 static bool _useDagDir = false;
 
+// _thisDagNum will be incremented for each DAG specified on the
+// condor_submit_dag command line.
 static int _thisDagNum = -1;
 static bool _mungeNames = true;
 
@@ -90,6 +92,10 @@ static bool parse_jobstate_log(Dag  *dag, const char *filename,
 static bool parse_pre_skip(Dag *dag, const char* filename,
 		int lineNumber);
 static bool parse_done(Dag  *dag, const char *filename, int  lineNumber);
+static bool parse_connect( Dag  *dag, const char *filename, int  lineNumber );
+static bool parse_pin_in_out( Dag  *dag, const char *filename,
+			int  lineNumber, bool isPinIn );
+static bool parse_include( Dag  *dag, const char *filename, int  lineNumber );
 static MyString munge_job_name(const char *jobName);
 
 static MyString current_splice_scope(void);
@@ -126,16 +132,14 @@ void parseSetDoNameMunge(bool doit)
 }
 
 //-----------------------------------------------------------------------------
-void parseSetThisDagNum(int num)
+bool parse(Dag *dag, const char *filename, bool useDagDir,
+			bool incrementDagNum)
 {
-	_thisDagNum = num;
-}
-
-//-----------------------------------------------------------------------------
-bool parse (Dag *dag, const char *filename, bool useDagDir) {
 	ASSERT( dag != NULL );
 
-	++_thisDagNum;
+	if ( incrementDagNum ) {
+		++_thisDagNum;
+	}
 
 	_useDagDir = useDagDir;
 
@@ -469,14 +473,39 @@ bool parse (Dag *dag, const char *filename, bool useDagDir) {
 						filename, lineNumber);
 		}
 
+		// Handle a CONNECT spec
+		else if(strcasecmp(token, "CONNECT") == 0) {
+			parsed_line_successfully = parse_connect( dag,
+						filename, lineNumber );
+		}
+
+		// Handle a PIN_IN spec
+		else if(strcasecmp(token, "PIN_IN") == 0) {
+			parsed_line_successfully = parse_pin_in_out( dag,
+						filename, lineNumber, true );
+		}
+
+		// Handle a PIN_OUT spec
+		else if(strcasecmp(token, "PIN_OUT") == 0) {
+			parsed_line_successfully = parse_pin_in_out( dag,
+						filename, lineNumber, false );
+		}
+
+		// Handle a INCLUDE spec
+		else if(strcasecmp(token, "INCLUDE") == 0) {
+			parsed_line_successfully = parse_include( dag,
+						filename, lineNumber );
+		}
+
 		// None of the above means that there was bad input.
 		else {
 			debug_printf( DEBUG_QUIET, "%s (line %d): "
-				"ERROR: expected JOB, DATA, SUBDAG, SCRIPT, PARENT, RETRY, "
-				"ABORT-DAG-ON, DOT, VARS, PRIORITY, CATEGORY, MAXJOBS, "
-				"CONFIG, SET_JOB_ATTR, SPLICE, FINAL, "
-				"NODE_STATUS_FILE, or PRE_SKIP token\n",
-				filename, lineNumber );
+				"ERROR: expected JOB, DATA, SUBDAG, FINAL, SCRIPT, PARENT, "
+				"RETRY, ABORT-DAG-ON, DOT, VARS, PRIORITY, CATEGORY, "
+				"MAXJOBS, CONFIG, SET_JOB_ATTR, SPLICE, FINAL, "
+				"NODE_STATUS_FILE, REJECT, JOBSTATE_LOG, PRE_SKIP, DONE, "
+				"CONNECT, PIN_IN, PIN_OUT, or INCLUDE token (found %s)\n",
+				filename, lineNumber, token );
 			parsed_line_successfully = false;
 		}
 		
@@ -913,17 +942,11 @@ parse_parent(
 	int  lineNumber)
 {
 	const char * example = "PARENT p1 [p2 p3 ...] CHILD c1 [c2 c3 ...]";
-	Dag *splice_dag;
-	
-	List<Job> parents;
-	ExtArray<Job*> *splice_initial;
-	ExtArray<Job*> *splice_final;
-	int i;
-	Job *job;
 	
 	const char *jobName;
 	
 	// get the job objects for the parents
+	List<Job> parents;
 	while ((jobName = strtok (NULL, DELIMITERS)) != NULL &&
 		   strcasecmp (jobName, "CHILD") != 0) {
 		const char *jobNameOrig = jobName; // for error output
@@ -931,15 +954,17 @@ parse_parent(
 		const char *jobName2 = tmpJobName.Value();
 
 		// if splice name then deal with that first...
+		Dag *splice_dag;
 		if (dag->LookupSplice(jobName2, splice_dag) == 0) {
 
 			// grab all of the final nodes of the splice and make them parents
 			// for this job.
+			ExtArray<Job*> *splice_final;
 			splice_final = splice_dag->FinalRecordedNodes();
 
 			// now add each final node as a parent
-			for (i = 0; i < splice_final->length(); i++) {
-				job = (*splice_final)[i];
+			for (int i = 0; i < splice_final->length(); i++) {
+				Job *job = (*splice_final)[i];
 				parents.Append(job);
 			}
 
@@ -947,7 +972,7 @@ parse_parent(
 
 			// orig code
 			// if the name is not a splice, then see if it is a true node name.
-			job = dag->FindNodeByName( jobName2 );
+			Job *job = dag->FindNodeByName( jobName2 );
 			if (job == NULL) {
 				// oops, it was neither a splice nor a parent name, bail
 				debug_printf( DEBUG_QUIET, 
@@ -986,6 +1011,7 @@ parse_parent(
 		const char *jobName2 = tmpJobName.Value();
 
 		// if splice name then deal with that first...
+		Dag *splice_dag;
 		if (dag->LookupSplice(jobName2, splice_dag) == 0) {
 			// grab all of the initial nodes of the splice and make them 
 			// children for this job.
@@ -994,13 +1020,14 @@ parse_parent(
 				"Detected splice %s as a child....\n", filename, lineNumber,
 					jobName2);
 
+			ExtArray<Job*> *splice_initial;
 			splice_initial = splice_dag->InitialRecordedNodes();
 			debug_printf( DEBUG_DEBUG_1, "Adding %d initial nodes\n", 
 				splice_initial->length());
 
 			// now add each initial node as a child
-			for (i = 0; i < splice_initial->length(); i++) {
-				job = (*splice_initial)[i];
+			for (int i = 0; i < splice_initial->length(); i++) {
+				Job *job = (*splice_initial)[i];
 
 				children.Append(job);
 			}
@@ -1009,7 +1036,7 @@ parse_parent(
 
 			// orig code
 			// if the name is not a splice, then see if it is a true node name.
-			job = dag->FindNodeByName( jobName2 );
+			Job *job = dag->FindNodeByName( jobName2 );
 			if (job == NULL) {
 				// oops, it was neither a splice nor a child name, bail
 				debug_printf( DEBUG_QUIET, 
@@ -1804,11 +1831,6 @@ parse_splice(
 
 	/* make a new dag to put everything into */
 
-	/* parse increments this number, however, we want the splice nodes to
-		be munged into the numeric identification of the invoking dag, so
-		decrement it here so when it is incremented, nothing happened. */
-	--_thisDagNum;
-
 	// This "copy" is tailored to be correct according to Dag::~Dag()
 	// We can pass in NULL for submitDagOpts because the splice DAG
 	// object will never actually do a submit.  wenger 2010-03-25
@@ -1849,7 +1871,7 @@ parse_splice(
 	}
 
 	// parse the splice file into a separate dag.
-	if (!parse(splice_dag, spliceFile.Value(), _useDagDir)) {
+	if (!parse(splice_dag, spliceFile.Value(), _useDagDir, false)) {
 		debug_error(1, DEBUG_QUIET, "ERROR: Failed to parse splice %s in file %s\n",
 			spliceName.Value(), spliceFile.Value());
 		return false;
@@ -2269,6 +2291,199 @@ parse_done(
 	return true;
 }
 
+//-----------------------------------------------------------------------------
+// 
+// Function: parse_connect
+// Purpose:  Parse a line of the format "Connect splice1 splice2"
+// 
+//-----------------------------------------------------------------------------
+static bool 
+parse_connect(
+	Dag  *dag, 
+	const char *filename, 
+	int  lineNumber )
+{
+	const char *example = "CONNECT splice1 splice2";
+
+	const char *splice1 = strtok( NULL, DELIMITERS );
+	if ( splice1 == NULL ) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): Missing splice1 name\n",
+					  filename, lineNumber );
+		exampleSyntax( example );
+		return false;
+	}
+	MyString splice1Name = munge_job_name( splice1 );
+	splice1 = splice1Name.Value();
+
+	const char *splice2 = strtok( NULL, DELIMITERS );
+	if ( splice2 == NULL ) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): Missing splice2 name\n",
+					  filename, lineNumber );
+		exampleSyntax( example );
+		return false;
+	}
+	MyString splice2Name = munge_job_name( splice2 );
+	splice2 = splice2Name.Value();
+
+	//
+	// Check for illegal extra tokens.
+	//
+	char *extraTok = strtok( NULL, DELIMITERS );
+	if ( extraTok != NULL ) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): Extra token (%s) on CONNECT line\n",
+					  filename, lineNumber, extraTok );
+		exampleSyntax( example );
+		return false;
+	}
+
+	Dag *parentSplice;
+	if ( dag->LookupSplice( splice1, parentSplice ) != 0) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): Splice %s not found!\n",
+					  filename, lineNumber, splice1 );
+		return false;
+	}
+
+	Dag *childSplice;
+	if ( dag->LookupSplice( splice2, childSplice ) != 0) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): Splice %s not found!\n",
+					  filename, lineNumber, splice2 );
+		return false;
+	}
+
+	if ( !Dag::ConnectSplices( parentSplice, childSplice ) ) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): (see previous line)\n",
+					  filename, lineNumber );
+		return false;
+	}
+
+	return true;
+}
+
+//-----------------------------------------------------------------------------
+// 
+// Function: parse_pin_in_out
+// Purpose:  Parse a line of the format "Pin_in|pin_out node pin_num"
+// 
+//-----------------------------------------------------------------------------
+static bool 
+parse_pin_in_out(
+	Dag  *dag, 
+	const char *filename, 
+	int  lineNumber, bool isPinIn )
+{
+	const char *example = "PIN_IN|PIN_OUT node pin_number";
+
+	const char *node = strtok( NULL, DELIMITERS );
+	if ( node == NULL ) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): Missing node name\n",
+					  filename, lineNumber );
+		exampleSyntax( example );
+		return false;
+	}
+	MyString nodeName = munge_job_name( node );
+	node = nodeName.Value();
+
+	const char *pinNumber = strtok( NULL, DELIMITERS );
+	if ( pinNumber == NULL ) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): Missing pin_number\n",
+					  filename, lineNumber );
+		exampleSyntax( example );
+		return false;
+	}
+
+	int pinNum;
+	char *tmp;
+	pinNum = (int)strtol( pinNumber, &tmp, 10 );
+	if ( tmp == pinNumber ) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): Invalid pin_number value \"%s\"\n",
+					  filename, lineNumber, pinNumber );
+		exampleSyntax( example );
+		return false;
+	}
+
+	if ( pinNum < 1 ) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): pin_number value must be positive\n",
+					  filename, lineNumber );
+		return false;
+	}
+
+	//
+	// Check for illegal extra tokens.
+	//
+	char *extraTok = strtok( NULL, DELIMITERS );
+	if ( extraTok != NULL ) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): Extra token (%s) on PIN_IN/PIN_OUT line\n",
+					  filename, lineNumber, extraTok );
+		exampleSyntax( example );
+		return false;
+	}
+	
+	if ( !dag->SetPinInOut( isPinIn, node, pinNum ) ) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): (see previous line)\n",
+					  filename, lineNumber );
+		return false;
+	}
+
+	return true;
+}
+
+//-----------------------------------------------------------------------------
+// 
+// Function: parse_include
+// Purpose:  Parse a line of the format "Include filename"
+// 
+//-----------------------------------------------------------------------------
+static bool 
+parse_include(
+	Dag  *dag, 
+	const char *filename, 
+	int  lineNumber )
+{
+	const char *example = "INCLUDE filename";
+
+	const char *includeFile = strtok( NULL, DELIMITERS );
+	if ( includeFile == NULL ) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): Missing include file name\n",
+					  filename, lineNumber );
+		exampleSyntax( example );
+		return false;
+	}
+
+	//
+	// Check for illegal extra tokens.
+	//
+	char *extraTok = strtok( NULL, DELIMITERS );
+	if ( extraTok != NULL ) {
+		debug_printf( DEBUG_QUIET,
+					  "ERROR: %s (line %d): Extra token (%s) on INCLUDE line\n",
+					  filename, lineNumber, extraTok );
+		exampleSyntax( example );
+		return false;
+	}
+
+		// Note:  we save the filename here because otherwise it gets
+		// goofed up by the tokenizing in parse().
+	MyString tmpFilename( includeFile );
+		// Note:  false here for useDagDir argument means that the
+		// include file path is always relative to the submit directory,
+		// *not* relative to the DAG file's directory, even if
+		// 'condor_submit -usedagdir' is specified.
+	return parse( dag, tmpFilename.Value(), false, false );
+}
+
 static MyString munge_job_name(const char *jobName)
 {
 		//
diff --git a/src/condor_dagman/parse.h b/src/condor_dagman/parse.h
index fc78bc2..d286ce9 100644
--- a/src/condor_dagman/parse.h
+++ b/src/condor_dagman/parse.h
@@ -35,8 +35,12 @@ void parseSetDoNameMunge(bool doit);
  * @param The Dag object we'll be adding nodes to.
  * @param The name of the DAG file.
  * @param Run DAGs in directories from DAG file paths if true
+ * @param Whether to increment the DAG number (should be true for
+ *     "normal" DAG files (on the command line), false for splices
+ *     and includes)
  */
-bool parse (Dag *dag, const char * filename, bool useDagDir);
+bool parse (Dag *dag, const char * filename, bool useDagDir,
+			bool incrementDagNum = true );
 
 /**
  * Determine whether the given token is a DAGMan reserved word.
diff --git a/src/condor_tests/CMakeLists.txt b/src/condor_tests/CMakeLists.txt
index c04c406..d6246b3 100644
--- a/src/condor_tests/CMakeLists.txt
+++ b/src/condor_tests/CMakeLists.txt
@@ -660,6 +660,13 @@ if (BUILD_TESTING)
 	condor_pl_test(job_dagman_batch_name "Test setting & propagation of batch-name" "dagman;quick;full;quicknolink")
 	condor_pl_test(job_dagman_cmd_order "Test flexible command order" "dagman;quick;full;quicknolink")
 	condor_pl_test(job_dagman_acct_grp "Test setting & propagation of accounting group and user" "dagman;quick;full;quicknolink")
+	condor_pl_test(job_dagman_splice_connect-A "Test splice pin connections" "dagman;quick;full;quicknolink")
+	condor_pl_test(job_dagman_splice_connect-B "Test splice pin connections" "dagman;quick;full;quicknolink")
+	condor_pl_test(job_dagman_splice_connect-C "Test splice pin connections" "dagman;quick;full;quicknolink")
+	condor_pl_test(job_dagman_splice_connect-D "Test splice pin connections" "dagman;quick;full;quicknolink")
+	condor_pl_test(job_dagman_splice_connect-E "Test splice pin connections" "dagman;quick;full;quicknolink")
+	condor_pl_test(job_dagman_splice_connect-F "Test splice pin connections" "dagman;quick;full;quicknolink")
+	condor_pl_test(job_dagman_splice_connect-G "Test splice pin connections" "dagman;quick;full;quicknolink")
 	#condor_pl_test(perf_jobs_sue_10_10_30_van "Generated jobs performance test" "performance;long")
 	#condor_pl_test(perf_xfer_deb_10_10_30_van "Generated transfer performance test" "performance;long")
 	condor_pl_test(job_filexfer_sandbox-empty_van "Are job sandboxes with bad permissions cleaned up?" "framework;quick;full;quicknolink")
diff --git a/src/condor_tests/Test_Requirements b/src/condor_tests/Test_Requirements
index 4cd14ec..21de0a8 100644
--- a/src/condor_tests/Test_Requirements
+++ b/src/condor_tests/Test_Requirements
@@ -209,6 +209,13 @@ job_dagman_event_timestamp: personal
 job_dagman_batch_name: personal
 job_dagman_cmd_order: personal
 job_dagman_acct_grp: personal
+job_dagman_splice_connect-A: personal
+job_dagman_splice_connect-B: personal
+job_dagman_splice_connect-C: personal
+job_dagman_splice_connect-D: personal
+job_dagman_splice_connect-E: personal
+job_dagman_splice_connect-F: personal
+job_dagman_splice_connect-G: personal
 job_filexfer_base-input1_van: personal
 job_filexfer_base_van: personal
 job_filexfer_basic_van: personal
diff --git a/src/condor_tests/Windows_SkipList b/src/condor_tests/Windows_SkipList
index e0ab4ff..e4bf503 100644
--- a/src/condor_tests/Windows_SkipList
+++ b/src/condor_tests/Windows_SkipList
@@ -136,6 +136,9 @@ job_dagman_vars
 job_dagman_script_defer
 job_dagman_set_attr
 job_negotiator_restart
+job_dagman_splice_connect-D
+job_dagman_splice_connect-E
+job_dagman_splice_connect-F
 
 lib_eventlog_rotation-no_rotations_1
 lib_eventlog_rotation-no_rotations_2
diff --git a/src/condor_tests/job_dagman_event_timestamp.run b/src/condor_tests/job_dagman_event_timestamp.run
index c22014f..84356b8 100755
--- a/src/condor_tests/job_dagman_event_timestamp.run
+++ b/src/condor_tests/job_dagman_event_timestamp.run
@@ -50,7 +50,7 @@ if (-e $outfile) {
 
 $abnormal = sub 
 {
-	die "Want to see only submit, execute and unsuccessful completion\n";
+	die "Want to see only submit, execute and successful completion\n";
 };
 
 $failure = sub 
@@ -77,7 +77,7 @@ $executed = sub
 
 $submitted = sub
 {
-	CondorTest::debug("submitted: This test will see submit, executing and unsuccessful completion\n",1);
+	CondorTest::debug("submitted: This test will see submit, executing and successful completion\n",1);
 };
 
 $success = sub
diff --git a/src/condor_tests/job_dagman_splice_connect-A-inc1.dag b/src/condor_tests/job_dagman_splice_connect-A-inc1.dag
new file mode 100644
index 0000000..0c7f229
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-A-inc1.dag
@@ -0,0 +1,2 @@
+connect SpliceA SpliceB
+connect SpliceB SpliceC
diff --git a/src/condor_tests/job_dagman_splice_connect-A-inc2.dag b/src/condor_tests/job_dagman_splice_connect-A-inc2.dag
new file mode 100644
index 0000000..52a3ba7
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-A-inc2.dag
@@ -0,0 +1,7 @@
+pin_in NodeA 1
+pin_in NodeB 2
+pin_in NodeC 3
+
+pin_out NodeA 3
+pin_out NodeB 2
+pin_out NodeC 1
diff --git a/src/condor_tests/job_dagman_splice_connect-A-node.pl b/src/condor_tests/job_dagman_splice_connect-A-node.pl
new file mode 100755
index 0000000..b01f0ae
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-A-node.pl
@@ -0,0 +1,11 @@
+#! /usr/bin/env perl
+
+$sleep = shift @ARGV;
+sleep($sleep);
+
+$file = shift @ARGV;
+open(OUT, ">>$file") or die "Can't open $file: $!";
+while ($arg = shift @ARGV) {
+	print OUT "$arg\n";
+}
+close(OUT);
diff --git a/src/condor_tests/job_dagman_splice_connect-A-node.sub b/src/condor_tests/job_dagman_splice_connect-A-node.sub
new file mode 100644
index 0000000..49427f9
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-A-node.sub
@@ -0,0 +1,6 @@
+universe = vanilla
+executable = job_dagman_splice_connect-A-node.pl
+arguments = $(sleep) $(file) $(name)
+output = job_dagman_splice_connect-A.$(name).out
+error = job_dagman_splice_connect-A.$(name).err
+queue
diff --git a/src/condor_tests/job_dagman_splice_connect-A-splice1.dag b/src/condor_tests/job_dagman_splice_connect-A-splice1.dag
new file mode 100644
index 0000000..605531a
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-A-splice1.dag
@@ -0,0 +1,21 @@
+job NodeA job_dagman_splice_connect-A-node.sub
+vars NodeA sleep = "30"
+vars NodeA file = "job_dagman_splice_connect-A-skewer1.out"
+vars NodeA name = "$(JOB)"
+
+job NodeB job_dagman_splice_connect-A-node.sub
+vars NodeB sleep = "0"
+vars NodeB file = "job_dagman_splice_connect-A-skewer2.out"
+vars NodeB name = "$(JOB)"
+
+job NodeC job_dagman_splice_connect-A-node.sub
+vars NodeC sleep = "0"
+vars NodeC file = "job_dagman_splice_connect-A-skewer3.out"
+vars NodeC name = "$(JOB)"
+
+pin_out NodeA 1
+pin_out NodeB 2
+pin_out NodeC 3
+
+# pin_in not used by connect shouldn't hurt.
+pin_in NodeA 3
diff --git a/src/condor_tests/job_dagman_splice_connect-A-splice2.dag b/src/condor_tests/job_dagman_splice_connect-A-splice2.dag
new file mode 100644
index 0000000..9b6d663
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-A-splice2.dag
@@ -0,0 +1,16 @@
+job NodeA job_dagman_splice_connect-A-node.sub
+vars NodeA sleep = "0"
+vars NodeA file = "job_dagman_splice_connect-A-skewer1.out"
+vars NodeA name = "$(JOB)"
+
+job NodeB job_dagman_splice_connect-A-node.sub
+vars NodeB sleep = "0"
+vars NodeB file = "job_dagman_splice_connect-A-skewer2.out"
+vars NodeB name = "$(JOB)"
+
+job NodeC job_dagman_splice_connect-A-node.sub
+vars NodeC sleep = "30"
+vars NodeC file = "job_dagman_splice_connect-A-skewer3.out"
+vars NodeC name = "$(JOB)"
+
+include job_dagman_splice_connect-A-inc2.dag
diff --git a/src/condor_tests/job_dagman_splice_connect-A-splice3.dag b/src/condor_tests/job_dagman_splice_connect-A-splice3.dag
new file mode 100644
index 0000000..64baa04
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-A-splice3.dag
@@ -0,0 +1,21 @@
+job NodeA job_dagman_splice_connect-A-node.sub
+vars NodeA sleep = "0"
+vars NodeA file = "job_dagman_splice_connect-A-skewer3.out"
+vars NodeA name = "$(JOB)"
+
+job NodeB job_dagman_splice_connect-A-node.sub
+vars NodeB sleep = "0"
+vars NodeB file = "job_dagman_splice_connect-A-skewer2.out"
+vars NodeB name = "$(JOB)"
+
+job NodeC job_dagman_splice_connect-A-node.sub
+vars NodeC sleep = "0"
+vars NodeC file = "job_dagman_splice_connect-A-skewer1.out"
+vars NodeC name = "$(JOB)"
+
+pin_in NodeA 1
+pin_in NodeB 2
+pin_in NodeC 3
+
+# pin_out not used by connect shouldn't hurt.
+pin_out NodeA 2
diff --git a/src/condor_tests/job_dagman_splice_connect-A.dag b/src/condor_tests/job_dagman_splice_connect-A.dag
new file mode 100644
index 0000000..ad0da39
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-A.dag
@@ -0,0 +1,10 @@
+# This workflow should succeed -- tests most splice connection
+# features.
+
+# Splice connections force nodes within a given "skewer" to run
+# in the correct order.
+splice SpliceA job_dagman_splice_connect-A-splice1.dag
+splice SpliceB job_dagman_splice_connect-A-splice2.dag
+splice SpliceC job_dagman_splice_connect-A-splice3.dag
+
+include job_dagman_splice_connect-A-inc1.dag
diff --git a/src/condor_tests/job_dagman_splice_connect-A.run b/src/condor_tests/job_dagman_splice_connect-A.run
new file mode 100755
index 0000000..33b3d53
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-A.run
@@ -0,0 +1,124 @@
+#! /usr/bin/env perl
+##**************************************************************
+##
+## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+## University of Wisconsin-Madison, WI.
+## 
+## Licensed under the Apache License, Version 2.0 (the "License"); you
+## may not use this file except in compliance with the License.  You may
+## obtain a copy of the License at
+## 
+##    http://www.apache.org/licenses/LICENSE-2.0
+## 
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an "AS IS" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+##
+##**************************************************************
+
+use CondorTest;
+use CondorUtils;
+
+$cmd = 'job_dagman_splice_connect-A.dag';
+$testdesc =  'Condor submit dag - test splice pin connections - scheduler U';
+$testname = "job_dagman_splice_connect-A";
+$dagman_args = "-verbose";
+
+@outfiles = ("job_dagman_splice_connect-A.dag.dagman.out",
+	"job_dagman_splice_connect-A-skewer1.out",
+	"job_dagman_splice_connect-A-skewer2.out",
+	"job_dagman_splice_connect-A-skewer3.out");
+
+# Lines must be *in order* within a given output file.
+@expected_output = ("SpliceA+NodeA\nSpliceB+NodeA\nSpliceC+NodeC\n",
+	"SpliceA+NodeB\nSpliceB+NodeB\nSpliceC+NodeB\n",
+	"SpliceA+NodeC\nSpliceB+NodeC\nSpliceC+NodeA\n");
+
+my $killedchosen = 0;
+
+# truly const variables in perl
+sub IDLE{1};
+sub HELD{5};
+sub RUNNING{2};
+
+# Get rid of any existing output files.
+foreach $file (@outfiles) {
+	runcmd("rm -f $file") if (-e $file);
+}
+
+$abnormal = sub 
+{
+	die "Want to see only submit, execute and successful completion\n";
+};
+
+$failure = sub 
+{
+	die "Error: DAG is not expected to fail!\n";
+};
+
+$aborted = sub 
+{
+	die "Abort event NOT expected\n";
+};
+
+$held = sub 
+{
+	die "Held event NOT expected\n";
+};
+
+$executed = sub
+{
+	my %info = @_;
+
+	CondorTest::debug("Good. We need the dag to run<$info{cluster}>\n",1);
+};
+
+$submitted = sub
+{
+	CondorTest::debug("submitted: This test will see submit, executing and successful completion\n",1);
+};
+
+$success = sub
+{
+	CondorTest::debug("executed successfully\n",1);
+	CondorTest::debug("Verifying output\n",1);
+	$diditpass = 1;
+	shift @outfiles; # Get rid of dagman.out
+	foreach $file (@outfiles) {
+		CondorTest::debug("Checking $file\n",1);
+		$canopen = open(OUT, "<$file");
+		if (! (defined $canopen)) {
+			CondorTest::debug("Cannot open output file <$file>:$!\n",1);
+			$diditpass = 0;
+		} else {
+			$contents = do { local $/; <OUT>; };
+			$expected = shift @expected_output;
+			if ($contents ne $expected) {
+				CondorTest::debug("ERROR: for file <$file> expected <$expected>; found <$contents>\n");
+				$diditpass = 0;
+			}
+		}
+	}
+
+	if ($diditpass == 0) {
+		die "All expected files and correct output failed\n";
+	}
+};
+
+CondorTest::RegisterExitedSuccess( $testname, $success);
+CondorTest::RegisterExitedFailure( $testname, $failure );
+CondorTest::RegisterExecute($testname, $executed);
+CondorTest::RegisterExitedAbnormal( $testname, $abnormal );
+CondorTest::RegisterAbort( $testname, $aborted );
+CondorTest::RegisterHold( $testname, $held );
+CondorTest::RegisterSubmit( $testname, $submitted );
+
+if( CondorTest::RunDagTest($testname, $cmd, 0, $dagman_args) ) {
+	CondorTest::debug("$testname: SUCCESS\n",1);
+	exit(0);
+} else {
+	die "$testname: CondorTest::RunTest() failed\n";
+}
+
diff --git a/src/condor_tests/job_dagman_splice_connect-B-1.dag b/src/condor_tests/job_dagman_splice_connect-B-1.dag
new file mode 100644
index 0000000..3f3f131
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-B-1.dag
@@ -0,0 +1,12 @@
+job Node1A job_dagman_splice_connect-B-node.sub
+vars Node1A sleep = "0"
+vars Node1A file = "job_dagman_splice_connect-B-skewer1.out"
+vars Node1A name = "$(JOB)"
+
+job Node1B job_dagman_splice_connect-B-node.sub
+vars Node1B sleep = "0"
+vars Node1B file = "job_dagman_splice_connect-B-skewer2.out"
+vars Node1B name = "$(JOB)"
+
+pin_out Node1A 1
+pin_out Node1B 2
diff --git a/src/condor_tests/job_dagman_splice_connect-B-2-1a.dag b/src/condor_tests/job_dagman_splice_connect-B-2-1a.dag
new file mode 100644
index 0000000..615cfcd
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-B-2-1a.dag
@@ -0,0 +1,18 @@
+job Node2-1a-A job_dagman_splice_connect-B-node.sub
+vars Node2-1a-A sleep = "0"
+vars Node2-1a-A file = "job_dagman_splice_connect-B-skewer1.out"
+vars Node2-1a-A name = "$(JOB)"
+
+job Node2-1a-B job_dagman_splice_connect-B-node.sub
+vars Node2-1a-B sleep = "0"
+vars Node2-1a-B file = "job_dagman_splice_connect-B-skewer3.out"
+vars Node2-1a-B name = "$(JOB)"
+
+job Node2-1a-C job_dagman_splice_connect-B-node.sub
+vars Node2-1a-C sleep = "0"
+vars Node2-1a-C file = "job_dagman_splice_connect-B-skewer4.out"
+vars Node2-1a-C name = "$(JOB)"
+
+pin_out Node2-1a-A 1
+pin_out Node2-1a-B 2
+pin_out Node2-1a-C 3
diff --git a/src/condor_tests/job_dagman_splice_connect-B-2-1b.dag b/src/condor_tests/job_dagman_splice_connect-B-2-1b.dag
new file mode 100644
index 0000000..dd2f43e
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-B-2-1b.dag
@@ -0,0 +1,18 @@
+job Node2-1b-A job_dagman_splice_connect-B-node.sub
+vars Node2-1b-A sleep = "0"
+vars Node2-1b-A file = "job_dagman_splice_connect-B-skewer1.out"
+vars Node2-1b-A name = "$(JOB)"
+
+job Node2-1b-B job_dagman_splice_connect-B-node.sub
+vars Node2-1b-B sleep = "0"
+vars Node2-1b-B file = "job_dagman_splice_connect-B-skewer3.out"
+vars Node2-1b-B name = "$(JOB)"
+
+job Node2-1b-C job_dagman_splice_connect-B-node.sub
+vars Node2-1b-C sleep = "0"
+vars Node2-1b-C file = "job_dagman_splice_connect-B-skewer4.out"
+vars Node2-1b-C name = "$(JOB)"
+
+pin_in Node2-1b-A 1
+pin_in Node2-1b-B 2
+pin_in Node2-1b-C 3
diff --git a/src/condor_tests/job_dagman_splice_connect-B-2-2a.dag b/src/condor_tests/job_dagman_splice_connect-B-2-2a.dag
new file mode 100644
index 0000000..70cce6b
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-B-2-2a.dag
@@ -0,0 +1,18 @@
+job Node2-2a-A job_dagman_splice_connect-B-node.sub
+vars Node2-2a-A sleep = "0"
+vars Node2-2a-A file = "job_dagman_splice_connect-B-skewer2.out"
+vars Node2-2a-A name = "$(JOB)"
+
+job Node2-2a-B job_dagman_splice_connect-B-node.sub
+vars Node2-2a-B sleep = "0"
+vars Node2-2a-B file = "job_dagman_splice_connect-B-skewer5.out"
+vars Node2-2a-B name = "$(JOB)"
+
+job Node2-2a-C job_dagman_splice_connect-B-node.sub
+vars Node2-2a-C sleep = "0"
+vars Node2-2a-C file = "job_dagman_splice_connect-B-skewer6.out"
+vars Node2-2a-C name = "$(JOB)"
+
+pin_out Node2-2a-A 1
+pin_out Node2-2a-B 2
+pin_out Node2-2a-C 3
diff --git a/src/condor_tests/job_dagman_splice_connect-B-2-2b.dag b/src/condor_tests/job_dagman_splice_connect-B-2-2b.dag
new file mode 100644
index 0000000..0b43392
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-B-2-2b.dag
@@ -0,0 +1,18 @@
+job Node2-2b-A job_dagman_splice_connect-B-node.sub
+vars Node2-2b-A sleep = "0"
+vars Node2-2b-A file = "job_dagman_splice_connect-B-skewer2.out"
+vars Node2-2b-A name = "$(JOB)"
+
+job Node2-2b-B job_dagman_splice_connect-B-node.sub
+vars Node2-2b-B sleep = "0"
+vars Node2-2b-B file = "job_dagman_splice_connect-B-skewer5.out"
+vars Node2-2b-B name = "$(JOB)"
+
+job Node2-2b-C job_dagman_splice_connect-B-node.sub
+vars Node2-2b-C sleep = "0"
+vars Node2-2b-C file = "job_dagman_splice_connect-B-skewer6.out"
+vars Node2-2b-C name = "$(JOB)"
+
+pin_in Node2-2b-A 1
+pin_in Node2-2b-B 2
+pin_in Node2-2b-C 3
diff --git a/src/condor_tests/job_dagman_splice_connect-B-2.dag b/src/condor_tests/job_dagman_splice_connect-B-2.dag
new file mode 100644
index 0000000..5697e14
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-B-2.dag
@@ -0,0 +1,34 @@
+splice Splice2Aa job_dagman_splice_connect-B-2-1a.dag
+splice Splice2Ab job_dagman_splice_connect-B-2-1b.dag
+splice Splice2Ba job_dagman_splice_connect-B-2-2a.dag
+splice Splice2Bb job_dagman_splice_connect-B-2-2b.dag
+
+connect Splice2Aa Splice2Ab
+connect Splice2Ba Splice2Bb
+
+# These are commented out because pins can't connect to splices
+# right now.
+# pin_in Splice2Aa 1
+# pin_in Splice2Ba 2
+
+# pin_out Splice2Ab 1
+# pin_out Splice2Bb 2
+
+# "Manual" socket nodes to allow this to work -- remove them once
+# pins can connect to splices.  (Probably once we implement socket
+# nodes!)
+job SocketPreA foo NOOP
+job SocketPreB foo NOOP
+job SocketPostA foo NOOP
+job SocketPostB foo NOOP
+
+parent SocketPreA child Splice2Aa
+parent SocketPreB child Splice2Ba
+parent Splice2Ab child SocketPostA
+parent Splice2Bb child SocketPostB
+
+pin_in SocketPreA 1
+pin_in SocketPreB 2
+
+pin_out SocketPostA 1
+pin_out SocketPostB 2
diff --git a/src/condor_tests/job_dagman_splice_connect-B-3.dag b/src/condor_tests/job_dagman_splice_connect-B-3.dag
new file mode 100644
index 0000000..b22131e
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-B-3.dag
@@ -0,0 +1,12 @@
+job Node3A job_dagman_splice_connect-B-node.sub
+vars Node3A sleep = "0"
+vars Node3A file = "job_dagman_splice_connect-B-skewer1.out"
+vars Node3A name = "$(JOB)"
+
+job Node3B job_dagman_splice_connect-B-node.sub
+vars Node3B sleep = "0"
+vars Node3B file = "job_dagman_splice_connect-B-skewer2.out"
+vars Node3B name = "$(JOB)"
+
+pin_in Node3A 1
+pin_in Node3B 2
diff --git a/src/condor_tests/job_dagman_splice_connect-B-node.pl b/src/condor_tests/job_dagman_splice_connect-B-node.pl
new file mode 100755
index 0000000..b01f0ae
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-B-node.pl
@@ -0,0 +1,11 @@
+#! /usr/bin/env perl
+
+$sleep = shift @ARGV;
+sleep($sleep);
+
+$file = shift @ARGV;
+open(OUT, ">>$file") or die "Can't open $file: $!";
+while ($arg = shift @ARGV) {
+	print OUT "$arg\n";
+}
+close(OUT);
diff --git a/src/condor_tests/job_dagman_splice_connect-B-node.sub b/src/condor_tests/job_dagman_splice_connect-B-node.sub
new file mode 100644
index 0000000..eb06a54
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-B-node.sub
@@ -0,0 +1,6 @@
+universe = vanilla
+executable = job_dagman_splice_connect-B-node.pl
+arguments = $(sleep) $(file) $(name)
+output = job_dagman_splice_connect-B.$(name).out
+error = job_dagman_splice_connect-B.$(name).err
+queue
diff --git a/src/condor_tests/job_dagman_splice_connect-B.dag b/src/condor_tests/job_dagman_splice_connect-B.dag
new file mode 100644
index 0000000..b67d954
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-B.dag
@@ -0,0 +1,10 @@
+# This is testing multiple levels of splice connections -- requires
+# "manual" socket nodes in lower levels (see
+# job_dagman_splice_connect-B-2.dag).
+
+splice SpliceA job_dagman_splice_connect-B-1.dag
+splice SpliceB job_dagman_splice_connect-B-2.dag
+splice SpliceC job_dagman_splice_connect-B-3.dag
+
+connect SpliceA SpliceB
+connect SpliceB SpliceC
diff --git a/src/condor_tests/job_dagman_splice_connect-B.run b/src/condor_tests/job_dagman_splice_connect-B.run
new file mode 100755
index 0000000..3640e70
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-B.run
@@ -0,0 +1,129 @@
+#! /usr/bin/env perl
+##**************************************************************
+##
+## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+## University of Wisconsin-Madison, WI.
+## 
+## Licensed under the Apache License, Version 2.0 (the "License"); you
+## may not use this file except in compliance with the License.  You may
+## obtain a copy of the License at
+## 
+##    http://www.apache.org/licenses/LICENSE-2.0
+## 
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an "AS IS" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+##
+##**************************************************************
+
+use CondorTest;
+use CondorUtils;
+
+$cmd = 'job_dagman_splice_connect-B.dag';
+$testdesc =  'Condor submit dag - test splice pin connections - scheduler U';
+$testname = "job_dagman_splice_connect-B";
+$dagman_args = "-verbose";
+
+@outfiles = ("job_dagman_splice_connect-B.dag.dagman.out",
+	"job_dagman_splice_connect-B-skewer1.out",
+	"job_dagman_splice_connect-B-skewer2.out",
+	"job_dagman_splice_connect-B-skewer3.out",
+	"job_dagman_splice_connect-B-skewer4.out",
+	"job_dagman_splice_connect-B-skewer5.out",
+	"job_dagman_splice_connect-B-skewer6.out");
+
+@expected_output = ("SpliceA+Node1A\nSpliceB+Splice2Aa+Node2-1a-A\nSpliceB+Splice2Ab+Node2-1b-A\nSpliceC+Node3A\n",
+	"SpliceA+Node1B\nSpliceB+Splice2Ba+Node2-2a-A\nSpliceB+Splice2Bb+Node2-2b-A\nSpliceC+Node3B\n",
+	"SpliceB+Splice2Aa+Node2-1a-B\nSpliceB+Splice2Ab+Node2-1b-B\n",
+	"SpliceB+Splice2Aa+Node2-1a-C\nSpliceB+Splice2Ab+Node2-1b-C\n",
+	"SpliceB+Splice2Ba+Node2-2a-B\nSpliceB+Splice2Bb+Node2-2b-B\n",
+	"SpliceB+Splice2Ba+Node2-2a-C\nSpliceB+Splice2Bb+Node2-2b-C\n");
+
+my $killedchosen = 0;
+
+# truly const variables in perl
+sub IDLE{1};
+sub HELD{5};
+sub RUNNING{2};
+
+# Get rid of any existing output files.
+foreach $file (@outfiles) {
+	runcmd("rm -f $file") if (-e $file);
+}
+
+$abnormal = sub 
+{
+	die "Want to see only submit, execute and successful completion\n";
+};
+
+$failure = sub 
+{
+	die "Error: DAG is not expected to fail!\n";
+};
+
+$aborted = sub 
+{
+	die "Abort event NOT expected\n";
+};
+
+$held = sub 
+{
+	die "Held event NOT expected\n";
+};
+
+$executed = sub
+{
+	my %info = @_;
+
+	CondorTest::debug("Good. We need the dag to run<$info{cluster}>\n",1);
+};
+
+$submitted = sub
+{
+	CondorTest::debug("submitted: This test will see submit, executing and successful completion\n",1);
+};
+
+$success = sub
+{
+	CondorTest::debug("executed successfully\n",1);
+	CondorTest::debug("Verifying output\n",1);
+	$diditpass = 1;
+	shift @outfiles; # Get rid of dagman.out
+	foreach $file (@outfiles) {
+		CondorTest::debug("Checking $file\n",1);
+		$canopen = open(OUT, "<$file");
+		if (! (defined $canopen)) {
+			CondorTest::debug("Cannot open output file <$file>:$!\n",1);
+			$diditpass = 0;
+		} else {
+			$contents = do { local $/; <OUT>; };
+			$expected = shift @expected_output;
+			if ($contents ne $expected) {
+				CondorTest::debug("ERROR: for file <$file> expected <$expected>; found <$contents>\n");
+				$diditpass = 0;
+			}
+		}
+	}
+
+	if ($diditpass == 0) {
+		die "All expected files and correct output failed\n";
+	}
+};
+
+CondorTest::RegisterExitedSuccess( $testname, $success);
+CondorTest::RegisterExitedFailure( $testname, $failure );
+CondorTest::RegisterExecute($testname, $executed);
+CondorTest::RegisterExitedAbnormal( $testname, $abnormal );
+CondorTest::RegisterAbort( $testname, $aborted );
+CondorTest::RegisterHold( $testname, $held );
+CondorTest::RegisterSubmit( $testname, $submitted );
+
+if( CondorTest::RunDagTest($testname, $cmd, 0, $dagman_args) ) {
+	CondorTest::debug("$testname: SUCCESS\n",1);
+	exit(0);
+} else {
+	die "$testname: CondorTest::RunTest() failed\n";
+}
+
diff --git a/src/condor_tests/job_dagman_splice_connect-C-node.sub b/src/condor_tests/job_dagman_splice_connect-C-node.sub
new file mode 100644
index 0000000..902f33b
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-C-node.sub
@@ -0,0 +1,6 @@
+universe = vanilla
+executable = ./x_echostring.pl
+arguments = $$([DAGParentNodeNames])
+output = job_dagman_splice_connect-C.$(name).out
+error = job_dagman_splice_connect-C.$(name).err
+queue
diff --git a/src/condor_tests/job_dagman_splice_connect-C-splice1.dag b/src/condor_tests/job_dagman_splice_connect-C-splice1.dag
new file mode 100644
index 0000000..ebd8d43
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-C-splice1.dag
@@ -0,0 +1,30 @@
+job Node0 job_dagman_splice_connect-C-node.sub
+job Node1 job_dagman_splice_connect-C-node.sub
+job Node2 job_dagman_splice_connect-C-node.sub
+job Node3 job_dagman_splice_connect-C-node.sub
+job Node4 job_dagman_splice_connect-C-node.sub
+job Node5 job_dagman_splice_connect-C-node.sub
+job Node6 job_dagman_splice_connect-C-node.sub
+
+vars Node0 name = "$(JOB)"
+vars Node1 name = "$(JOB)"
+vars Node2 name = "$(JOB)"
+vars Node3 name = "$(JOB)"
+vars Node4 name = "$(JOB)"
+vars Node5 name = "$(JOB)"
+vars Node6 name = "$(JOB)"
+
+parent Node0 child Node1
+parent Node0 child Node2
+parent Node0 child Node3
+parent Node0 child Node4
+parent Node0 child Node5
+parent Node0 child Node6
+
+pin_out Node1 1
+pin_out Node2 1
+pin_out Node3 1
+pin_out Node3 2
+pin_out Node4 2
+pin_out Node5 2
+pin_out Node6 2
diff --git a/src/condor_tests/job_dagman_splice_connect-C-splice2.dag b/src/condor_tests/job_dagman_splice_connect-C-splice2.dag
new file mode 100644
index 0000000..ca40cd8
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-C-splice2.dag
@@ -0,0 +1,15 @@
+job Node1 job_dagman_splice_connect-C-node.sub
+job Node2 job_dagman_splice_connect-C-node.sub
+job Node3 job_dagman_splice_connect-C-node.sub
+job Node4 job_dagman_splice_connect-C-node.sub
+
+vars Node1 name = "$(JOB)"
+vars Node2 name = "$(JOB)"
+vars Node3 name = "$(JOB)"
+vars Node4 name = "$(JOB)"
+
+pin_in Node1 1
+pin_in Node2 1
+pin_in Node2 2
+pin_in Node3 2
+pin_in Node4 2
diff --git a/src/condor_tests/job_dagman_splice_connect-C.dag b/src/condor_tests/job_dagman_splice_connect-C.dag
new file mode 100644
index 0000000..ac3733f
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-C.dag
@@ -0,0 +1,9 @@
+# This tests one pin to many nodes and one node to many pins connections.
+
+splice Splice1 job_dagman_splice_connect-C-splice1.dag
+splice Splice2 job_dagman_splice_connect-C-splice2.dag
+job node3 job_dagman_splice_connect-C-node.sub
+vars node3 name = "$(JOB)"
+
+connect Splice1 Splice2
+parent Splice2 child node3
diff --git a/src/condor_tests/job_dagman_splice_connect-C.run b/src/condor_tests/job_dagman_splice_connect-C.run
new file mode 100755
index 0000000..7167d91
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-C.run
@@ -0,0 +1,143 @@
+#! /usr/bin/env perl
+##**************************************************************
+##
+## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+## University of Wisconsin-Madison, WI.
+## 
+## Licensed under the Apache License, Version 2.0 (the "License"); you
+## may not use this file except in compliance with the License.  You may
+## obtain a copy of the License at
+## 
+##    http://www.apache.org/licenses/LICENSE-2.0
+## 
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an "AS IS" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+##
+##**************************************************************
+
+use CondorTest;
+use CondorUtils;
+
+$cmd = 'job_dagman_splice_connect-C.dag';
+$testdesc =  'Condor submit dag - test splice pin connections - scheduler U';
+$testname = "job_dagman_splice_connect-C";
+$dagman_args = "-verbose";
+
+@outfiles = ("job_dagman_splice_connect-C.dag.dagman.out",
+	"job_dagman_splice_connect-C.node3.out",
+	"job_dagman_splice_connect-C.Splice1+Node0.out",
+	"job_dagman_splice_connect-C.Splice1+Node1.out",
+	"job_dagman_splice_connect-C.Splice1+Node2.out",
+	"job_dagman_splice_connect-C.Splice1+Node3.out",
+	"job_dagman_splice_connect-C.Splice1+Node4.out",
+	"job_dagman_splice_connect-C.Splice1+Node5.out",
+	"job_dagman_splice_connect-C.Splice1+Node6.out",
+	"job_dagman_splice_connect-C.Splice2+Node1.out",
+	"job_dagman_splice_connect-C.Splice2+Node2.out",
+	"job_dagman_splice_connect-C.Splice2+Node3.out",
+	"job_dagman_splice_connect-C.Splice2+Node4.out");
+
+# Lines must be *in order* within a given output file.
+@expected_output = (
+	"Splice2+Node1,Splice2+Node2,Splice2+Node3,Splice2+Node4 \n",
+	"\n",
+	"Splice1+Node0 \n",
+	"Splice1+Node0 \n",
+	"Splice1+Node0 \n",
+	"Splice1+Node0 \n",
+	"Splice1+Node0 \n",
+	"Splice1+Node0 \n",
+	"Splice1+Node1,Splice1+Node2,Splice1+Node3 \n",
+	"Splice1+Node1,Splice1+Node2,Splice1+Node3,Splice1+Node4,Splice1+Node5,Splice1+Node6 \n",
+	"Splice1+Node3,Splice1+Node4,Splice1+Node5,Splice1+Node6 \n",
+	"Splice1+Node3,Splice1+Node4,Splice1+Node5,Splice1+Node6 \n");
+
+my $killedchosen = 0;
+
+# truly const variables in perl
+sub IDLE{1};
+sub HELD{5};
+sub RUNNING{2};
+
+# Get rid of any existing output files.
+foreach $file (@outfiles) {
+	runcmd("rm -f $file") if (-e $file);
+}
+
+$abnormal = sub 
+{
+	die "Want to see only submit, execute and successful completion\n";
+};
+
+$failure = sub 
+{
+	die "Error: DAG is not expected to fail!\n";
+};
+
+$aborted = sub 
+{
+	die "Abort event NOT expected\n";
+};
+
+$held = sub 
+{
+	die "Held event NOT expected\n";
+};
+
+$executed = sub
+{
+	my %info = @_;
+
+	CondorTest::debug("Good. We need the dag to run<$info{cluster}>\n",1);
+};
+
+$submitted = sub
+{
+	CondorTest::debug("submitted: This test will see submit, executing and successful completion\n",1);
+};
+
+$success = sub
+{
+	CondorTest::debug("executed successfully\n",1);
+	CondorTest::debug("Verifying output\n",1);
+	$diditpass = 1;
+	shift @outfiles; # Get rid of dagman.out
+	foreach $file (@outfiles) {
+		CondorTest::debug("Checking $file\n",1);
+		$canopen = open(OUT, "<$file");
+		if (! (defined $canopen)) {
+			CondorTest::debug("Cannot open output file <$file>:$!\n",1);
+			$diditpass = 0;
+		} else {
+			$contents = do { local $/; <OUT>; };
+			$expected = shift @expected_output;
+			if ($contents ne $expected) {
+				CondorTest::debug("ERROR: for file <$file> expected <$expected>; found <$contents>\n");
+				$diditpass = 0;
+			}
+		}
+	}
+
+	if ($diditpass == 0) {
+		die "All expected files and correct output failed\n";
+	}
+};
+
+CondorTest::RegisterExitedSuccess( $testname, $success);
+CondorTest::RegisterExitedFailure( $testname, $failure );
+CondorTest::RegisterExecute($testname, $executed);
+CondorTest::RegisterExitedAbnormal( $testname, $abnormal );
+CondorTest::RegisterAbort( $testname, $aborted );
+CondorTest::RegisterHold( $testname, $held );
+CondorTest::RegisterSubmit( $testname, $submitted );
+
+if( CondorTest::RunDagTest($testname, $cmd, 0, $dagman_args) ) {
+	CondorTest::debug("$testname: SUCCESS\n",1);
+	exit(0);
+} else {
+	die "$testname: CondorTest::RunTest() failed\n";
+}
+
diff --git a/src/condor_tests/job_dagman_splice_connect-D-1.dag b/src/condor_tests/job_dagman_splice_connect-D-1.dag
new file mode 100644
index 0000000..72d036e
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-D-1.dag
@@ -0,0 +1,5 @@
+job Node1A - noop
+job Node1B - noop
+
+# pin_out Node1A 1
+# pin_out Node1B 2
diff --git a/src/condor_tests/job_dagman_splice_connect-D-2.dag b/src/condor_tests/job_dagman_splice_connect-D-2.dag
new file mode 100644
index 0000000..025a3c2
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-D-2.dag
@@ -0,0 +1,5 @@
+job Node2A - noop
+job Node2B - noop
+
+# pin_in Node2A 1
+# pin_in Node2B 2
diff --git a/src/condor_tests/job_dagman_splice_connect-D.dag b/src/condor_tests/job_dagman_splice_connect-D.dag
new file mode 100644
index 0000000..7a2050d
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-D.dag
@@ -0,0 +1,7 @@
+# Test missing pin in/outs -- this should fail.
+
+splice Splice1 job_dagman_splice_connect-D-1.dag
+splice Splice2 job_dagman_splice_connect-D-2.dag
+
+connect Splice1 Splice2
+
diff --git a/src/condor_tests/job_dagman_splice_connect-D.run b/src/condor_tests/job_dagman_splice_connect-D.run
new file mode 100755
index 0000000..e7af889
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-D.run
@@ -0,0 +1,97 @@
+#! /usr/bin/env perl
+##**************************************************************
+##
+## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+## University of Wisconsin-Madison, WI.
+## 
+## Licensed under the Apache License, Version 2.0 (the "License"); you
+## may not use this file except in compliance with the License.  You may
+## obtain a copy of the License at
+## 
+##    http://www.apache.org/licenses/LICENSE-2.0
+## 
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an "AS IS" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+##
+##**************************************************************
+
+use CondorTest;
+use CondorUtils;
+
+$cmd = 'job_dagman_splice_connect-D.dag';
+$testdesc =  'Condor submit dag - test splice pin connections - scheduler U';
+$testname = "job_dagman_splice_connect-D";
+$dagman_args = "-verbose";
+
+@outfiles = ("job_dagman_splice_connect-D.dag.dagman.out");
+
+# Lines must be *in order* within a given output file.
+@expected_output = ();
+
+my $killedchosen = 0;
+
+# truly const variables in perl
+sub IDLE{1};
+sub HELD{5};
+sub RUNNING{2};
+
+# Get rid of any existing output files.
+foreach $file (@outfiles) {
+	runcmd("rm -f $file") if (-e $file);
+}
+
+$abnormal = sub 
+{
+	die "Want to see only submit, execute and unsuccessful completion\n";
+};
+
+$aborted = sub 
+{
+	die "Abort event NOT expected\n";
+};
+
+$held = sub 
+{
+	die "Held event NOT expected\n";
+};
+
+$executed = sub
+{
+	my %info = @_;
+
+	CondorTest::debug("Good. We need the dag to run<$info{cluster}>\n",1);
+};
+
+$submitted = sub
+{
+	CondorTest::debug("submitted: This test will see submit, executing and unsuccessful completion\n",1);
+};
+
+$success = sub
+{
+	die "Error: DAG should fail!\n";
+};
+
+$failure = sub 
+{
+	CondorTest::debug("DAG failed as expected\n",1);
+};
+
+CondorTest::RegisterExitedSuccess( $testname, $success);
+CondorTest::RegisterExitedFailure( $testname, $failure );
+CondorTest::RegisterExecute($testname, $executed);
+CondorTest::RegisterExitedAbnormal( $testname, $abnormal );
+CondorTest::RegisterAbort( $testname, $aborted );
+CondorTest::RegisterHold( $testname, $held );
+CondorTest::RegisterSubmit( $testname, $submitted );
+
+if( CondorTest::RunDagTest($testname, $cmd, 0, $dagman_args) ) {
+	CondorTest::debug("$testname: SUCCESS\n",1);
+	exit(0);
+} else {
+	die "$testname: CondorTest::RunTest() failed\n";
+}
+
diff --git a/src/condor_tests/job_dagman_splice_connect-E-1.dag b/src/condor_tests/job_dagman_splice_connect-E-1.dag
new file mode 100644
index 0000000..671cec8
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-E-1.dag
@@ -0,0 +1,5 @@
+job Node1A - noop
+job Node1B - noop
+
+pin_out Node1A 1
+pin_out Node1B 2
diff --git a/src/condor_tests/job_dagman_splice_connect-E-2.dag b/src/condor_tests/job_dagman_splice_connect-E-2.dag
new file mode 100644
index 0000000..6c7bf13
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-E-2.dag
@@ -0,0 +1,6 @@
+job Node2A - noop
+job Node2B - noop
+job Node2C - noop
+
+pin_in Node2A 1
+pin_in Node2B 2
diff --git a/src/condor_tests/job_dagman_splice_connect-E.dag b/src/condor_tests/job_dagman_splice_connect-E.dag
new file mode 100644
index 0000000..db88095
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-E.dag
@@ -0,0 +1,7 @@
+# Test "orphan" nodes -- this should fail.
+
+splice Splice1 job_dagman_splice_connect-E-1.dag
+splice Splice2 job_dagman_splice_connect-E-2.dag
+
+connect Splice1 Splice2
+
diff --git a/src/condor_tests/job_dagman_splice_connect-E.run b/src/condor_tests/job_dagman_splice_connect-E.run
new file mode 100755
index 0000000..405eca4
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-E.run
@@ -0,0 +1,97 @@
+#! /usr/bin/env perl
+##**************************************************************
+##
+## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+## University of Wisconsin-Madison, WI.
+## 
+## Licensed under the Apache License, Version 2.0 (the "License"); you
+## may not use this file except in compliance with the License.  You may
+## obtain a copy of the License at
+## 
+##    http://www.apache.org/licenses/LICENSE-2.0
+## 
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an "AS IS" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+##
+##**************************************************************
+
+use CondorTest;
+use CondorUtils;
+
+$cmd = 'job_dagman_splice_connect-E.dag';
+$testdesc =  'Condor submit dag - test splice pin connections - scheduler U';
+$testname = "job_dagman_splice_connect-E";
+$dagman_args = "-verbose";
+
+@outfiles = ("job_dagman_splice_connect-E.dag.dagman.out");
+
+# Lines must be *in order* within a given output file.
+@expected_output = ();
+
+my $killedchosen = 0;
+
+# truly const variables in perl
+sub IDLE{1};
+sub HELD{5};
+sub RUNNING{2};
+
+# Get rid of any existing output files.
+foreach $file (@outfiles) {
+	runcmd("rm -f $file") if (-e $file);
+}
+
+$abnormal = sub 
+{
+	die "Want to see only submit, execute and unsuccessful completion\n";
+};
+
+$aborted = sub 
+{
+	die "Abort event NOT expected\n";
+};
+
+$held = sub 
+{
+	die "Held event NOT expected\n";
+};
+
+$executed = sub
+{
+	my %info = @_;
+
+	CondorTest::debug("Good. We need the dag to run<$info{cluster}>\n",1);
+};
+
+$submitted = sub
+{
+	CondorTest::debug("submitted: This test will see submit, executing and unsuccessful completion\n",1);
+};
+
+$success = sub
+{
+	die "Error: DAG should fail!\n";
+};
+
+$failure = sub 
+{
+	CondorTest::debug("DAG failed as expected\n",1);
+};
+
+CondorTest::RegisterExitedSuccess( $testname, $success);
+CondorTest::RegisterExitedFailure( $testname, $failure );
+CondorTest::RegisterExecute($testname, $executed);
+CondorTest::RegisterExitedAbnormal( $testname, $abnormal );
+CondorTest::RegisterAbort( $testname, $aborted );
+CondorTest::RegisterHold( $testname, $held );
+CondorTest::RegisterSubmit( $testname, $submitted );
+
+if( CondorTest::RunDagTest($testname, $cmd, 0, $dagman_args) ) {
+	CondorTest::debug("$testname: SUCCESS\n",1);
+	exit(0);
+} else {
+	die "$testname: CondorTest::RunTest() failed\n";
+}
+
diff --git a/src/condor_tests/job_dagman_splice_connect-F-1.dag b/src/condor_tests/job_dagman_splice_connect-F-1.dag
new file mode 100644
index 0000000..671cec8
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-F-1.dag
@@ -0,0 +1,5 @@
+job Node1A - noop
+job Node1B - noop
+
+pin_out Node1A 1
+pin_out Node1B 2
diff --git a/src/condor_tests/job_dagman_splice_connect-F-2.dag b/src/condor_tests/job_dagman_splice_connect-F-2.dag
new file mode 100644
index 0000000..61c1518
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-F-2.dag
@@ -0,0 +1,5 @@
+job Node2A - noop
+job Node2B - noop
+
+pin_in Node2A 1
+pin_in Node2B 1
diff --git a/src/condor_tests/job_dagman_splice_connect-F.dag b/src/condor_tests/job_dagman_splice_connect-F.dag
new file mode 100644
index 0000000..f086125
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-F.dag
@@ -0,0 +1,7 @@
+# Test pin in/pin out mismatch -- this should fail.
+
+splice Splice1 job_dagman_splice_connect-F-1.dag
+splice Splice2 job_dagman_splice_connect-F-2.dag
+
+connect Splice1 Splice2
+
diff --git a/src/condor_tests/job_dagman_splice_connect-F.run b/src/condor_tests/job_dagman_splice_connect-F.run
new file mode 100755
index 0000000..8c34502
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-F.run
@@ -0,0 +1,97 @@
+#! /usr/bin/env perl
+##**************************************************************
+##
+## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+## University of Wisconsin-Madison, WI.
+## 
+## Licensed under the Apache License, Version 2.0 (the "License"); you
+## may not use this file except in compliance with the License.  You may
+## obtain a copy of the License at
+## 
+##    http://www.apache.org/licenses/LICENSE-2.0
+## 
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an "AS IS" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+##
+##**************************************************************
+
+use CondorTest;
+use CondorUtils;
+
+$cmd = 'job_dagman_splice_connect-F.dag';
+$testdesc =  'Condor submit dag - test splice pin connections - scheduler U';
+$testname = "job_dagman_splice_connect-F";
+$dagman_args = "-verbose";
+
+@outfiles = ("job_dagman_splice_connect-F.dag.dagman.out");
+
+# Lines must be *in order* within a given output file.
+@expected_output = ();
+
+my $killedchosen = 0;
+
+# truly const variables in perl
+sub IDLE{1};
+sub HELD{5};
+sub RUNNING{2};
+
+# Get rid of any existing output files.
+foreach $file (@outfiles) {
+	runcmd("rm -f $file") if (-e $file);
+}
+
+$abnormal = sub 
+{
+	die "Want to see only submit, execute and unsuccessful completion\n";
+};
+
+$aborted = sub 
+{
+	die "Abort event NOT expected\n";
+};
+
+$held = sub 
+{
+	die "Held event NOT expected\n";
+};
+
+$executed = sub
+{
+	my %info = @_;
+
+	CondorTest::debug("Good. We need the dag to run<$info{cluster}>\n",1);
+};
+
+$submitted = sub
+{
+	CondorTest::debug("submitted: This test will see submit, executing and unsuccessful completion\n",1);
+};
+
+$success = sub
+{
+	die "Error: DAG should fail!\n";
+};
+
+$failure = sub 
+{
+	CondorTest::debug("DAG failed as expected\n",1);
+};
+
+CondorTest::RegisterExitedSuccess( $testname, $success);
+CondorTest::RegisterExitedFailure( $testname, $failure );
+CondorTest::RegisterExecute($testname, $executed);
+CondorTest::RegisterExitedAbnormal( $testname, $abnormal );
+CondorTest::RegisterAbort( $testname, $aborted );
+CondorTest::RegisterHold( $testname, $held );
+CondorTest::RegisterSubmit( $testname, $submitted );
+
+if( CondorTest::RunDagTest($testname, $cmd, 0, $dagman_args) ) {
+	CondorTest::debug("$testname: SUCCESS\n",1);
+	exit(0);
+} else {
+	die "$testname: CondorTest::RunTest() failed\n";
+}
+
diff --git a/src/condor_tests/job_dagman_splice_connect-G-1lowerA.dag b/src/condor_tests/job_dagman_splice_connect-G-1lowerA.dag
new file mode 100644
index 0000000..ec9b897
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-G-1lowerA.dag
@@ -0,0 +1,7 @@
+job 1A_A no_file noop
+job 1A_B no_file noop
+job 1A_C no_file noop
+
+pin_out 1A_A 1
+pin_out 1A_B 2
+pin_out 1A_C 3
diff --git a/src/condor_tests/job_dagman_splice_connect-G-1lowerB.dag b/src/condor_tests/job_dagman_splice_connect-G-1lowerB.dag
new file mode 100644
index 0000000..9b32211
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-G-1lowerB.dag
@@ -0,0 +1,7 @@
+job 1B_A no_file noop
+job 1B_B no_file noop
+job 1B_C no_file noop
+
+pin_in 1B_A 1
+pin_in 1B_B 2
+pin_in 1B_C 3
diff --git a/src/condor_tests/job_dagman_splice_connect-G-1upper.dag b/src/condor_tests/job_dagman_splice_connect-G-1upper.dag
new file mode 100644
index 0000000..baa6818
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-G-1upper.dag
@@ -0,0 +1,5 @@
+# This is testing multiple independent DAGs with splice connections.
+
+splice Splice1A job_dagman_splice_connect-G-1lowerA.dag
+splice Splice1B job_dagman_splice_connect-G-1lowerB.dag
+connect Splice1A Splice1B
diff --git a/src/condor_tests/job_dagman_splice_connect-G-2lowerA.dag b/src/condor_tests/job_dagman_splice_connect-G-2lowerA.dag
new file mode 100644
index 0000000..7aa6d9b
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-G-2lowerA.dag
@@ -0,0 +1,7 @@
+job 2A_A no_file noop
+job 2A_B no_file noop
+job 2A_C no_file noop
+
+pin_out 2A_A 1
+pin_out 2A_B 2
+pin_out 2A_C 3
diff --git a/src/condor_tests/job_dagman_splice_connect-G-2lowerB.dag b/src/condor_tests/job_dagman_splice_connect-G-2lowerB.dag
new file mode 100644
index 0000000..5b43885
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-G-2lowerB.dag
@@ -0,0 +1,7 @@
+job 2B_A no_file noop
+job 2B_B no_file noop
+job 2B_C no_file noop
+
+pin_in 2B_A 1
+pin_in 2B_B 2
+pin_in 2B_C 3
diff --git a/src/condor_tests/job_dagman_splice_connect-G-2upper.dag b/src/condor_tests/job_dagman_splice_connect-G-2upper.dag
new file mode 100644
index 0000000..77d3f05
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-G-2upper.dag
@@ -0,0 +1,3 @@
+splice Splice2A job_dagman_splice_connect-G-2lowerA.dag
+splice Splice2B job_dagman_splice_connect-G-2lowerB.dag
+connect Splice2A Splice2B
diff --git a/src/condor_tests/job_dagman_splice_connect-G.run b/src/condor_tests/job_dagman_splice_connect-G.run
new file mode 100755
index 0000000..dfb8407
--- /dev/null
+++ b/src/condor_tests/job_dagman_splice_connect-G.run
@@ -0,0 +1,98 @@
+#! /usr/bin/env perl
+##**************************************************************
+##
+## Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+## University of Wisconsin-Madison, WI.
+## 
+## Licensed under the Apache License, Version 2.0 (the "License"); you
+## may not use this file except in compliance with the License.  You may
+## obtain a copy of the License at
+## 
+##    http://www.apache.org/licenses/LICENSE-2.0
+## 
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an "AS IS" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+##
+##**************************************************************
+
+use CondorTest;
+use CondorUtils;
+
+$cmd = ['job_dagman_splice_connect-G-1upper.dag', 'job_dagman_splice_connect-G-2upper.dag'];
+$testdesc =  'Condor submit dag - test splice pin connections - scheduler U';
+$testname = "job_dagman_splice_connect-G";
+$dagman_args = "-verbose";
+
+@outfiles = ("job_dagman_splice_connect-G-1upper.dag.dagman.out");
+
+# Lines must be *in order* within a given output file.
+@expected_output = ();
+
+my $killedchosen = 0;
+
+# truly const variables in perl
+sub IDLE{1};
+sub HELD{5};
+sub RUNNING{2};
+
+# Get rid of any existing output files.
+foreach $file (@outfiles) {
+	runcmd("rm -f $file") if (-e $file);
+}
+
+$abnormal = sub 
+{
+	die "Want to see only submit, execute and successful completion\n";
+};
+
+$failure = sub 
+{
+	die "Error: DAG is not expected to fail!\n";
+};
+
+$aborted = sub 
+{
+	die "Abort event NOT expected\n";
+};
+
+$held = sub 
+{
+	die "Held event NOT expected\n";
+};
+
+$executed = sub
+{
+	my %info = @_;
+
+	CondorTest::debug("Good. We need the dag to run<$info{cluster}>\n",1);
+};
+
+$submitted = sub
+{
+	CondorTest::debug("submitted: This test will see submit, executing and unsuccessful completion\n",1);
+};
+
+$success = sub
+{
+	CondorTest::debug("executed successfully\n",1);
+	CondorTest::debug("Verifying output\n",1);
+};
+
+CondorTest::RegisterExitedSuccess( $testname, $success);
+CondorTest::RegisterExitedFailure( $testname, $failure );
+CondorTest::RegisterExecute($testname, $executed);
+CondorTest::RegisterExitedAbnormal( $testname, $abnormal );
+CondorTest::RegisterAbort( $testname, $aborted );
+CondorTest::RegisterHold( $testname, $held );
+CondorTest::RegisterSubmit( $testname, $submitted );
+
+if( CondorTest::RunDagTest($testname, $cmd, 0, $dagman_args) ) {
+	CondorTest::debug("$testname: SUCCESS\n",1);
+	exit(0);
+} else {
+	die "$testname: CondorTest::RunTest() failed\n";
+}
+
