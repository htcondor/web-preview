<html><head><TITLE>Driver_Fib</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  Driver_Fib : public <!2><A HREF="MWDriver.html#DOC.26.16">MWDriver</A> </H2><BLOCKQUOTE>
The driver class derived from the MWDriver class for this application
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CMWDriver,MMWDriver.html,CDriver_Fib,MDriver_Fib.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.33.3"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Driver_Fib</B>() </B>
 <DD><I>Constructor</I>
<DT><A HREF="#DOC.33.4"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>~Driver_Fib</B>() </B>
 <DD><I>Destructor</I>
</DL><DL>
<DT><h3>Public</h3><DD><DT><A HREF="#DOC.33.2"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Checkpointing Methods </B> </B>
 <DD><I></I>

<DL>
<DT><A HREF="#DOC.33.2.2"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>write_master_state</B>( FILE *fp ) </B>
 <DD><I>Write out the state of the master to an fp</I>
<DT><A HREF="#DOC.33.2.1"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>read_master_state</B>( FILE *fp ) </B>
 <DD><I>Read the state from an fp</I>
<DT><A HREF="#DOC.33.2.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWTask.html">MWTask</A>*  <B>gimme_a_task</B>() </B>
 <DD><I>That simple annoying function </I>

</DL>
<DT><A HREF="#DOC.33.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Implemented Methods</B> </B>
 <DD><I></I>

<DL>
<DT><A HREF="#DOC.33.1.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B></B> </B>
 <DD><I>Get the info from the user.  Don't forget to get the </I>
<DT><A HREF="#DOC.33.1.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWReturn.html">MWReturn</A>  <B>get_userinfo</B>( int argc, char *argv[] ) </B>
 <DD><I>worker_executable!</I>
<DT><A HREF="#DOC.33.1.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWReturn.html">MWReturn</A>  <B>setup_initial_tasks</B>( int *, <!1><A HREF="MWTask.html">MWTask</A> *** ) </B>
 <DD><I>Set up an array of tasks here</I>
<DT><A HREF="#DOC.33.1.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWReturn.html">MWReturn</A>  <B>act_on_completed_task</B>( <!1><A HREF="MWTask.html">MWTask</A> * ) </B>
 <DD><I>What to do when a task finishes:</I>
<DT><A HREF="#DOC.33.1.5"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWReturn.html">MWReturn</A>  <B>pack_worker_init_data</B>( void ) </B>
 <DD><I>Put things in the send buffer here that go to a worker</I>
<DT><A HREF="#DOC.33.1.6"> <IMG BORDER=0 SRC=icon1.gif></A>  <B></B> </B>
 <DD><I>OK, this one doesn't *have* to be...but you want to be able to</I>
<DT><A HREF="#DOC.33.1.7"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>printresults</B>() </B>
 <DD><I>tell the world the results, don't you? :-)</I>

</DL>
</DL></DL>
<hr><H3>Inherited from <A HREF="MWDriver.html">MWDriver:</A></h3>

<DL>
<DL>
<DT><h3>Public Fields</h3><DD><DT><IMG SRC=icon2.gif> static  MWRMComm*  <B>RMC</B>
</DL><DL>
<DT><h3>Public Methods</h3><DD><DT><IMG SRC=icon2.gif> void  <B>go</B>()
<DT><IMG SRC=icon2.gif> void  <B>go</B>( int argc, char *argv[] )
<DT><IMG SRC=icon2.gif> virtual  void  <B>printresults</B>()
</DL><DL>
<DT><h3>Protected</h3><DD><DT><P> <B>A. Pure Virtual Methods</B>

<DL>
<DT><A HREF="#DOC.26.4.6"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="MWReturn.html">MWReturn</A>  <B>get_userinfo</B>( int argc, char *argv[] ) </B>
 <DD><I>This function is called to read in all information
specific to a user's application and do any initialization on
this information</I>
<DT><A HREF="#DOC.26.4.1"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="MWReturn.html">MWReturn</A>  <B>setup_initial_tasks</B>( int *n, <!1><A HREF="MWTask.html">MWTask</A> ***task ) </B>
 <DD><I>This function must return a number n &gt; 0 of pointers
to Tasks to "jump start" the application</I>
<DT><A HREF="#DOC.26.4.2"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="MWReturn.html">MWReturn</A>  <B>act_on_completed_task</B>( <!1><A HREF="MWTask.html">MWTask</A> * ) </B>
 <DD><I>
This function performs actions that happen
once the Driver receives notification of a completed task</I>
<DT><A HREF="#DOC.26.4.3"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="MWReturn.html">MWReturn</A>  <B>pack_worker_init_data</B>( void ) </B>
 <DD><I>
A common theme of Master-Worker applications is that there is 
a base amount of "initial" data defining the problem, and then 
just incremental data defining "Tasks" to be done by the Workers</I>
<DT><A HREF="#DOC.26.4.4"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>unpack_worker_initinfo</B>( <!1><A HREF="MWWorkerID.html">MWWorkerID</A> *w ) </B>
 <DD><I>
This one unpacks the "initial" information sent to the driver
once the worker initializes</I>
<DT><A HREF="#DOC.26.4.5"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>pack_driver_task_data</B>( void ) </B>
 <DD><I>
OK, This one is not pure virtual either, but if you have some 
"driver" data that is conceptually part of the task and you wish
not to replicate the data in each task, you can pack it in a
message buffer by implementing this function</I>

</DL>
<DT><P> <B>B. Task List Management</B>

<DL>
<DT><A HREF="#DOC.26.5.2"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>addTask</B>( <!1><A HREF="MWTask.html">MWTask</A> * ) </B>
 <DD><I>Add a task to the list</I>
<DT><A HREF="#DOC.26.5.1"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>addTasks</B>( int, <!1><A HREF="MWTask.html">MWTask</A> ** ) </B>
 <DD><I>Add a bunch of tasks to the list</I>
<DT><A HREF="#DOC.26.5.3"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>set_task_key_function</B>( <!2><A HREF="#DOC.20">MWKey</A> (*)( <!1><A HREF="MWTask.html">MWTask</A> * ) ) </B>
 <DD><I>Sets the function that MWDriver users to get the "key" for a task</I>
<DT><A HREF="#DOC.26.5.4"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>set_task_add_mode</B>( <!1><A HREF="MWTaskAdditionMode.html">MWTaskAdditionMode</A> ) </B>
 <DD><I>Set the mode you wish for task addition.</I>
<DT><A HREF="#DOC.26.5.5"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>set_task_retrieve_mode</B>( <!1><A HREF="MWTaskRetrievalMode.html">MWTaskRetrievalMode</A> ) </B>
 <DD><I>Set the mode you wish for task retrieval.  </I>
<DT><A HREF="#DOC.26.5.6"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>set_machine_ordering_policy</B>( <!1><A HREF="MWMachineOrderingPolicy.html">MWMachineOrderingPolicy</A> ) </B>
 <DD><I>Sets the machine ordering policy.  </I>
<DT><A HREF="#DOC.26.5.7"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>print_task_keys</B>( void ) </B>
 <DD><I>(Mostly for debugging) -- Prints the task keys in the todo list</I>
<DT><A HREF="#DOC.26.5.8"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>sort_task_list</B>( void ) </B>
 <DD><I>This sorts the task list by the key that is set</I>
<DT><A HREF="#DOC.26.5.9"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>delete_tasks_worse_than</B>( <!2><A HREF="#DOC.20">MWKey</A> ) </B>
 <DD><I>This deletes all tasks in the task list with a key worse than 
the one specified </I>
<DT><A HREF="#DOC.26.5.10"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>get_number_tasks</B>() </B>
 <DD><I>returns the number of tasks on the todo list.</I>
<DT><A HREF="#DOC.26.5.11"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>get_number_running_tasks</B>() </B>
 <DD><I>returns the number of running tasks.</I>

</DL>
<DT><P> <B>Benchmarking</B>

<DL>
<DT><A HREF="#DOC.26.9.1"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>register_benchmark_task</B>( <!1><A HREF="MWTask.html">MWTask</A> *t ) </B>
 <DD><I>register the task that will be used for benchmarking</I>
<DT><A HREF="#DOC.26.9.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWTask.html">MWTask</A>*  <B>get_benchmark_task</B>() </B>
 <DD><I>get the benchmark task </I>

</DL>
<DT><P> <B>C. Worker Policy Management </B>

<DL>
<DT><A HREF="#DOC.26.6.1"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>set_target_num_workers</B>( int iWantThisMany ) </B>
 <DD><I>Sets the desired number of workers</I>
<DT><A HREF="#DOC.26.6.2"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>set_target_num_workers</B>( int *iWantThisany, int num_arches ) </B>
 <DD><I>Sets the desired number of workers</I>
<DT><A HREF="#DOC.26.6.3"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>set_suspension_policy</B>( <!1><A HREF="MWSuspensionPolicy.html">MWSuspensionPolicy</A> ) </B>
 <DD><I>Set the policy to use when suspending</I>
<DT><A HREF="#DOC.26.6.5"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>worker_timeout</B> </B>
 <DD><I>If 0 : workers never timeout and can potentially work forever on a task
If 1 : workers time out after worker_timeout_limit seconds </I>
<DT><A HREF="#DOC.26.6.6"> <IMG BORDER=0 SRC=icon1.gif></A> double  <B>worker_timeout_limit</B> </B>
 <DD><I>Limit of seconds after which workers are considered time out and tasks are re-assigned </I>
<DT><A HREF="#DOC.26.6.7"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>worker_timeout_check_frequency</B> </B>
 <DD><I>frequency at which we check if there are timed out workers </I>
<DT><A HREF="#DOC.26.6.8"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>next_worker_timeout_check</B> </B>
 <DD><I>based on the time out frequency, next timeout check time</I>
<DT><A HREF="#DOC.26.6.9"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>set_worker_timeout_limit</B>(double timeout_limit, int timeout_frequency) </B>
 <DD><I>Sets the timeout_limit and turn worker_timeout to 1 </I>
<DT><A HREF="#DOC.26.6.10"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>reassign_tasks_timedout_workers</B>() </B>
 <DD><I>Go through the list of timed out WORKING workers and reschedule tasks </I>
<DT><A HREF="#DOC.26.6.4"> <IMG BORDER=0 SRC=icon1.gif></A> double  <B>timeval_to_double</B>( struct timeval t ) </B>
 <DD><I>A helper function</I>

</DL>
<DT><P> <B>D. Event Handling Methods</B>

<DL>
<DT><A HREF="#DOC.26.7.1"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="MWReturn.html">MWReturn</A>  <B>handle_benchmark</B>( <!1><A HREF="MWWorkerID.html">MWWorkerID</A> *w ) </B>
 <DD><I>Here, we get back the benchmarking
results, which tell us something about the worker we've got</I>
<DT><A HREF="#DOC.26.7.2"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>handle_hostdel</B>() </B>
 <DD><I>This is what gets called when a host goes away</I>
<DT><A HREF="#DOC.26.7.3"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>handle_hostsuspend</B>() </B>
 <DD><I>Implements a suspension policy</I>
<DT><A HREF="#DOC.26.7.4"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>handle_hostresume</B>() </B>
 <DD><I>Here's where you go when a host gets resumed</I>
<DT><A HREF="#DOC.26.7.5"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>handle_taskexit</B>() </B>
 <DD><I>We do basically the same thing as handle_hostdel()</I>
<DT><A HREF="#DOC.26.7.6"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>handle_checksum</B>() </B>
 <DD><I>Routine to handle when the communication layer says that a
checksum error happened</I>

</DL>
<DT><P> <B>E. Checkpoint Handling Functions</B>

<DL>
<DT><A HREF="#DOC.26.8.1"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>checkpoint</B>() </B>
 <DD><I>This function writes the current state of the job to disk</I>
<DT><A HREF="#DOC.26.8.2"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>restart_from_ckpt</B>() </B>
 <DD><I>This function does the inverse of checkpoint</I>
<DT><A HREF="#DOC.26.8.3"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>set_checkpoint_frequency</B>( int freq ) </B>
 <DD><I>This function sets the frequency with with checkpoints are
done</I>
<DT><A HREF="#DOC.26.8.4"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>set_checkpoint_time</B>( int secs ) </B>
 <DD><I>Set a time-based frequency for checkpoints</I>
<DT><A HREF="#DOC.26.8.5"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>write_master_state</B>( FILE *fp ) </B>
 <DD><I>Here you write out all 'state' of the driver to fp</I>
<DT><A HREF="#DOC.26.8.6"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>read_master_state</B>( FILE *fp ) </B>
 <DD><I>Here, you read in the 'state' of the driver from fp</I>
<DT><A HREF="#DOC.26.8.7"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="MWTask.html">MWTask</A>*  <B>gimme_a_task</B>() </B>
 <DD><I>It's really annoying that the user has to do this, but
they do</I>

</DL>
</DL><DL>
<DT><h3>Private Fields</h3><DD><DT><IMG SRC=icon2.gif> <!1><A HREF="MWStatistics.html">MWStatistics</A>  <B>stats</B>
</DL><DL>
<DT><h3>Private Methods</h3><DD><DT><IMG SRC=icon2.gif> double  <B>get_instant_pool_perf</B>()
</DL><DL>
<DT><h3>Private</h3><DD><DT><P> <B>Checkpoint internal helpers... </B>

<DL>
<DT><A HREF="#DOC.26.13.3"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>checkpoint_frequency</B> </B>
 <DD><I>How often to checkpoint?  Task frequency based</I>
<DT><A HREF="#DOC.26.13.4"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>checkpoint_time_freq</B> </B>
 <DD><I>How often to checkpoint?  Time based</I>
<DT><A HREF="#DOC.26.13.1"> <IMG BORDER=0 SRC=icon1.gif></A> long  <B>next_ckpt_time</B> </B>
 <DD><I>Time to do next checkpoint</I>
<DT><A HREF="#DOC.26.13.2"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>num_completed_tasks</B> </B>
 <DD><I>The number of tasks acted upon up to now</I>
<DT><A HREF="#DOC.26.13.5"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWTask.html">MWTask</A>*  <B>bench_task</B> </B>
 <DD><I>The benchmark task</I>
<DT><A HREF="#DOC.26.13.6"> <IMG BORDER=0 SRC=icon1.gif></A> const  char*  <B>ckpt_filename</B> </B>
 <DD><I>The name of the checkpoint file </I>

</DL>
<DT><P> <B>Internal Task List Routines </B>

<DL>
<DT><A HREF="#DOC.26.11.3"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>pushTask</B>( <!1><A HREF="MWTask.html">MWTask</A> * ) </B>
 <DD><I>This puts a (generally failed) task at the beginning of the list</I>
<DT><A HREF="#DOC.26.11.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWTask.html">MWTask</A>*  <B>getNextTask</B>() </B>
 <DD><I>Get a Task.  </I>
<DT><A HREF="#DOC.26.11.5"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>putOnRunQ</B>( <!1><A HREF="MWTask.html">MWTask</A> *t ) </B>
 <DD><I>This puts a task at the end of the list</I>
<DT><A HREF="#DOC.26.11.6"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWTask.html">MWTask</A>*  <B>rmFromRunQ</B>( int jobnum ) </B>
 <DD><I>Removes a task from the queue of things to run</I>
<DT><A HREF="#DOC.26.11.7"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>printRunQ</B>() </B>
 <DD><I>Print the tasks in the list of tasks to do</I>
<DT><A HREF="#DOC.26.11.8"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>ckpt_addTask</B>( <!1><A HREF="MWTask.html">MWTask</A> * ) </B>
 <DD><I>Add one task to the todo list; do NOT set the 'number' of
the task - useful in restarting from a checkpoint </I>
<DT><A HREF="#DOC.26.11.9"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWWorkerID.html">MWWorkerID</A>*  <B>task_assigned</B>( <!1><A HREF="MWTask.html">MWTask</A> *t ) </B>
 <DD><I>returns the worker this task is assigned to, NULL if none.</I>
<DT><A HREF="#DOC.26.11.10"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="#DOC.9">bool</A>  <B>task_in_todo_list</B>( <!1><A HREF="MWTask.html">MWTask</A> *t ) </B>
 <DD><I>Returns true if "t" is still in the todo list</I>
<DT><A HREF="#DOC.26.11.11"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>ControlPanel</B>( ) </B>
 <DD><I>The control panel that controls the execution of the
independent mode</I>
<DT><A HREF="#DOC.26.11.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="#DOC.20">MWKey</A> <B>(*task_key)</B>( <!1><A HREF="MWTask.html">MWTask</A> * ) </B>
 <DD><I>A pointer to a (user written) function that takes an MWTask
and returns the "key" for this task</I>
<DT><A HREF="#DOC.26.11.12"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWTaskAdditionMode.html">MWTaskAdditionMode</A>  <B>addmode</B> </B>
 <DD><I>Where should tasks be added to the list?</I>
<DT><A HREF="#DOC.26.11.13"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWTaskRetrievalMode.html">MWTaskRetrievalMode</A>  <B>getmode</B> </B>
 <DD><I>Where should tasks by retrived from the list</I>
<DT><A HREF="#DOC.26.11.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="#DOC.20">MWKey</A> <B>(*worker_key)</B>( <!1><A HREF="MWWorkerID.html">MWWorkerID</A> * ) </B>
 <DD><I>A pointer to the function that returns the "key" by which machines are ranked</I>
<DT><A HREF="#DOC.26.11.14"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>task_counter</B> </B>
 <DD><I>MWDriver keeps a unique identifier for each task -- 
here's the counter </I>
<DT><A HREF="#DOC.26.11.15"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="#DOC.9">bool</A>  <B>listsorted</B> </B>
 <DD><I>Is the list sorted by the current key function</I>
<DT><A HREF="#DOC.26.11.16"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWTask.html">MWTask</A>*  <B>todo</B> </B>
 <DD><I>The head of the list of tasks to do</I>
<DT><A HREF="#DOC.26.11.17"> <IMG BORDER=0 SRC=icon1.gif></A>  <B></B> </B>
 <DD><I>This is Jeff's nasty addition so that he can get access</I>
<DT><A HREF="#DOC.26.11.18"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWTask.html">MWTask</A>*  <B>get_todo_head</B>() </B>
 <DD><I>to the tasks on the master</I>
<DT><A HREF="#DOC.26.11.19"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWTask.html">MWTask</A>*  <B>todoend</B> </B>
 <DD><I>The tail of the list of tasks to do</I>
<DT><A HREF="#DOC.26.11.20"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWTask.html">MWTask</A>*  <B>running</B> </B>
 <DD><I>The head of the list of tasks that are actually running</I>
<DT><A HREF="#DOC.26.11.21"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWTask.html">MWTask</A>*  <B>runningend</B> </B>
 <DD><I>The tail of the list of tasks that are actually running</I>

</DL>
<DT><P> <B>Main Internal Handling Routines </B>

<DL>
<DT><A HREF="#DOC.26.10.1"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWReturn.html">MWReturn</A>  <B>master_setup</B>( int argc, char *argv[] ) </B>
 <DD><I>This method is called before master_mainloop() is</I>
<DT><A HREF="#DOC.26.10.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWReturn.html">MWReturn</A>  <B>master_mainloop</B>() </B>
 <DD><I>This is the main controlling routine of the master</I>
<DT><A HREF="#DOC.26.10.9"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWReturn.html">MWReturn</A>  <B>worker_init</B>( <!1><A HREF="MWWorkerID.html">MWWorkerID</A> *w ) </B>
 <DD><I>
unpacks the initial worker information, and sends the
application startup information (by calling pure virtual
<TT>pack_worker_init_data()</tt><P>The return value is taken as the return value from the user's 
<TT>pack_worker_init_data()</tt> function</I>
<DT><A HREF="#DOC.26.10.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWReturn.html">MWReturn</A>  <B>create_initial_tasks</B>() </B>
 <DD><I>
This routine sets up the list of initial tasks to do on the 
todo list</I>
<DT><A HREF="#DOC.26.10.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWReturn.html">MWReturn</A>  <B>handle_worker_results</B>( <!1><A HREF="MWWorkerID.html">MWWorkerID</A> *w ) </B>
 <DD><I>
Act on a "completed task" message from a worker</I>
<DT><A HREF="#DOC.26.10.5"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>send_task_to_worker</B>( <!1><A HREF="MWWorkerID.html">MWWorkerID</A> *w ) </B>
 <DD><I>We grab the next task off the todo list, make and send a work
message, and send it to a worker</I>
<DT><A HREF="#DOC.26.10.6"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>rematch_tasks_to_workers</B>( <!1><A HREF="MWWorkerID.html">MWWorkerID</A> *nosend ) </B>
 <DD><I>After each result message is processed, we try to match up
tasks with workers</I>
<DT><A HREF="#DOC.26.10.7"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>call_hostaddlogic</B>() </B>
 <DD><I>A wrapper around the lower level's hostaddlogic</I>
<DT><A HREF="#DOC.26.10.10"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>kill_workers</B>() </B>
 <DD><I>Kill all the workers</I>
<DT><A HREF="#DOC.26.10.8"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>hostPostmortem</B>( <!1><A HREF="MWWorkerID.html">MWWorkerID</A> *w ) </B>
 <DD><I>This is called in both handle_hostdelete and handle_taskexit</I>

</DL>
<DT><P> <B>Worker management methods</B>

<DL>
<DT><A HREF="#DOC.26.12.1"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>addWorker</B>( <!1><A HREF="MWWorkerID.html">MWWorkerID</A> *w ) </B>
 <DD><I>Adds a worker to the list of avaiable workers</I>
<DT><A HREF="#DOC.26.12.2"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWWorkerID.html">MWWorkerID</A>*  <B>lookupWorker</B>( int tid ) </B>
 <DD><I>Looks up information about a worker given its task ID</I>
<DT><A HREF="#DOC.26.12.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWWorkerID.html">MWWorkerID</A>*  <B>rmWorker</B>( int tid ) </B>
 <DD><I>Removes a worker from the list of available workers</I>
<DT><A HREF="#DOC.26.12.4"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>printWorkers</B>() </B>
 <DD><I>Prints the available workers</I>
<DT><A HREF="#DOC.26.12.5"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWWorkerID.html">MWWorkerID</A>*  <B>get_workers_head</B>() </B>
 <DD><I>Another terrible addition so that Jeff can print out the worker list
in his own format </I>
<DT><A HREF="#DOC.26.12.6"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWWorkerID.html">MWWorkerID</A>*  <B>workers</B> </B>
 <DD><I>The head of the list of workers.</I>
<DT><A HREF="#DOC.26.12.7"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="MWSuspensionPolicy.html">MWSuspensionPolicy</A>  <B>suspensionPolicy</B> </B>
 <DD><I>Here's where we store what should happen on a suspension...</I>
<DT><A HREF="#DOC.26.12.8"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>sort_worker_list</B>() </B>
 <DD><I>Based on the ordering policy, place w in the worker list appropriately</I>
<DT><A HREF="#DOC.26.12.9"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>numWorkers</B>() </B>
 <DD><I>Counts the existing workers</I>
<DT><A HREF="#DOC.26.12.10"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>numWorkers</B>( int arch ) </B>
 <DD><I>Counts the number of workers in the given arch class</I>
<DT><A HREF="#DOC.26.12.11"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>numWorkersInState</B>( int ThisState ) </B>
 <DD><I>Counts the number of workers in the given state</I>
<DT><A HREF="#DOC.26.12.12"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="#DOC.20">MWKey</A>  <B>return_best_todo_keyval</B>( void ) </B>
 <DD><I>Returns the value (only) of the best key in the Todo list </I>
<DT><A HREF="#DOC.26.12.13"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="#DOC.20">MWKey</A>  <B>return_best_running_keyval</B>( void ) </B>
 <DD><I>Returns the best value (only) of the best key in the Running list.</I>

</DL>
<DT><P> <B>XML and Status Methods.</B>

<DL>
<DT><A HREF="#DOC.26.15.2"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>write_XML_status</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.1"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  char*  <B>get_XML_results_status</B>(void ) </B>
 <DD><I>
If you want to display information about status of some
results variables of your solver, you have to dump a string in
ASCII, HTML or XML format out of the following method</I>
<DT><A HREF="#DOC.26.15.3"> <IMG BORDER=0 SRC=icon1.gif></A> char*  <B>get_XML_status</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.4"> <IMG BORDER=0 SRC=icon1.gif></A> char*  <B>get_XML_job_information</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.5"> <IMG BORDER=0 SRC=icon1.gif></A> char*  <B>get_XML_problem_description</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.6"> <IMG BORDER=0 SRC=icon1.gif></A> char*  <B>get_XML_interface_remote_files</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.7"> <IMG BORDER=0 SRC=icon1.gif></A> char*  <B>get_XML_resources_status</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.8"> <IMG BORDER=0 SRC=icon1.gif></A> const  char*  <B>xml_filename</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.9"> <IMG BORDER=0 SRC=icon1.gif></A> const  char*  <B>xml_menus_filename</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.10"> <IMG BORDER=0 SRC=icon1.gif></A> const  char*  <B>xml_jobinfo_filename</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.11"> <IMG BORDER=0 SRC=icon1.gif></A> const  char*  <B>xml_pbdescrib_filename</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.12"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>get_machine_info</B>() </B>
 <DD><I>Set the current machine information</I>
<DT><A HREF="#DOC.26.15.13"> <IMG BORDER=0 SRC=icon1.gif></A> char*  <B>get_Arch</B>() </B>
 <DD><I>Returns a pointer to the machine's Arch</I>
<DT><A HREF="#DOC.26.15.14"> <IMG BORDER=0 SRC=icon1.gif></A> char*  <B>get_OpSys</B>() </B>
 <DD><I>Returns a pointer to the machine's OpSys</I>
<DT><A HREF="#DOC.26.15.15"> <IMG BORDER=0 SRC=icon1.gif></A> char*  <B>get_IPAddress</B>() </B>
 <DD><I>Returns a pointer to the machine's IPAddress</I>
<DT><A HREF="#DOC.26.15.16"> <IMG BORDER=0 SRC=icon1.gif></A> double  <B>get_CondorLoadAvg</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.17"> <IMG BORDER=0 SRC=icon1.gif></A> double  <B>get_LoadAvg</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.18"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>get_Memory</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.19"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>get_Cpus</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.20"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>get_VirtualMemory</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.21"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>get_Disk</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.22"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>get_KFlops</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.23"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>get_Mips</B>() </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.24"> <IMG BORDER=0 SRC=icon1.gif></A> char  <B>Arch</B>[64] </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.25"> <IMG BORDER=0 SRC=icon1.gif></A> char  <B>OpSys</B>[64] </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.26"> <IMG BORDER=0 SRC=icon1.gif></A> char  <B>IPAddress</B>[64] </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.27"> <IMG BORDER=0 SRC=icon1.gif></A> double  <B>CondorLoadAvg</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.28"> <IMG BORDER=0 SRC=icon1.gif></A> double  <B>LoadAvg</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.29"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>Memory</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.30"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>Cpus</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.31"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>VirtualMemory</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.32"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>Disk</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.33"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>KFlops</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.34"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>Mips</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.26.15.35"> <IMG BORDER=0 SRC=icon1.gif></A> int  <B>check_for_int_val</B>(char* name, char* key, char* value) </B>
 <DD><I>Utility functions used by get_machine info</I>
<DT><A HREF="#DOC.26.15.36"> <IMG BORDER=0 SRC=icon1.gif></A> char  <B>mach_name</B>[64] </B>
 <DD><I>The name of the machine the worker is running on.</I>

</DL>
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>
The driver class derived from the MWDriver class for this application.<P>In particular, this application is a very simple one that calculates 
the fibonacci sequence for different pairs of starting numbers.<P>This simple app will not need any special math packages to run, and
is designed with the non-math-specialist in mind (like me!).<P>

</BLOCKQUOTE>
<DL>

<A NAME="Driver_Fib">
<A NAME ="DOC.33.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Driver_Fib()</B></TT>
<DD>Constructor
<DL></DL><P>
<A NAME="~Driver_Fib">
<A NAME ="DOC.33.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  ~Driver_Fib()</B></TT>
<DD>Destructor
<DL></DL><P>
<A NAME="Implemented Methods">
<A NAME ="DOC.33.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Implemented Methods</B></TT>
<DD>
These methods are the ones that *must* be implemented in order
to create an application
<DL></DL><P><DL>

<A NAME="">
<A NAME ="DOC.33.1.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  </B></TT>
<DD>Get the info from the user.  Don't forget to get the 
<DL></DL><P>
<A NAME="get_userinfo">
<A NAME ="DOC.33.1.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="MWReturn.html">MWReturn</A>  get_userinfo( int argc, char *argv[] )</B></TT>
<DD>worker_executable!
<DL></DL><P>
<A NAME="setup_initial_tasks">
<A NAME ="DOC.33.1.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="MWReturn.html">MWReturn</A>  setup_initial_tasks( int *, <!1><A HREF="MWTask.html">MWTask</A> *** )</B></TT>
<DD>Set up an array of tasks here
<DL></DL><P>
<A NAME="act_on_completed_task">
<A NAME ="DOC.33.1.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="MWReturn.html">MWReturn</A>  act_on_completed_task( <!1><A HREF="MWTask.html">MWTask</A> * )</B></TT>
<DD>What to do when a task finishes:
<DL></DL><P>
<A NAME="pack_worker_init_data">
<A NAME ="DOC.33.1.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="MWReturn.html">MWReturn</A>  pack_worker_init_data( void )</B></TT>
<DD>Put things in the send buffer here that go to a worker
<DL></DL><P>
<A NAME="">
<A NAME ="DOC.33.1.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  </B></TT>
<DD>OK, this one doesn't *have* to be...but you want to be able to
<DL></DL><P>
<A NAME="printresults">
<A NAME ="DOC.33.1.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  printresults()</B></TT>
<DD>tell the world the results, don't you? :-)
<DL></DL><P></DL>

<A NAME="Checkpointing Methods ">
<A NAME ="DOC.33.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Checkpointing Methods </B></TT>
<DL></DL><P><DL>

<A NAME="write_master_state">
<A NAME ="DOC.33.2.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  write_master_state( FILE *fp )</B></TT>
<DD>Write out the state of the master to an fp
<DL></DL><P>
<A NAME="read_master_state">
<A NAME ="DOC.33.2.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  read_master_state( FILE *fp )</B></TT>
<DD>Read the state from an fp.  This is the reverse of 
write_master_state(). 
<DL></DL><P>
<A NAME="gimme_a_task">
<A NAME ="DOC.33.2.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="MWTask.html">MWTask</A>*  gimme_a_task()</B></TT>
<DD>That simple annoying function 
<DL></DL><P></DL>
</DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL><DT><B>Author:</B><DD>Mike Yoder
</DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P></BODY><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++
<P Align=Center>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&oumlckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de </a>