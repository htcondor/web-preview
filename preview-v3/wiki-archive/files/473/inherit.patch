diff --git a/src/condor_utils/dprintf.cpp b/src/condor_utils/dprintf.cpp
index 884c03c..76a9383 100644
--- a/src/condor_utils/dprintf.cpp
+++ b/src/condor_utils/dprintf.cpp
@@ -246,7 +246,7 @@ _condor_dfprintf_va( int flags, int mask_flags, time_t clock_now, struct tm *tm,
 		if ( (mask_flags|flags) & D_FDS ) {
 			//Regardless of whether we're keeping the log file open our not, we open
 			//the NULL file for the FD number.
-			if( (local_fp=safe_fopen_wrapper_follow(NULL_FILE,"r",0644)) == NULL )
+			if( (local_fp=safe_fopen_wrapper_follow(NULL_FILE,"rN",0644)) == NULL )
 			{
 				local_fp = fp;
 				fopen_rc = 0;
@@ -717,7 +717,7 @@ debug_lock(int debug_level, const char *mode, int force_lock )
 	debug_file_ptr = DebugFPs[debug_level];
 
 	if ( mode == NULL ) {
-		mode = "a";
+		mode = "aN";
 	}
 
 	if(DebugFile[debug_level] == NULL)
@@ -938,7 +938,7 @@ preserve_log_file(int debug_level)
 #if defined(WIN32)
 	if (result < 0) { // MoveFileEx and Copy failed
 		failed_to_rotate = TRUE;
-		debug_file_ptr = open_debug_file(debug_level, "w");
+		debug_file_ptr = open_debug_file(debug_level, "wN");
 		if ( debug_file_ptr ==  NULL ) {
 			still_in_old_file = TRUE;
 		}
@@ -991,7 +991,7 @@ preserve_log_file(int debug_level)
 #endif
 
 	if (debug_file_ptr == NULL) {
-		debug_file_ptr = open_debug_file(debug_level, "a");
+		debug_file_ptr = open_debug_file(debug_level, "aN");
 	}
 
 	if( debug_file_ptr == NULL ) {
@@ -1057,7 +1057,7 @@ _condor_fd_panic( int line, const char* file )
 		(void)close( i );
 	}
 	if( DebugFile[0] ) {
-		DebugFPs[0] = safe_fopen_wrapper_follow(DebugFile[0], "a", 0644);
+		DebugFPs[0] = safe_fopen_wrapper_follow(DebugFile[0], "aN", 0644);
 	}
 
 	if( DebugFPs[0] == NULL ) {
@@ -1203,7 +1203,7 @@ _condor_dprintf_exit( int error_code, const char* msg )
 		if( tmp ) {
 			snprintf( buf, sizeof(buf), "%s/dprintf_failure.%s",
 					  tmp, get_mySubSystemName() );
-			fail_fp = safe_fopen_wrapper_follow( buf, "w",0644 );
+			fail_fp = safe_fopen_wrapper_follow( buf, "wN",0644 );
 			if( fail_fp ) {
 				fprintf( fail_fp, "%s", header );
 				fprintf( fail_fp, "%s", msg );
diff --git a/src/condor_utils/dprintf_config.cpp b/src/condor_utils/dprintf_config.cpp
index 03a1632..e53edca 100644
--- a/src/condor_utils/dprintf_config.cpp
+++ b/src/condor_utils/dprintf_config.cpp
@@ -249,9 +249,9 @@ dprintf_config( const char *subsys )
 				}
 
 				if( first_time && want_truncate ) {
-					debug_file_fp = debug_lock(debug_level, "w", 0);
+					debug_file_fp = debug_lock(debug_level, "wN", 0);
 				} else {
-					debug_file_fp = debug_lock(debug_level, "a", 0);
+					debug_file_fp = debug_lock(debug_level, "aN", 0);
 				}
 
 				if( debug_file_fp == NULL && debug_level == 0 ) {
diff --git a/src/safefile/configure b/src/safefile/configure
index 7d88314..17c8ac3 100755
--- a/src/safefile/configure
+++ b/src/safefile/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.59 for safefile 1.0.1.
+# Generated by GNU Autoconf 2.59 for safefile 1.0.4.
 #
 # Report bugs to <kupsch atsign cs period wisc period edu>.
 #
@@ -11,7 +11,7 @@
 #
 # Safefile Library (http://www.cs.wisc.edu/~kupsch/safefile).
 #
-# Copyright 2007-2010 James A. Kupsch
+# Copyright 2007-2011 James A. Kupsch
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
@@ -285,8 +285,8 @@ SHELL=${CONFIG_SHELL-/bin/sh}
 # Identity of this package.
 PACKAGE_NAME='safefile'
 PACKAGE_TARNAME='safefile'
-PACKAGE_VERSION='1.0.1'
-PACKAGE_STRING='safefile 1.0.1'
+PACKAGE_VERSION='1.0.4'
+PACKAGE_STRING='safefile 1.0.4'
 PACKAGE_BUGREPORT='kupsch atsign cs period wisc period edu'
 
 ac_unique_file="safe_fopen.c"
@@ -796,7 +796,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures safefile 1.0.1 to adapt to many kinds of systems.
+\`configure' configures safefile 1.0.4 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -858,7 +858,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of safefile 1.0.1:";;
+     short | recursive ) echo "Configuration of safefile 1.0.4:";;
    esac
   cat <<\_ACEOF
 
@@ -976,7 +976,7 @@ fi
 test -n "$ac_init_help" && exit 0
 if $ac_init_version; then
   cat <<\_ACEOF
-safefile configure 1.0.1
+safefile configure 1.0.4
 generated by GNU Autoconf 2.59
 
 Copyright (C) 2003 Free Software Foundation, Inc.
@@ -986,7 +986,7 @@ gives unlimited permission to copy, distribute and modify it.
 
 Safefile Library (http://www.cs.wisc.edu/~kupsch/safefile).
 
-Copyright 2007-2010 James A. Kupsch
+Copyright 2007-2011 James A. Kupsch
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
@@ -1006,7 +1006,7 @@ cat >&5 <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by safefile $as_me 1.0.1, which was
+It was created by safefile $as_me 1.0.4, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   $ $0 $@
@@ -1656,7 +1656,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='safefile'
- VERSION='1.0.1'
+ VERSION='1.0.4'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -7795,7 +7795,7 @@ _ASBOX
 } >&5
 cat >&5 <<_CSEOF
 
-This file was extended by safefile $as_me 1.0.1, which was
+This file was extended by safefile $as_me 1.0.4, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -7858,7 +7858,7 @@ _ACEOF
 
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-safefile config.status 1.0.1
+safefile config.status 1.0.4
 configured by $0, generated by GNU Autoconf 2.59,
   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
diff --git a/src/safefile/safe_fopen.c b/src/safefile/safe_fopen.c
index 26ac511..70454ef 100644
--- a/src/safefile/safe_fopen.c
+++ b/src/safefile/safe_fopen.c
@@ -1,7 +1,7 @@
 /*
  * safefile package    http://www.cs.wisc.edu/~kupsch/safefile
  *
- * Copyright 2007-2008 James A. Kupsch
+ * Copyright 2007-2008, 2011 James A. Kupsch
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,11 +20,8 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
-#ifdef WIN32
-#include <string.h>
-#include <io.h>
-#else
-#include <unistd.h>
+#ifndef WIN32
+#include <unistd.h>
 #endif
 #include <errno.h>
 #include <stdio.h>
@@ -37,19 +34,37 @@
 /*
  * Internal helper function declarations
  */
-static int stdio_mode_to_open_flag(const char* flags, int* mode, int create_file);
-static FILE* safe_fdopen(int fd, const char* flags);
+static int stdio_mode_to_open_flag(const char *flags, int *mode, int create_file);
+static FILE *safe_fdopen(int fd, const char *flags);
+
+#ifdef WIN32
+#include <string.h>
+#include <stdlib.h>
+#include <io.h>
+static char *fix_stdio_fdopen_mode_on_windows(const char *flags);
+
+const char *ccsStr = "ccs=";
+const char *unicodeStr = "UNICODE";
+const char *utf8Str = "UTF-8";
+const char *utf16Str = "UTF-16LE";
+
+const size_t ccsStrLen = sizeof(ccsStr) - 1;
+const size_t unicodeStrLen = sizeof(unicodeStr) - 1;
+const size_t utf8StrLen = sizeof(utf8Str) - 1;
+const size_t utf16StrLen = sizeof(utf16Str) - 1;
+#endif
 
 
 /*
  * Replacement functions for fopen.  These functions differ in the following
  * ways:
  *
- * 1) file creation is always done safely and the semantics are determined by
- *    which of the 4 functions is used.
+ * 1) file creation is always done safely with file creation semantics determined
+ *    by the choice of the 4 available functions, allowing semantics not possible
+ *    using fopen
  * 2) the default file permission is 0644 instead of 0666.  umask still applies.
  * 3) a file permissions argument exists for file creation (optional in C++)
- * 4) in the case of "a", the file is opened with O_APPEND
+ * 4) in the case of flags containing "a", the file is opened with O_APPEND
  * 5) EINVAL is returned if the filename or flags are a NULL pointer, or the
  *    first character of the flag is not a valid standard fopen flag value:  rwa
  * 6) EEXISTS is returned if the final component is a symbolic link in both
@@ -58,7 +73,7 @@ static FILE* safe_fdopen(int fd, const char* flags);
 
 
 /* open existing file */
-FILE* safe_fopen_no_create(const char* fn, const char* flags)
+FILE *safe_fopen_no_create(const char *fn, const char *flags)
 {
     int open_flags;
     int r = stdio_mode_to_open_flag(flags, &open_flags, 0);
@@ -78,7 +93,7 @@ FILE* safe_fopen_no_create(const char* fn, const char* flags)
 
 
 /* create file, fail if it exists, don't follow symlink */
-FILE* safe_fcreate_fail_if_exists(const char *fn, const char* flags, mode_t mode)
+FILE *safe_fcreate_fail_if_exists(const char *fn, const char *flags, mode_t mode)
 {
     int open_flags;
     int r = stdio_mode_to_open_flag(flags, &open_flags, 1);
@@ -95,7 +110,7 @@ FILE* safe_fcreate_fail_if_exists(const char *fn, const char* flags, mode_t mode
 
 
 /* create file if it doesn't exist, keep inode if it does */
-FILE* safe_fcreate_keep_if_exists(const char *fn, const char* flags, mode_t mode)
+FILE *safe_fcreate_keep_if_exists(const char *fn, const char *flags, mode_t mode)
 {
     int open_flags;
     int r = stdio_mode_to_open_flag(flags, &open_flags, 1);
@@ -112,7 +127,7 @@ FILE* safe_fcreate_keep_if_exists(const char *fn, const char* flags, mode_t mode
 
 
 /* create file, replace file if exists */
-FILE* safe_fcreate_replace_if_exists(const char *fn, const char* flags, mode_t mode)
+FILE *safe_fcreate_replace_if_exists(const char *fn, const char *flags, mode_t mode)
 {
     int open_flags;
     int r = stdio_mode_to_open_flag(flags, &open_flags, 1);
@@ -129,7 +144,7 @@ FILE* safe_fcreate_replace_if_exists(const char *fn, const char* flags, mode_t m
 
 
 /* open existing file */
-FILE* safe_fopen_no_create_follow(const char* fn, const char* flags)
+FILE *safe_fopen_no_create_follow(const char *fn, const char *flags)
 {
     int open_flags;
     int r = stdio_mode_to_open_flag(flags, &open_flags, 0);
@@ -149,7 +164,7 @@ FILE* safe_fopen_no_create_follow(const char* fn, const char* flags)
 
 
 /* create file if it doesn't exist, keep inode if it does */
-FILE* safe_fcreate_keep_if_exists_follow(const char *fn, const char* flags, mode_t mode)
+FILE *safe_fcreate_keep_if_exists_follow(const char *fn, const char *flags, mode_t mode)
 {
     int open_flags;
     int r = stdio_mode_to_open_flag(flags, &open_flags, 1);
@@ -166,17 +181,17 @@ FILE* safe_fcreate_keep_if_exists_follow(const char *fn, const char* flags, mode
 
 
 /*
- * Helper functions for us in safe_fcreate* and safe_fopen functions
+ * Helper functions for use in safe_fcreate and safe_fopen function families
  */
 
 /*
- * create the flags needed by open from mode string passed to fopen
- * fail if the create_file is true and mode is "r" or "rb", or if the
+ * Create the flags needed by open from mode string passed to fopen.
+ * Fail if the create_file is true and mode is "r" or "rb", or if the
  * mode does not start with one of the 15 valid modes:
  *   r rb r+ r+b rb+  w wb w+ w+b wb+  a ab a+ a+b ab+
- * also fail if the flags or mode pointers are NULL.
+ * Also fail if the flags or mode pointers are NULL.
  */
-int stdio_mode_to_open_flag(const char* flags, int* mode, int create_file)
+int stdio_mode_to_open_flag(const char *flags, int *mode, int create_file)
 {
     int		plus_flag = 0;
     char	mode_char;
@@ -226,67 +241,236 @@ int stdio_mode_to_open_flag(const char* flags, int* mode, int create_file)
 	*mode |= O_TRUNC;
     }
 
-    /* deal with windows extra flags: b t S R T D */
-
 #ifdef WIN32
+    /* deal with extra flags on windows:
+     *     b t S R T D N ccs=UNICODE ccs=UTF8 ccs=UTF16LE
+     */
+    {
+	const char *f = &flags[1];
+
+	/* This loop skips the first character, but that is what we want as the
+	 * first character is always 'r', 'w', or 'a', and we have already 
+	 * processed them.
+	 */
+	while (*f)  {
+	    switch (*f)  {
+	    case '+':
+		/* Ignore. Handled above. */
+		break;
+
 #ifdef _O_BINARY
-    if (strchr(flags, 'b'))  {
-	*mode |= _O_BINARY;
-    }
+	    case 'b':
+		*mode |= _O_BINARY;
+		break;
 #endif
 
 #ifdef _O_TEXT
-    if (strchr(flags, 't'))  {
-	*mode |= _O_TEXT;
-    }
+	    case 't':
+		*mode |= _O_TEXT;
+		break;
 #endif
 
 #ifdef _O_SEQUENTIAL
-    if (strchr(flags, 'S'))  {
-	*mode |= _O_SEQUENTIAL;
-    }
+	    case 'S':
+		*mode |= _O_SEQUENTIAL;
+		break;
 #endif
 
 #ifdef _O_RANDOM
-    if (strchr(flags, 'R'))  {
-	*mode |= _O_RANDOM;
-    }
+	    case 'R':
+		*mode |= _O_RANDOM;
+		break;
 #endif
 
 #ifdef _O_SHORT_LIVED
-    if (strchr(flags, 'T'))  {
-	*mode |= _O_SHORT_LIVED;
-    }
+	    case 'T':
+		*mode |= _O_SHORT_LIVED;
+		break;
 #endif
 
 #ifdef _O_TEMPORARY
-    if (strchr(flags, 'D'))  {
-	*mode |= _O_TEMPORARY;
-    }
+	    case 'D':
+		*mode |= _O_TEMPORARY;
+		break;
+#endif
+
+#ifdef _O_NOINHERIT
+	    case 'N':
+		*mode |= _O_NOINHERIT;
+		break;
+#endif
+
+#if defined(_O_WTEXT) || defined(_O_UTF8) || defined(_O_UTF16)
+	    case 'c':
+		if (strncmp(f, ccsStr, ccsStrLen) == 0)  {
+		    /* found ccs= sequence */
+		    f += ccsStrLen;
+#ifdef _O_WTEXT
+		    if (strncmp(f, unicodeStr, unicodeStrLen) == 0)  {
+			/* found ccs=UNICODE sequence */
+			f += unicodeStrLen - 1;
+			*mode |= _O_WTEXT;
+			break;
+		    }
+#endif
+#ifdef _O_UTF8
+		    if (strncmp(f, utf8Str, utf8StrLen) == 0)  {
+			/* found ccs=UTF8 sequence */
+			f += utf8StrLen - 1;
+			*mode |= _O_UTF8;
+			break;
+		    }
+#endif
+#ifdef _O_UTF16
+		    if (strncmp(f, utf16Str, utf16StrLen) == 0)  {
+			/* found ccs=UTF16LE sequence */
+			f += utf16StrLen - 1;
+			*mode |= _O_UTF16;
+			break;
+		    }
+#endif
+		}
+		/* no valid ccs sequence found */
+		errno = EINVAL;
+		return -1;
 #endif
+
+	    case ',':
+		/* Ignore commas.  Used to separate modes like ccs=ENCODING */
+		break;
+
+	    default:
+		errno = EINVAL;
+		return -1;
+	    }
+
+	++f;
+	}
+    }
 #endif
 
     return 0;
 }
 
 
+#ifdef WIN32
 /*
- * turn the file descriptor into a FILE*.  return NULL if fd == -1.
+ * fdopen on windows does not accept the N flag in the mode string.
+ * Create a new mode string without the N flag
+ */
+char * fix_stdio_fdopen_mode_on_windows(const char *flags)
+{
+    const char *from;
+    char *new_flags;
+    char *to;
+
+    if (flags == NULL)  {
+	errno = EINVAL;
+	return NULL;
+    }
+
+    new_flags = malloc(strlen(flags) + 1);
+    if (new_flags == NULL)  {
+	return NULL;
+    }
+
+    from = flags;
+    to = new_flags;
+
+    do  {
+	switch (*from)  {
+	case 'N':
+	    /* N isn't allowed in fdopen, so skip. */
+	    ++from;
+	    break;
+
+#if defined(_O_WTEXT) || defined(_O_UTF8) || defined(_O_UTF16)
+	case 'c':
+	    if (strncmp(from, ccsStr, ccsStrLen) == 0)  {
+		/* found ccs= sequence */
+		memcpy(to, ccsStr, ccsStrLen);
+		from += ccsStrLen;
+		to += ccsStrLen;
+#ifdef _O_WTEXT
+		if (strncmp(from, unicodeStr, unicodeStrLen) == 0)  {
+		    /* found ccs=UNICODE sequence */
+		    memcpy(to, unicodeStr, unicodeStrLen);
+		    from += unicodeStrLen;
+		    to += unicodeStrLen;
+		}
+#endif
+#ifdef _O_UTF8
+		if (strncmp(from, utf8Str, utf8StrLen) == 0)  {
+		    /* found ccs=UTF8 sequence */
+		    memcpy(to, utf8Str, utf8StrLen);
+		    from += utf8StrLen;
+		    to += utf8StrLen;
+		    break;
+		}
+#endif
+#ifdef _O_UTF16
+		if (strncmp(from, utf16Str, utf16StrLen) == 0)  {
+		    /* found ccs=UTF16LE sequence */
+		    memcpy(to, utf16Str, utf16StrLen);
+		    from += utf16StrLen;
+		    to += utf16StrLen;
+		    break;
+		}
+#endif
+	    }
+	    /* no valid ccs sequence found */
+	    errno = EINVAL;
+	    free(new_flags);
+	    return NULL;
+#endif
+	default:
+	    *to++ = *from++;
+	    break;
+	}
+    }  while (*from);
+
+    /* null terminate the new flags string */
+    *to = 0;
+
+    return new_flags;
+}
+#endif
+
+
+/*
+ * Turn the file descriptor into a FILE*.  Return NULL if fd == -1.
  * close the file descriptor if the fdopen fails.
  */
-FILE* safe_fdopen(int fd, const char* flags)
+FILE *safe_fdopen(int fd, const char *flags)
 {
-    FILE* F;
+    FILE *F;
+#ifdef WIN32
+    char *new_flags;
+#endif
 
     if (fd == -1)  {
 	return NULL;
     }
 
+#ifdef WIN32
+    new_flags = fix_stdio_fdopen_mode_on_windows(flags);
+    if (new_flags == NULL)  {
+	close(fd);
+	errno = EINVAL;
+	return NULL;
+    }
+    flags = new_flags;
+#endif
+
     F = fdopen(fd, flags);
     if (!F)  {
 	(void)close(fd);
     }
 
+#ifdef WIN32
+    free(new_flags);
+#endif
+
     return F;
 }
 
@@ -301,7 +485,7 @@ FILE* safe_fdopen(int fd, const char* flags)
 
 
 /* replacement function for fopen, fails if fn is a symbolic links */
-FILE* safe_fopen_wrapper(const char *fn, const char *flags, mode_t mode)
+FILE *safe_fopen_wrapper(const char *fn, const char *flags, mode_t mode)
 {
     int create_file;
     int r;
@@ -323,7 +507,7 @@ FILE* safe_fopen_wrapper(const char *fn, const char *flags, mode_t mode)
 
 
 /* replacement function for fopen, follows existing symbolic links */
-FILE* safe_fopen_wrapper_follow(const char *fn, const char *flags, mode_t mode)
+FILE *safe_fopen_wrapper_follow(const char *fn, const char *flags, mode_t mode)
 {
     int create_file;
     int r;
@@ -341,4 +525,4 @@ FILE* safe_fopen_wrapper_follow(const char *fn, const char *flags, mode_t mode)
     f = safe_open_wrapper_follow(fn, open_flags, mode);
 
     return safe_fdopen(f, flags);
-}
\ No newline at end of file
+}
diff --git a/src/safefile/safe_fopen.h b/src/safefile/safe_fopen.h
index a7509da..e9bdf92 100644
--- a/src/safefile/safe_fopen.h
+++ b/src/safefile/safe_fopen.h
@@ -4,7 +4,7 @@
 /*
  * safefile package    http://www.cs.wisc.edu/~kupsch/safefile
  *
- * Copyright 2007-2008 James A. Kupsch
+ * Copyright 2007-2008, 2011 James A. Kupsch
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,7 +25,7 @@
 #include <sys/types.h>
 
 
-/* needed for FILE declaration, it is a typedef so an imcomplete struct will
+/* needed for FILE declaration, it is a typedef so an incomplete struct will
  * not work :(
  */
 #include <stdio.h>
@@ -39,8 +39,8 @@ extern "C"  {
 #else
 #define SAFE_OPEN_DEFAULT_MODE
 #endif
-#ifdef WIN32
-typedef unsigned short mode_t;
+#ifdef WIN32
+typedef unsigned short mode_t;
 #endif
 
 
@@ -48,13 +48,19 @@ typedef unsigned short mode_t;
  * Replacement functions for fopen.  These functions differ in the following
  * ways:
  *
- * 1) file creation is always done safely and the semantics are determined by
- *    which of the 6 functions is used.
+ * 1) file creation is always done safely with file creation semantics determined
+ *    by the choice of the 4 available functions, allowing semantics not possible
+ *    using fopen
  * 2) the default file permission is 0644 instead of 0666.  umask still applies.
- * 3) an optional permissions argument is allowed in C++ (required in C)
- * 4) in the case of "a", the file is opened with O_APPEND
+ * 3) a file permissions argument exists for file creation (optional in C++)
+ * 4) in the case of flags containing "a", the file is opened with O_APPEND
+ * 5) EINVAL is returned if the filename or flags are a NULL pointer, or the
+ *    first character of the flag is not a valid standard fopen flag value:  rwa
+ * 6) EEXISTS is returned if the final component is a symbolic link in both
+ *    the case of creating and of opening an existing file
  */
 
+
 /* create file, error if it exists, don't follow symbolic links */
 FILE* safe_fcreate_fail_if_exists(const char *fn, const char* flags,
 				mode_t mode SAFE_OPEN_DEFAULT_MODE);
@@ -77,7 +83,7 @@ FILE* safe_fopen_no_create_follow(const char* fn, const char* flags);
  * Wrapper functions for open/fopen replacements.  A simple replacement of the
  * existing function with these will result in symbolic links not being
  * followed and for a valid initial mode (file permissions) to always be
- * present.  In C the initial mode will have to be added where absent.
+ * present.  In C the initial mode will have to be added.
  */
 
 /* safe wrapper to fopen, do not follow final sym link */
diff --git a/src/safefile/safe_id_range_list.c b/src/safefile/safe_id_range_list.c
index 5b4c08f..7cfa5e9 100644
--- a/src/safefile/safe_id_range_list.c
+++ b/src/safefile/safe_id_range_list.c
@@ -560,7 +560,7 @@ id_t safe_strto_id(const char *value, const char **endptr)
  * 	<id> is of the form parsed by strto_id.  If the option '-' and second
  * 	<id> is not present, the first <id> is returned for both the minimum
  * 	and maximum value.  Since an <id> in a non-numeric form may contain a
- * 	'-', a space must preceed the '-' if the first <id> is in a non-numeric
+ * 	'-', a space must precede the '-' if the first <id> is in a non-numeric
  * 	form.  The value '*' as the second value specifies the maximum allowed
  * 	id (assumes id_t is an unsigned type, if it is unsigned the code will
  * 	work correctly, but '*' will not work.
@@ -623,7 +623,7 @@ static void strto_id_range(id_t *min_id, id_t *max_id, const char *value, const
 
 /*
  * strto_id_list
- * 	Adds the rnages in the value to the list.  Ranges are as specified in
+ * 	Adds the ranges in the value to the list.  Ranges are as specified in
  * 	strto_id_range, and there may be multiple ranges in value that are
  * 	separated by whitespace and a colon of the form:
  * 		<ID_RANGE> [ <SP>* ':' <SP>* <ID_RANGE> ]*
diff --git a/src/safefile/safe_id_range_list.h.in b/src/safefile/safe_id_range_list.h.in
index d1d0d80..367c43d 100644
--- a/src/safefile/safe_id_range_list.h.in
+++ b/src/safefile/safe_id_range_list.h.in
@@ -4,7 +4,7 @@
 /*
  * safefile package    http://www.cs.wisc.edu/~kupsch/safefile
  *
- * Copyright 2007-2008 James A. Kupsch
+ * Copyright 2007-2008, 2011 James A. Kupsch
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,9 +24,12 @@
 #include <sys/types.h>
 #include <unistd.h>
 #include <limits.h>
+
 #ifdef __cplusplus
 extern "C"  {
 #endif
+
+
 /* define id_t to uid_t if not defined */
 #undef id_t
 
@@ -63,6 +66,8 @@ void    safe_strto_gid_list(safe_id_range_list *list, const char *value, const c
 int     safe_parse_id_list(safe_id_range_list *list, const char *value);
 int     safe_parse_uid_list(safe_id_range_list *list, const char *value);
 int     safe_parse_gid_list(safe_id_range_list *list, const char *value);
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/safefile/safe_is_path_trusted.c b/src/safefile/safe_is_path_trusted.c
index 8651c4c..8f24f51 100644
--- a/src/safefile/safe_is_path_trusted.c
+++ b/src/safefile/safe_is_path_trusted.c
@@ -51,6 +51,7 @@
  * 	safe_gids
  * 		list of safe group ids
  * returns
+ *     -1   SAFE_PATH_ERROR
  *	0   SAFE_PATH_UNTRUSTED
  *	1   SAFE_PATH_TRUSTED_STICKY_DIR
  *	2   SAFE_PATH_TRUSTED
@@ -61,38 +62,51 @@ static int is_mode_trusted(struct stat *stat_buf, safe_id_range_list *trusted_ui
     mode_t	mode			= stat_buf->st_mode;
     uid_t	uid			= stat_buf->st_uid;
     gid_t	gid			= stat_buf->st_gid;
-    int		is_untrusted_uid	= (uid != 0 && !safe_is_id_in_list(trusted_uids, uid));
-    int		is_dir			= S_ISDIR(mode);
-    int		is_untrusted_group	= !safe_is_id_in_list(trusted_gids, gid);
-    int		is_untrusted_group_writable
-					= is_untrusted_group && (mode & S_IWGRP);
-    mode_t	is_other_writable	= (mode & S_IWOTH);
-    
-    int is_trusted = SAFE_PATH_UNTRUSTED;
-    
-    if (!(is_untrusted_uid || is_untrusted_group_writable || is_other_writable))  {
-	mode_t other_read_mask		= (mode_t)(is_dir ? S_IXOTH : S_IROTH);
-	mode_t is_other_readable	= (mode & other_read_mask);
+    int		uid_in_list		= safe_is_id_in_list(trusted_uids, uid);
+    int		gid_in_list		= safe_is_id_in_list(trusted_gids, gid);
+
+    if (uid_in_list == -1 || gid_in_list == -1)  {
+	return SAFE_PATH_ERROR;
+    }  else  {
+	int	is_trusted_uid		= uid == 0 || uid_in_list;
+	int	is_dir			= S_ISDIR(mode);
+	int	is_untrusted_gid	= !gid_in_list;
+	int	is_untrusted_gid_writable
+					= is_untrusted_gid && (mode & S_IWGRP);
+	mode_t	is_other_writable	= (mode & S_IWOTH);
+	
+	int is_trusted = SAFE_PATH_UNTRUSTED;
+	
+	if (is_trusted_uid && !is_untrusted_gid_writable && !is_other_writable)  {
+	    /* Path is trusted, now determine if it is confidential.
+	     * Do not allow viewing of directory entries or access to any of the
+	     * entries of a directory.  For other types do not allow read access.
+	     */
+	    mode_t gid_read_mask		= (mode_t)(is_dir ? (S_IXGRP | S_IRGRP) : S_IRGRP);
+	    int    is_untrusted_gid_readable	= is_untrusted_gid && (mode & gid_read_mask);
 
-	mode_t group_read_mask		= (mode_t)(is_dir ? S_IXGRP : S_IRGRP);
-	int is_untrusted_group_readable	= is_untrusted_group && (mode & group_read_mask);
+	    mode_t other_read_mask		= (mode_t)(is_dir ? (S_IXOTH | S_IROTH) : S_IROTH);
+	    mode_t is_other_readable		= (mode & other_read_mask);
 
-	if (is_other_readable || is_untrusted_group_readable)  {
+	    if (is_other_readable || is_untrusted_gid_readable)  {
+		is_trusted = SAFE_PATH_TRUSTED;
+	    }  else  {
+		is_trusted = SAFE_PATH_TRUSTED_CONFIDENTIAL;
+	    }
+	}  else if (S_ISLNK(mode))  {
+	    /* Symbolic links are trusted since they are immutable */
 	    is_trusted = SAFE_PATH_TRUSTED;
-	}  else  {
-	    is_trusted = SAFE_PATH_TRUSTED_CONFIDENTIAL;
-	}
-    }  else if (S_ISLNK(mode))  {
-	is_trusted = SAFE_PATH_TRUSTED;
-    }  else {
-	int	is_sticky_dir	= is_dir && (mode & S_ISVTX);
+	}  else {
+	    /* Directory with sticky bit set and trusted owner is trusted */
+	    int	is_sticky_dir	= is_dir && (mode & S_ISVTX);
 
-	if (is_sticky_dir && !is_untrusted_uid)  {
-	    is_trusted = SAFE_PATH_TRUSTED_STICKY_DIR;
+	    if (is_sticky_dir && is_trusted_uid)  {
+		is_trusted = SAFE_PATH_TRUSTED_STICKY_DIR;
+	    }
 	}
+	
+	return is_trusted;
     }
-    
-    return is_trusted;
 }
 
 
@@ -106,23 +120,23 @@ enum  {	PATH_U = SAFE_PATH_UNTRUSTED,
 
 /* trust composition table, given the trust of the parent directory and the child
  * this is only valid for directories.  is_component_in_dir_trusted() modifies it
- * slightly for other file system types
+ * slightly for other file system object types
  */
 static int trust_matrix[][4] = {
-	/*	parent\child | 	PATH_U	PATH_U	PATH_U	PATH_U	*/
+	/*	parent\child | 	PATH_U	PATH_S	PATH_T	PATH_C	*/
 	/*      ------          ------------------------------  */
 	/*	PATH_U  */  {	PATH_U,	PATH_U,	PATH_U,	PATH_U	},
 	/*	PATH_S  */  {	PATH_U,	PATH_S,	PATH_T,	PATH_C	},
 	/*	PATH_T  */  {	PATH_U,	PATH_S,	PATH_T,	PATH_C	},
 	/*	PATH_C  */  {	PATH_U,	PATH_S,	PATH_T,	PATH_C	}
-		       };
+};
 
 
 /*
  * is_component_in_dir_trusted
  * 	Returns trustedness of mode.  See trust_matrix above, plus if the
- * 	parent directory is a stick bit directory everything that can be
- * 	hard linked (everyting except directories) is SAFE_PATH_UNTRUSTED.
+ * 	parent directory is a stick bit directory every file system object
+ * 	that can be hard linked (all except directories) is SAFE_PATH_UNTRUSTED.
  * parameters
  * 	parent_dir_trust
  * 		trust level of parent directory
@@ -133,6 +147,7 @@ static int trust_matrix[][4] = {
  * 	safe_gids
  * 		list of safe group ids
  * returns
+ *     -1   SAFE_PATH_ERROR
  *	0   SAFE_PATH_UNTRUSTED
  *	1   SAFE_PATH_TRUSTED_STICKY_DIR
  *	2   SAFE_PATH_TRUSTED
@@ -147,15 +162,25 @@ static int is_component_in_dir_trusted(
 {
     int child_trust = is_mode_trusted(child_stat_buf, trusted_uids, trusted_gids);
 
-    int status = trust_matrix[parent_dir_trust][child_trust];
+    if (child_trust == SAFE_PATH_ERROR)  {
+	return child_trust;
+    }  else  {
+	int status = trust_matrix[parent_dir_trust][child_trust];
+
+	/* Fix trust of objects in a sticky bit directory.  Everything in them
+	 * should be considered untrusted except directories.  Any user can
+	 * create a hard link to any file system object except a directory.
+	 * Although the contents of the object may be trusted based on the
+	 * permissions, the directory entry itself could have been made by an
+	 * untrusted user.
+	 */
+	int is_dir = S_ISDIR(child_stat_buf->st_mode);
+	if (parent_dir_trust == SAFE_PATH_TRUSTED_STICKY_DIR && !is_dir)  {
+	    status = SAFE_PATH_UNTRUSTED;
+	}
 
-    int is_dir = S_ISDIR(child_stat_buf->st_mode);
-    if (parent_dir_trust == SAFE_PATH_TRUSTED_STICKY_DIR && !is_dir)  {
-	/* anything in a sticky bit directory is untrusted, except a directory */
-	status = SAFE_PATH_UNTRUSTED;
+	return status;
     }
-
-    return status;
 }
 
 
@@ -165,16 +190,15 @@ static int is_component_in_dir_trusted(
  * 	directory from here to the root is untrusted the path is untrusted,
  * 	otherwise it returns the trustedness of the current working directory.
  *
- * 	This function is not thread safe if other threads depend on the value
- * 	of the current working directory as it changes the current working
- * 	directory while checking the path and restores it on exit.
+ * 	This function is not thread safe.  The current working directory is
+ * 	changed while checking the path, and restores it on exit.
  * parameters
  * 	safe_uids
  * 		list of safe user ids
  * 	safe_gids
  * 		list of safe group ids
  * returns
- *	<0  on error
+ *     -1   SAFE_PATH_ERROR
  *	0   SAFE_PATH_UNTRUSTED
  *	1   SAFE_PATH_TRUSTED_STICKY_DIR
  *	2   SAFE_PATH_TRUSTED
@@ -206,7 +230,7 @@ static int is_current_working_directory_trusted(safe_id_range_list *trusted_uids
     }
 
 
-    /* Walk the directory tree, from the directory given to the root.
+    /* Walk the directory tree, from the current working directory to the root.
      *
      * If there is a directory that is_trusted_mode returns SAFE_PATH_UNTRUSTED
      * exit immediately with that value
@@ -215,17 +239,19 @@ static int is_current_working_directory_trusted(safe_id_range_list *trusted_uids
      */
     do  {
 	cur_status = is_mode_trusted(&cur_stat, trusted_uids, trusted_gids);
-	if (status == SAFE_PATH_UNTRUSTED)  {
-	    /* this is true only the first time through the loop (the cwd).
-	     * The return result is the value of the cwd.
-	     */
+	if (cur_status <= SAFE_PATH_UNTRUSTED)  {
+	    /* untrusted directory permissions or an error occurred */
 	    status = cur_status;
+	    goto restore_dir_and_exit;
 	}
 
-	if (cur_status == SAFE_PATH_UNTRUSTED)  {
-	    /* untrusted directory persmissions */
-	    status = SAFE_PATH_UNTRUSTED;
-	    goto restore_dir_and_exit;
+	if (status == SAFE_PATH_UNTRUSTED)  {
+	    /* This is true only the first time through the loop.  The
+	     * directory is the current work directory (cwd).  If the rest of
+	     * the path to the root is trusted, the trust of the cwd is the
+	     * value returned by this function.
+	     */
+	    status = cur_status;
 	}
 
 	prev_stat = cur_stat;
@@ -244,7 +270,7 @@ static int is_current_working_directory_trusted(safe_id_range_list *trusted_uids
 	    goto restore_dir_and_exit;
 	}
 
-	/* check if we are at the root directory */
+	/* check if we are at the root directory (parent of root is root) */
 	not_at_root = cur_stat.st_dev != prev_stat.st_dev || cur_stat.st_ino != prev_stat.st_ino;
 
 	if (not_at_root)  {
@@ -268,10 +294,8 @@ static int is_current_working_directory_trusted(safe_id_range_list *trusted_uids
 
 
   restore_dir_and_exit:
-    /* restore the old working directory & close open file descriptors if needed
-     * and return value 
-     */
 
+    /* restore cwd, close open file descriptors, return value */
     if (saved_dir != -1)  {
 	r = fchdir(saved_dir);
 	if (r == -1)  {
@@ -305,7 +329,7 @@ static int is_current_working_directory_trusted(safe_id_range_list *trusted_uids
  * 	safe_gids
  * 		list of safe group ids
  * returns
- *	<0  on error
+ *     -1   SAFE_PATH_ERROR
  *	0   SAFE_PATH_UNTRUSTED
  *	1   SAFE_PATH_TRUSTED_STICKY_DIR
  *	2   SAFE_PATH_TRUSTED
@@ -320,7 +344,7 @@ static int is_current_working_directory_trusted_r(safe_id_range_list *trusted_ui
     struct stat prev_stat;
     int not_at_root;
     char path[PATH_MAX] = ".";
-    char *path_end = &path[0];
+    char *path_end = &path[0];		/* points to null char, except on 1st pass */
 
     
     r = lstat(path, &cur_stat);
@@ -328,32 +352,35 @@ static int is_current_working_directory_trusted_r(safe_id_range_list *trusted_ui
 	return SAFE_PATH_ERROR;
     }
 
-    /* Walk the directory tree, from the directory given to the root.
+    /* Walk the directory tree, from the current working directory to the root.
      *
      * If there is a directory that is_trusted_mode returns SAFE_PATH_UNTRUSTED
-     * exit immediately with that value
+     * or SAFE_PATH_ERROR, exit immediately with that value
      *
      * Assumes no hard links to directories.
      */
     do  {
 	cur_status = is_mode_trusted(&cur_stat, trusted_uids, trusted_gids);
+	if (cur_status <= SAFE_PATH_UNTRUSTED)  {
+	    /* untrusted directory permissions or an error occurred */
+	    return cur_status;
+	}
+
 	if (status == SAFE_PATH_UNTRUSTED)  {
-	    /* this is true only the first time through the loop (the cwd).
-	     * The return result is the value of the cwd.
+	    /* This is true only the first time through the loop.  The
+	     * directory is the current work directory (cwd).  If the rest of
+	     * the path to the root is trusted, the trust of the cwd is the
+	     * value returned by this function.
 	     */
 	    status = cur_status;
 	}
 
-	if (cur_status == SAFE_PATH_UNTRUSTED)  {
-	    /* untrusted directory persmissions */
-	    return SAFE_PATH_UNTRUSTED;
-	}
-
 	prev_stat = cur_stat;
 
 	if (path_end != path)  {
 	    /* if not the first time through, append a directory separator */
-	    if ((size_t)(path_end - path + 1) > sizeof(path))  {
+	    if ((size_t)(path_end - path + 1) >= sizeof(path))  {
+		/* couldn't add 1 character */
 		errno = ENAMETOOLONG;
 		return SAFE_PATH_ERROR;
 	    }
@@ -362,8 +389,9 @@ static int is_current_working_directory_trusted_r(safe_id_range_list *trusted_ui
 	    *path_end   = '\0';
 	}
 
-	/* append a parent directory, .. */
-	if ((size_t)(path_end - path + 1) > sizeof(path))  {
+	/* append a parent directory, "..", or on the first pass set to ".."  */
+	if ((size_t)(path_end - path + 2) >= sizeof(path))  {
+	    /* couldn't add 2 characters */
 	    errno = ENAMETOOLONG;
 	    return SAFE_PATH_ERROR;
 	}
@@ -378,7 +406,7 @@ static int is_current_working_directory_trusted_r(safe_id_range_list *trusted_ui
 	    return SAFE_PATH_ERROR;
 	}
 
-	/* check if we are at the root directory */
+	/* check if we are at the root directory (parent of root is root) */
 	not_at_root = cur_stat.st_dev != prev_stat.st_dev || cur_stat.st_ino != prev_stat.st_ino;
     }  while (not_at_root);
 
@@ -395,11 +423,11 @@ static int is_current_working_directory_trusted_r(safe_id_range_list *trusted_ui
 
 typedef struct dir_stack  {
     struct dir_path  {
-	char *original_ptr;
-	char *cur_position;
+	char *original_ptr;	/* points to beginning of malloc'd buffer */
+	char *cur_position;	/* points to next component in path */
     }  stack[MAX_SYMLINK_DEPTH];
 
-    int  count;
+    int  count;			/* number of items on stack */
 }  dir_stack;
 
 
@@ -421,7 +449,7 @@ static void init_dir_stack(dir_stack* stack)
 
 /*
  * destroy_dir_stack
- * 	Destroy a dir_stack data structure, free's unfreed paths that have
+ * 	Destroy a dir_stack data structure by freeing paths that have
  * 	been pushed onto the stack
  * parameters
  * 	stack
@@ -446,7 +474,7 @@ static void destroy_dir_stack(dir_stack* stack)
  *	path
  *		path to push on the stack.  A copy is made.
  * returns
- *	0  on sucess
+ *	0  on success
  *	<0 on error (if the stack if contains MAX_SYMLINK_DEPTH directories
  *		errno = ELOOP for detecting symbolic link loops
  */
@@ -490,14 +518,14 @@ static int push_path_on_stack(dir_stack* stack, const char* path)
  *	path
  *		pointer to a pointer to store the next component
  * returns
- *	0  on sucess
+ *	0  on success
  *	<0 on stack empty
  */
 static int get_next_component(dir_stack* stack, const char **path)
 {
     while (stack->count > 0)  {
 	if (!*stack->stack[stack->count - 1].cur_position)  {
-	    /* current top is now empty, delete it, and try again */
+	    /* current top path is now empty, pop it, and try again */
 	    --stack->count;
 	    free(stack->stack[stack->count].original_ptr);
 	}  else  {
@@ -547,7 +575,7 @@ static int is_stack_empty(dir_stack* stack)
 {
     /* since the empty items are not removed until the next call to
      * get_next_component(), we need to check all the items on the stack
-     * and if any of them are not empty, return false, otherwise it truely
+     * and if any of them are not empty, return false, otherwise it truly
      * is empty.
      */
     int cur_head = stack->count - 1;
@@ -571,17 +599,17 @@ static int is_stack_empty(dir_stack* stack)
  * 	is_current_working_directory_trusted().
  *
  * 	This checks directory entry by directory entry for trustedness,
- * 	following symbolic links as discovered.  Non-directory entries in a
- * 	sticky bit directory are not trusted as untrusted users could have
- * 	hard linked an old file at that name.
+ * 	following the paths in symbolic links as discovered.  Non-directory
+ * 	entries in a sticky bit directory are not trusted as untrusted users
+ * 	could have hard linked an old file at that name.
  *
  * 	SAFE_PATH_UNTRUSTED is returned if the path is not trusted somewhere.
  * 	SAFE_PATH_TRUSTED_STICKY_DIR is returned if the path is trusted but ends
  * 		in a stick bit directory.  This path should only be used to
- * 		make a true temporaray file (opened using mkstemp(), and
+ * 		make a true temporary file (opened using mkstemp(), and
  * 		the pathname returned never used again except to remove the
  * 		file in the same process), or to create a directory.
- * 	SAFE_PATH_TRUSTED is returned only if the path given always referes to
+ * 	SAFE_PATH_TRUSTED is returned only if the path given always refers to
  * 		the same object and the object referred can not be modified.
  * 	SAFE_PATH_TRUSTED_CONFIDENTIAL is returned if the path is
  * 		SAFE_PATH_TRUSTED and the object referred to can not be read by
@@ -592,9 +620,8 @@ static int is_stack_empty(dir_stack* stack)
  * 		weak permissions in a confidential directory is not
  * 		confidential).
  *
- * 	This function is not thread safe if other threads depend on the value
- * 	of the current working directory as it changes the current working
- * 	directory while checking the path and restores it on exit.
+ * 	This function is not thread safe.  This function changes the current
+ * 	working directory while checking the path, and restores it on exit.
  * parameters
  * 	pathname
  * 		name of path to check
@@ -603,7 +630,7 @@ static int is_stack_empty(dir_stack* stack)
  * 	safe_gids
  * 		list of safe group ids
  * returns
- *	<0  on error
+ *     -1   SAFE_PATH_ERROR
  *	0   SAFE_PATH_UNTRUSTED
  *	1   SAFE_PATH_TRUSTED_STICKY_DIR
  *	2   SAFE_PATH_TRUSTED
@@ -613,7 +640,6 @@ int safe_is_path_trusted(const char *pathname, safe_id_range_list *trusted_uids,
 {
     int			r;
     int			status = SAFE_PATH_UNTRUSTED;
-    int			previous_status;
     int			num_tries;
     int			saved_dir;
     dir_stack		paths;
@@ -631,8 +657,7 @@ int safe_is_path_trusted(const char *pathname, safe_id_range_list *trusted_uids,
 	goto restore_dir_and_exit;
     }
 
-    /*
-     * If the path is relative, check that the current working directory is a
+    /* If the path is relative, check that the current working directory is a
      * trusted file system object.  If it is not then the path is not trusted
      */
     if (*pathname != '/')  {
@@ -645,7 +670,7 @@ int safe_is_path_trusted(const char *pathname, safe_id_range_list *trusted_uids,
     }
 
     /* start the stack with the pathname given */
-    if (push_path_on_stack(&paths, pathname))  {
+    if (push_path_on_stack(&paths, pathname) < 0)  {
 	status = SAFE_PATH_ERROR;
 	goto restore_dir_and_exit;
     }
@@ -666,8 +691,7 @@ int safe_is_path_trusted(const char *pathname, safe_id_range_list *trusted_uids,
 
 	prev_status = status;
 
-	/*
-	 * At this point if the directory component is '..', then the status
+	/* At this point if the directory component is '..', then the status
 	 * should be set to be that of the grandparent directory, '../..',
 	 * for the code below to work, which would require either recomputing
 	 * the value, or keeping a cache of the value (which could then be used
@@ -679,12 +703,11 @@ int safe_is_path_trusted(const char *pathname, safe_id_range_list *trusted_uids,
 	 *   3) the current trust level (status) is not SAFE_PATH_UNTRUSTED
 	 *   4) the trust matrix rows are the same, when the parent is not
 	 *      SAFE_PATH_UNTRUSTED
-	 * So not chnaging status will still result in the correct value
+	 * So not changing status will still result in the correct value
 	 *
 	 * WARNING: If any of these assumptions change, this will need to change.
 	 */
 
-	previous_status = status;
 	num_tries = 0;
 
       try_lstat_again:
@@ -725,8 +748,8 @@ int safe_is_path_trusted(const char *pathname, safe_id_range_list *trusted_uids,
 	    }
 
 	    /* Get the link's referent.  readlink does not null terminate.
-	     * Let it read one more than the size it is supposed to be to
-	     * detect truncation.
+	     * Set buffer size to one more than the size from lstat to detect
+	     * truncation.
 	     */
 	    readlink_len = readlink(path, link_path, link_path_len + 1);
 	    if (readlink_len == -1)  {
@@ -738,7 +761,7 @@ int safe_is_path_trusted(const char *pathname, safe_id_range_list *trusted_uids,
 	    /* check for truncation of value */
 	    if ((size_t)readlink_len > link_path_len)  {
 		free(link_path);
-		status = previous_status;
+		status = prev_status;
 		goto try_lstat_again;
 	    }
 
@@ -746,7 +769,7 @@ int safe_is_path_trusted(const char *pathname, safe_id_range_list *trusted_uids,
 	    link_path[readlink_len] = '\0';
 
 	    /* add the path of the referent to the stack */
-	    if (push_path_on_stack(&paths, link_path))  {
+	    if (push_path_on_stack(&paths, link_path) < 0)  {
 		free(link_path);
 		status = SAFE_PATH_ERROR;
 		goto restore_dir_and_exit;
@@ -759,8 +782,9 @@ int safe_is_path_trusted(const char *pathname, safe_id_range_list *trusted_uids,
 
 	    continue;
 	}  else if (!is_stack_empty(&paths))  {
-	    /* more components remaining, change directory
-	     * it is not a sym link, so it must be a directory, or an error
+	    /* More components remain, so change current working directory.
+	     * path is not a symbolic link, if it is not a directory, chdir
+	     * will fail and set errno to the proper value we want.
 	     */
 	    r = chdir(path);
 	    if (r == -1)  {
@@ -773,8 +797,7 @@ int safe_is_path_trusted(const char *pathname, safe_id_range_list *trusted_uids,
 
   restore_dir_and_exit:
 
-    /* restore original directory if needed and return value */
-
+    /* free memory, restore cwd, and return value */
     destroy_dir_stack(&paths);
 
     if (saved_dir != -1)  {
@@ -788,7 +811,6 @@ int safe_is_path_trusted(const char *pathname, safe_id_range_list *trusted_uids,
 	}
     }
 
-
     return status;
 }
 
@@ -799,33 +821,33 @@ int safe_is_path_trusted(const char *pathname, safe_id_range_list *trusted_uids,
  *
  * 	Returns the trustedness of the path.
  *
- * 	This functino is thread/signal handler safe in that it does not change
- * 	the current working directory.  It does fork the process to return do
- * 	the check, which changes the new process's current working directory as
- * 	it does the checks by calling safe_is_path_trusted().
+ * 	This function is thread/signal handler safe in that it does not change
+ * 	the current working directory.  It forks a process to do the check, the
+ * 	new process changes itscurrent working directory as it does the checks
+ * 	by calling safe_is_path_trusted().
  *
  * 	If the path is relative the path from the current working directory to
  * 	the root must be trusted as defined in
  * 	is_current_working_directory_trusted().
  *
  * 	This checks directory entry by directory entry for trustedness,
- * 	following symbolic links as discovered.  Non-directory entries in a
- * 	sticky bit directory are not trusted as untrusted users could have
- * 	hard linked an old file at that name.
+ * 	following the paths in symbolic links as discovered.  Non-directory
+ * 	entries in a sticky bit directory are not trusted as untrusted users
+ * 	could have hard linked an old file at that name.
  *
  * 	SAFE_PATH_UNTRUSTED is returned if the path is not trusted somewhere.
  * 	SAFE_PATH_TRUSTED_STICKY_DIR is returned if the path is trusted but ends
  * 		in a stick bit directory.  This path should only be used to
- * 		make a true temporaray file (opened using mkstemp(), and
+ * 		make a true temporary file (opened using mkstemp(), and
  * 		the pathname returned never used again except to remove the
  * 		file in the same process), or to create a directory.
- * 	SAFE_PATH_TRUSTED is returned only if the path given always referes to
+ * 	SAFE_PATH_TRUSTED is returned only if the path given always refers to
  * 		the same object and the object referred can not be modified.
  * 	SAFE_PATH_TRUSTED_CONFIDENTIAL is returned if the path is
  * 		SAFE_PATH_TRUSTED and the object referred to can not be read by
  * 		untrusted users.  This assumes the permissions on the object
  * 		were always strong enough to return this during the life of the
- * 		object.  This confidentiality is only based on the the actual
+ * 		object.  This confidentiality is only based on the actual
  * 		object, not the containing directories (for example a file with
  * 		weak permissions in a confidential directory is not
  * 		confidential).
@@ -838,7 +860,7 @@ int safe_is_path_trusted(const char *pathname, safe_id_range_list *trusted_uids,
  * 	safe_gids
  * 		list of safe group ids
  * returns
- *	<0  on error
+ *     -1   SAFE_PATH_ERROR
  *	0   SAFE_PATH_UNTRUSTED
  *	1   SAFE_PATH_TRUSTED_STICKY_DIR
  *	2   SAFE_PATH_TRUSTED
@@ -1012,7 +1034,7 @@ int safe_is_path_trusted_fork(const char *pathname, safe_id_range_list *trusted_
 /*
  * append_dir_entry_to_path
  *
- * 	Creates a new path that starts in "path" and moves to "name".  Path are
+ * 	Creates a new path that starts in "path" and moves to "name".  Path and
  * 	name are both assumed to contain no symbolic links.
  *
  * 	If name is "/", path is set to "/".  If name is "" or ".", path is
@@ -1116,23 +1138,23 @@ static int append_dir_entry_to_path(char *path, char **path_end, char *buf_end,
  * 	is_current_working_directory_trusted().
  *
  * 	This checks directory entry by directory entry for trustedness,
- * 	following symbolic links as discovered.  Non-directory entries in a
- * 	sticky bit directory are not trusted as untrusted users could have
- * 	hard linked an old file at that name.
+ * 	following the paths in symbolic links as discovered.  Non-directory
+ * 	entries in a sticky bit directory are not trusted as untrusted users
+ * 	could have hard linked an old file at that name.
  *
  * 	SAFE_PATH_UNTRUSTED is returned if the path is not trusted somewhere.
  * 	SAFE_PATH_TRUSTED_STICKY_DIR is returned if the path is trusted but ends
  * 		in a stick bit directory.  This path should only be used to
- * 		make a true temporaray file (opened using mkstemp(), and
+ * 		make a true temporary file (opened using mkstemp(), and
  * 		the pathname returned never used again except to remove the
  * 		file in the same process), or to create a directory.
- * 	SAFE_PATH_TRUSTED is returned only if the path given always referes to
+ * 	SAFE_PATH_TRUSTED is returned only if the path given always refers to
  * 		the same object and the object referred can not be modified.
  * 	SAFE_PATH_TRUSTED_CONFIDENTIAL is returned if the path is
  * 		SAFE_PATH_TRUSTED and the object referred to can not be read by
  * 		untrusted users.  This assumes the permissions on the object
  * 		were always strong enough to return this during the life of the
- * 		object.  This confidentiality is only based on the the actual
+ * 		object.  This confidentiality is only based on the actual
  * 		object, not the containing directories (for example a file with
  * 		weak permissions in a confidential directory is not
  * 		confidential).
@@ -1144,7 +1166,7 @@ static int append_dir_entry_to_path(char *path, char **path_end, char *buf_end,
  * 	safe_gids
  * 		list of safe group ids
  * returns
- *	<0  on error
+ *     -1   SAFE_PATH_ERROR
  *	0   SAFE_PATH_UNTRUSTED
  *	1   SAFE_PATH_TRUSTED_STICKY_DIR
  *	2   SAFE_PATH_TRUSTED
@@ -1154,7 +1176,6 @@ int safe_is_path_trusted_r(const char *pathname, safe_id_range_list *trusted_uid
 {
     int			r;
     int			status = SAFE_PATH_UNTRUSTED;
-    int			previous_status;
     int			num_tries;
     dir_stack		paths;
     const char		*comp_name;
@@ -1179,7 +1200,7 @@ int safe_is_path_trusted_r(const char *pathname, safe_id_range_list *trusted_uid
     }
 
     /* start the stack with the pathname given */
-    if (push_path_on_stack(&paths, pathname))  {
+    if (push_path_on_stack(&paths, pathname) < 0)  {
 	status = SAFE_PATH_ERROR;
 	goto cleanup_and_exit;
     }
@@ -1207,8 +1228,7 @@ int safe_is_path_trusted_r(const char *pathname, safe_id_range_list *trusted_uid
 	    goto cleanup_and_exit;
 	}
 
-	/*
-	 * At this point if the directory component is '..', then the status
+	/* At this point if the directory component is '..', then the status
 	 * should be set to be that of the grandparent directory, '../..',
 	 * for the code below to work, which would require either recomputing
 	 * the value, or keeping a cache of the value (which could then be used
@@ -1220,12 +1240,11 @@ int safe_is_path_trusted_r(const char *pathname, safe_id_range_list *trusted_uid
 	 *   3) the current trust level (status) is not SAFE_PATH_UNTRUSTED
 	 *   4) the trust matrix rows are the same, when the parent is not
 	 *      SAFE_PATH_UNTRUSTED
-	 * So not chnaging status will still result in the correct value
+	 * So not changing status will still result in the correct value
 	 *
 	 * WARNING: If any of these assumptions change, this will need to change.
 	 */
 
-	previous_status = status;
 	num_tries = 0;
 
       try_lstat_again:
@@ -1265,8 +1284,8 @@ int safe_is_path_trusted_r(const char *pathname, safe_id_range_list *trusted_uid
 	    }
 
 	    /* Get the link's referent.  readlink does not null terminate.
-	     * Let it read on emore that the size it is supposed to be to
-	     * detect truncation.
+	     * Set buffer size to one more than the size from lstat to detect
+	     * truncation.
 	     */
 	    readlink_len = readlink(path, link_path, link_path_len + 1);
 	    if (readlink_len == -1)  {
@@ -1277,7 +1296,7 @@ int safe_is_path_trusted_r(const char *pathname, safe_id_range_list *trusted_uid
 
 	    if ((size_t)readlink_len > link_path_len)  {
 		free(link_path);
-		status = previous_status;
+		status = prev_status;
 		goto try_lstat_again;
 	    }
 
@@ -1285,7 +1304,7 @@ int safe_is_path_trusted_r(const char *pathname, safe_id_range_list *trusted_uid
 	    link_path[readlink_len] = '\0';
 
 	    /* add path to the stack */
-	    if (push_path_on_stack(&paths, link_path))  {
+	    if (push_path_on_stack(&paths, link_path) < 0)  {
 		free(link_path);
 		status = SAFE_PATH_ERROR;
 		goto cleanup_and_exit;
@@ -1309,7 +1328,7 @@ int safe_is_path_trusted_r(const char *pathname, safe_id_range_list *trusted_uid
 
   cleanup_and_exit:
 
-    /* restore original directory if needed and return value */
+    /* free memory, restore cwd, and return value */
     destroy_dir_stack(&paths);
 
     /* if this algorithm failed because the pathname was too long,
diff --git a/src/safefile/safe_is_path_trusted.h b/src/safefile/safe_is_path_trusted.h
index e34fcfa..367d034 100644
--- a/src/safefile/safe_is_path_trusted.h
+++ b/src/safefile/safe_is_path_trusted.h
@@ -4,7 +4,7 @@
 /*
  * safefile package    http://www.cs.wisc.edu/~kupsch/safefile
  *
- * Copyright 2007-2008 James A. Kupsch
+ * Copyright 2007-2008, 2011 James A. Kupsch
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,9 +22,11 @@
 
 #include <sys/stat.h>
 #include <sys/types.h>
-#ifdef __cplusplus
+
+#ifdef _cplusplus
 extern "C"  {
 #endif
+
 struct safe_id_range_list;
 
 #ifndef SAFE_IS_PATH_TRUSTED_RETRY_MAX
@@ -57,7 +59,9 @@ int safe_is_path_trusted_r(
 	    struct safe_id_range_list	*trusted_gids
 	);
 
-#ifdef __cplusplus
+
+#ifdef _cplusplus
 }
 #endif
+
 #endif
diff --git a/src/safefile/safe_open.cpp b/src/safefile/safe_open.cpp
index e3bb6da..c6b74ef 100644
--- a/src/safefile/safe_open.cpp
+++ b/src/safefile/safe_open.cpp
@@ -28,7 +28,7 @@
 #include <errno.h>
 #include <stdio.h>
 #include "safe_open.h"
-
+#include <Windows.h>
 
 
 /*
@@ -113,7 +113,7 @@ int safe_open_no_create(const char *fn, int flags)
      * first and succeeds, the device and inode pair cannot be reused before
      * the lstat.  If they are done the other way around an attacker can stop
      * or slow the process and wait for the lstat'd file to be deleted, then a
-     * file with the same deveice and inode is created by the attacker or a
+     * file with the same device and inode is created by the attacker or a
      * victim and a symbolic at the filename can point to the new file and it
      * will appear to match and not be a symbolic link.
      */
@@ -143,7 +143,7 @@ int safe_open_no_create(const char *fn, int flags)
     }
 
     /* Check if lstat fn is a symbolic link.  This is an error no matter what
-     * the result of the open was.  return an error of EEXIST.
+     * the result of the open was.  Return an error of EEXIST.
      */
     if (S_ISLNK(lstat_buf.st_mode))  {
 	if (f != -1)  {
@@ -162,7 +162,7 @@ int safe_open_no_create(const char *fn, int flags)
 	    /* Since this is not a symbolic link, the only way this could have
 	     * happened is if during the open the entry was a dangling symbolic
 	     * link or didn't exist, and during the lstat it exists and is not
-	     * a symbolic link.  try again to get a consistent open/lstat.
+	     * a symbolic link.  Try again to get a consistent open/lstat.
 	     */
 
 	    goto TRY_AGAIN;
@@ -194,7 +194,7 @@ int safe_open_no_create(const char *fn, int flags)
     }
 	
     /* Check if the immutable properties (device, inode and type) of the file
-     * system object opened match (fstat_buf) those of the dirctory entry
+     * system object opened match (fstat_buf) those of the directory entry
      * (lstat_buf).
      */
     if (    lstat_buf.st_dev != fstat_buf.st_dev
@@ -215,13 +215,13 @@ int safe_open_no_create(const char *fn, int flags)
      */
 
     /* Check if we still need to truncate the file.  POSIX says to ignore the
-     * truncate flage if the file type is a fifo or it is a tty.  Otherwise if
+     * truncate flag if the file type is a fifo or it is a tty.  Otherwise if
      * it is not * a regular file, POSIX says the behavior is implementation
-     * definded.
+     * defined.
      *
-     * Do not do the trunccate if the file is already 0 in size.  This also
+     * Do not do the truncate if the file is already 0 in size.  This also
      * prevents some unspecified behavior in truncate file types which are not
-     * regular, fifo's or tty's, such as device files like /dev/null.  on some
+     * regular, fifo's or tty's, such as device files like /dev/null.  On some
      * platforms O_CREAT|O_WRONLY|O_TRUNC works properly on /dev/null, but
      * O_WRONLY|O_TRUNC fails.
      */
@@ -283,7 +283,7 @@ int safe_create_keep_if_exists(const char *fn, int flags, mode_t mode)
 
     /* Loop alternating between creating the file (and failing if it exists)
      * and opening an existing file.  Return an error if any error occurs other
-     * than an indication that the other function should work.
+     * than an indication that the other open method should work.
      */
     while (f == -1)  {
 	/* If this is the second or subsequent attempt, then someone is
@@ -325,7 +325,7 @@ int safe_create_keep_if_exists(const char *fn, int flags, mode_t mode)
 	}
     }
 
-    /* no error, restore errno incase we had recoverable failures */
+    /* no error, restore errno in case we had recoverable failures */
     errno = saved_errno;
 
     return f;
@@ -389,7 +389,7 @@ int safe_create_replace_if_exists(const char *fn, int flags, mode_t mode)
 	 */
     }
 
-    /* no error, restore errno incase we had recoverable failures */
+    /* no error, restore errno in case we had recoverable failures */
     errno = saved_errno;
 
     return f;
@@ -436,11 +436,11 @@ int safe_open_no_create_follow(const char *fn, int flags)
 	}
 	
 	/* Check if we still need to truncate the file.  POSIX says to ignore
-	 * the truncate flage if the file type is a fifo or it is a tty.
+	 * the truncate flag if the file type is a fifo or it is a tty.
 	 * Otherwise if it is not * a regular file, POSIX says the behavior is
-	 * implementation definded.
+	 * implementation defined.
 	 *
-	 * Do not do the trunccate if the file is already 0 in size.  This also
+	 * Do not do the truncate if the file is already 0 in size.  This also
 	 * prevents some unspecified behavior in truncate file types which are
 	 * not regular, fifo's or tty's, such as device files like /dev/null.
 	 * on some platforms O_CREAT|O_WRONLY|O_TRUNC works properly on
@@ -486,7 +486,7 @@ int safe_create_keep_if_exists_follow(const char *fn, int flags, mode_t mode)
      */
     flags &= ~O_CREAT & ~O_EXCL;
 
-    /* Loop atternating between creating the file (and failing if it exists)
+    /* Loop alternating between creating the file (and failing if it exists)
      * and opening an existing file.  Return an error if any error occurs other
      * than an indication that the other function should work.
      */
@@ -530,7 +530,7 @@ int safe_create_keep_if_exists_follow(const char *fn, int flags, mode_t mode)
 		/* At this point, creating the file returned EEXIST and opening
 		 * the file returned ENOENT.  Either the file did exist during
 		 * the attempt to create the file and was removed before the
-		 * open, or the file was dangling symoblic link.  If it is a
+		 * open, or the file was dangling symbolic link.  If it is a
 		 * dangling symbolic link we want to return ENOENT and if not
 		 * we should retry.
 		 */
@@ -540,7 +540,7 @@ int safe_create_keep_if_exists_follow(const char *fn, int flags, mode_t mode)
 		    return -1;
 		}
 
-		/* lstat succeeded check if directory entry is a symobolic
+		/* lstat succeeded check if directory entry is a symbolic
 		 * link.
 		 */
 		if (S_ISLNK(lstat_buf.st_mode))  {
@@ -556,7 +556,7 @@ int safe_create_keep_if_exists_follow(const char *fn, int flags, mode_t mode)
 	}
     }
 
-    /* no error, restore errno incase we had recoverable failures */
+    /* no error, restore errno in case we had recoverable failures */
     errno = saved_errno;
 
     return f;
@@ -633,4 +633,4 @@ int safe_open_path_warning(const char *fn)
     }
 
     return f(fn);
-}
\ No newline at end of file
+}
diff --git a/src/safefile/safe_open.h b/src/safefile/safe_open.h
index 78577b1..1e5c578 100644
--- a/src/safefile/safe_open.h
+++ b/src/safefile/safe_open.h
@@ -4,7 +4,7 @@
 /*
  * safefile package    http://www.cs.wisc.edu/~kupsch/safefile
  *
- * Copyright 2007-2008 James A. Kupsch
+ * Copyright 2007-2008, 2011 James A. Kupsch
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -27,9 +27,7 @@
 typedef unsigned short mode_t;
 #endif
 
-/* needed for FILE declaration, it is a typedef so an imcomplete struct will
- * not work :(
- */
+
 #ifdef __cplusplus
 extern "C"  {
 #ifndef SAFE_OPEN_DEFAULT_MODE_VALUE
@@ -103,7 +101,7 @@ int safe_open_wrapper_follow(const char *fn, int flags,
  *
  * If any of the open/create functions detect the file system object has
  * changed (removed, added or replaced) during their operation, the callback
- * function will be called with the file name
+ * function will be called with the file name.
  */
 
 /* type of the callback function */
