{"id": 7107, "title": "Ticket #7107: Wrong semantics for Python bindings ExprTree equality", "description": "<blockquote>\nWhile trying to write some tests for <code>htcondor-jobs</code>, I ran into the following weirdness:\n\n<p></p><div class=\"code\">\n<pre class=\"code\">In [1]: import classad\n\nIn [2]: a = classad.ExprTree('a')\n\nIn [3]: a_again = classad.ExprTree('a')\n\nIn [5]: expr = (a == a_again)\n\nIn [6]: expr\nOut[6]: a == a\n\nIn [7]: type(expr)\nOut[7]: classad._classad.ExprTree\n\nIn [9]: bool(expr)\nOut[9]: False\n\nIn [10]: a &lt; a_again\nOut[10]: a &lt; a\n</pre></div>\n\n\n<p>While this is quite sensible from the perspective of the actual <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span> language, it's total gibberish in Python. Equality operators must return booleans, by contract. For example, the semantics of == should be the same as\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">In [8]: str(a) == str(a_again)\nOut[8]: True\n</pre></div>\n\n\n<p>This will make <code>ExprTree</code> and therefore <code>ClassAd</code> play much more nicely with standard Python. For example, right now, even if two <code>ClassAd</code> contain all the same keys and values, if any of those values are expressions, <code>dict(classad)</code> will not compare equal to each other because of the <code>bool(expr)</code> example above.\n\n</p><p>Proposal:\n</p><ul>\n<li><code>__eq__</code> should check whether two expressions are literally the same expression. The other overloaded boolean operators should be removed.\n</li><li>Add a new set of <code>ExprTree</code> methods which express the various <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span> comparisons.\n</li><li><code>ClassAd.__eq__</code> should behave exactly like <code>dict.__eq__</code> (equal if and only if all keys and values compare equal).\n</li></ul>\n\n<p>This is unfortunate, because the operator overloading on <code>ExprTree</code> is very clever, but ultimately it's very confusing for doing anything other than building <code>ExprTree</code>. Is there a compelling reason to break the boolean comparison contract here?</p></blockquote>", "remarks": "<blockquote>\n<em>2019-Jun-13 08:16:34 by bbockelm:</em> <br/>\n\nI disagree.  This is where the semantics of <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAds\" title=\"Class Ads\">ClassAds</a></span> are different than python and relevant.\n\n<p></p><div class=\"code\">\n<pre class=\"code\">ExprTree('a == a')\n</pre></div>\n\n\n<p>Evaluates to <code>undefined</code>; in terms of <code>if</code> statements, it evaluates to false.  That is,\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">if ExprTree('a == a'):\n   print(\"foo\")\n</pre></div>\n\n\n<p>will not print <code>foo</code>.  This is how the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span> language works.  The only questionable matter in this case is whether <code>undefined</code> should map to <code>False</code> or throw an exception.  Possibly an exception is better, but the die is cast...\n\n</p><p>To quote the python data model:\n\n</p><p></p><div class=\"blockquote\">\n<table width=\"95%\"><tbody><tr><td>\u00a0</td><td>\n  \nBy convention, False and True are returned for a successful comparison. However, these methods can return any value, so if the comparison operator is used in a Boolean context (e.g., in the condition of an if statement), Python will call bool() on the value to determine if the result is true or false.\n</td></tr></tbody></table></div>\n\n\n<p>Even if <code>ExprTree('a').__eq__(ExprTree('a'))</code> returns a boolean, I'd still argue the correct boolean is <code>False</code> (or throwing an undefined comparison exception).\n\n</p><p>Long story short, I think this is correct behavior:\n</p><div class=\"code\">\n<pre class=\"code\">&gt;&gt;&gt; {\"1\": classad.ExprTree('1')} == {\"1\": classad.ExprTree('1')}\nTrue\n&gt;&gt;&gt; {\"1\": classad.ExprTree('a')} == {\"1\": classad.ExprTree('a')}\nFalse\n</pre></div>\n\n\n<p>It's just unfortunate that <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAds\" title=\"Class Ads\">ClassAds</a></span> makes a distinction between equality and the <code>sameAs</code> operator.  The three different <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span> concepts of \"equality\" are always going to be tough to map to Python\n\n</p><p>Now, one thing that is really just wacky is that the <code>Undefined</code> bool operator is not overloaded resulting in the integer <code>__bool__</code> being used.  Look at this nonsense:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">&gt;&gt;&gt; if classad.ExprTree(\"undefined\"):\n...   print \"foo\"\n...\n&gt;&gt;&gt; if classad.ExprTree(\"undefined\").eval():\n...   print \"foo\"\n...\nfoo\n&gt;&gt;&gt; if classad.ExprTree(\"error\"):\n...   print \"foo\"\n...\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nRuntimeError: Unable to evaluate expression.\n&gt;&gt;&gt; if classad.ExprTree(\"error\").eval():\n...   print \"foo\"\n...\nfoo\n</pre></div>\n\n\n<p><em>That</em> seems worth fixing.</p></blockquote>", "derived_tickets": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">\n<span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=7109\" onclick=\"get_ticket_and_populate_wrapper('7109'); return false;\" title=\"Provide reasonable overloads for Undefined / Error in python\">#7109</a></span></td>\n<td align=\"center\" valign=\"center\" width=\"30\">\n<span class=\"icon ptr1\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\">\nProvide reasonable overloads for Undefined / Error in python</td></tr>\n</tbody></table>", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "defect", "last_change": "2019-Jun-13 08:16", "status": "new", "created": "2019-Jun-12 12:43", "fixed_version": "2019-Jun-12 12:43", "broken_version": "", "priority": "3", "subsystem": "PythonBinding", "assigned_to": "bbockelm", "derived_from": "", "creator": "karpel", "rust": "", "customer_group": "other", "visibility": "public", "notify": "karpel@wisc.edu, johnkn@cs.wisc.edu, bbockelman@morgridge.org", "due_date": ""}