{"id": 1215, "title": "Ticket #1215: job_queue.log can be corrupted in case of rotation failure", "description": "<blockquote>\nCaused by a recent Windows problem (see gittrac <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=1191\" onclick=\"get_ticket_and_populate_wrapper('1191'); return false;\" title=\"Windows job_queue.log rotation not atomic\">#1191</a></span> ), we inspected the behavior of job_queue.log rotation a bit more closely. Turns out, in case of rotation failure, the old rotation file will be reopened with <code>O_RDWR</code> flag but without <code>O_APPEND</code>. Thus, future writers will start in the beginning of the file and therefore may produce nonsense for the schedd. That is, if the amount of data to be written in a schedd uptime does not exceed the amount of data written during the last session, the file's tail still consists of the old data. This will cause any future schedd to terminate until the job_queue.log file is manually deleted.\n\n<p>The responsible code is the following (in <code>bool ClassAdLog::TruncLog()</code> in condor_c++_util/classad_log.cpp ):\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">\tif (rotate_file(tmp_log_filename.Value(), logFilename()) &lt; 0) {\n\t\tdprintf(D_ALWAYS, \"failed to rotate job queue log!\\n\");\n\n\t\t// Beat a hasty retreat into the past.\n\t\thistorical_sequence_number--;\n\n\t\tint log_fd = safe_open_wrapper(logFilename(), O_RDWR | O_LARGEFILE, 0600);\n\t\tif (log_fd &lt; 0) {\n\t\t\tEXCEPT(\"failed to reopen log %s, errno = %d after failing to rotate log.\",logFilename(),errno);\n\t\t}\n\n\t\tlog_fp = fdopen(log_fd, \"r+\");\n\t\tif (log_fp == NULL) {\n\t\t\tEXCEPT(\"failed to refdopen log %s, errno = %d after failing to rotate log.\",logFilename(),errno);\n\t\t}\n\n\t\treturn false;\n\t}\n</pre></div>\n\n\n<p>Obviously, on Linux it happens extremely rarely that a file rotation (i.e. a rename) does not succeed. As for Windows, it will fail if either file has another file descriptor open.\n\n</p><p></p><hr/>\n<strong>Now, when exactly would this cause bad things?</strong>\n\n<p>The job queue will get corrupted if the following conditions are met:\n\n</p><p></p><ul>\n<li><code>rotate_file(.. )</code> returns a negative integer, i.e. <code>rename(..)</code> fails on POSIX or <code>MoveFileEx(..)</code> on WIN32.\n<ul>\n<li><code>rename(..)</code> will only in very rare occasions fail. One scenario that comes to mind would be a disk failure.\n</li><li><code>MoveFileEx(..)</code> in this scenario will fail if either the renaming file or the to be renamed file have another file descriptor open (which might be caused by a file-scanning anti-virus program or backup tool, for example)\n</li></ul>\n</li><li>The corresponding code block is executed, and <code>job_queue.log</code> therefore opened with <code>O_RDWR</code> flag only.\n</li><li>As a result, the next write to the job queue will start in the beginning of the file without truncating it.\n</li><li>In case the old data will eventually entirely overwritten before the schedd's next restart, everything is ok.\n</li><li>If the schedd terminates before the old data is entirely overwritten, this means that the file tail constitutes garbage which therefore renders the whole file to nonsense to the schedd upon restart. As a result the schedd will immediately terminate until the <code>job_queue.log</code> is manually deleted.\n</li><li>manual deletion of the job queue will cause a loss of job information, and therefore: jobs\n</li></ul>\n\n<p>Another (WIN32-only) quirk is the not necessarily atomic nature of <code>MoveFileEx(..)</code>, which potentially could leave the job queue in a corrupted state (for example in case of a sudden reboot while rotating)\n\n</p><p></p><hr/>\nI would like to collect some comments about how to deal with this problem. Some suggestions:\n\n<p>a) Reopen the old file with  <code>O_RDWR | O_APPPEND | O_LARGEFILE</code> . This will leave the file intact. On the downside, if the rotation is caused by a clean-up due to a dirty job queue (see <code>CleanJobQueue()</code> in condor_schedd.V6/qmgmt.cpp ), then some written changes will be expected (done by the function <code>void ClassAdLog::LogState(FILE *fp)</code> ). <br/>\n\nAnother problem with this is that, in theory, <code>job_queue.log</code> might never be rotated and grow indefinitely. This would be unacceptable.\n\n</p><p>b) Truncating the old file by setting the flag <code>O_TRUNC</code>. This will lead to a correct reinitialization of the file for the schedd and also avoid indefinite growth. But it can cause problems if, for example, quill is currently reading the <code>job_queue.log</code>. Additionally, there may be third-party tools beyond Condor's control that regularly read this file and therefore could get into trouble with this solution.\n\n</p><p>Thoughts, comments?</p></blockquote>", "remarks": "<blockquote>\n<em>2010-Feb-15 13:51:29 by matt:</em> <br/>\n\nFirst thought is that this seems like a rather major issue, even if rare.\n\n<p>Second, use of Quill (deprecated?) or the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=JobRouter\" title=\"Job Router\">JobRouter</a></span> (nice and new) will make this more likely to happen.\n\n</p><p>Does (b) suggest there will be a window where the only copy of the queue will be in the Schedd's memory? If so that seems like a dangerous solution. The typical solution to problems like this is to EXCEPT, and it looks like the intent of the original code was to just continue on. That suggests (a) as a better solution.\n\n</p><p>Though (a) has a downside of indefinite job_queue.log growth, since we can rank sins, that's a less serious one than losing the queue altogether.\n\n</p><p></p><hr/>\n<em>2010-Feb-17 16:56:16 by danb:</em> <br/>\n\nCathrin, I looked at the patch.  It looks good to me, except I am a little worried about an upper bound of 30 seconds of sleep time in rotate_file().  I would be more comfortable with an upper bound of ~2 seconds.\n\n<p>Regarding the question you pose in the comment after reopening the file.  No, we definitely do not want to call LogState() on the reopened file.  We want to just continue appending to the file as if we had never attempted to rotate the file.  That way we are assured that at all times, the contents of the log can be used to reconstruct the in-memory classad collection.\n\n</p><p>In your description of the problem in this ticket, you say that the job queue is corrupted and therefore information is lost if the schedd does not write beyond the existing contents of the file.  However, even if the schedd writes beyond the end, the information it has overwritten is lost, so the job queue might not be reconstructable from the contents of the log.\n\n</p><p></p><hr/>\n<em>2010-Feb-17 17:09:22 by matt:</em> <br/>\n\nI am seriously concerned about any sleep() placed in the code, doubly concerned in the Schedd.\n\n<p>The Schedd is not a multi-threaded daemon, any sleep will completely block all functions, not limited to: responding to condor_q, participating in negotiation (actually may block the negotiator indirectly), responding to shadows, sending keep alives to its master.\n\n</p><p>In all situations we should return to DC::Driver as fast as possible. A sleep() directly prevents that.\n\n</p><p>Instead of sleep(), register a timer to try the rotation sometime in the near future. The best thing would be to have rotation happening on a timer and the failure of rename should be propagated up to that timer so it can re-register itself for a short delay instead of its normal delay.\n\n</p><p></p><hr/>\n<em>2010-Feb-18 14:50:29 by cweiss:</em> <br/>\n\nIt is true that the schedd will be blocked entirely due to sleep(). However, the event of a failing rotation should be rare anyway. Having a timer (or separate process) deal with the rotation ties back to the whole plan to have a logd at some point. I am not sure, though, whether currently it would a good idea to detach this from the schedd entirely, since there are certainly situations when the job queue should rather not be rotated.\n\n<p>We could certainly not do repeated rotation attempts for now and more thoroughly think about a better solution for this.\n\n</p><p></p><hr/>\n<em>2010-Feb-18 15:06:05 by matt:</em> <br/>\n\nSeparating the O_APPEND part of the patch with the re-try part is a good idea.\n\n<p>sleep() only happening when rename rarely fails is motivation to not sleep(), because it will become yet another unexpected behavior during a time of unexpected behaviors (those leading to a rename failure).\n\n</p><p>I'm not sure how a separate process could handle rotation of the job_queue.log, which has very different semantics from a debug/trace/developer log.\n\n</p><p></p><hr/>\n<em>2010-Feb-18 15:11:36 by danb:</em> <br/>\n\nI agree that for the 7.4 series, it is sufficient to just fix O_APPEND and leave everything else as is (no retries in rotate_file).  If we become aware of real cases where failure to rotate for days in a row is actually causing a problem, then we can look into an additional fix in 7.4 for that problem.\n\n<p>In 7.5, it is even easier than it used to be to change the interval of an existing timer, using DaemonCore::Reset_Timer_Period().  The schedd's job queue cleaning timer could simply reset itself each time, using a shorter interval if the operation failed and the normal interval otherwise.</p></blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2010-Feb-18 15:20</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/caf83e4dc76bf3fa6d3f88c22d6248d07804430f\">[17281]</a></span>: Added O_APPEND flag to re-open classad_log in case of rotation failure (see <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=1215\" onclick=\"get_ticket_and_populate_wrapper('1215'); return false;\" title=\"job_queue.log can be corrupted in case of rotation failure\">#1215</a></span> and <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=1191\" onclick=\"get_ticket_and_populate_wrapper('1191'); return false;\" title=\"Windows job_queue.log rotation not atomic\">#1191</a></span> )  (By Cathrin Weiss )</td></tr>\n</tbody></table>", "type": "defect", "last_change": "2010-Feb-19 10:43", "status": "resolved", "created": "2010-Feb-15 10:26", "fixed_version": "2010-Feb-15 10:26", "broken_version": "v070000", "priority": "2", "subsystem": "Daemons", "assigned_to": "cweiss", "derived_from": "", "creator": "cweiss", "rust": "", "customer_group": "other", "visibility": "public", "notify": "cweiss@cs.wisc.edu , psilord@cs.wisc.edu, matt@cs.wisc.edu,dan@hep.wisc.edu", "due_date": ""}