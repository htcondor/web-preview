{"id": 1756, "title": "Ticket #1756: Be able to dynamically add nodes to a running DAG", "description": "<blockquote>\nThis was requested by the Pegasus folks (and I think other people have wanted it in the past).  I think the main thing we'd have to define is the interface for doing this.  One thing that was suggested recently is that we have places in the DAG where DAGMan reads a designated \"DAG addition\" file and incorporates it into the current DAG.  That should be fairly simple to implement, I think.</blockquote>", "remarks": "<blockquote>\n<em>2010-Nov-04 10:27:38 by wenger:</em> <br/>\n\nWe need to define exactly how this would work.  I'm not sure whether we'd be better off having an entirely new keyword like \"INSERT DAG\" or whether this should be a special case of \"JOB\".  Internally in the code it probably needs to be a Job object (or maybe a subclass of Job), but instead of actually submitting a job we'd parse the given DAG file.  For example:\n\n<p></p><pre>  INSERT DAG foo_sub.dag\n</pre>\n\n<p></p><hr/>\n<em>2011-Apr-12 12:28:53 by wenger:</em> <br/>\n\nMaybe also allow the \"insert\" DAG files to declare an existing node to be a NOOP (re yim with Matt F).\n\n<p></p><hr/>\n<em>2014-May-08 10:43:45 by wenger:</em> <br/>\n\nI talked with Karan about this at HTCondor Week.  For a first cut, at least, they'd be happy with just specifying a \"node\" in the DAG that would parse a specified \"snippet\" DAG file and incorporate it into the existing DAG (not as a splice, just directly).\n\n<p>I don't think that should be too hard to do -- basically we can just call the existing parse code on the snippet.\n\n</p><p>Some things to watch out for:\n</p><ul>\n<li>We'll have to check for a bunch of illegal actions, like adding a parent to a node that's already run.\n</li><li>I have to think about how to make this work for rescue DAGs and recovery mode.\n</li></ul>\n\n<p>We'll have to figure out exactly what actions should be illegal -- obviously, adding a parent to an already-run node must be illegal.  But I suspect there are other things that could cause problems.\n\n</p><p>At any rate, I need to write up a detailed design for this.\n\n</p><p></p><hr/>\n<em>2016-Apr-12 10:37:15 by wenger:</em> <br/>\n\nHmm -- something else to think about is handling syntax errors in the dynamic parts.  I guess the question is whether a syntax error should be immediately fatal, or whether it should be treated like a node failure.\n\n<p>Also, we need to make sure that this works with rescue DAGs and recovery mode...\n\n</p><p></p><hr/>\n<em>2016-Apr-12 10:41:53 by wenger:</em> <br/>\n\nWe also need to think about how to handle this internally.  I guess there should be a Job object to represent the dynamic parts, since it will have to have parents and children, at least potentially.  But either we could subclass Job or have a special flag that says, when you get to this job, don't submit something, parse the specified file.\n\n<p></p><hr/>\n<em>2016-Apr-12 11:31:18 by wenger:</em> <br/>\n\nHere's a link to the relevant Pegasus document: <a class=\"external\" href=\"https://docs.google.com/document/d/11bqnjiQEsIO8nShkeqBTrpmTqi02okm2tBc7c3cUftM/edit\">https://docs.google.com/document/d/11bqnjiQEsIO8nShkeqBTrpmTqi02okm2tBc7c3cUftM/edit</a>\n\n<p></p><hr/>\n<em>2016-Apr-12 12:08:39 by wenger:</em> <br/>\n\nMy initial thought is that the syntax could be something like this:\n\n<p></p><pre>  DYNAMIC INCLUDE NodeX my_include.dag\n</pre>\n\n<p>or\n\n</p><p></p><pre>  JOB INCLUDE NodeX my_include.dag\n</pre>\n\n<p>(although the second option would cause problems if anyone already has nodes named \"include\").\n\n</p><p>I guess, though, that a way to do this without syntax changes would be to simply make splices parsed dynamically, but I don't think that would be any easier to implement, and I like the increased flexibility of not forcing the dynamic nodes to be a splice (if we implement dynamic include, the include DAG file could just have \"bare\" nodes).\n\n</p><p>The really tricky thing, though, is that Pegasus wants to use this to do looping.  My initial thought on this is that you'd do something like this:\n\n</p><p></p><pre>  DYNAMIC INCLUDE NodeX ...\n  SCRIPT PRE NodeX ...\n  PRE_SKIP NodeX ...\n  RETRY NodeX ...\n</pre>\n\n<p>However, looking at the Pegasus document, it looks like they are thinking more in terms of recursion than actual looping.  In other words, something like this:\n\n</p><p></p><pre>  == top.dag:\n  DYNAMIC INCLUDE It0 it0.dag\n  SCRIPT PRE It0 ...\n</pre>\n\n<p></p><pre>  == it0.dag:\n  JOB calculate ...\n  DYNAMIC INCLUDE It1 it1.dag\n  SCRIPT PRE It1\n  PARENT calculate CHILD It1\n  ...\n</pre>\n\n<p>I think the \"recursion\" would actually be easier to deal with from the DAGMan point of view than retries on the dynamic includes.  The problem I see with allowing retries on dynamic includes is the interaction with rescue DAGs -- if the same dynamic include file gets overwritten, when you start up the rescue DAG, you'll have lost the nodes for all but the last iteration of the loop.  If we use recursion, each \"iteration\" has its own include DAG, so then we should be okay.\n\n</p><p>Assuming we go with \"dynamic include\" instead of \"dynamic splice\", I see possibly implementing this in three phases:\n</p><ol>\n<li>Dynamic includes work with \"bare\" nodes.\n</li><li>Dynamic includes work with splices.\n</li><li>Dynamic includes work with loops (optional).\n</li></ol>\n\n<p>Anyhow, we clearly need a design document for this, and I need to think more about whether the \"recursion\" option will actually work with rescue DAGs.\n\n</p><p></p><hr/>\n<em>2016-Apr-12 12:20:36 by wenger:</em> <br/>\n\nHmm -- something else I just thought of:  if we go with \"dynamic include\" instead of \"dynamic splice\", what happens if the included DAG file has nodes that have no parents?  How will that interact with rescue DAGs?\n\n<p>Maybe the way to go <strong>is</strong> just to make all splices dynamically-parsed, and be able to have PRE and POST scripts on them.  (Hmm -- now that I think about it, it would be fairly easy to have PRE scripts on either dynamic includes/dynamic splices, but having POST scripts would be much harder unless we implement socket nodes (gittrac <span class=\"ticket\"><a class=\"stalled\" href=\"/wiki-archive/tickets/?ticket=3587\" onclick=\"get_ticket_and_populate_wrapper('3587'); return false;\" title='Add \"socket\" nodes for splices'>#3587</a></span>).  I haven't really looked at how much work adding the socket nodes is, although we might not absolutely need POST scripts to do what Pegasus wants.)\n\n</p><p></p><hr/>\n<em>2016-Apr-12 12:43:14 by wenger:</em> <br/>\n\nHmm -- now I'm wondering whether the way to do this is to add socket nodes and make the splices dynamically parsed all at once.  I'm thinking that, when we parse the splice command in the top-level DAG, we'd create the parent and child socket nodes, with a parent-child relationship between them.  That would give us a place to \"attach\" PRE and POST scripts, and parent/child relationships to the parents and children of the splice.  The parent socket node could then do the parsing of the splice DAG when we get to that point in the DAG -- when we parse the splice DAG, we'd create the proper parent/child relationships between the \"internal\" splice nodes and the socket nodes.\n\n<p></p><hr/>\n<em>2016-Apr-26 11:30:16 by wenger:</em> <br/>\n\nAs per phone conference with Karan today -- I need to create a design document for this from the DAGMan point of view, with some examples of what would and would not be allowed.\n\n<p></p><hr/>\n<em>2016-Apr-28 13:13:40 by wenger:</em> <br/>\n\nHmm -- need to think about how this would work (if at all) with the new splice connect feature (also see <span class=\"ticket\"><a class=\"stalled\" href=\"/wiki-archive/tickets/?ticket=3587\" onclick=\"get_ticket_and_populate_wrapper('3587'); return false;\" title='Add \"socket\" nodes for splices'>#3587</a></span>: Add \"socket\" nodes for splices).  Maybe we wouldn't allow connected splices to be dynamically parsed?\n\n<p></p><hr/>\n<em>2016-Apr-28 14:54:51 by wenger:</em> <br/>\n\nJust had a discussion about this with Miron.  A few points from this discussion:\n<ol>\n<li>Add socket nodes first, without dynamic capability (see <span class=\"ticket\"><a class=\"stalled\" href=\"/wiki-archive/tickets/?ticket=3587\" onclick=\"get_ticket_and_populate_wrapper('3587'); return false;\" title='Add \"socket\" nodes for splices'>#3587</a></span>).\n</li><li>Splices should <strong>not</strong> be dynamic by default -- we should have some new keyword for dynamic splices.\n</li><li>The first version, at least, of dynamic splices will not support pin connections.\n</li></ol>\n\n<p>Note: my thought is that maybe we could have a keyword like SPLICE_DYNAMIC or something, but the exact keyword isn't critical.</p></blockquote>", "derived_tickets": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">\n<span class=\"ticket\"><a class=\"abandoned\" href=\"/wiki-archive/tickets/?ticket=2438\" onclick=\"get_ticket_and_populate_wrapper('2438'); return false;\" title=\"Modifying DAGman parameters at runtime\">#2438</a></span></td>\n<td align=\"center\" valign=\"center\" width=\"30\">\n<span class=\"icon ptr1\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\">\nModifying DAGman parameters at runtime</td></tr>\n</tbody></table>", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "enhance", "last_change": "2016-Apr-28 14:54", "status": "stalled", "created": "2010-Nov-04 10:24", "fixed_version": "2010-Nov-04 10:24", "broken_version": "v070504", "priority": "2", "subsystem": "Dag", "assigned_to": "", "derived_from": "", "creator": "wenger", "rust": "", "customer_group": "other", "visibility": "public", "notify": "wenger@cs.wisc.edu, psilord@cs.wisc.edu, matt@cs.wisc.edu, vahi@isi.edu", "due_date": ""}