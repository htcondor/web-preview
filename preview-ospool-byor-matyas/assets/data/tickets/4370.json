{"id": 4370, "title": "Ticket #4370: Memory leak when reusing cached collector connection", "description": "<blockquote>\nWhenever a cached connection to the collector is reused to send a new command, if the collector can't read the full CEDAR message immediately, it leaks a <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCommandProtocol\" title=\"Daemon Command Protocol\">DaemonCommandProtocol</a></span> object. This appears to have resulted in a large amount of leaked memory in GlideinWMS's collectors when they upgraded to HTCondor 8.1.5.\n\n<p>When a daemon needs to handle a new incoming command on a socket, it creates a <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCommandProtocol\" title=\"Daemon Command Protocol\">DaemonCommandProtocol</a></span> object. This object handles security negotiation, determining which command is being requested, and calling the appropriate callback for that command. It can do a lot of the requisite network I/O non-blocking, allowing the main event loop to run when it needs to wait for data. It does this by registering the socket with <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCore\" title=\"Daemon Core\">DaemonCore</a></span>, requesting to be called back when there's data available for reading.\n\n</p><p>This is a problem when a new command arrives on a socket that the collector has cached from a previous command. The socket is already registered in <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCore\" title=\"Daemon Core\">DaemonCore</a></span> as a command socket and the same socket can't be registered for two different callbacks. Before HTCondor 8.1.5, the new registration would fail and the collector would close the connection. With the new non-blocking code added in 8.1.5, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCommandProtocol\" title=\"Daemon Command Protocol\">DaemonCommandProtocol</a></span> avoids re-registering the socket if it's already registered. That leaves the original registration in place, the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCommandProtocol\" title=\"Daemon Command Protocol\">DaemonCommandProtocol</a></span> object's callback is never called, and the object hangs around forever.\n\n</p><p>To fix this, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCommandProtocol\" title=\"Daemon Command Protocol\">DaemonCommandProtocol</a></span> needs to replace the existing socket registration with its new registration, then restore the old one when its callback is invoked.</p></blockquote>", "remarks": "<blockquote>\n</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2014-Jun-16 10:16</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/c174823e778e1f6a9cd382482ed166d24de40b16\">[40433]</a></span>: quick 8.2.0 version history item edit <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=4370\" onclick=\"get_ticket_and_populate_wrapper('4370'); return false;\" title=\"Memory leak when reusing cached collector connection\">#4370</a></span>  (By Karen Miller )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2014-Jun-16 09:32</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/4175b021539dfdd162ec21e613bc95d35658a6a4\">[40429]</a></span>: Document <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=4370\" onclick=\"get_ticket_and_populate_wrapper('4370'); return false;\" title=\"Memory leak when reusing cached collector connection\">#4370</a></span>  (By Greg Thain )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2014-May-19 16:34</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/acb69998cd936b3d25d0d3463e61cfa60ab86897\">[40173]</a></span>: Fix memory leak when reusing cached collector connection. <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=4370\" onclick=\"get_ticket_and_populate_wrapper('4370'); return false;\" title=\"Memory leak when reusing cached collector connection\">#4370</a></span> When <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCommandProtocol\" title=\"Daemon Command Protocol\">DaemonCommandProtocol</a></span> wants to register its socket with <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCore\" title=\"Daemon Core\">DaemonCore</a></span> for read data and the socket is already registered, the existing registration is now replaced with the new and restored when the new callback is invoked. Before, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCommandProtocol\" title=\"Daemon Command Protocol\">DaemonCommandProtocol</a></span>\u00a0[...]\n (By Jaime Frey )</td></tr>\n</tbody></table>", "type": "defect", "last_change": "2014-Jun-16 09:33", "status": "resolved", "created": "2014-May-19 13:38", "fixed_version": "2014-May-19 13:38", "broken_version": "v080105", "priority": "2", "subsystem": "Libs", "assigned_to": "gthain", "derived_from": "#4237", "creator": "jfrey", "rust": "", "customer_group": "cms", "visibility": "public", "notify": "", "due_date": ""}