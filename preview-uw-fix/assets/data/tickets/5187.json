{"id": 5187, "title": "Ticket #5187: Improved concurrency interfaces for python bindings", "description": "<blockquote>\nA common use case for the python bindings are the equivalent of \"condor_q -g ...\" -- finding all the jobs in a pool matching a constraint.  This is typically implemented as:\n\n<p></p><div class=\"verbatim\">\n<pre>all_ads = []\nfor ad in collector.query(htcondor.AdTypes.Schedd, schedd_const):\n   schedd = htcondor.Schedd(ad)\n   all_ads += schedd.xquery(jobs_const)\n</pre></div>\n\n\n<p>This is inherently serial, however - even though the returned iterator is non-blocking.\n\n</p><p>I'd like to introduce a <code>gather</code> function:\n\n</p><p></p><div class=\"verbatim\">\n<pre>queries = [htcondor.Schedd(ad).xquery(jobs_const) for ad in collector.query(htcondor.AdTypes.Schedd, schedd_const)]\nall_ads = []\nfor query in htcondor.gather(queries):\n  all_ads += query.nextAdsNonBlocking()\n</pre></div>\n\n\n<p></p><ul>\n<li><code>gather</code> will keep track of the given iterator objects and return any that has events ready to read.  If all iterators are complete, then throws a <code>StopIteration</code> exception.\n</li><li><code>QueryIterator.nextAdsNonBlocking()</code> will return all the currently available ads.  Returns an empty list if no ads are available.  Returns an empty list if the query has completed.\n</li><li><code>QueryIterator.next()</code> will be extended to optionally not block.  Still throws <code>StopIteration</code> if the query has completed.\n</li><li><code>QueryIterator.tag()</code> will return the query's tag.\n</li><li><code>Schedd.query</code> will get a new keyword argument, <code>tag</code>.  When set, it'll set the created =QueryIterator='s tag.  If not set, the =QueryIterator='s tag will be set to the schedd's name.\n</li></ul>\n\n<p>The <code>tag</code> allows us to identify queries:\n\n</p><p></p><div class=\"verbatim\">\n<pre>queries = [htcondor.Schedd(ad).xquery(jobs_const) for ad in collector.query(htcondor.AdTypes.Schedd, schedd_const)]\nads_per_schedd = {}\nfor query in htcondor.gather(queries):\n  schedd = query.tag()\n  if schedd not in ads_per_schedd: ads_per_schedd[schedd] = []\n  ads_per_schedd[query.tag()] += query.nextAdsNonBlocking()\n</pre></div>\n\n\n<p>Hmm - that's a bit more complex than I had hoped.  Suggestions?</p></blockquote>", "remarks": "<blockquote>\n<em>2015-Aug-01 12:51:19 by bbockelm:</em> <br/>\n\nHere is the serial test script used:\n\n<p></p><div class=\"verbatim\">\n<pre>$ cat test_query_old.py\n#!/usr/bin/python\n\nimport time\nimport htcondor\n\ncoll = htcondor.Collector(\"vocms099.cern.ch\")\njob_counts = {}\nprint \"Querying collector for schedds\"\nstart = time.time()\ncoll_query = coll.query(htcondor.AdTypes.Schedd)\nend = time.time()\n\nfor schedd_ad in coll_query:\n    schedd_obj = htcondor.Schedd(schedd_ad)\n    if True or not schedd_ad['Name'].startswith('crab'):\n        print \"Starting query to\", schedd_ad['Name']\n#        job_counts[schedd_ad['Name']] = len(list(schedd_obj.xquery(opts=htcondor.QueryOpts.AutoCluster)))\n        job_counts[schedd_ad['Name']] = len(list(schedd_obj.xquery()))\nend2= time.time()\n\nprint \"Found %d schedds to query.\" % len(job_counts)\n\nprint job_counts\n\nprint \"Collector query time: %.2f\" % (end-start)\nprint \"Schedd query time: %.2f\" % (end2-end)\nprint \"Total time: %.2f\" % (end2-start)\n</pre></div>\n\n\n<p>And concurrent version:\n\n</p><p></p><div class=\"verbatim\">\n<pre>$ cat test_query_poll.py\n#!/usr/bin/python\n\nimport time\nimport htcondor\n\ncoll = htcondor.Collector(\"vocms099.cern.ch\")\nqueries = []\nstart = time.time()\nprint \"Querying collector for schedds\"\ncoll_query = coll.query(htcondor.AdTypes.Schedd)\nend = time.time()\nfor schedd_ad in coll_query:\n    schedd_obj = htcondor.Schedd(schedd_ad)\n    if True or not schedd_ad['Name'].startswith('crab'):\n        print \"Starting query to\", schedd_ad['Name']\n#        queries.append(schedd_obj.xquery(opts=htcondor.QueryOpts.AutoCluster))\n        queries.append(schedd_obj.xquery())\nend2= time.time()\nprint \"Found %d schedds to query.\" % len(queries)\n\njob_counts = {}\nfor query in htcondor.poll(queries):\n    schedd_name = query.tag()\n    job_counts.setdefault(schedd_name, 0)\n    count = len(query.nextAdsNonBlocking())\n    job_counts[schedd_name] += count\n    print \"Got %d results from %s.\" % (count, schedd_name)\n\nprint job_counts\nend3 = time.time()\n\nprint \"Collector query time: %.2f\" % (end-start)\nprint \"Schedd query startup time: %.2f\" % (end2-end)\nprint \"Schedd query finish time: %.2f\" % (end3-end)\nprint \"Total time: %.2f\" % (end3-start)\n\n</pre></div>\n\n\n<p>Note that they are somewhat the equivalent of \"condor_q -g -l\".  I ran both scripts on the CMS global pool on a relatively sleepy Saturday (68k jobs total).\n\n</p><p>Doing things serially:\n</p><div class=\"verbatim\">\n<pre>Collector query time: 4.63\nSchedd query time: 239.67\nTotal time: 244.31\n</pre></div>\n\n\n<p>versus concurrently:\n</p><div class=\"verbatim\">\n<pre>Collector query time: 4.67\nSchedd query startup time: 9.40\nSchedd query finish time: 71.15\nTotal time: 75.82\n</pre></div>\n\n\n<p>So, about a 3x speedup.  Note the CPU usage from the latter:\n\n</p><p></p><div class=\"verbatim\">\n<pre>real\t1m15.952s\nuser\t0m59.239s\nsys\t0m2.827s\n</pre></div>\n\n\n<p>Basically, the larger the pool, the closer we get to being CPU-bound (as we do so much network IO concurrently).  The CMS global pool has 38 schedds at the time of writing.\n\n</p><p>Now, an important lesson here comes by switching from job queries to autocluster queries (uncomment appropriate lines above).  First, serial:\n\n</p><p></p><div class=\"verbatim\">\n<pre>Collector query time: 4.61\nSchedd query time: 22.83\nTotal time: 27.43\n</pre></div>\n\n\n<p>Then, concurrent:\n\n</p><p></p><div class=\"verbatim\">\n<pre>Collector query time: 4.75\nSchedd query startup time: 7.41\nSchedd query finish time: 7.93\nTotal time: 12.67\n\nreal\t0m12.745s\nuser\t0m0.607s\nsys\t0m0.068s\n</pre></div>\n\n\n<p>This is a 6x speedup!  So, while going parallel is indeed worthwhile, there are bigger savings in utilizing auto-clusters instead of jobs (keep in mind that not all queries can do this - but I suspect many can!).\n\n</p><p>Note also, when querying auto-clusters, the penalty for opening connections and security sessions to schedds increases significantly.  At some point, we may want to do a follow-up ticket to make this phase non-blocking.  However, this would first require making the client-side of the authentication stack non-blocking.</p></blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2015-Aug-08 10:57</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/ad2d8d3ad677f30fd6024bd871727a8de8559e0c\">[45542]</a></span>: Fix header ordering for Mac OS X. <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=5187\" onclick=\"get_ticket_and_populate_wrapper('5187'); return false;\" title=\"Improved concurrency interfaces for python bindings\">#5187</a></span> As we've seen before, header ordering can be quite tricky. Attempt to fix the build for Mac OS X without breaking others.  (By Brian Bockelman )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2015-Aug-08 09:01</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/3de10506378efa6d74ee7590740d304caee1cdc5\">[45540]</a></span>: Add unit test for bulk query interface. <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=5187\" onclick=\"get_ticket_and_populate_wrapper('5187'); return false;\" title=\"Improved concurrency interfaces for python bindings\">#5187</a></span> Fixes a memory management issue found when testing. Additionally fixes next() behavior in non-blocking mode. <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=5187\" onclick=\"get_ticket_and_populate_wrapper('5187'); return false;\" title=\"Improved concurrency interfaces for python bindings\">#5187</a></span>\u00a0[...]\n (By Brian Bockelman )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2015-Aug-08 08:10</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/bea17c0e991f6f03107a7b629bb68bd1bae9bcb4\">[45539]</a></span>: Version history and initial documentation. <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=5187\" onclick=\"get_ticket_and_populate_wrapper('5187'); return false;\" title=\"Improved concurrency interfaces for python bindings\">#5187</a></span>  (By Brian Bockelman )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2015-Aug-08 07:47</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/1ef1739adb24e5e3f49351415a3d1048a3b009a2\">[45538]</a></span>: Merged <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/89eda176eadd7cfa902e68efd0aa6500594f9aec\">[45450]</a></span>, Merge branch 'V8_3-gt5187'. <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=5187\" onclick=\"get_ticket_and_populate_wrapper('5187'); return false;\" title=\"Improved concurrency interfaces for python bindings\">#5187</a></span> Conflicts: src/python-bindings/CMakeLists.txt src/python-bindings/export_headers.h src/python-bindings/htcondor.cpp  (By Brian Bockelman )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2015-Aug-03 11:04</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/89eda176eadd7cfa902e68efd0aa6500594f9aec\">[45450]</a></span>: Add header accidentally left out from previous commit. <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=5187\" onclick=\"get_ticket_and_populate_wrapper('5187'); return false;\" title=\"Improved concurrency interfaces for python bindings\">#5187</a></span>  (By Brian Bockelman )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2015-Aug-01 14:09</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/faa43279597cb9a809cf4e670cc6d413daa3c12b\">[45446]</a></span>: Add concurrency interfaces for Schedd queries. <span class=\"ticket\"><a class=\"resolved\" href=\"/wiki-archive/tickets/?ticket=5187\" onclick=\"get_ticket_and_populate_wrapper('5187'); return false;\" title=\"Improved concurrency interfaces for python bindings\">#5187</a></span> This provides new python APIs to better manage multiple concurrent queries without resorting to to the use of threads.\u00a0[...]\n (By Brian Bockelman )</td></tr>\n</tbody></table>", "type": "enhance", "last_change": "2015-Oct-19 13:57", "status": "resolved", "created": "2015-Jul-31 14:44", "fixed_version": "2015-Jul-31 14:44", "broken_version": "", "priority": "4", "subsystem": "Tools", "assigned_to": "bbockelm", "derived_from": "", "creator": "bbockelm", "rust": "", "customer_group": "other", "visibility": "public", "notify": "bbockelm@cse.unl.edu", "due_date": ""}