{"id": 3138, "title": "Ticket #3138: Periodic evicts/fast restart in vanilla universe (checkpoints)", "description": "<blockquote>\n<span class=\"section\"><h2>Overview </h2></span>\nPeriodically evict a job, sending its sandbox home, then immediately restart it in the same claim.\n\n<p>This is part of work to do checkpointing in the vanilla universe (see parent <span class=\"ticket\"><a class=\"abandoned\" href=\"/wiki-archive/tickets/?ticket=2007\" onclick=\"get_ticket_and_populate_wrapper('2007'); return false;\" title=\"Can stduniv run as a vanilla job with standalone checkpointing?\">#2007</a></span> \"Can stduniv run as a vanilla job with standalone checkpointing?\" and grandparent <span class=\"ticket\"><a class=\"abandoned\" href=\"/wiki-archive/tickets/?ticket=1956\" onclick=\"get_ticket_and_populate_wrapper('1956'); return false;\" title=\"Move stduniv to new starter/shadow\">#1956</a></span> \"Move stduniv to new starter/shadow\"). By itself, this will massively simplify doing periodic checkpoints in the vanilla universe.  This will solve problems LIGO has today, primarily because the standard shadow/starter combination lack modern niceties, including CCB.\n\n</p><p>(This may be useful for DMTCP or KVM. I'm just mentioning them so this will show up in searches.)\n\n</p><p><span class=\"section\"></span></p><h2>Architecture: \"Clueless Starter\"</h2>\n\n<p></p><ol>\n<li>The startd will decide when a periodic checkpoint is desired, using existing functionality with some tweaks.\n\n<p></p></li><li>Upon deciding, the startd will signal the starter that it is time to exit while internally noting this special case.  The signal will note \"this is a periodic checkpoint\".\n\n<p></p></li><li>The starter will signal the shadow that this is a periodic checkpoint.\n\n<p></p></li><li>When the starter exits, the startd will note that it is prepared to accept the old claim again.  It will not clean up the execute directory as it normally would.\n\n<p></p></li><li>When the shadow finishes talking with the starter, the shadow enters a \"try to claim\" mode, nothing that it's a reclaim.\n\n<p></p></li><li>When the shadow reclaims and starts talking to the new starter, it avoids re-sending any files.\n\n<p></p></li><li>Everything presumable restarts and all is well.\n</li></ol>\n\n<p>Specific steps are described in the development plan below.\n\n</p><p><span class=\"section\"></span></p><h2>Development Plan</h2>\n\n<p>This only happens if a vanilla universe job specifically requests periodic checkpoints with \"+WantCheckpoint=TRUE\".  If Universe==$(vanilla) &amp;&amp; <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=WantCheckpoint\" title=\"Want Checkpoint\">WantCheckpoint</a></span> &amp;&amp; PERIODIC_CHECKPOINT, then it's time to do a checkpoint.\n\n</p><p></p><ul>\n<li>03 days - Change startd: startd tells starter to shut down for periodic checkpoint.  startd enters a new state \"shutting down, but not really.\"\n<ul>\n<li>Probably involves changing <a class=\"file\" href=\"rlog?f=src/condor_startd.V6/Resource.cpp\">/src/condor_startd.V6/Resource.cpp</a> Resource::periodic_checkpoint around line 352 to know about this case (and not to do so for the VM universe, which has its own rules!) and instead kill off the starter.\n</li></ul>\n</li><li>02 days - Change starter: On periodic checkpoint shutdown, shutdown\n</li><li>03 days - Change starter and shadow: On periodic checkpoint shutdown, signal to the shadow that this is a periodic checkpoint shutdown.\n</li><li>03 days - Change startd: when starter exits, transition to \"being re-claimed\" maintaining the old claim information.  Ensure we don't clean up the working directory!\n<ul>\n<li>Work probably needs to be done in Starter::exited (/src/condor_Startd.V6/Starter.cpp around line 670)\n</li></ul>\n</li><li>03 days - Change shadow: When files sent back, transition to \"(re)claiming slot mode\". It should have the old machine ad with the claim information, so it should be able to reconnect.\n</li><li>03 days - Change startd: if we're in \"being re-claimed\" and someone shows up with the correct claim ID, reuse the existing execute directory.\n<ul>\n<li>Maybe change starter: when starting the starter be sure to pass in \"assume file transfer is done\". (May not be necessary)\n</li></ul>\n</li><li>04 days - Change shadow and/or starter to be able to be skip file transfer.  Might it be enough to have the shadow simply not bother?\n</li><li>02 days - Change condor_vacate and condor_vacate_job: Add --and-restart which will initiate a periodic checkpoint shutdown?  Useful for testing, as well as forcing a checkpoint now without (kinda) interrupting the job.\n</li><li>02 days - change condor_startd to respect --and-restart flag from condor_vacate/condor_vacate_job\n</li></ul>\n\n<p>Open issues\n</p><ul>\n<li>What if a competing claim shows up while waiting for a reclaim? Accept it?  Compare it to current claim and consider it?  If we might consider it, we'll need to exit being-re-claimed and clean up the execute directory.\n</li></ul>\n\n<p><span class=\"section\"></span></p><h2>Rejected Designs</h2>\n\n<p><span class=\"subsection\"></span></p><h3>Clueless Starter</h3>\n\n<p>As above, but have the shadow exit and try to reuse claim.  Necessitates changes in the schedd, adding further complexity.\n\n</p><p><span class=\"subsection\"></span></p><h3>Intelligent starter</h3>\n\n<p></p><ol>\n<li>Send the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=KillSig\" title=\"Kill Sig\">KillSig</a></span> (SIGTERM by default, set via kill_sig in submit file)\n</li><li>Wait for the user job to exit.\n<ul>\n<li>This doesn't count as shutting the job down, it counts as normal run time.\n</li><li>If something happens that would normally SIGKILL the, go ahead and skip the rest of this.\n</li><li>If something happens that would normally send the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=KillSig\" title=\"Kill Sig\">KillSig</a></span>, follow that code path and skip the rest of this.\n</li></ul>\n</li><li>Send all files back home, as though we were leaving the machine (even though we aren't)\n</li><li>Immediately restart the job.\n<ul>\n<li>Specifically avoid re-downloading the files.\n</li></ul>\n</li></ol>\n\n<p>Problems:\n</p><ul>\n<li>The starter has code to handle a periodic checkpoint for the VM universe.  However, this code path blocks until the checkpoint is done!  That is a mess in a pile of ways.  The correct solution is to teach the starter that it can an internal state of \"waiting for checkpoint\" and dealing with how to respond to external requests while waiting.\n</li></ul>\n\n<p><span class=\"section\"></span></p><h2>Notes </h2>\n\n<p><span class=\"subsection\"></span></p><h3>Teach startd to do periodic checkpoints:</h3>\n\n<p>Resource::wants_pckpt\n(<a class=\"file\" href=\"rlog?f=src/condor_startd.V6/Resource.cpp\">/src/condor_startd.V6/Resource.cpp</a> around line 1344)\nwill want changes something like:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">bool want_periodic = false;\nr_cur-&gt;c_ad-&gt;EvalAttrBool(\"WantCheckpoint\", want_periodic)\n...\n&amp;&amp; (r_cur-&gt;universe() != CONDOR_UNIVERSE_VANILLA &amp;&amp; want_periodic)\n</pre></div>\n\n\n<p>This is called from ResState::eval (<a class=\"file\" href=\"rlog?f=src/condor_startd.V6/ResState.cpp\">/src/condor_startd.V6/ResState.cpp</a> around line 350) .  If true, we'll call into Resource::periodic_checkpoint (<a class=\"file\" href=\"rlog?f=src/condor_startd.V6/Resource.cpp\">/src/condor_startd.V6/Resource.cpp</a> around line 346).  That calls into Claim::periodicCheckpoint (<a class=\"file\" href=\"rlog?f=src/condor_startd.V6/claim.cpp\">/src/condor_startd.V6/claim.cpp</a> around line 1766), which (after a pile more stuff), send DC_SIGPCKT/SIGUSR2 to the starter.\n\n</p><p>File transfer of results:\n</p><ul>\n<li>CStarter::allJobsDone <a class=\"file\" href=\"rlog?f=src/condor_starter.V6.1/baseStarter.cpp\">/src/condor_starter.V6.1/baseStarter.cpp</a> line 2387\n<ul>\n<li>CStarter::transferOutput <a class=\"file\" href=\"rlog?f=src/condor_starter.V6.1/baseStarter.cpp\">/src/condor_starter.V6.1/baseStarter.cpp</a> line 2427\n<ul>\n<li>JICShadow::transferOutput <a class=\"file\" href=\"rlog?f=src/condor_starter.V6.1/jic_shadow.cpp\">/src/condor_starter.V6.1/jic_shadow.cpp</a> line 390\n</li></ul>\n</li></ul>\n</li></ul>\n\n<p>Eventually the starter exits, leading to calls to a change of *::starterExited\n</p><ul>\n<li>Claim::starterExited(int status) <a class=\"file\" href=\"rlog?f=src/condor_startd.V6/claim.cpp\">/src/condor_startd.V6/claim.cpp</a> line 1414\n<ul>\n<li>Calls Starter::exited(int status) <a class=\"file\" href=\"rlog?f=src/condor_startd.V6/Starter.cpp\">/src/condor_startd.V6/Starter.cpp</a> line 616\n<ul>\n<li>Deletes execute directory and logs final classad. Probably bad!\n</li></ul>\n</li><li>Calls Resource::starterExited(Claim * cur_claim) <a class=\"file\" href=\"rlog?f=src/condor_startd.V6/Resource.cpp\">/src/condor_startd.V6/Resource.cpp</a> line 692\n<ul>\n<li>Calls ResState::starterExited() <a class=\"file\" href=\"rlog?f=src/condor_startd.V6/ResState.cpp\">/src/condor_startd.V6/ResState.cpp</a> line 985\n<ul>\n<li>Switches state; probably want to suppress?\n</li></ul>\n</li><li>changes ResState's state; probably want to suppress?\n</li></ul>\n</li></ul>\n</li></ul>\n\n<p>Jobs are started by the shadow sending the activate command:\ncommand_activate_claim -&gt; activate_claim -&gt;  Claim::spawnStarter\n\n</p><p></p><ul>\n<li><a class=\"file\" href=\"rlog?f=src/condor_starter.V6.1/baseStarter.cpp\">/src/condor_starter.V6.1/baseStarter.cpp</a> 2207 <code>CStarter::PeriodicCkpt( void )</code></li></ul>\n</blockquote>", "remarks": "<blockquote>\nMarking abandoned in favor of <span class=\"ticket\"><a class=\"defer\" href=\"/wiki-archive/tickets/?ticket=4968\" onclick=\"get_ticket_and_populate_wrapper('4968'); return false;\" title=\"Periodic Application-Level Checkpoints in the Vanilla Universe\">#4968</a></span>,</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body><blockquote>\n<ul>\n<li><a href=\"../files/680/3138-design-doc.doc\">3138-design-doc.doc</a>\n20480 bytes added by adesmet on 2013-Feb-04 23:43:35 UTC.\n<br/>\nv1 design doc<br/>\n</li></ul>\n</blockquote></body></html>", "check_ins": "", "type": "enhance", "last_change": "2019-Sep-18 14:36", "status": "abandoned", "created": "2012-Jul-18 14:10", "fixed_version": "2012-Jul-18 14:10", "broken_version": "v000000", "priority": "5", "subsystem": "", "assigned_to": "tannenba", "derived_from": "#2007", "creator": "adesmet", "rust": "", "customer_group": "ligo", "visibility": "public", "notify": "pcouvare@caltech.edu", "due_date": ""}