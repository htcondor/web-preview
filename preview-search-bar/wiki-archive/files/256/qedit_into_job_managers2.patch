diff --git a/src/condor_c++_util/classad_collection.cpp b/src/condor_c++_util/classad_collection.cpp
index ae7a5e1..ff1b2c2 100644
--- a/src/condor_c++_util/classad_collection.cpp
+++ b/src/condor_c++_util/classad_collection.cpp
@@ -130,9 +130,9 @@ Output: true on success, false otherwise
 */
 //----------------------------------------------------------------------------------
 
-bool ClassAdCollection::SetAttribute(const char *key, const char *name, const char *value)
+bool ClassAdCollection::SetAttribute(const char *key, const char *name, const char *value, bool is_dirty)
 {
-  LogRecord* log=new LogSetAttribute(key,name,value);
+  LogRecord* log=new LogSetAttribute(key,name,value,is_dirty);
   ClassAdLog::AppendLog(log);
   // return ChangeClassAd(key);
   return true;
@@ -155,6 +155,20 @@ bool ClassAdCollection::DeleteAttribute(const char *key, const char *name)
   return true;
 }
 
+//----------------------------------------------------------------------------------
+/** Clear the ditry bits for all attributes of a class ad - this operation
+    is not logged.
+Input: key - the class ad's key
+Output: true on success, false otherwise
+*/
+//----------------------------------------------------------------------------------
+bool ClassAdCollection::ClearClassAdDirtyBits(const char* key)
+{
+  ClassAd* Ad;
+  if (table.lookup(HashKey(key),Ad)==-1) return false;
+  Ad->ClearAllDirtyFlags();
+  return true;
+}
 
 #if 0 // NOT USED
 //----------------------------------------------------------------------------------
diff --git a/src/condor_c++_util/classad_collection.h b/src/condor_c++_util/classad_collection.h
index 81e2023..a37edfc 100644
--- a/src/condor_c++_util/classad_collection.h
+++ b/src/condor_c++_util/classad_collection.h
@@ -189,9 +189,10 @@ public:
       @param key The class-ad's key.
       @param name the name of the attribute.
       @param value the value of the attrinute.
+      @param is_dirty the parameter should be marked dirty in the classad.
       @return true on success, false otherwise.
   */
-  bool SetAttribute(const char* key, const char* name, const char* value);
+  bool SetAttribute(const char* key, const char* name, const char* value, const bool is_dirty=false);
 
   /** Delete an attribute in a class-ad.
       @param key The class-ad's key.
@@ -200,6 +201,12 @@ public:
   */
   bool DeleteAttribute(const char* key, const char* name);
 
+  /** Clear all parameter dirty bits in a class-ad.
+      @param key The class-ad's key.
+      @return true on success, false otherwise.
+  */
+  bool ClearClassAdDirtyBits(const char* key);
+
   /** Get a class-ad from the repository.
       Note that the class-ad returned cannot be modified directly.
       @param key The class-ad's key.
diff --git a/src/condor_c++_util/classad_log.cpp b/src/condor_c++_util/classad_log.cpp
index 041466c..e10bfa7 100644
--- a/src/condor_c++_util/classad_log.cpp
+++ b/src/condor_c++_util/classad_log.cpp
@@ -801,7 +801,7 @@ LogDestroyClassAd::ReadBody(FILE* fp)
 	return readword(fp, key);
 }
 
-LogSetAttribute::LogSetAttribute(const char *k, const char *n, const char *val)
+LogSetAttribute::LogSetAttribute(const char *k, const char *n, const char *val, bool dirty)
 {
 	op_type = CondorLogOp_SetAttribute;
 	key = strdup(k);
@@ -811,6 +811,7 @@ LogSetAttribute::LogSetAttribute(const char *k, const char *n, const char *val)
 	} else {
 		value = strdup("UNDEFINED");
 	}
+        is_dirty = dirty;
 }
 
 
@@ -831,6 +832,8 @@ LogSetAttribute::Play(void *data_structure)
 	if (table->lookup(HashKey(key), ad) < 0)
 		return -1;
 	rval = ad->AssignExpr(name, value);
+	ad->SetDirtyFlag(name, is_dirty);
+
 
 #if HAVE_DLOPEN
 	ClassAdLogPluginManager::SetAttribute(key, name, value);
diff --git a/src/condor_c++_util/classad_log.h b/src/condor_c++_util/classad_log.h
index bbf920e..d005b18 100644
--- a/src/condor_c++_util/classad_log.h
+++ b/src/condor_c++_util/classad_log.h
@@ -209,7 +209,7 @@ private:
 
 class LogSetAttribute : public LogRecord {
 public:
-	LogSetAttribute(const char *key, const char *name, const char *value);
+	LogSetAttribute(const char *key, const char *name, const char *value, const bool dirty=false);
 	virtual ~LogSetAttribute();
 	int Play(void *data_structure);
 	virtual char const *get_key() { return key; }
@@ -223,6 +223,7 @@ private:
 	char *key;
 	char *name;
 	char *value;
+        bool is_dirty;
 };
 
 class LogDeleteAttribute : public LogRecord {
diff --git a/src/condor_c++_util/command_strings.cpp b/src/condor_c++_util/command_strings.cpp
index 752cae6..db798e6 100644
--- a/src/condor_c++_util/command_strings.cpp
+++ b/src/condor_c++_util/command_strings.cpp
@@ -172,6 +172,8 @@ const struct Translation DCTranslation[] = {
 	{ "CREATE_JOB_OWNER_SEC_SESSION", CREATE_JOB_OWNER_SEC_SESSION },
 	{ "START_SSHD", START_SSHD },
 	{ "RECYCLE_SHADOW", RECYCLE_SHADOW },
+	{ "CLEAR_DIRTY_JOB_ATTRS", CLEAR_DIRTY_JOB_ATTRS },
+	{ "UPDATE_JOBAD", UPDATE_JOBAD },
 	{ NULL, 0 }
 };
 
diff --git a/src/condor_c++_util/enum_utils.cpp b/src/condor_c++_util/enum_utils.cpp
index 579a9f6..603d71c 100644
--- a/src/condor_c++_util/enum_utils.cpp
+++ b/src/condor_c++_util/enum_utils.cpp
@@ -94,6 +94,7 @@ struct Translation JobActionTranslation[] = {
 	{ "Remove-Force", JA_REMOVE_X_JOBS },
 	{ "Vacate", JA_VACATE_JOBS },
 	{ "Vacate-Fast", JA_VACATE_FAST_JOBS },
+	{ "ClearDirtyAttrs", JA_CLEAR_DIRTY_JOB_ATTRS },
 	{ "NULL", 0 }
 };
 
diff --git a/src/condor_c++_util/enum_utils.h b/src/condor_c++_util/enum_utils.h
index e2dd6ca..dd3abb3 100644
--- a/src/condor_c++_util/enum_utils.h
+++ b/src/condor_c++_util/enum_utils.h
@@ -105,7 +105,8 @@ typedef enum {
 	JA_REMOVE_JOBS,
 	JA_REMOVE_X_JOBS,
 	JA_VACATE_JOBS,
-	JA_VACATE_FAST_JOBS
+	JA_VACATE_FAST_JOBS,
+	JA_CLEAR_DIRTY_JOB_ATTRS
 } JobAction;
 
 const char* getJobActionString( JobAction action );
diff --git a/src/condor_daemon_client/dc_schedd.cpp b/src/condor_daemon_client/dc_schedd.cpp
index 3f2aaa1..b0b847e 100644
--- a/src/condor_daemon_client/dc_schedd.cpp
+++ b/src/condor_daemon_client/dc_schedd.cpp
@@ -227,6 +227,20 @@ DCSchedd::vacateJobs( StringList* ids, VacateType vacate_type,
 }
 
 
+ClassAd*
+DCSchedd::clearDirtyAttrs( StringList* ids, CondorError * errstack,
+                                         action_result_type_t result_type )
+{
+	if( ! ids ) {
+		dprintf( D_ALWAYS, "DCSchedd::clearDirtyAttrs: "
+				"list of jobs is NULL, aborting\n" );
+		return NULL;
+	}
+	return actOnJobs( JA_CLEAR_DIRTY_JOB_ATTRS, NULL, ids, NULL, NULL,
+				result_type, false, errstack );
+}
+
+
 bool
 DCSchedd::reschedule()
 {
diff --git a/src/condor_daemon_client/dc_schedd.h b/src/condor_daemon_client/dc_schedd.h
index 9368791..6e4cb43 100644
--- a/src/condor_daemon_client/dc_schedd.h
+++ b/src/condor_daemon_client/dc_schedd.h
@@ -236,6 +236,13 @@ public:
 						 action_result_type_t result_type = AR_TOTALS,
 						 bool notify_scheduler = true );
 
+		/** Clear dirty attributes for a list of job ids
+			@param ids What jobs to act on
+			@param result_type What kind of results you want
+		*/
+	ClassAd* clearDirtyAttrs( StringList* ids, CondorError * errstack,
+						action_result_type_t result_type = AR_TOTALS );
+
 		/** Get starter connection info for a running job.
 			@param jobid What job to act on
 			@param subproc For parallel jobs, which one (-1 if not specified)
diff --git a/src/condor_gridmanager/basejob.cpp b/src/condor_gridmanager/basejob.cpp
index ba74bde..3bd7b91 100644
--- a/src/condor_gridmanager/basejob.cpp
+++ b/src/condor_gridmanager/basejob.cpp
@@ -31,6 +31,7 @@
 #include "condor_config.h"
 #include "condor_email.h"
 #include "classad_helpers.h"
+#include "classad_merge.h"
 
 #define HASH_TABLE_SIZE			500
 
@@ -650,8 +651,7 @@ void BaseJob::JobAdUpdateFromSchedd( const ClassAd *new_ad )
 	new_ad->LookupInteger( ATTR_JOB_STATUS, new_condor_state );
 
 	if ( new_condor_state == condorState ) {
-			// The job state in the sched hasn't changed, so we can ignore
-			// this "update".
+		MergeClassAds( jobAd, (ClassAd*)new_ad, true );
 		return;
 	}
 
@@ -713,6 +713,9 @@ void BaseJob::JobAdUpdateFromSchedd( const ClassAd *new_ad )
 			// TODO do we need to update any other attributes?
 		SetEvaluateState();
 	}
+	else {
+		MergeClassAds( jobAd, (ClassAd*)new_ad, true );
+	}
 
 }
 
diff --git a/src/condor_gridmanager/gridmanager.cpp b/src/condor_gridmanager/gridmanager.cpp
index 2eeff94..717edc0 100644
--- a/src/condor_gridmanager/gridmanager.cpp
+++ b/src/condor_gridmanager/gridmanager.cpp
@@ -99,6 +99,7 @@ struct ScheddUpdateRequest {
 HashTable <PROC_ID, ScheddUpdateRequest *> pendingScheddUpdates( HASH_TABLE_SIZE,
 													 hashFuncPROC_ID );
 bool addJobsSignaled = false;
+bool updateJobsSignaled = false;
 bool checkLeasesSignaled = false;
 int contactScheddTid = TIMER_UNSET;
 int contactScheddDelay;
@@ -120,6 +121,7 @@ int doContactSchedd();
 // handlers
 int ADD_JOBS_signalHandler( int );
 int REMOVE_JOBS_signalHandler( int );
+int UPDATE_JOBAD_signalHandler( int );
 int CHECK_LEASES_signalHandler( int );
 
 
@@ -414,6 +416,9 @@ Register()
 								 (SignalHandler)&REMOVE_JOBS_signalHandler,
 								 "REMOVE_JOBS_signalHandler", NULL );
 
+	daemonCore->Register_Signal( UPDATE_JOBAD, "UpdateJobAd",
+								 (SignalHandler)&UPDATE_JOBAD_signalHandler,
+								 "UPDATE_JOBAD_signalHandler", NULL );
 /*
 	daemonCore->Register_Signal( GRIDMAN_CHECK_LEASES, "CheckLeases",
 								 (SignalHandler)&CHECK_LEASES_signalHandler,
@@ -487,12 +492,24 @@ REMOVE_JOBS_signalHandler( int )
 	return TRUE;
 }
 
+int
+UPDATE_JOBAD_signalHandler( int )
+{
+	dprintf(D_FULLDEBUG,"Received UPDATE_JOBAD signal\n");
+	if ( !updateJobsSignaled ) {
+		RequestContactSchedd();
+		updateJobsSignaled = true;
+	}
+
+	return TRUE;
+}
+
 // Call initJobExprs before using any of the expr_*
 // variables.  It is safe to repeatedly call
 // initJobExprs.
 static const char * expr_false = "FALSE";
+static const char * expr_true = "TRUE";
 // Not currently used
-//static const char * expr_true = "TRUE";
 //static const char * expr_undefined = "UNDEFINED";
 	// The job is matched, or in unknown match state.
 	// definately unmatched
@@ -559,10 +576,15 @@ doContactSchedd()
 	bool schedd_updates_complete = false;
 	bool schedd_deletes_complete = false;
 	bool add_remove_jobs_complete = false;
+	bool update_jobs_complete = false;
 	bool commit_transaction = true;
 	int failure_line_num = 0;
 	bool send_reschedule = false;
 	MyString error_str = "";
+	StringList dirty_job_ids;
+	char *job_id_str;
+	PROC_ID job_id;
+	CondorError errstack;
 
 	dprintf(D_FULLDEBUG,"in doContactSchedd()\n");
 
@@ -578,7 +600,6 @@ doContactSchedd()
 		VacateRequest curr_request;
 
 		int result;
-		CondorError errstack;
 		ClassAd* rval;
 
 		pendingScheddVacates.startIterations();
@@ -911,6 +932,49 @@ contact_schedd_next_add_job:
 
 	add_remove_jobs_complete = true;
 
+
+	// Retrieve dirty attributes
+	/////////////////////////////////////////////////////
+	if ( updateJobsSignaled ) {
+		sprintf( expr_buf, "%s && %s && %s && %s",
+				 expr_schedd_job_constraint.Value(), 
+				 expr_not_completely_done.Value(),
+				 expr_not_held.Value(),
+				 expr_managed.Value()
+				 );
+		dprintf( D_FULLDEBUG,"Using constraint %s\n",expr_buf);
+		next_ad = GetNextDirtyJobByConstraint( expr_buf, 1 );
+		while ( next_ad != NULL ) {
+			ClassAd updates;
+			char str[PROC_ID_STR_BUFLEN];
+			next_ad->LookupInteger( ATTR_CLUSTER_ID, job_id.cluster );
+			next_ad->LookupInteger( ATTR_PROC_ID, job_id.proc );
+			if ( GetDirtyAttributes( job_id.cluster, job_id.proc, &updates ) < 0 ) {
+				dprintf( D_ALWAYS, "Failed to retrieve dirty attributes for job %d.%d\n", job_id.cluster, job_id.proc );
+				failure_line_num = __LINE__;
+				delete next_ad;
+				goto contact_schedd_disconnect;
+		        }
+			else {
+				dprintf (D_FULLDEBUG, "Retrieved updated attributes for job %d.%d\n", job_id.cluster, job_id.proc);
+				updates.dPrint(D_JOB);
+			}
+			if ( BaseJob::JobsByProcId.lookup( job_id, curr_job ) == 0 ) {
+				curr_job->JobAdUpdateFromSchedd( &updates );
+				ProcIdToStr( job_id, str );
+				dirty_job_ids.append( str );
+			}
+			else {
+				dprintf( D_ALWAYS, "Don't know about updated job %d.%d. "
+						 "Ignoring it\n",
+						 job_id.cluster, job_id.proc );
+			}
+			delete next_ad;
+			next_ad = GetNextDirtyJobByConstraint( expr_buf, 0 );
+		}
+	}
+	update_jobs_complete = true;
+
 //	if ( BeginTransaction() < 0 ) {
 	errno = 0;
 	BeginTransaction();
@@ -1068,11 +1132,24 @@ contact_schedd_next_add_job:
 		goto contact_schedd_failure;
 	}
 
+	if ( update_jobs_complete == true ) {
+		updateJobsSignaled = false;
+	} else {
+		error_str.sprintf( "Schedd connection error during dirty attribute update at line %d!", failure_line_num );
+		goto contact_schedd_failure;
+	}
+
 	if ( schedd_updates_complete == false ) {
 		error_str.sprintf( "Schedd connection error during updates at line %d!", failure_line_num );
 		goto contact_schedd_failure;
 	}
 
+	// Clear dirty bits for all jobs updated
+	dirty_job_ids.rewind();
+	if ( ScheddObj->clearDirtyAttrs( &dirty_job_ids, &errstack ) == NULL ) {
+		dprintf(D_ALWAYS, "Failed to notify schedd to clear dirty attributes.  CondorError: %s\n", errstack.getFullText() );
+	}
+
 	// Wake up jobs that had schedd updates pending and delete job
 	// objects that wanted to be deleted
 	pendingScheddUpdates.startIterations();
@@ -1143,6 +1220,15 @@ contact_schedd_next_add_job:
 
 	scheddFailureCount = 0;
 
+	// For each job that had dirty attributes, re-evaluate the policy
+	dirty_job_ids.rewind();
+	while ( (job_id_str = dirty_job_ids.next()) != NULL ) {
+		StrToProcId(job_id_str, job_id);
+		if ( BaseJob::JobsByProcId.lookup( job_id, curr_job ) == 0 ) {
+			curr_job->EvalPeriodicJobExpr();
+		}
+	}
+
 dprintf(D_FULLDEBUG,"leaving doContactSchedd()\n");
 	return TRUE;
 
diff --git a/src/condor_includes/condor_commands.h b/src/condor_includes/condor_commands.h
index 08751d4..3dc775e 100644
--- a/src/condor_includes/condor_commands.h
+++ b/src/condor_includes/condor_commands.h
@@ -163,6 +163,7 @@
 #define GET_JOB_CONNECT_INFO (SCHED_VERS+109) // schedd: get connection information for starter running a job
 
 #define RECYCLE_SHADOW (SCHED_VERS+110) // schedd: get a new job for a shadow
+#define CLEAR_DIRTY_JOB_ATTRS (SCHED_VERS+111) // schedd: clear dirty attributes for a job
 
 // HAD-related commands
 #define HAD_ALIVE_CMD                   (HAD_COMMANDS_BASE + 0)
@@ -392,6 +393,7 @@ const int QUERY_GENERIC_ADS = 74;
 #define MPI_START_COMRADE      (DCSHADOW_BASE+2)  // for MPI & parallel shadow
 #define GIVE_MATCHES 	       (DCSHADOW_BASE+3)  // for MPI & parallel shadow
 #define RECEIVE_JOBAD		   (DCSHADOW_BASE+4)
+#define UPDATE_JOBAD		   (DCSHADOW_BASE+5)
 
 
 /*
diff --git a/src/condor_includes/condor_qmgr.h b/src/condor_includes/condor_qmgr.h
index 8e78ff5..6653a48 100644
--- a/src/condor_includes/condor_qmgr.h
+++ b/src/condor_includes/condor_qmgr.h
@@ -36,6 +36,7 @@ typedef int (*scan_func)(ClassAd *ad);
 
 typedef unsigned char SetAttributeFlags_t;
 const SetAttributeFlags_t NONDURABLE = 1;
+const SetAttributeFlags_t SETDIRTY = 2;
 
 #define SHADOW_QMGMT_TIMEOUT 300
 
@@ -101,28 +102,32 @@ int DestroyCluster(int cluster_id, const char *reason = NULL);
 	@return -1 on failure; 0 on success
 */
 int SetAttributeByConstraint(const char *constraint, const char *attr,
-							 const char *value);
+							 const char *value,
+							 SetAttributeFlags_t flags=0);
 /** For all jobs in the queue for which constraint evaluates to true, set
 	attr = value.  The value should be a valid ClassAd value (strings
 	should be surrounded by quotes).
 	@return -1 on failure; 0 on success
 */
 int SetAttributeIntByConstraint(const char *constraint, const char *attr,
-								int value);
+							 int value,
+							 SetAttributeFlags_t flags=0);
 /** For all jobs in the queue for which constraint evaluates to true, set
 	attr = value.  The value should be a valid ClassAd value (strings
 	should be surrounded by quotes).
 	@return -1 on failure; 0 on success
 */
 int SetAttributeFloatByConstraint(const char *constraing, const char *attr,
-								  float value);
+							   float value,
+							   SetAttributeFlags_t flags=0);
 /** For all jobs in the queue for which constraint evaluates to true, set
 	attr = value.  The value should be a valid ClassAd value (strings
 	should be surrounded by quotes).
 	@return -1 on failure; 0 on success
 */
 int SetAttributeStringByConstraint(const char *constraint, const char *attr,
-								   const char *value);
+							     const char *value,
+							     SetAttributeFlags_t flags=0);
 /** Set attr = value for job with specified cluster and proc.  The value
 	should be a valid ClassAd value (strings should be surrounded by
 	quotes)
@@ -221,6 +226,12 @@ int GetAttributeString( int cluster_id, int proc_id, char const *attr_name,
 	@return -1 on failure; 0 on success
 */
 int GetAttributeExprNew(int cluster, int proc, const char *attr, char **value);
+
+/** Retrieves a classad of attributes that are marked as dirty, then clears
+	the dirty list
+*/
+int GetDirtyAttributes(int cluster_id, int proc_id, ClassAd *updated_attrs);
+
 /** Delete specified attribute for job with specified cluster and proc.
 	@return -1 on failure; 0 on success
 */
@@ -255,6 +266,11 @@ ClassAd *GetNextJob(int initScan);
 	The caller MUST call FreeJobAd when the ad is no longer in use. 
 */
 ClassAd *GetNextJobByConstraint(const char *constraint, int initScan);
+/** Iterate over jobs with dirty attributes in the queue which match the
+	specified constraint.
+	The caller MUST call FreeJobAd when the ad is no longer in use. 
+*/
+ClassAd *GetNextDirtyJobByConstraint(const char *constraint, int initScan);
 /** De-allocate job ClassAd allocated by GetJobAd, GetJobAdByConstraint,
 	GetNextJob, or GetNextJobByConstraint.
 */
@@ -289,7 +305,9 @@ void InitJobQueue(const char *job_queue_name,int max_historical_logs);
 void CleanJobQueue();
 bool setQSock( ReliSock* rsock );
 void unsetQSock();
-
+void MarkJobClean(PROC_ID job_id);
+void MarkJobClean(int cluster_id, int proc_id);
+void MarkJobClean(const char* job_id_str);
 
 int rusage_to_float(struct rusage, float *, float *);
 int float_to_rusage(float, float, struct rusage *);
diff --git a/src/condor_schedd.V6/grid_universe.cpp b/src/condor_schedd.V6/grid_universe.cpp
index fc6b61c..386fa2f 100644
--- a/src/condor_schedd.V6/grid_universe.cpp
+++ b/src/condor_schedd.V6/grid_universe.cpp
@@ -383,6 +383,25 @@ GridUniverseLogic::lookupGmanByOwner(const char* owner, const char* attr_value,
 	return result;
 }
 
+int
+GridUniverseLogic::FindGManagerPid(const char* owner,
+					const char* attr_value,	
+					int cluster, int proc)
+{
+	gman_node_t* gman_node;
+
+	if ( attr_value && strlen(attr_value)==0 ) {
+		attr_value = NULL;
+	}
+
+	if ( (gman_node=lookupGmanByOwner(owner, attr_value, cluster, proc)) ) {
+		return gman_node->pid;
+	}
+	else {
+		return -1;
+	}
+}
+
 GridUniverseLogic::gman_node_t *
 GridUniverseLogic::StartOrFindGManager(const char* owner, const char* domain,
 	   	const char* attr_value, const char* attr_name, int cluster, int proc)
diff --git a/src/condor_schedd.V6/grid_universe.h b/src/condor_schedd.V6/grid_universe.h
index dca47bb..72fc1cf 100644
--- a/src/condor_schedd.V6/grid_universe.h
+++ b/src/condor_schedd.V6/grid_universe.h
@@ -40,6 +40,9 @@ class GridUniverseLogic : public Service
 			   	const char* attr_value, const char* attr_name, int cluster, 
 				int proc);
 
+		static int FindGManagerPid(const char* owner,
+							const char* attr_value,
+							int cluster, int proc);
 		static void reconfig() { signal_all(SIGHUP); }
 		static void shutdown_graceful() { signal_all(SIGTERM); }
 		static void shutdown_fast() { signal_all(SIGQUIT); }
diff --git a/src/condor_schedd.V6/qmgmt.cpp b/src/condor_schedd.V6/qmgmt.cpp
index ed44856..37599ef 100644
--- a/src/condor_schedd.V6/qmgmt.cpp
+++ b/src/condor_schedd.V6/qmgmt.cpp
@@ -71,6 +71,7 @@ extern "C" {
 
 extern  void    cleanup_ckpt_files(int, int, const char*);
 extern	bool	service_this_universe(int, ClassAd *);
+extern	bool	jobExternallyManaged(ClassAd * ad);
 static QmgmtPeer *Q_SOCK = NULL;
 
 // Hash table with an entry for every job owner that
@@ -83,6 +84,7 @@ void	FindPrioJob(PROC_ID &);
 
 static bool qmgmt_was_initialized = false;
 static ClassAdCollection *JobQueue = 0;
+static StringList DirtyJobIDs;
 static int next_cluster_num = -1;
 static int next_proc_num = 0;
 static int active_cluster_num = -1;	// client is restricted to only insert jobs to the active cluster
@@ -124,8 +126,11 @@ static ClusterSizeHashTable_t *ClusterSizeHashTable = 0;
 static int TotalJobsCount = 0;
 
 static int flush_job_queue_log_timer_id = -1;
+static int dirty_notice_timer_id = -1;
 static int flush_job_queue_log_delay = 0;
+static int dirty_notice_interval = 0;
 static int HandleFlushJobQueueLogTimer(Service *);
+static int PeriodicDirtyAttributeNotification(Service *);
 static void ScheduleJobQueueLogFlush();
 
 bool qmgmt_all_users_trusted = false;
@@ -683,6 +688,7 @@ InitQmgmt()
     cluster_maximum_val = param_integer("SCHEDD_CLUSTER_MAXIMUM_VALUE",0,0);
 
 	flush_job_queue_log_delay = param_integer("SCHEDD_JOB_QUEUE_LOG_FLUSH_DELAY",5,0);
+	dirty_notice_interval = param_integer("SCHEDD_JOB_QUEUE_NOTIFY_UPDATES",30,0);
 }
 
 void
@@ -960,6 +966,8 @@ DestroyJobQueue( void )
 	delete JobQueue;
 	JobQueue = NULL;
 
+	DirtyJobIDs.clearAll();
+
 		// There's also our hashtable of the size of each cluster
 	delete ClusterSizeHashTable;
 	ClusterSizeHashTable = NULL;
@@ -1777,7 +1785,8 @@ int DestroyCluster(int cluster_id, const char* reason)
 
 int
 SetAttributeByConstraint(const char *constraint, const char *attr_name,
-						 const char *attr_value)
+						 const char *attr_value,
+						 SetAttributeFlags_t flags)
 {
 	ClassAd	*ad;
 	int cluster_num, proc_num;
@@ -1792,7 +1801,7 @@ SetAttributeByConstraint(const char *constraint, const char *attr_name,
 			 (proc_num > -1) &&
 			 EvalBool(ad, constraint)) {
 			found_one = 1;
-			if( SetAttribute(cluster_num,proc_num,attr_name,attr_value) < 0 ) {
+			if( SetAttribute(cluster_num,proc_num,attr_name,attr_value,flags) < 0 ) {
 				had_error = 1;
 			}
 			FreeJobAd(ad);	// a no-op on the server side
@@ -1811,7 +1820,7 @@ SetAttributeByConstraint(const char *constraint, const char *attr_name,
 
 int
 SetAttribute(int cluster_id, int proc_id, const char *attr_name,
-			 const char *attr_value, SetAttributeFlags_t flags )
+			 const char *attr_value, SetAttributeFlags_t flags)
 {
 //	LogSetAttribute	*log;
 	char			key[PROC_ID_STR_BUFLEN];
@@ -1968,7 +1977,7 @@ SetAttribute(int cluster_id, int proc_id, const char *attr_name,
 						 &nice_user );
 		user.sprintf( "\"%s%s@%s\"", (nice_user) ? "nice-user." : "",
 				 owner, scheduler.uidDomain() );
-		SetAttribute( cluster_id, proc_id, ATTR_USER, user.Value() );
+		SetAttribute( cluster_id, proc_id, ATTR_USER, user.Value(), flags );
 
 			// Also update the owner history hash table
 		AddOwnerHistory(owner);
@@ -1998,7 +2007,7 @@ SetAttribute(int cluster_id, int proc_id, const char *attr_name,
 			>= 0 ) {
 			user.sprintf( "\"%s%s@%s\"", (nice_user) ? "nice-user." :
 					 "", owner.Value(), scheduler.uidDomain() );
-			SetAttribute( cluster_id, proc_id, ATTR_USER, user.Value() );
+			SetAttribute( cluster_id, proc_id, ATTR_USER, user.Value(), flags );
 		}
 	}
 	else if (stricmp(attr_name, ATTR_PROC_ID) == 0) {
@@ -2034,7 +2043,7 @@ SetAttribute(int cluster_id, int proc_id, const char *attr_name,
 			// UNEXPANDED.
 		int status = UNEXPANDED;
 		GetAttributeInt( cluster_id, proc_id, ATTR_JOB_STATUS, &status );
-		SetAttributeInt( cluster_id, proc_id, ATTR_LAST_JOB_STATUS, status );
+		SetAttributeInt( cluster_id, proc_id, ATTR_LAST_JOB_STATUS, status, flags );
 	}
 
 	// If any of the attrs used to create the signature are
@@ -2078,7 +2087,7 @@ SetAttribute(int cluster_id, int proc_id, const char *attr_name,
 			// first, store the actual value
 			MyString raw_attribute = attr_name;
 			raw_attribute += "_RAW";
-			JobQueue->SetAttribute(key, raw_attribute.Value(), attr_value);
+			JobQueue->SetAttribute(key, raw_attribute.Value(), attr_value, flags & SETDIRTY);
 
 			long ivalue;
 			double fvalue;
@@ -2174,20 +2183,82 @@ SetAttribute(int cluster_id, int proc_id, const char *attr_name,
 		old_nondurable_level = JobQueue->IncNondurableCommitLevel();
 	}
 
-	JobQueue->SetAttribute(key, attr_name, attr_value);
+	JobQueue->SetAttribute(key, attr_name, attr_value, flags & SETDIRTY);
 
+	int status;
 	if( flags & NONDURABLE ) {
 		JobQueue->DecNondurableCommitLevel( old_nondurable_level );
 
 		ScheduleJobQueueLogFlush();
 	}
 
+	// Get the job's status and only mark dirty if it is running
+	int universe;
+	GetAttributeInt( cluster_id, proc_id, ATTR_JOB_STATUS, &status );
+	GetAttributeInt( cluster_id, proc_id, ATTR_JOB_UNIVERSE, &universe );
+	if( ( flags & SETDIRTY ) && ( status == RUNNING || ( universe == CONDOR_UNIVERSE_GRID ) && jobExternallyManaged( ad ) ) ) {
+		// Add the key to list of dirty classads
+		DirtyJobIDs.rewind();
+		if( ! DirtyJobIDs.contains( key ) ) {
+			DirtyJobIDs.append( key );
+		}
+
+		// Start timer to ensure notice is confirmed
+		if( dirty_notice_timer_id <= 0 ) {
+			dprintf(D_FULLDEBUG, "Starting dirty attribute notification timer\n");
+			dirty_notice_timer_id = daemonCore->Register_Timer(
+				dirty_notice_interval,
+				dirty_notice_interval,
+				PeriodicDirtyAttributeNotification,
+				"PeriodicDirtyAttributeNotification");
+		}
+
+		SendDirtyJobAdNotification(key);
+	}
+
 	JobQueueDirty = true;
 
 	return 0;
 }
 
 void
+SendDirtyJobAdNotification(char *job_id_str)
+{
+	PROC_ID job_id;
+	int pid = -1;
+
+	StrToId(job_id_str, job_id.cluster, job_id.proc);
+	shadow_rec *srec = scheduler.FindSrecByProcID(job_id);
+	if( srec ) {
+		pid = srec->pid;
+	}
+	else {
+		pid = scheduler.FindGManagerPid(job_id);
+	}
+
+	if( pid > 0 ) {
+		dprintf(D_FULLDEBUG, "Sending signal %d, to pid %d\n", UPDATE_JOBAD, pid);
+		classy_counted_ptr<DCSignalMsg> msg = new DCSignalMsg(pid, UPDATE_JOBAD);
+		daemonCore->Send_Signal_nonblocking(msg.get());
+//		daemonCore->Send_Signal(srec->pid, UPDATE_JOBAD);
+	}
+	else {
+		dprintf(D_ALWAYS, "Failed to send signal %d, no job manager found\n", UPDATE_JOBAD);
+	}
+}
+
+int
+PeriodicDirtyAttributeNotification(Service *)
+{
+	char	*job_id;
+
+	DirtyJobIDs.rewind();
+	while( (job_id = DirtyJobIDs.next()) != NULL ) {
+		SendDirtyJobAdNotification(job_id);
+	}
+}
+
+void
 ScheduleJobQueueLogFlush()
 {
 		// Flush the log after a short delay so that we avoid spending
@@ -2739,6 +2810,44 @@ GetAttributeExprNew(int cluster_id, int proc_id, const char *attr_name, char **v
 
 
 int
+GetDirtyAttributes(int cluster_id, int proc_id, ClassAd *updated_attrs)
+{
+	ClassAd 	*ad;
+	char		key[PROC_ID_STR_BUFLEN];
+	char		*val;
+	char		*name;
+	ExprTree 	*expr;
+
+	IdToStr(cluster_id,proc_id,key);
+
+	if(!JobQueue->LookupClassAd(key, ad)) {
+		return -1;
+	}
+
+	ad->ResetExpr();
+	while( (expr = ad->NextDirtyExpr()) != NULL )
+	{
+		expr->LArg()->PrintToNewStr(&name);
+		if(!ad->ClassAdAttributeIsPrivate(name))
+		{
+			if(!JobQueue->LookupInTransaction(key, name, val) )
+			{
+				updated_attrs->Insert(expr->DeepCopy());
+			}
+			else
+			{
+				updated_attrs->AssignExpr(name, val);
+				free(val);
+			}
+		}
+		free(name);
+	}
+
+	return 0;
+}
+
+
+int
 DeleteAttribute(int cluster_id, int proc_id, const char *attr_name)
 {
 	ClassAd				*ad;
@@ -2775,6 +2884,45 @@ DeleteAttribute(int cluster_id, int proc_id, const char *attr_name)
 	return 1;
 }
 
+void
+MarkJobClean(PROC_ID job_id)
+{
+
+	MarkJobClean(job_id.cluster, job_id.proc);
+}
+
+void
+MarkJobClean(int cluster_id, int proc_id)
+{
+	char	key[PROC_ID_STR_BUFLEN];
+
+	IdToStr(cluster_id,proc_id,key);
+	MarkJobClean(key);
+}
+
+void
+MarkJobClean(const char* job_id_str)
+{
+	int cluster;
+	int proc;
+
+	if(JobQueue->ClearClassAdDirtyBits(job_id_str))
+	{
+		dprintf(D_FULLDEBUG, "Cleared dirty attributes for job %s\n", job_id_str);
+	}
+
+	DirtyJobIDs.rewind();
+	DirtyJobIDs.remove(job_id_str);
+
+	if( DirtyJobIDs.isEmpty() && dirty_notice_timer_id > 0 )
+	{
+		dprintf(D_FULLDEBUG, "Cancelling dirty attribute notification timer\n");
+		daemonCore->Cancel_Timer(dirty_notice_timer_id);
+		dirty_notice_timer_id = -1;
+	}
+	StrToId(job_id_str, cluster, proc);
+}
+
 ClassAd *
 dollarDollarExpand(int cluster_id, int proc_id, ClassAd *ad, ClassAd *startd_ad, bool persist_expansions)
 {
@@ -3411,6 +3559,30 @@ GetNextJobByConstraint(const char *constraint, int initScan)
 	return NULL;
 }
 
+
+ClassAd *
+GetNextDirtyJobByConstraint(const char *constraint, int initScan)
+{
+	ClassAd *ad;
+	char *job_id_str;
+
+	if (initScan) {
+		DirtyJobIDs.rewind( );
+	}
+
+	while( (job_id_str = DirtyJobIDs.next( )) != NULL ) {
+		if( !JobQueue->LookupClassAd( job_id_str, ad ) ) {
+			dprintf(D_ALWAYS, "Warning: Job %s is marked dirty, but could not find in the job queue.  Skipping\n", job_id_str);
+			continue;
+		}
+
+		if ( !constraint || !constraint[0] || EvalBool(ad, constraint)) {
+			return ad;
+		}
+	}
+	return NULL;
+}
+
 ClassAd *
 GetNextJobByCluster(int c, int initScan)
 {
diff --git a/src/condor_schedd.V6/qmgmt.h b/src/condor_schedd.V6/qmgmt.h
index 6751de1..9cdd233 100644
--- a/src/condor_schedd.V6/qmgmt.h
+++ b/src/condor_schedd.V6/qmgmt.h
@@ -82,6 +82,8 @@ time_t GetOriginalJobQueueBirthdate();
 void DestroyJobQueue( void );
 int handle_q(Service *, int, Stream *sock);
 void dirtyJobQueue( void );
+void SendDirtyJobAdNotification(char *job_id_str);
+
 bool isQueueSuperUser( const char* user );
 
 // Verify that the user issuing a command (test_owner) is authorized
diff --git a/src/condor_schedd.V6/qmgmt_constants.h b/src/condor_schedd.V6/qmgmt_constants.h
index b440bfe..1cb8f09 100644
--- a/src/condor_schedd.V6/qmgmt_constants.h
+++ b/src/condor_schedd.V6/qmgmt_constants.h
@@ -47,3 +47,6 @@
 #define CONDOR_CloseSocket			10028
 #define CONDOR_SendSpoolFileIfNeeded 10029
 #define CONDOR_CommitTransaction    10031
+#define	CONDOR_SetAttributeByConstraint2	10032		/* Rob */
+#define CONDOR_GetDirtyAttributes	10033		/* Rob */
+#define CONDOR_GetNextDirtyJobByConstraint	10034	/* Rob */
diff --git a/src/condor_schedd.V6/qmgmt_receivers.cpp b/src/condor_schedd.V6/qmgmt_receivers.cpp
index b1bb18e..aaea982 100644
--- a/src/condor_schedd.V6/qmgmt_receivers.cpp
+++ b/src/condor_schedd.V6/qmgmt_receivers.cpp
@@ -224,16 +224,21 @@ do_Q_request(ReliSock *syscall_sock,bool &may_fork)
 #endif
 
 	case CONDOR_SetAttributeByConstraint:
+	case CONDOR_SetAttributeByConstraint2:
 	  {
 		char *attr_name=NULL;
 		char *attr_value=NULL;
 		char *constraint=NULL;
 		int terrno;
+		SetAttributeFlags_t flags = 0;
 
 		assert( syscall_sock->code(constraint) );
 		dprintf( D_SYSCALLS, "  constraint = %s\n",constraint);
 		assert( syscall_sock->code(attr_value) );
 		assert( syscall_sock->code(attr_name) );
+		if( request_num == CONDOR_SetAttributeByConstraint2 ) {
+			assert( syscall_sock->code( flags ) );
+		}
 		assert( syscall_sock->end_of_message() );;
 
 		if (strcmp (attr_name, ATTR_MYPROXY_PASSWORD) == 0) {
@@ -244,7 +249,7 @@ do_Q_request(ReliSock *syscall_sock,bool &may_fork)
 		} else {
 
 			errno = 0;
-			rval = SetAttributeByConstraint( constraint, attr_name, attr_value );
+			rval = SetAttributeByConstraint( constraint, attr_name, attr_value, flags );
 			terrno = errno;
 			dprintf( D_SYSCALLS, "\trval = %d, errno = %d\n", rval, terrno );
 		}
@@ -596,6 +601,43 @@ do_Q_request(ReliSock *syscall_sock,bool &may_fork)
 		return 0;
 	}
 
+	case CONDOR_GetDirtyAttributes:
+	  {
+		int cluster_id = -1;
+		int proc_id = -1;
+		ClassAd updates;
+
+		int terrno;
+
+		assert( syscall_sock->code(cluster_id) );
+		dprintf( D_SYSCALLS, "	cluster_id = %d\n", cluster_id );
+		assert( syscall_sock->code(proc_id) );
+		dprintf( D_SYSCALLS, "	proc_id = %d\n", proc_id );
+		assert( syscall_sock->end_of_message() );;
+
+		errno = 0;
+		rval = GetDirtyAttributes( cluster_id, proc_id, &updates );
+
+		terrno = errno;
+		dprintf( D_SYSCALLS, "\trval = %d, errno = %d\n", rval, terrno );
+
+		syscall_sock->encode();
+
+		if ( !syscall_sock->code(rval) ) {
+			return -1;
+		}
+		if( rval < 0 ) {
+			if ( !syscall_sock->code(terrno) ) {
+					return -1;
+			}
+		}
+		if( rval >= 0 ) {
+			assert( updates.put(*syscall_sock) );
+		}
+		assert( syscall_sock->end_of_message() );;
+		return 0;
+	}
+
 	case CONDOR_DeleteAttribute:
 	  {
 		int cluster_id = -1;
@@ -788,6 +830,45 @@ do_Q_request(ReliSock *syscall_sock,bool &may_fork)
 		assert( syscall_sock->end_of_message() );;
 		return 0;
 	}
+	case CONDOR_GetNextDirtyJobByConstraint:
+	{
+		char *constraint=NULL;
+		ClassAd *ad;
+		int initScan = 0;
+		int terrno;
+
+		assert( syscall_sock->code(initScan) );
+		dprintf( D_SYSCALLS, "  initScan = %d\n", initScan );
+		if ( !(syscall_sock->code(constraint)) ) {
+			if (constraint != NULL) {
+				free(constraint);
+				constraint = NULL;
+			}
+			return -1;
+		}
+		assert( syscall_sock->end_of_message() );
+
+		errno = 0;
+		ad = GetNextDirtyJobByConstraint( constraint, initScan );
+		terrno = errno;
+		rval = ad ? 0 : -1;
+		dprintf( D_SYSCALLS, "\trval = %d, errno = %d\n", rval, terrno );
+
+		syscall_sock->encode();
+		assert( syscall_sock->code(rval) );
+		if( rval < 0 ) {
+			assert( syscall_sock->code(terrno) );
+		}
+		if( rval >= 0 ) {
+			ad->SetPrivateAttributesInvisible( true );
+			assert( ad->put(*syscall_sock) );
+			ad->SetPrivateAttributesInvisible( false );
+		}
+		FreeJobAd(ad);
+		free( (char *)constraint );
+		assert( syscall_sock->end_of_message() );
+		return 0;
+	}
 
 	case CONDOR_SendSpoolFile:
 	  {
diff --git a/src/condor_schedd.V6/qmgmt_send_stubs.cpp b/src/condor_schedd.V6/qmgmt_send_stubs.cpp
index 0be0fe2..2a75085 100644
--- a/src/condor_schedd.V6/qmgmt_send_stubs.cpp
+++ b/src/condor_schedd.V6/qmgmt_send_stubs.cpp
@@ -192,17 +192,23 @@ DestroyClusterByConstraint( char *constraint )
 
 
 int
-SetAttributeByConstraint( char const *constraint, char const *attr_name, char const *attr_value )
+SetAttributeByConstraint( char const *constraint, char const *attr_name, char const *attr_value, SetAttributeFlags_t flags )
 {
 	int	rval = -1;
 
 		CurrentSysCall = CONDOR_SetAttributeByConstraint;
+		if( flags ) {
+			CurrentSysCall = CONDOR_SetAttributeByConstraint2;
+		}
 
 		qmgmt_sock->encode();
 		assert( qmgmt_sock->code(CurrentSysCall) );
 		assert( qmgmt_sock->put(constraint) );
 		assert( qmgmt_sock->put(attr_value) );
 		assert( qmgmt_sock->put(attr_name) );
+		if( flags ) {
+			assert( qmgmt_sock->code(flags) );
+		}
 		assert( qmgmt_sock->end_of_message() );
 
 		qmgmt_sock->decode();
@@ -500,6 +506,41 @@ GetAttributeExprNew( int cluster_id, int proc_id, char const *attr_name, char **
 
 
 int
+GetDirtyAttributes(int cluster_id, int proc_id, ClassAd *updated_attrs)
+{
+	int	rval = -1;
+	char	*attrs = NULL;
+	int	size;
+	MyString errs;
+
+	CurrentSysCall = CONDOR_GetDirtyAttributes;
+
+	qmgmt_sock->encode();
+	assert( qmgmt_sock->code(CurrentSysCall) );
+	assert( qmgmt_sock->code(cluster_id) );
+	assert( qmgmt_sock->code(proc_id) );
+	assert( qmgmt_sock->end_of_message() );
+
+	qmgmt_sock->decode();
+	assert( qmgmt_sock->code(rval) );
+	if( rval < 0 ) {
+		assert( qmgmt_sock->code(terrno) );
+		assert( qmgmt_sock->end_of_message() );
+		errno = terrno;
+		return rval;
+	}
+
+	if ( !(updated_attrs->initFromStream(*qmgmt_sock)) ) {
+		errno = ETIMEDOUT;
+		return NULL;
+	}
+	assert( qmgmt_sock->end_of_message() );
+
+	return rval;
+}
+
+
+int
 DeleteAttribute( int cluster_id, int proc_id, char const *attr_name )
 {
 	int	rval = -1;
@@ -777,3 +818,38 @@ GetAllJobsByConstraint( char const *constraint, char const *projection, ClassAdL
 {
 	GetAllJobsByConstraint_imp(constraint,projection,list);
 }
+
+ClassAd *
+GetNextDirtyJobByConstraint( char const *constraint, int initScan )
+{
+	int	rval = -1;
+
+	CurrentSysCall = CONDOR_GetNextDirtyJobByConstraint;
+
+	qmgmt_sock->encode();
+	assert( qmgmt_sock->code(CurrentSysCall) );
+	assert( qmgmt_sock->code(initScan) );
+	assert( qmgmt_sock->put(constraint) );
+	assert( qmgmt_sock->end_of_message() );
+
+	qmgmt_sock->decode();
+	assert( qmgmt_sock->code(rval) );
+	if( rval < 0 ) {
+		assert( qmgmt_sock->code(terrno) );
+		assert( qmgmt_sock->end_of_message() );
+		errno = terrno;
+		return NULL;
+	}
+
+	ClassAd *ad = new ClassAd;
+
+	if ( ! (ad->initFromStream(*qmgmt_sock)) ) {
+		delete ad;
+		errno = ETIMEDOUT;
+		return NULL;
+	}
+
+	assert( qmgmt_sock->end_of_message() );
+
+	return ad;
+}
diff --git a/src/condor_schedd.V6/qmgr_job_updater.cpp b/src/condor_schedd.V6/qmgr_job_updater.cpp
index 128de25..da5da7f 100644
--- a/src/condor_schedd.V6/qmgr_job_updater.cpp
+++ b/src/condor_schedd.V6/qmgr_job_updater.cpp
@@ -25,10 +25,12 @@
 #include "condor_attributes.h"
 #include "condor_classad.h"
 #include "internet.h"
+#include "classad_merge.h"
 
 
 #include "qmgr_job_updater.h"
 #include "condor_qmgr.h"
+#include "dc_schedd.h"
 
 
 QmgrJobUpdater::QmgrJobUpdater( ClassAd* job, const char* schedd_address )
@@ -333,6 +335,40 @@ QmgrJobUpdater::updateJob( update_t type, SetAttributeFlags_t commit_flags )
 }
 
 
+bool
+QmgrJobUpdater::retrieveJobUpdates( void )
+{
+	ClassAd updates;
+	CondorError errstack;
+	StringList job_ids;
+	char id_str[PROC_ID_STR_BUFLEN];
+	MyString error;
+
+	ProcIdToStr(cluster, proc, id_str);
+	job_ids.insert(id_str);
+
+	if ( !ConnectQ( schedd_addr, SHADOW_QMGMT_TIMEOUT, false ) ) {
+		return false;
+	}
+	if ( GetDirtyAttributes( cluster, proc, &updates ) < 0 ) {
+		DisconnectQ(NULL,false);
+		return false;
+	}
+	DisconnectQ( NULL, false );
+
+	dprintf( D_FULLDEBUG, "Retrieved updated attributes from schedd\n" );
+	updates.dPrint( D_JOB );
+	MergeClassAds( job_ad, &updates, true );
+
+	DCSchedd schedd( schedd_addr );
+	if ( schedd.clearDirtyAttrs( &job_ids, &errstack ) == NULL ) {
+		dprintf( D_ALWAYS, "clearDirtyAttrs() failed: %s\n", errstack.getFullText( ) );
+		return false;
+	}
+	return true;
+}
+
+
 void
 QmgrJobUpdater::periodicUpdateQ( void )
 {
diff --git a/src/condor_schedd.V6/qmgr_job_updater.h b/src/condor_schedd.V6/qmgr_job_updater.h
index 5d40ace..ea377fb 100644
--- a/src/condor_schedd.V6/qmgr_job_updater.h
+++ b/src/condor_schedd.V6/qmgr_job_updater.h
@@ -87,6 +87,10 @@ public:
 		*/
 	bool watchAttribute( const char* attr, update_t type = U_NONE );
 
+		/** Connect to the job queue and retrieve changed attributes
+		*/
+	bool retrieveJobUpdates( void );
+
 private:
 
 		/** Initialize our StringLists for attributes we want to keep
diff --git a/src/condor_schedd.V6/schedd.cpp b/src/condor_schedd.V6/schedd.cpp
index 2e01967..3f2fb81 100644
--- a/src/condor_schedd.V6/schedd.cpp
+++ b/src/condor_schedd.V6/schedd.cpp
@@ -604,7 +604,6 @@ Scheduler::~Scheduler()
 		}
 		delete this->cronTabs;
 	}
-
 }
 
 void
@@ -1550,6 +1549,9 @@ abort_job_myself( PROC_ID job_id, JobAction action, bool log_hold,
 				ATTR_JOB_STATUS,job_id.cluster, job_id.proc);
 	}
 
+	// Mark the job clean
+	MarkJobClean(job_id);
+
 	int job_universe = CONDOR_UNIVERSE_STANDARD;
 	job_ad->LookupInteger(ATTR_JOB_UNIVERSE,job_universe);
 
@@ -3984,8 +3986,9 @@ Scheduler::actOnJobs(int, Stream* s)
 		   Find out what they want us to do.  This classad should
 		   contain:
 		   ATTR_JOB_ACTION - either JA_HOLD_JOBS, JA_RELEASE_JOBS,
-		                     JA_REMOVE_JOBS, JA_REMOVE_X_JOBS, 
-							 JA_VACATE_JOBS, or JA_VACATE_FAST_JOBS
+					JA_REMOVE_JOBS, JA_REMOVE_X_JOBS, 
+					JA_VACATE_JOBS, JA_VACATE_FAST_JOBS, or
+					JA_CLEAR_DIRTY_JOB_ATTRS
 		   ATTR_ACTION_RESULT_TYPE - either AR_TOTALS or AR_LONG
 		   and one of:
 		   ATTR_ACTION_CONSTRAINT - a string with a ClassAd constraint 
@@ -4027,6 +4030,7 @@ Scheduler::actOnJobs(int, Stream* s)
 		break;
 	case JA_VACATE_JOBS:
 	case JA_VACATE_FAST_JOBS:
+	case JA_CLEAR_DIRTY_JOB_ATTRS:
 			// no new_status needed.  also, we're not touching
 			// anything in the job queue, so we don't need a
 			// transaction, either...
@@ -4121,6 +4125,9 @@ Scheduler::actOnJobs(int, Stream* s)
 				// Only vacate running jobs
 			snprintf( buf, 256, "(%s==%d) && (", ATTR_JOB_STATUS, RUNNING );
 			break;
+		case JA_CLEAR_DIRTY_JOB_ATTRS:
+				// No need to further restrict jobs
+			break;
 		default:
 			EXCEPT( "impossible: unknown action (%d) in actOnJobs() after "
 					"it was already recognized", action_num );
@@ -4177,11 +4184,19 @@ Scheduler::actOnJobs(int, Stream* s)
 			// do what we want.  Instead, we'll just iterate through
 			// the Q ourselves so we know exactly what jobs we hit. 
 
+		ClassAd* (*GetNextJobFunc) (const char *, int);
 		ClassAd* job_ad;
-		job_ad = GetNextJobByConstraint( constraint, 1 );
-		for( job_ad = GetNextJobByConstraint( constraint, 1 );
+		if( action == JA_CLEAR_DIRTY_JOB_ATTRS )
+		{
+			GetNextJobFunc = &GetNextDirtyJobByConstraint;
+		}
+		else
+		{
+			GetNextJobFunc = &GetNextJobByConstraint;
+		}
+		for( job_ad = (*GetNextJobFunc)( constraint, 1 );
 		     job_ad;
-		     job_ad = GetNextJobByConstraint( constraint, 0 ))
+		     job_ad = (*GetNextJobFunc)( constraint, 0 ))
 		{
 			if(	job_ad->LookupInteger(ATTR_CLUSTER_ID,tmp_id.cluster) &&
 				job_ad->LookupInteger(ATTR_PROC_ID,tmp_id.proc) ) 
@@ -4235,6 +4250,13 @@ Scheduler::actOnJobs(int, Stream* s)
 						continue;
 					}
 				}
+				if( action == JA_CLEAR_DIRTY_JOB_ATTRS ) {
+					MarkJobClean( tmp_id.cluster, tmp_id.proc );
+					results.record( tmp_id, AR_SUCCESS );
+					jobs[num_matches] = tmp_id;
+					num_matches++;
+					continue;
+				}
 				if( SetAttributeInt(tmp_id.cluster, tmp_id.proc,
 									ATTR_JOB_STATUS, new_status) < 0 ) {
 					results.record( tmp_id, AR_PERMISSION_DENIED );
@@ -4333,6 +4355,10 @@ Scheduler::actOnJobs(int, Stream* s)
 					continue;
 				}
 				break;
+			case JA_CLEAR_DIRTY_JOB_ATTRS:
+				MarkJobClean( tmp_id.cluster, tmp_id.proc );
+				results.record( tmp_id, AR_SUCCESS );
+				break;
 			default:
 				EXCEPT( "impossible: unknown action (%d) in actOnJobs() "
 						"after it was already recognized", action_num );
@@ -4598,6 +4624,9 @@ Scheduler::actOnJobMyselfHandler( ServiceData* data )
 		DestroyProc( job_id.cluster, job_id.proc );
 		break;
     }
+	case JA_CLEAR_DIRTY_JOB_ATTRS:
+		// Nothing to do
+		break;
 	case JA_ERROR:
 	default:
 		EXCEPT( "impossible: unknown action (%d) at the end of actOnJobs()",
@@ -8716,6 +8745,7 @@ _mark_job_running(PROC_ID* job_id)
 		SetAttributeInt(job_id->cluster, job_id->proc,
 						ATTR_NUM_JOB_STARTS, num);
 	}
+	MarkJobClean(*job_id);
 }
 
 void
@@ -9603,6 +9633,7 @@ Scheduler::jobExitCode( PROC_ID job_id, int exit_code )
 		daemon_name = ( IsLocalUniverse( srec ) ? "Local Starter" : "Shadow" );
 	}
 
+	MarkJobClean( job_id );
 		//
 		// If this boolean gets set to true, then we need to report
 		// that an Exception occurred for the job.
@@ -9739,6 +9770,7 @@ Scheduler::jobExitCode( PROC_ID job_id, int exit_code )
 					this->cronTabs->remove(job_id);
 				}
 			} // CronTab
+
 			break;
 		}
 
@@ -10952,6 +10984,10 @@ Scheduler::Register()
 								  (CommandHandlercpp)&Scheduler::get_job_connect_info_handler,
 								  "get_job_connect_info", this, WRITE );
 
+	daemonCore->Register_Command( CLEAR_DIRTY_JOB_ATTRS, "CLEAR_DIRTY_JOB_ATTRS",
+								  (CommandHandlercpp)&Scheduler::clear_dirty_job_attrs_handler,
+								  "clear_dirty_job_attrs_handler", this, WRITE );
+
 	 // reaper
 	shadowReaperId = daemonCore->Register_Reaper(
 		"reaper",
@@ -13711,3 +13747,56 @@ Scheduler::finishRecycleShadow(shadow_rec *srec)
 	delete new_ad;
 	delete stream;
 }
+
+int
+Scheduler::FindGManagerPid(PROC_ID job_id)
+{
+	MyString owner;
+	MyString domain;
+	ClassAd *job_ad = GetJobAd(job_id.cluster,job_id.proc);
+
+	if ( ! job_ad ) {
+		return -1;
+	}
+
+	job_ad->LookupString(ATTR_OWNER,owner);
+	job_ad->LookupString(ATTR_NT_DOMAIN,domain);
+	UserIdentity userident(owner.Value(),domain.Value(),job_ad);
+	return GridUniverseLogic::FindGManagerPid(userident.username().Value(),
+                                        userident.auxid().Value(), 0, 0);
+}
+
+int
+Scheduler::clear_dirty_job_attrs_handler(int /*cmd*/, Stream *stream)
+{
+	int cluster_id;
+	int proc_id;
+	Sock *sock = (Sock *)stream;
+
+		// force authentication
+	sock->decode();
+	if( !sock->triedAuthentication() ) {
+		CondorError errstack;
+		if( ! SecMan::authenticate_sock(sock, WRITE, &errstack) ||
+			! sock->getFullyQualifiedUser() )
+		{
+			dprintf( D_ALWAYS,
+					 "clear_dirty_job_attrs_handler(): authentication failed: %s\n", 
+					 errstack.getFullText() );
+			return FALSE;
+		}
+	}
+
+	sock->decode();
+	if( !sock->get( cluster_id ) ||
+		!sock->get( proc_id ) ||
+		!sock->end_of_message() )
+	{
+		dprintf(D_ALWAYS,
+			"clear_dirty_job_attrs_handler() failed to receive job id\n");
+		return FALSE;
+	}
+
+	MarkJobClean( cluster_id, proc_id );
+	return TRUE;
+}
diff --git a/src/condor_schedd.V6/scheduler.h b/src/condor_schedd.V6/scheduler.h
index a9dbeaf..60e9e2d 100644
--- a/src/condor_schedd.V6/scheduler.h
+++ b/src/condor_schedd.V6/scheduler.h
@@ -313,6 +313,7 @@ class Scheduler : public Service
 	void			finishRecycleShadow(shadow_rec *srec);
 
 	int				requestSandboxLocation(int mode, Stream* s);
+	int			FindGManagerPid(PROC_ID job_id);
 
 	// match managing
 	int 			publish( ClassAd *ad );
@@ -541,6 +542,8 @@ private:
 	int				jobThrottleNextJobDelay;	// used by jobThrottle()
 
 	int				shadowReaperId; // daemoncore reaper id for shadows
+//	int 				dirtyNoticeId;
+//	int 				dirtyNoticeInterval;
 
 		// Here we enqueue calls to 'contactStartd' when we can't just 
 		// call it any more.  See contactStartd and the call to it...
@@ -701,6 +704,9 @@ private:
 	int get_job_connect_info_handler(int, Stream* s);
 	int get_job_connect_info_handler_implementation(int, Stream* s);
 
+		// Mark a job as clean
+	int clear_dirty_job_attrs_handler(int, Stream *stream);
+
 		// A bit that says wether or not we've sent email to the admin
 		// about a shadow not starting.
 	int sent_shadow_failure_email;
diff --git a/src/condor_shadow.V6.1/baseshadow.cpp b/src/condor_shadow.V6.1/baseshadow.cpp
index c71e4cd..33aaedf 100644
--- a/src/condor_shadow.V6.1/baseshadow.cpp
+++ b/src/condor_shadow.V6.1/baseshadow.cpp
@@ -1296,3 +1296,19 @@ BaseShadow::getMachineName( MyString & /*machineName*/ )
 {
 	return false;
 }
+
+
+int
+BaseShadow::handleUpdateJobAd( int sig )
+{
+	dprintf ( D_FULLDEBUG, "In handleUpdateJobAd, sig %d\n", sig );
+	if (!job_updater->retrieveJobUpdates()) {
+		dprintf(D_ALWAYS, "Error: Failed to update JobAd\n");
+		return -1;
+	}
+
+	// Attributes might have changed that would cause the job policy
+	// to evaluate differently, so evaluate now.
+	shadow_user_policy.checkPeriodic();
+	return 0;
+}
diff --git a/src/condor_shadow.V6.1/baseshadow.h b/src/condor_shadow.V6.1/baseshadow.h
index e26fa89..57e7a76 100644
--- a/src/condor_shadow.V6.1/baseshadow.h
+++ b/src/condor_shadow.V6.1/baseshadow.h
@@ -244,6 +244,10 @@ class BaseShadow : public Service
 		 */
 	virtual int handleJobRemoval(int sig) = 0;
 
+		/** Update this job.
+		 */
+	int handleUpdateJobAd(int sig);
+
 		/** This function returns a file pointer that one can 
 			write an email message into.
 			@return A mail message file pointer.
diff --git a/src/condor_shadow.V6.1/shadow_v61_main.cpp b/src/condor_shadow.V6.1/shadow_v61_main.cpp
index 3a3d08b..11d5dc4 100644
--- a/src/condor_shadow.V6.1/shadow_v61_main.cpp
+++ b/src/condor_shadow.V6.1/shadow_v61_main.cpp
@@ -293,6 +293,7 @@ void startShadow( ClassAd *ad )
 
 }
 
+
 int handleJobRemoval(Service*,int sig)
 {
 	if( Shadow ) {
@@ -302,6 +303,16 @@ int handleJobRemoval(Service*,int sig)
 }
 
 
+int handleUpdateJobAd(Service*,int sig)
+//int handleUpdateJobAd(Service*,int sig, Stream *sock)
+{
+	if( Shadow ) {
+		return Shadow->handleUpdateJobAd(sig);
+	}
+	return 0;
+}
+
+
 void
 main_init(int argc, char *argv[])
 {
@@ -324,6 +335,13 @@ main_init(int argc, char *argv[])
 	daemonCore->Register_Signal( SIGUSR1, "SIGUSR1", 
 		(SignalHandler)&handleJobRemoval,"handleJobRemoval");
 
+		// ragister UPDATE_JOBAD for qedit changes
+	daemonCore->Register_Signal( UPDATE_JOBAD, "UPDATE_JOBAD", 
+		(SignalHandler)&handleUpdateJobAd,"handleUpdateJobAd");
+//	daemonCore->Register_Command( UPDATE_JOBAD, "UPDATE_JOBAD",
+//		(CommandHandler)&handleUpdateJobAd, "handleUpdateJobAd", NULL,
+//		WRITE, D_FULLDEBUG);
+
 	int shadow_worklife = param_integer( "SHADOW_WORKLIFE", 3600 );
 	if( shadow_worklife > 0 ) {
 		shadow_worklife_expires = time(NULL) + shadow_worklife;
diff --git a/src/condor_tools/qedit.cpp b/src/condor_tools/qedit.cpp
index d2de173..2a8c728 100644
--- a/src/condor_tools/qedit.cpp
+++ b/src/condor_tools/qedit.cpp
@@ -187,16 +187,24 @@ main(int argc, char *argv[])
 			exit(1);
 		}
 		if (UseConstraint) {
-			if (SetAttributeByConstraint(constraint.Value(), argv[nextarg],
-										 argv[nextarg+1]) < 0) {
-				fprintf(stderr,
+			// Try to communicate with the newer protocol first
+			if (SetAttributeByConstraint(constraint.Value(),
+							argv[nextarg],
+							argv[nextarg+1],
+							SETDIRTY) < 0) {
+				if (SetAttributeByConstraint(constraint.Value(),
+							argv[nextarg],
+							argv[nextarg+1]) < 0) {
+
+					fprintf(stderr,
 						"Failed to set attribute \"%s\" by constraint: %s\n",
 						argv[nextarg], constraint.Value());
-				exit(1);
+					exit(1);
+				}
 			}
 		} else {
 			if (SetAttribute(cluster, proc, argv[nextarg],
-							 argv[nextarg+1]) < 0) {
+							 argv[nextarg+1], SETDIRTY) < 0) {
 				fprintf(stderr,
 						"Failed to set attribute \"%s\" for job %d.%d.\n",
 						argv[nextarg], cluster, proc);
