diff --git a/src/condor_daemon_core.V6/condor_daemon_core.h b/src/condor_daemon_core.V6/condor_daemon_core.h
index 2801cd0..b784589 100644
--- a/src/condor_daemon_core.V6/condor_daemon_core.h
+++ b/src/condor_daemon_core.V6/condor_daemon_core.h
@@ -58,6 +58,7 @@
 #include "limit.h"
 #include "ccb_listener.h"
 #include "condor_sinful.h"
+#include "filesystem_remap.h"
 
 #include "../condor_procd/proc_family_io.h"
 class ProcFamilyInterface;
@@ -176,6 +177,7 @@ struct FamilyInfo {
 	gid_t* group_ptr;
 #endif
 	const char* glexec_proxy;
+	bool want_pid_namespace;
 
 	FamilyInfo() {
 		max_snapshot_interval = -1;
@@ -184,6 +186,7 @@ struct FamilyInfo {
 		group_ptr = NULL;
 #endif
 		glexec_proxy = NULL;
+		want_pid_namespace = false;
 	}
 };
 
@@ -1052,27 +1053,30 @@ class DaemonCore : public Service
         ...
         @param err_return_msg Returned with error message pertaining to
                failure inside the method.  Ignored if NULL (default).
+        @param remap Performs bind mounts for the child process.
+               Ignored if NULL (default).  Ignored on non-Linux.
         @return On success, returns the child pid.  On failure, returns FALSE.
     */
     int Create_Process (
-        const char    *name,
-        ArgList const &arglist,
-        priv_state    priv                 = PRIV_UNKNOWN,
-        int           reaper_id            = 1,
-        int           want_commanand_port  = TRUE,
-        Env const     *env                 = NULL,
-        const char    *cwd                 = NULL,
-        FamilyInfo    *family_info         = NULL,
-        Stream        *sock_inherit_list[] = NULL,
-        int           std[]                = NULL,
-        int           fd_inherit_list[]    = NULL,
-        int           nice_inc             = 0,
-        sigset_t      *sigmask             = NULL,
-        int           job_opt_mask         = 0,
-        size_t        *core_hard_limit     = NULL,
-		int			  *affinity_mask	   = NULL,
-		char const    *daemon_sock         = NULL,
-        MyString      *err_return_msg      = NULL
+        const char      *name,
+        ArgList const   &arglist,
+        priv_state      priv                 = PRIV_UNKNOWN,
+        int             reaper_id            = 1,
+        int             want_commanand_port  = TRUE,
+        Env const       *env                 = NULL,
+        const char      *cwd                 = NULL,
+        FamilyInfo      *family_info         = NULL,
+        Stream          *sock_inherit_list[] = NULL,
+        int             std[]                = NULL,
+        int             fd_inherit_list[]    = NULL,
+        int             nice_inc             = 0,
+        sigset_t        *sigmask             = NULL,
+        int             job_opt_mask         = 0,
+        size_t          *core_hard_limit     = NULL,
+		int			    *affinity_mask	     = NULL,
+		char const      *daemon_sock         = NULL,
+        MyString        *err_return_msg      = NULL,
+        FilesystemRemap *remap               = NULL
         );
 
     //@}
diff --git a/src/condor_daemon_core.V6/daemon_core.cpp b/src/condor_daemon_core.V6/daemon_core.cpp
index 8624bab..ca01a50 100644
--- a/src/condor_daemon_core.V6/daemon_core.cpp
+++ b/src/condor_daemon_core.V6/daemon_core.cpp
@@ -41,6 +41,10 @@ void Generic_stop_logging();
 #if HAVE_CLONE
 #include <sched.h>
 #include <sys/syscall.h>
+#include <sys/mount.h>
+
+static const char* MOUNT_PROC = "proc";
+static const char* MOUNT_SLASH_PROC = "/proc";
 #endif
 
 #if HAVE_RESOLV_H && HAVE_DECL_RES_INIT
@@ -118,6 +122,10 @@ CRITICAL_SECTION Big_fat_mutex; // coarse grained mutex for debugging purposes
 #include <sched.h>
 #endif
 
+#if !defined(CLONE_NEWPID)
+#define CLONE_NEWPID 0x20000000
+#endif
+
 static const char* EMPTY_DESCRIP = "<NULL>";
 
 // special errno values that may be returned from Create_Process
@@ -6275,7 +6289,9 @@ public:
 		int the_want_command_port,
 		const sigset_t *the_sigmask,
 		size_t *core_hard_limit,
-		int		*affinity_mask
+		int		*affinity_mask,
+		bool want_pid_namespace,
+		FilesystemRemap *fs_remap
 	): m_errorpipe(the_errorpipe), m_args(the_args),
 	   m_job_opt_mask(the_job_opt_mask), m_env(the_env),
 	   m_inheritbuf(the_inheritbuf),
@@ -6290,8 +6306,14 @@ public:
 	   m_priv(the_priv), m_want_command_port(the_want_command_port),
 	   m_sigmask(the_sigmask), m_unix_args(0), m_unix_env(0),
 	   m_core_hard_limit(core_hard_limit),
-	   m_affinity_mask(affinity_mask)
+	   m_affinity_mask(affinity_mask),
+	   m_priv_state(PRIV_UNKNOWN),
+	   m_priv_state_parent(PRIV_UNKNOWN),
+	   m_want_pid_namespace(want_pid_namespace),
+	   m_fs_remap(fs_remap)
 	{
+		pthread_cond_init(&m_register_cond, NULL);
+		pthread_mutex_init(&m_register_mutex, NULL);
 	}
 
 	~CreateProcessForkit() {
@@ -6299,6 +6321,8 @@ public:
 			// memory.
 		deleteStringArray(m_unix_args);
 		deleteStringArray(m_unix_env);
+		pthread_cond_destroy(&m_register_cond);
+		pthread_mutex_destroy(&m_register_mutex);
 	}
 
 	pid_t fork_exec();
@@ -6307,6 +6331,7 @@ public:
 
 	pid_t clone_safe_getpid();
 	pid_t clone_safe_getppid();
+	int child_registration(pid_t, pid_t, bool);
 
 private:
 		// Data passed to us from the parent:
@@ -6343,7 +6368,13 @@ private:
 	char **m_unix_env;
 	size_t *m_core_hard_limit;
 	const int    *m_affinity_mask;
+	priv_state m_priv_state;
+	priv_state m_priv_state_parent;
 	Env m_envobject;
+	pthread_cond_t m_register_cond;
+	pthread_mutex_t m_register_mutex;
+	const bool m_want_pid_namespace;
+	FilesystemRemap *m_fs_remap;
 };
 
 enum {
@@ -6404,6 +6435,28 @@ pid_t CreateProcessForkit::fork_exec() {
 		dprintf(D_FULLDEBUG,"Create_Process: using fast clone() "
 		                    "to create child process.\n");
 
+			// If we have a cgroup, request a unique PID and FS namespace.
+			// Need a new FS namespace in order to remount /proc so 'ps' works.
+		bool valid_flags = true;
+		struct pollfd fds[0];
+		fds[0].fd = m_errorpipe[0];
+		fds[0].events = POLLIN;
+		bool pid_ns = false, fs_ns = false;
+		// Both PID and FS namespaces require PRIV_ROOT
+		if (m_want_pid_namespace || m_fs_remap) {
+			if (can_switch_ids()) {
+				m_priv_state = set_root_priv();
+				m_priv_state_parent = m_priv_state;
+			}
+			if (get_priv_state() == PRIV_ROOT) {
+				pid_ns = m_want_pid_namespace;
+				fs_ns = m_fs_remap != NULL;
+			} else {
+				m_priv_state = PRIV_UNKNOWN;
+				m_priv_state_parent = m_priv_state;
+			}
+		}
+
 			// The stack size must be big enough for everything that
 			// happens in CreateProcessForkit::clone_fn().  In some
 			// environments, some extra steps may need to be taken to
@@ -6426,29 +6479,82 @@ pid_t CreateProcessForkit::fork_exec() {
 		dprintf_before_shared_mem_clone();
 
 			// reason for flags passed to clone:
-			// CLONE_VM    - child shares same address space (so no time
-			//               wasted copying page tables)
-			// CLONE_VFORK - parent is suspended until child calls exec/exit
-			//               (so we do not throw away child's stack etc.)
-			// SIGCHLD     - we want this signal when child dies, as opposed
-			//               to some other non-standard signal
+			// CLONE_VM     - child shares same address space (so no time
+			//                wasted copying page tables)
+			// CLONE_VFORK  - parent is suspended until child calls exec/exit
+			//                (so we do not throw away child's stack etc.)
+			// SIGCHLD      - we want this signal when child dies, as opposed
+			//                to some other non-standard signal
+			// CLONE_NEWPID - Child lives in its own PID namespace; thinks
+			//                it's PID 1
+			// CLONE_NEWNS  - Child gets its own set of mounts; necessary for
+			//                remounting /proc later on.
 
 		enterCreateProcessChild(m_errorpipe[1]);
 
-		newpid = clone(
-			CreateProcessForkit::clone_fn,
-			child_stack_ptr,
-			(CLONE_VM|CLONE_VFORK|SIGCHLD),
-			this );
+		if (pid_ns || fs_ns) {
+			// Lock the mutex - the child will unlock it when it waits for the cond.
+			pthread_mutex_lock(&m_register_mutex);
+			// We need a new FS namespace if we get a PID namespace to remount /proc
+			int flags = (CLONE_VM|SIGCHLD|CLONE_NEWNS);
+			if (pid_ns)
+				flags |= CLONE_NEWPID;
+			newpid = clone(
+				CreateProcessForkit::clone_fn,
+				child_stack_ptr,
+				flags,
+				this );
+			if ((newpid == -1) && (errno == EINVAL)) {
+				valid_flags = false;
+				pthread_mutex_unlock(&m_register_mutex);
+			}
+		}
+		if (!valid_flags || !pid_ns){
+			newpid = clone(
+				CreateProcessForkit::clone_fn,
+				child_stack_ptr,
+				(CLONE_VM|CLONE_VFORK|SIGCHLD),
+				this );
+			pid_ns = false;
+			fs_ns = false;
+			// Make sure we don't accidentally try to use this later.
+			m_fs_remap = NULL;
+		}
 
 		exitCreateProcessChild();
 
-			// Since we used the CLONE_VFORK flag, the child has exited
-			// or called exec by now.
+		// Close our copy of the write end.  As we didn't pass CLONE_FS, the
+		// child holds a separate FD for this pipe.
+		// We can detect when the child either exits or execs by whether the pipe is readable.
+		close(m_errorpipe[1]);
+
+			// If we used the CLONE_VFORK flag, the child has exited
+			// or called exec by now.  Otherwise, we need to register it.
+		if (pid_ns && newpid > 0) {
+			// Note that the child will unlock this for us.  If we acquire the lock,
+			// the child is already waiting.
+			pthread_mutex_lock(&m_register_mutex);
+			if (child_registration(newpid, clone_safe_getpid(), true)) {
+				// Drat, registration fail.  Kill the child.
+				kill(newpid, SIGKILL);
+				pthread_mutex_unlock(&m_register_mutex);
+			} else {
+				pthread_cond_signal(&m_register_cond);
+				pthread_mutex_unlock(&m_register_mutex);
+				// After the signal, we can't make any memory modifications until
+				// the error pipe is closed or written to.
+				// Poll indefinitely - as long as the child dies, OS will return
+				// Throw away the result - the upper layer will actually read from pipe.
+				poll(fds, 1, -1);
+			}
+		}
 
 			// restore state
 		dprintf_after_shared_mem_clone();
 
+		if (m_priv_state_parent != PRIV_UNKNOWN)
+			set_priv(m_priv_state_parent);
+
 		return newpid;
 	}
 #endif /* HAVE_CLONE */
@@ -6471,34 +6577,12 @@ int CreateProcessForkit::clone_fn( void *arg ) {
 	return 0;
 }
 
-void CreateProcessForkit::exec() {
-	extern char **environ;
+int CreateProcessForkit::child_registration(pid_t pid, pid_t ppid, bool parent=false) {
+		// Register the child process.
+		// If CLONE_NEWPID is used, then the child will think it's PID 1 and
+		// register itself as that with the procd; not going to work.  This function
+		// is called by the parent process in this case.
 
-		// Keep in mind that there are two cases:
-		//   1. We got here by forking, (cannot modify parent's memory)
-		//   2. We got here by cloning, (can modify parent's memory)
-		// So don't screw up the parent's memory and don't allocate any
-		// memory assuming it will be freed on exec() or _exit().  All objects
-		// that allocate memory MUST BE in data structures that are cleaned
-		// up by the parent (e.g. this instance of CreateProcessForkit).
-		// We do have our own copy of the file descriptors and signal masks.
-
-		// All critical errors in this function should write out the error
-		// code to the error pipe and then should call _exit().  Since
-		// some of the functions called below may result in a call to
-		// exit() (e.g. dprintf could EXCEPT), we use daemonCore's
-		// exit() wrapper to catch these cases and do the right thing.
-		// That is, this function must be wrapped by calls to
-		// enterCreateProcessChild() and exitCreateProcessChild().
-
-		// make sure we're not going to try to share the lock file
-		// with our parent (if it's been defined).
-	dprintf_init_fork_child();
-
-		// close the read end of our error pipe and set the
-		// close-on-exec flag on the write end
-	close(m_errorpipe[0]);
-	fcntl(m_errorpipe[1], F_SETFD, FD_CLOEXEC);
 
 		/********************************************************
 			  Make sure we're not about to re-use a PID that
@@ -6527,75 +6611,23 @@ void CreateProcessForkit::exec() {
 			  Derek Wright <wright@cs.wisc.edu> 2004-12-15
 		********************************************************/
 
-	pid_t pid = clone_safe_getpid();
-	pid_t ppid = clone_safe_getppid();
 	DaemonCore::PidEntry* pidinfo = NULL;
 	if( (daemonCore->pidTable->lookup(pid, pidinfo) >= 0) ) {
 			// we've already got this pid in our table! we've got
 			// to bail out immediately so our parent can retry.
 		int child_errno = DaemonCore::ERRNO_PID_COLLISION;
 		write(m_errorpipe[1], &child_errno, sizeof(child_errno));
-		_exit(4);
+		return 4;
 	}
 		// If we made it here, we didn't find the PID in our
 		// table, so it's safe to continue and eventually do the
 		// exec() in this process...
 
-		/////////////////////////////////////////////////////////////////
-		// figure out what stays and goes in the child's environment
-		/////////////////////////////////////////////////////////////////
-
-		// We may determine to seed the child's environment with the parent's.
-	if( HAS_DCJOBOPT_ENV_INHERIT(m_job_opt_mask) ) {
-		m_envobject.MergeFrom(environ);
-	}
-
-		// Put the caller's env requests into the job's environment, potentially
-		// adding/overriding things in the current env if the job was allowed to
-		// inherit the parent's environment.
-	if(m_env) {
-		m_envobject.MergeFrom(*m_env);
-	}
-
-		// if I have brought in the parent's environment, then ensure that
-		// after the caller's changes have been enacted, this overrides them.
-	if( HAS_DCJOBOPT_ENV_INHERIT(m_job_opt_mask) ) {
-
-			// add/override the inherit variable with the correct value
-			// for this process.
-		m_envobject.SetEnv( EnvGetName( ENV_INHERIT ), m_inheritbuf.Value() );
-
-		if( !m_privateinheritbuf.IsEmpty() ) {
-			m_envobject.SetEnv( EnvGetName( ENV_PRIVATE ), m_privateinheritbuf.Value() );
-		}
-			// Make sure PURIFY can open windows for the daemons when
-			// they start. This functionality appears to only exist when we've
-			// decided to inherit the parent's environment. I'm not sure
-			// what the ramifications are if we include it all the time so here
-			// it stays for now.
-		char *display;
-		display = param ( "PURIFY_DISPLAY" );
-		if ( display ) {
-			m_envobject.SetEnv( "DISPLAY", display );
-			free ( display );
-			char *purebuf;
-			purebuf = (char*)malloc(sizeof(char) * 
-									(strlen("-program-name=") + strlen(m_executable) + 
-									 1));
-			if (purebuf == NULL) {
-				EXCEPT("Create_Process: PUREOPTIONS is out of memory!");
-			}
-			sprintf ( purebuf, "-program-name=%s", m_executable );
-			m_envobject.SetEnv( "PUREOPTIONS", purebuf );
-			free(purebuf);
-		}
-	}
-
-		// Now we add/override  things that must ALWAYS be in the child's 
+		// Now we add/override  things that must ALWAYS be in the child's
 		// environment regardless of what is already in the child's environment.
 
-		// BEGIN pid family environment id propogation 
-		// Place the pidfamily accounting entries into our 
+		// BEGIN pid family environment id propogation
+		// Place the pidfamily accounting entries into our
 		// environment if we can and hope any children.
 		// This will help ancestors track their children a little better.
 		// We should be automatically propogating the pidfamily specifying
@@ -6609,11 +6641,11 @@ void CreateProcessForkit::exec() {
 	pidenvid_init(&penvid);
 
 		// if we weren't inheriting the parent's environment, then grab out
-		// the parent's pidfamily history... and jam it into the child's 
+		// the parent's pidfamily history... and jam it into the child's
 		// environment
 	if ( HAS_DCJOBOPT_NO_ENV_INHERIT(m_job_opt_mask) ) {
 		int i;
-			// The parent process could not have been exec'ed if there were 
+			// The parent process could not have been exec'ed if there were
 			// too many ancestor markers in its environment, so this check
 			// is more of an assertion.
 		if (pidenvid_filter_and_insert(&penvid, environ) ==
@@ -6626,12 +6658,12 @@ void CreateProcessForkit::exec() {
 					// before we exit, make sure our parent knows something
 					// went wrong before the exec...
 				write(m_errorpipe[1], &errno, sizeof(errno));
-				_exit(errno);
+				return errno;
 			}
 
 			// Propogate the ancestor history to the child's environment
 		for (i = 0; i < PIDENVID_MAX; i++) {
-			if (penvid.ancestors[i].active == TRUE) { 
+			if (penvid.ancestors[i].active == TRUE) {
 				m_envobject.SetEnv( penvid.ancestors[i].envid );
 			} else {
 					// After the first FALSE entry, there will never be
@@ -6642,19 +6674,19 @@ void CreateProcessForkit::exec() {
 	}
 
 		// create the new ancestor entry for the child's environment
-	if (pidenvid_format_to_envid(envid, PIDENVID_ENVID_SIZE, 
-								 m_forker_pid, pid, m_time_of_fork, m_mii) == PIDENVID_BAD_FORMAT) 
+	if (pidenvid_format_to_envid(envid, PIDENVID_ENVID_SIZE,
+								 m_forker_pid, pid, m_time_of_fork, m_mii) == PIDENVID_BAD_FORMAT)
 		{
 			dprintf ( D_ALWAYS, "Create_Process: Failed to create envid "
 					  "\"%s\" due to bad format. !\n", envid );
 				// before we exit, make sure our parent knows something
 				// went wrong before the exec...
 			write(m_errorpipe[1], &errno, sizeof(errno));
-			_exit(errno);
+			return errno;
 		}
 
-		// if the new entry fits into the penvid, then add it to the 
-		// environment, else EXCEPT cause it is programmer's error 
+		// if the new entry fits into the penvid, then add it to the
+		// environment, else EXCEPT cause it is programmer's error
 	if (pidenvid_append(&penvid, envid) == PIDENVID_OK) {
 		m_envobject.SetEnv( envid );
 	} else {
@@ -6665,41 +6697,19 @@ void CreateProcessForkit::exec() {
 			// before we exit, make sure our parent knows something
 			// went wrong before the exec...
 		write(m_errorpipe[1], &errno, sizeof(errno));
-		_exit(errno);
+		return errno;
 	}
-		// END pid family environment id propogation 
-
-		// The child's environment:
-	m_unix_env = m_envobject.getStringArray();
-
-
-		/////////////////////////////////////////////////////////////////
-		// figure out what stays and goes in the job's arguments
-		/////////////////////////////////////////////////////////////////
-
-	if( m_args.Count() == 0 ) {
-		dprintf(D_DAEMONCORE, "Create_Process: Arg: NULL\n");
-		ArgList tmpargs;
-		tmpargs.AppendArg(m_executable);
-		m_unix_args = tmpargs.GetStringArray();
-	}
-	else {
-		if(DebugFlags & D_DAEMONCORE) {
-			MyString arg_string;
-			m_args.GetArgsStringForDisplay(&arg_string);
-			dprintf(D_DAEMONCORE, "Create_Process: Arg: %s\n", arg_string.Value());
-		}
-		m_unix_args = m_args.GetStringArray();
-	}
-
+		// END pid family environment id propogation
 
 		// check to see if this is a subfamily
 	if( ( m_family_info != NULL ) ) {
 
 			//create a new process group if we are supposed to
-		if(param_boolean( "USE_PROCESS_GROUPS", true )) {
+		if((!parent) && param_boolean( "USE_PROCESS_GROUPS", true )) {
 
 				// Set sid is the POSIX way of creating a new proc group
+				// If we have our own PID namespace, we are already the session leader
+				// and this call will fail.
 			if( setsid() == -1 )
 				{
 					dprintf(D_ALWAYS, "Create_Process: setsid() failed: %s\n",
@@ -6707,7 +6717,7 @@ void CreateProcessForkit::exec() {
 						// before we exit, make sure our parent knows something
 						// went wrong before the exec...
 					write(m_errorpipe[1], &errno, sizeof(errno));
-					_exit(errno);
+					return errno;
 				}
 		}
 
@@ -6751,7 +6761,7 @@ void CreateProcessForkit::exec() {
 			if (!ok) {
 				errno = DaemonCore::ERRNO_REGISTRATION_FAILED;
 				write(m_errorpipe[1], &errno, sizeof(errno));
-				_exit(4);
+				return 4;
 			}
 
 			if (tracking_gid_ptr != NULL) {
@@ -6759,6 +6769,131 @@ void CreateProcessForkit::exec() {
 			}
 		}
 	}
+	return 0;
+}
+
+void CreateProcessForkit::exec() {
+	extern char **environ;
+
+		// Keep in mind that there are two cases:
+		//   1. We got here by forking, (cannot modify parent's memory)
+		//   2. We got here by cloning, (can modify parent's memory)
+		// So don't screw up the parent's memory and don't allocate any
+		// memory assuming it will be freed on exec() or _exit().  All objects
+		// that allocate memory MUST BE in data structures that are cleaned
+		// up by the parent (e.g. this instance of CreateProcessForkit).
+		// We do have our own copy of the file descriptors and signal masks.
+
+		// All critical errors in this function should write out the error
+		// code to the error pipe and then should call _exit().  Since
+		// some of the functions called below may result in a call to
+		// exit() (e.g. dprintf could EXCEPT), we use daemonCore's
+		// exit() wrapper to catch these cases and do the right thing.
+		// That is, this function must be wrapped by calls to
+		// enterCreateProcessChild() and exitCreateProcessChild().
+
+		// make sure we're not going to try to share the lock file
+		// with our parent (if it's been defined).
+	dprintf_init_fork_child();
+
+	pid_t pid = clone_safe_getpid();
+	if (pid == 1) {
+		// Once we are signalled, we can proceed.
+		// The mutex is already locked prior to clone; we "own" it.
+		pthread_cond_wait(&m_register_cond, &m_register_mutex);
+		pthread_mutex_unlock(&m_register_mutex);
+	} else {
+		pid_t ppid = clone_safe_getppid();
+		int retc = child_registration(pid, ppid);
+		if (retc)
+			_exit(retc);
+	}
+
+		// close the read end of our error pipe and set the
+		// close-on-exec flag on the write end
+	close(m_errorpipe[0]);
+	fcntl(m_errorpipe[1], F_SETFD, FD_CLOEXEC);
+
+
+		// If we made it here, we didn't find the PID in our
+		// table, so it's safe to continue and eventually do the
+		// exec() in this process...
+
+		/////////////////////////////////////////////////////////////////
+		// figure out what stays and goes in the child's environment
+		/////////////////////////////////////////////////////////////////
+
+		// We may determine to seed the child's environment with the parent's.
+	if( HAS_DCJOBOPT_ENV_INHERIT(m_job_opt_mask) ) {
+		m_envobject.MergeFrom(environ);
+	}
+
+		// Put the caller's env requests into the job's environment, potentially
+		// adding/overriding things in the current env if the job was allowed to
+		// inherit the parent's environment.
+	if(m_env) {
+		m_envobject.MergeFrom(*m_env);
+	}
+
+		// if I have brought in the parent's environment, then ensure that
+		// after the caller's changes have been enacted, this overrides them.
+	if( HAS_DCJOBOPT_ENV_INHERIT(m_job_opt_mask) ) {
+
+			// add/override the inherit variable with the correct value
+			// for this process.
+		m_envobject.SetEnv( EnvGetName( ENV_INHERIT ), m_inheritbuf.Value() );
+
+		if( !m_privateinheritbuf.IsEmpty() ) {
+			m_envobject.SetEnv( EnvGetName( ENV_PRIVATE ), m_privateinheritbuf.Value() );
+		}
+			// Make sure PURIFY can open windows for the daemons when
+			// they start. This functionality appears to only exist when we've
+			// decided to inherit the parent's environment. I'm not sure
+			// what the ramifications are if we include it all the time so here
+			// it stays for now.
+		char *display;
+		display = param ( "PURIFY_DISPLAY" );
+		if ( display ) {
+			m_envobject.SetEnv( "DISPLAY", display );
+			free ( display );
+			char *purebuf;
+			purebuf = (char*)malloc(sizeof(char) * 
+									(strlen("-program-name=") + strlen(m_executable) +
+									 1));
+			if (purebuf == NULL) {
+				EXCEPT("Create_Process: PUREOPTIONS is out of memory!");
+			}
+			sprintf ( purebuf, "-program-name=%s", m_executable );
+			m_envobject.SetEnv( "PUREOPTIONS", purebuf );
+			free(purebuf);
+		}
+	}
+
+
+		// The child's environment:
+	m_unix_env = m_envobject.getStringArray();
+
+
+		/////////////////////////////////////////////////////////////////
+		// figure out what stays and goes in the job's arguments
+		/////////////////////////////////////////////////////////////////
+
+	if( m_args.Count() == 0 ) {
+		dprintf(D_DAEMONCORE, "Create_Process: Arg: NULL\n");
+		ArgList tmpargs;
+		tmpargs.AppendArg(m_executable);
+		m_unix_args = tmpargs.GetStringArray();
+	}
+	else {
+		if(DebugFlags & D_DAEMONCORE) {
+			MyString arg_string;
+			m_args.GetArgsStringForDisplay(&arg_string);
+			dprintf(D_DAEMONCORE, "Create_Process: Arg: %s\n", arg_string.Value());
+		}
+		m_unix_args = m_args.GetStringArray();
+	}
+
+
 
 	int openfds = getdtablesize();
 
@@ -6955,6 +7090,21 @@ void CreateProcessForkit::exec() {
 		}
 	}
 
+	// We need to remount /proc.  As we have our own mount namespace,
+	// this won't change the parent's memory.
+	if ((pid == 1) && mount(MOUNT_PROC, MOUNT_SLASH_PROC, MOUNT_PROC, 0, 0)) {
+		write(m_errorpipe[1], &errno, sizeof(errno));
+		_exit(errno);
+	}
+	if (m_fs_remap && m_fs_remap->PerformMappings()) {
+		write(m_errorpipe[1], &errno, sizeof(errno));
+		_exit(errno);
+	}
+
+	// Restore the privilege state; only needed if we are going to use NEWPID
+	if (m_priv_state != PRIV_UNKNOWN)
+		set_priv_no_memory_changes(m_priv_state);
+
 		// now head into the proper priv state...
 	if ( m_priv != PRIV_UNKNOWN ) {
 			// This is tricky in the case where we share memory with our
@@ -7024,6 +7174,7 @@ void CreateProcessForkit::exec() {
 
 		// and ( finally ) exec:
 	int exec_results;
+
 	exec_results =  execve(m_executable_fullpath, m_unix_args, m_unix_env);
 
 	if( exec_results == -1 ) {
@@ -7031,6 +7182,7 @@ void CreateProcessForkit::exec() {
 			// Let's exit with our errno.
 			// before we exit, make sure our parent knows something
 			// went wrong before the exec...
+
 		write(m_errorpipe[1], &errno, sizeof(errno));
 		_exit(errno);
 	}
@@ -7055,7 +7207,8 @@ int DaemonCore::Create_Process(
 			size_t        *core_hard_limit,
 			int			  *affinity_mask,
 			char const    *daemon_sock,
-			MyString      *err_return_msg
+			MyString      *err_return_msg,
+			FilesystemRemap *remap
             )
 {
 	int i, j;
@@ -7066,6 +7219,9 @@ int DaemonCore::Create_Process(
 	MyString executable_buf;
 	priv_state current_priv = PRIV_UNKNOWN;
 
+	// Remap our executable and CWD if necessary.
+	std::string alt_executable_fullpath, alt_cwd;
+
 	// For automagic DC std pipes.
 	int dc_pipe_fds[3][2] = {{-1, -1}, {-1, -1}, {-1, -1}};
 
@@ -8049,6 +8205,15 @@ int DaemonCore::Create_Process(
 		}
 	}
 
+	if (remap) {
+		alt_executable_fullpath = remap->RemapFile(executable_fullpath);
+		alt_cwd = remap->RemapDir(cwd);
+		if (alt_executable_fullpath.compare(executable_fullpath))
+			dprintf(D_ALWAYS, "Remapped file: %s\n", alt_executable_fullpath.c_str());
+		if (alt_cwd.compare(cwd))
+			dprintf(D_ALWAYS, "Remapped cwd: %s\n", alt_cwd.c_str());
+	}
+
 	{
 			// Create a "forkit" object to hold all the state that we need in the child.
 			// In some cases, the "fork" will actually be a clone() operation, which
@@ -8065,9 +8230,9 @@ int DaemonCore::Create_Process(
 			time_of_fork,
 			mii,
 			family_info,
-			cwd,
+			alt_cwd.length() ? alt_cwd.c_str() : cwd,
 			executable,
-			executable_fullpath,
+			alt_executable_fullpath.length() ? alt_executable_fullpath.c_str() : executable_fullpath,
 			std,
 			numInheritFds,
 			inheritFds,
@@ -8076,7 +8241,9 @@ int DaemonCore::Create_Process(
 			want_command_port,
 			sigmask,
 			core_hard_limit,
-			affinity_mask);
+			affinity_mask,
+			family_info ? family_info->want_pid_namespace : false,
+			remap);
 
 		newpid = forkit.fork_exec();
 	}
@@ -8096,9 +8263,6 @@ int DaemonCore::Create_Process(
 			}
 		}
 
-			// close the write end of our error pipe
-		close(errorpipe[1]);
-
 			// check our error pipe for any problems before the exec
 		int child_errno = 0;
 		if (read(errorpipe[0], &child_errno, sizeof(int)) == sizeof(int)) {
@@ -8237,6 +8401,8 @@ int DaemonCore::Create_Process(
 	}
 #endif
 
+	dprintf(D_ALWAYS, "Create process made PID %d\n", newpid);
+
 	// Now that we have a child, store the info in our pidTable
 	pidtmp = new PidEntry;
 	pidtmp->pid = newpid;
diff --git a/src/condor_starter.V6.1/os_proc.cpp b/src/condor_starter.V6.1/os_proc.cpp
index 775f97e..1870761 100644
--- a/src/condor_starter.V6.1/os_proc.cpp
+++ b/src/condor_starter.V6.1/os_proc.cpp
@@ -70,7 +70,7 @@ OsProc::~OsProc()
 
 
 int
-OsProc::StartJob(FamilyInfo* family_info)
+OsProc::StartJob(FamilyInfo* family_info, FilesystemRemap* fs_remap=NULL)
 {
 	int nice_inc = 0;
 	bool has_wrapper = false;
@@ -494,7 +494,8 @@ OsProc::StartJob(FamilyInfo* family_info)
 		                                     core_size_ptr,
                                              affinity_mask,
 											 NULL,
-                                             &create_process_err_msg);
+                                             &create_process_err_msg,
+                                             fs_remap);
 	}
 
 	// Create_Process() saves the errno for us if it is an "interesting" error.
diff --git a/src/condor_starter.V6.1/os_proc.h b/src/condor_starter.V6.1/os_proc.h
index 18a200d..8b5a581 100644
--- a/src/condor_starter.V6.1/os_proc.h
+++ b/src/condor_starter.V6.1/os_proc.h
@@ -46,9 +46,9 @@ public:
 			output, error files for re-direction, and (finally) call
 			daemonCore->Create_Process().
 		 */
-	virtual int StartJob() { return StartJob(NULL); };
+	virtual int StartJob() { return StartJob(NULL, NULL); };
 
-	int StartJob(FamilyInfo*);
+	int StartJob(FamilyInfo*, FilesystemRemap *);
 
 		/** In this function, we determine if pid == our pid, and if so
 			do a CONDOR_job_exit remote syscall.  
diff --git a/src/condor_starter.V6.1/vanilla_proc.cpp b/src/condor_starter.V6.1/vanilla_proc.cpp
index b27af2a..ab299a8 100644
--- a/src/condor_starter.V6.1/vanilla_proc.cpp
+++ b/src/condor_starter.V6.1/vanilla_proc.cpp
@@ -32,6 +32,8 @@
 #include "condor_config.h"
 #include "domain_tools.h"
 #include "classad_helpers.h"
+#include "filesystem_remap.h"
+#include "directory.h"
 
 #ifdef WIN32
 #include "executable_scripts.WINDOWS.h"
@@ -208,9 +210,73 @@ VanillaProc::StartJob()
 	}
 #endif
 
+	FilesystemRemap * fs_remap = NULL;
+#if defined(LINUX)
+
+	// On Linux kernel 2.6.24 and later, we can give each
+	// job its own PID namespace
+	if (param_boolean("USE_PID_NAMESPACES", false)) {
+		if (!can_switch_ids()) {
+			EXCEPT("USE_PID_NAMESPACES enabled, but can't perform this "
+					"call in Linux unless running as root.");
+		}
+		fi.want_pid_namespace = true;
+	}
+	dprintf(D_ALWAYS, "PID namespace option: %s\n", fi.want_pid_namespace ? "true" : "false");
+
+	// On Linux kernel 2.4.19 and later, we can give each job its
+	// own FS mounts.
+	if (param_boolean("USE_FS_NAMESPACES", false)) {
+		// It's very likely the 'condor' user doesn't have permission to stat some of these
+		// directories.  Switch to root for now.
+		priv_state original_priv = set_root_priv();
+
+		fs_remap = new FilesystemRemap();
+		std::string working_dir = Starter->GetWorkingDir();
+		if (IsDirectory(working_dir.c_str())) {
+			if (IsDirectory("/tmp")) {
+				dprintf(D_FULLDEBUG, "Adding mapping: %s -> /tmp.\n", working_dir.c_str());
+				fs_remap->AddMapping(working_dir, "/tmp");
+			}
+			if (IsDirectory("/var/tmp")) {
+				dprintf(D_FULLDEBUG, "Adding mapping: %s -> /var/tmp.\n", working_dir.c_str());
+				fs_remap->AddMapping(working_dir, "/var/tmp");
+			}
+			StringList squash_dirs(param("SQUASH_DIRS"));
+			squash_dirs.rewind();
+			char * next_dir;
+			while ((next_dir = squash_dirs.next()) != NULL) {
+				if (IsDirectory(next_dir)) {
+					dprintf(D_FULLDEBUG, "Adding mapping: %s -> %s.\n", working_dir.c_str(), next_dir);
+					fs_remap->AddMapping(working_dir, next_dir);
+				}
+			}
+		}
+		// Don't mangle the IWD until we know how to rewrite the environment.
+/*
+		const char* job_iwd = Starter->jic->jobRemoteIWD();
+		dprintf(D_ALWAYS, "Job IWD: %s\n", job_iwd);
+		if (IsDirectory(job_iwd)) {
+			std::string execute_dir;
+			param(execute_dir, "EXECUTE");
+			if (IsDirectory(execute_dir.c_str())) {
+				dprintf(D_FULLDEBUG, "Adding mapping: %s -> %s.\n", job_iwd, execute_dir.c_str());
+				fs_remap->AddMapping(job_iwd, execute_dir);
+			}
+		}
+*/
+		set_priv(original_priv);
+	}
+#endif
+
 	// have OsProc start the job
 	//
-	return OsProc::StartJob(&fi);
+	int retval = OsProc::StartJob(&fi, fs_remap);
+
+	if (fs_remap != NULL)
+		delete fs_remap;
+
+	return retval;
 }
 
 
diff --git a/src/condor_utils/filesystem_remap.cpp b/src/condor_utils/filesystem_remap.cpp
new file mode 100644
index 0000000..c670d6d
--- /dev/null
+++ b/src/condor_utils/filesystem_remap.cpp
@@ -0,0 +1,74 @@
+/***************************************************************
+ *
+ * Copyright (C) 1990-2011, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#include "filesystem_remap.h"
+
+#if defined(LINUX)
+#include <sys/mount.h>
+#endif
+
+void FilesystemRemap::AddMapping(std::string source, std::string dest) {
+	if (source[0] == '/' && dest[0] == '/') {
+		std::list<pair_strings>::iterator it;
+		for (it = m_mappings.begin(); it != m_mappings.end(); it++) {
+			if ((it->second.length() == dest.length()) && (it->second.compare(dest) == 0))
+				return;
+		}
+		m_mappings.push_back( std::pair<std::string, std::string>(source, dest) );
+	}
+}
+
+// This is called within the exec
+// IT CANNOT CALL DPRINTF!
+int FilesystemRemap::PerformMappings() {
+	int retval = 0;
+#if defined(LINUX)
+	std::list<pair_strings>::iterator it;
+	for (it = m_mappings.begin(); it != m_mappings.end(); it++) {
+		if ((retval = mount(it->first.c_str(), it->second.c_str(), NULL, MS_BIND, NULL))) {
+			break;
+		}
+	}
+#endif
+	return retval;
+}
+
+std::string FilesystemRemap::RemapFile(std::string target) {
+	if (target[0] != '/')
+		return std::string();
+	size_t pos = target.rfind("/");
+	if (pos == std::string::npos)
+		return target;
+	std::string filename = target.substr(pos, target.size() - pos);
+	std::string directory = target.substr(0, target.size() - filename.size());
+	return RemapDir(directory) + filename;
+}
+
+std::string FilesystemRemap::RemapDir(std::string target) {
+	if (target[0] != '/')
+		return std::string();
+	std::list<pair_strings>::iterator it;
+	for (it = m_mappings.begin(); it != m_mappings.end(); it++) {
+		if ((it->first.compare(0, it->first.length(), target, 0, it->first.length()) == 0)
+				&& (it->second.compare(0, it->second.length(), it->first, 0, it->second.length()) == 0)) {
+			target.replace(0, it->first.length(), it->second);
+		}
+	}
+	return target;
+}
diff --git a/src/condor_utils/filesystem_remap.h b/src/condor_utils/filesystem_remap.h
new file mode 100644
index 0000000..f7e6fd7
--- /dev/null
+++ b/src/condor_utils/filesystem_remap.h
@@ -0,0 +1,80 @@
+/***************************************************************
+ *
+ * Copyright (C) 1990-2011, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#ifndef FILESYSTEM_REMAP_H
+#define FILESYSTEM_REMAP_H
+
+#include <string>
+#include <list>
+#include <utility>
+
+/**
+ * Represents a set of mappings to perform on the filesystem.
+ *
+ * Contains a mapping of source directories that will be remounted to destinations.
+ * So, if we have the mapping (/var/lib/condor/execute/1234) -> (/tmp), this class
+ * will perform the equivalent of this command:
+ *    mount --bind /var/lib/condor/execute/1234 /tmp
+ * This is meant to give Condor the ability to provide per-job temporary directories.
+ */
+typedef std::pair<std::string, std::string> pair_strings;
+
+class FilesystemRemap {
+
+public:
+
+	FilesystemRemap() : m_mappings() {};
+
+	/**
+	 * Add a mapping to the filesystem remap.
+	 * @param source: A source directory that will be remapped to the destination.
+	 * @param dest: A destination directory
+	 */
+	void AddMapping(std::string source, std::string dest);
+
+	/**
+	 * Performs the mappings known to this class.
+	 * This method does not touch the privilege settings - the caller is responsible
+	 * for setting the appropriate context.  This is done because the primary usage
+	 * of this class is the 'exec' part of the clone, where we have special rules
+	 * for touching shared memory.
+	 * @returns: 0 if everything went well, -1 if the remounts failed.
+	 */
+	int PerformMappings();
+
+	/**
+	 * Determine where a directory will be accessible from after the mapping.
+	 * @param Directory to consider.
+	 * @return Renamed directory.
+	 */
+	std::string RemapDir(std::string);
+
+	/**
+	 * Determine where a file will be accessible from after the mapping.
+	 * @param Directory to consider.
+	 * @return Renamed directory.
+	 */
+	std::string RemapFile(std::string);
+
+private:
+
+	std::list<pair_strings> m_mappings;
+
+};
+#endif
