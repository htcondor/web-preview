{"id": 1968, "title": "Ticket #1968: Making flocking the general case, even for \"local\" pool. FLOCK_TO", "description": "<blockquote>\nCurrently flocking is a special case: If there are jobs that can't get slots locally, try the first entry in the FLOCK_TO list.  Still jobs without slots, try the second entry, and so on until you run out of sites.\n\n<p>Problem 1: Special cases add complexity.\n\n</p><p>Problem 2: You can't dynamically change the flocking rules, perhaps based on the job ad.\n\n</p><p>Problem 3: If you have a mix of jobs that desire different flocking rules, you need multiple schedds.\n\n</p><p>Proposal: \"Flocking\" becomes the default state.  A schedd doesn't automatically advertise to the local collector, it's a side effect of the \"local\" collector being the first entry in the FLOCK_TO list.  We'll probably want to rename FLOCK_TO and friends.\n\n</p><p>Furthermore, make FLOCK_TO and friends expressions that are evaluated in the context of a job ad.\n\n</p><p>Concrete example, based on a real CHTC use case:  There are two pools, the local pool and a glide-in pool.  The administrator wants to be able to control where jobs go: local overflowing to glide-in, glide-in overflowing to local, just local, or just glide-in.  The flow will vary on a job-by-job, user-by-user basis.  Most jobs only run locally, but Octave jobs should run glide-in overflowing to local, while user Xavier's GNU-R jobs should run locally overflowing to glide-in.  We want to be able to change these assignments, including for queued, but not yet running, jobs.  For example, we might discover that a particular user's Octave jobs don't work on the glide-ins, so we want to exclude him from using the glide-in pool.  Another user of GNU-R might discover that he can use the glide-in pool and we want to add him to the flocking.\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">IS_OCTAVE=(regexp(\"/octave$\",CMD))\nIS_XR=(USER==\"xavier\" &amp;&amp; regexp(\"/R$\",CMD))\nFLOCK_TO= \\\n    ifThenElse(IS_OCTAVE, \"glidein.example.com,local.example.com\", \\\n        ifThenElse(IS_XR, \"local.example.com,glidein.example.com\", \\\n            \"local.example.com\" \\\n        ) \\\n    )\n</pre></div>\n</blockquote>", "remarks": "<blockquote>\n<em>2011-Mar-15 16:09:00 by adesmet:</em> <br/>\n\nImplementation note: We'll need to know which jobs are interested in which flocking lists when a) building an ad to send to each collector and b) when the collector wanders by looking for jobs.  Rebuilding those lists every time we care could be expensive for a large queue. We may need to cache and only update occasionally.  Perhaps every 5 minutes, or on a rolling basis, or on job state transitions.\n\n<p></p><hr/>\n<em>2011-Mar-15 16:54:47 by bbockelm:</em> <br/>\n\nHi Alan,\n\n<p>One thing I've been wanting for awhile is the ability to have dynamic FLOCK_TO lists.  I.e., if I had an \"uber-collector\" which contained other several collector ads, it would be nice if the schedd was smart enough to take its list of collectors to flock to from there.  When looking at the ticket, I think how unmanageable a job ad would be at Purdue where there are 10-15 levels of flocking.\n\n</p><p>Anyhow, if it's not possible to actually execute this idea, if we're redesigning this code, it would be beneficial to make sure the framework is there for further improvements.\n\n</p><p>In general, a great idea.\n\n</p><p>Brian\n\n</p><p></p><hr/>\n<em>2011-Mar-16 14:14:23 by adesmet:</em> <br/>\n\nFurther thoughts after a discussion with psilord, inspired by bbockelm's thoughts above.\n\n<p></p><ol>\n<li>Take the above proposal, then add a <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span> function something like this:\n\n<p></p><ul>\n<strong>String QueryCollector(String collector_name_and_port, String constraint_expr, String rank_expr, String attr_to_extract, String concatenation_character)</strong>\n<ul>\nQuery collector_name_and_port (e.g. condor-cm.example.com:3472) for classads that satisfy constraint_expr.  Ads are queried from all available ads, equivalent to the -any option to condor_status.  The ads are then sorted by rank_expr.  For each ad, extract the attribute named attr_to_extract as a string.  Join the list of extracted attributes with concatenation_character\n</ul>\n</ul>\n\n<p></p></li></ol>\n<ul>\nGiven this, you might say something like:\n\n<p></p><ul>\nFLOCK_TO=QueryCollector(\"condor-cm.example.com\", \"MyType==\\\"Collector\\\"\", \"Machine==\\\"condor-cm.example.com\\\"\", \"<span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CollectorIpAddr\" title=\"Collector Ip Addr\">CollectorIpAddr</a></span>\", \",\")\n</ul>\n\n<p>That sets the flocking list to all collectors reporting to condor-cm.example.com, with a preference for condor-cm.example.com.\n\n</p><p></p></ul>\n<ol>\n<li>We could design the entire system around pulling collectors from the collector.  Instead of FLOCK_TO, we would have FLOCK_CONSTRAINT and FLOCK_RANK, which evaluate pairs of Job ads and Collector ads.  It would look something like:\n\n<p></p><ul>\nFLOCK_CONSTRAINT = TRUE\nFLOCK_RANK       = Machine==\"condor-cm.example.com\"\n</ul>\n\n<p></p></li></ol>\n<ul>\nYou could have more clever things, like letting a job be picky (This assumes that the collector is MY and the job is TARGET):\n\n<p></p><ul>\nFLOCK_CONSTRAINT = ifThenElse(TARGET.OnlyRunLocal, Machine==\"condor-cm.example.com\", TRUE)\n</ul>\n\n<p>The default would be:\n\n</p><p></p><ul>\nFLOCK_CONSTRAINT = TRUE\nFLOCK_RANK       =\n</ul>\n\n<p>Since the local collector advertises itself locally, this would Just Work for the non-flocking case.\n</p></ul>\n\n<p>Either of these solutions will be making a large number of queries, so some kind of caching would likely help.  We could to a sort of autoclustering on attributes specified in FLOCK_TO to identify a smaller number of queries we might reuse.  We could query all collectors, then do the constraint filtering on the schedd side where it should be cheaper (even with a huge number of potential flocking sites, say 100, a constraint and rank operation should be relatively cheap).</p></blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "enhance", "last_change": "2011-Mar-16 14:14", "status": "new", "created": "2011-Mar-15 13:16", "fixed_version": "2011-Mar-15 13:16", "broken_version": "v070000", "priority": "4", "subsystem": "", "assigned_to": "", "derived_from": "", "creator": "adesmet", "rust": "", "customer_group": "other", "visibility": "public", "notify": "", "due_date": ""}