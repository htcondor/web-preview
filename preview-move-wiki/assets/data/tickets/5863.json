{"id": 5863, "title": "Ticket #5863: Procd crash at Purdue", "description": "<blockquote>\nSteve Clark at Purdue reports regular crashes of the condor_procd, and sometimes the master and schedd. After a crash and restart of the procd, idle jobs don't start running (until the schedd is restarted).\n\n<p>Investigation turned up a 3-layer cake of bugs:\n</p><ul>\n<li>Procapi crash in reading a process's environment out of /proc.\n</li><li>Procd clients don't recover for a procd restart discovered in Create_Process()\n</li><li>Schedd doesn't handle cleanup after failure to start a local universe job\n</li></ul>\n\n<p><span class=\"subsection\"></span></p><h3>Procapi Crash</h3>\n\n<p>When building the process family tree on linux, procapi will look at each process's environment for special variables. This is done in ProcAPI::fillProcInfoEnv() by reading /proc/&lt;pid&gt;/environ. It calls read() with a 1MB buffer, and sometimes the result is a value around 1,000,000,000. The function then tries to examine that amount of data in its 1MB buffer, which quickly runs into unallocated memory space.\n\n</p><p>This primarily affects the procd, but other daemons could run this procapi code directly (when USE_PROCD=False).\n\n</p><p>This is under investigation.\n\n</p><p><span class=\"subsection\"></span></p><h3>Procd Restart Recovery in Clients</h3>\n\n<p>When the procd dies and restarts, it unlinks the old named pipes used for clients to communicate and creates new ones. When existing clients get a communication error on an open pipe, they normally close and reopen, thereby connecting with the new procd. But this doesn't happen with calls to the procd that happen in Create_Process() (used to register a new child process with the procd), because the recovery code may need to call Create_Process() to spawn the new procd. Thus, all calls to Create_Process() will fail until the daemon does a different call to the procd.\n\n</p><p>Create_Process() knows when communication with the procd fails in the child process. In this situation, the parent could register a one-time timer to trigger a command to the procd that would happen after Create_Process() returns.\n\n</p><p><span class=\"subsection\"></span></p><h3>Schedd Cleanup After Local Universe Spawn Failure</h3>\n\n<p>When the schedd fails to launch the starter for a local universe job, it leaks a shadow_rec. There's an 11-year-old command saying this needs to be fixed ASAP. Also, <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=LocalUniverseJobsRunning\" title=\"Local Universe Jobs Running\">LocalUniverseJobsRunning</a></span> ends up being inaccurate, which can cause the schedd to not shutdown until the next run count_jobs() runs.</p></blockquote>", "remarks": "<blockquote>\n<em>2016-Aug-29 16:28:19 by jfrey:</em> <br/>\n\nWe've attempted adding retries when a read() of /proc/&lt;pid&gt;/environ returns a bogus value much larger than the requested read size. Doing an lseek() to the start of the file and then doing a read() gives the same result. Reopening the file and then doing a read() also gives the same result.\n\n<p>I have failed to reproduce the behavior on a machine at UW with the same linux distribution (Debian 7). I attempted to recreate race conditions between reading the file and the target process exiting. The result was always a documented behavior of read():\n</p><ul>\n<li>read() returns an expected size\n</li><li>read() returns 0 (empty file)\n</li><li>read() returns -1 (No such process)\n</li></ul>\n\n<p>We logged data about the affected processes that procapi had already gathered. They were all command-line tools, both HTCondor-related and unrelated, owned by several users, including root.\n\n</p><p>Several google searches turned up no mention of this behavior.\n\n</p><p></p><hr/>\n<em>2016-Sep-29 10:30:39 by johnkn:</em> <br/>\n\n<strong>CODE_REVIEW</strong> : changes look good.</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2016-Sep-08 15:30</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/0b3ef71eaf99534f8a600636341a763fd49f669b\">[49147]</a></span>: Docs for procapi /proc/pid/environ crash fix <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=5863\" onclick=\"get_ticket_and_populate_wrapper('5863'); return false;\" title=\"Procd crash at Purdue\">#5863</a></span>  (By Jaime Frey )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2016-Sep-07 16:42</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/aece637af3003eaa241db028fe5e645e274b8159\">[49138]</a></span>: Fix local variables to match the size of read()/write() parameters. <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=5863\" onclick=\"get_ticket_and_populate_wrapper('5863'); return false;\" title=\"Procd crash at Purdue\">#5863</a></span>  (By Jaime Frey )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2016-Sep-07 16:42</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/cbba101b781cc5e9ba1538b1d0cb36dc4fab020d\">[49137]</a></span>: Work around bogus read() results when reading /proc/pid/environ <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=5863\" onclick=\"get_ticket_and_populate_wrapper('5863'); return false;\" title=\"Procd crash at Purdue\">#5863</a></span> We are seeing instances where read() returns values in the 1GB when asked to read the contents of /proc/&lt;pid&gt;/environ into a 1MB buffer. Attempts to re-read the file (with and without reopening it) give the same result. In this situation,\u00a0[...]\n (By Jaime Frey )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2016-Aug-24 15:42</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/38b996637da0ff6e5e737645ce23a7cb59020421\">[49077]</a></span>: Remove comment noting a leak we just fixed. <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=5863\" onclick=\"get_ticket_and_populate_wrapper('5863'); return false;\" title=\"Procd crash at Purdue\">#5863</a></span>  (By Jaime Frey )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2016-Aug-24 15:41</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/40f010e9424262c9412d792fd09a3a6be484417d\">[49076]</a></span>: Fix memory leak when the schedd fails to spawn a starter. <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=5863\" onclick=\"get_ticket_and_populate_wrapper('5863'); return false;\" title=\"Procd crash at Purdue\">#5863</a></span>  (By Jaime Frey )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2016-Aug-24 15:39</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"https://github.com/htcondor/htcondor/commit/537c255a4a8afd287e49e097056cac03617787d1\">[49075]</a></span>: Improve recovery from procd failure in daemons. <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=5863\" onclick=\"get_ticket_and_populate_wrapper('5863'); return false;\" title=\"Procd crash at Purdue\">#5863</a></span> When the procd dies and restarts, other daemons need to reopen their pipes to it. This happens automatically in <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ProcFamilyProxy\" title=\"Proc Family Proxy\">ProcFamilyProxy</a></span> for most requests to the procd. But it can't happen for requests that occur during Create_Process(). This is because recovery\u00a0[...]\n (By Jaime Frey )</td></tr>\n</tbody></table>", "type": "defect", "last_change": "2016-Dec-12 14:12", "status": "resolved", "created": "2016-Aug-23 15:39", "fixed_version": "2016-Aug-23 15:39", "broken_version": "v080408", "priority": "3", "subsystem": "DaemonsSubmitNode", "assigned_to": "jfrey", "derived_from": "", "creator": "jfrey", "rust": "a30453", "customer_group": "other", "visibility": "public", "notify": "jfrey@cs.wisc.edu", "due_date": ""}