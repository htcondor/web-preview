{"id": 228, "title": "Ticket #228: glibc opens nscd socket and defers checkpointing until exit()", "description": "<blockquote>\nI need a program written that will be tested on RHEL 5 x86, x86_64,\nand Debian 5.0 x86, x86_64. The machines chosen must have the nscd\ndaemon running and the glibc actively using it to resolve questions like\ngetpwnam(), among other things.\n\n<p>You can tell if a machine is configured correctly by seeing of nscd is\nrunning with ps -aux, and using this command (adjust to your shell):\n</p><div class=\"code\">\n<pre class=\"code\">Linux nmi-0199 &gt; strace whoami |&amp; grep nscd\nconnect(3, {sa_family=AF_FILE, path=\"/var/run/nscd/socket\"...}, 110) = 0\n</pre></div>\n\n\n<p>If you notice, a connect is made to the specific socket which represents\nthe connection to the nscd daemon. It is this successful socket connection\nthat I am interested in. The question I specifically want this ticket\nand the program associated with it to answer is: under what conditions\nis this socket closed?\n\n</p><p>The reason why it is important to me is because check pointing of a\nstduniv program is deferred while sockets are open and I have a belief\nthat once glibc connects to that socket it caches it and <strong>never</strong> closes\nit until the application is exiting. Currently, we disable the nscd feature\nin the glibc we compile and distribute with Condor and it is one of the reasons\nwhy we have to do this in the first place.\n\n</p><p>So, the program you will write will have a few stages:\n\n</p><p><span class=\"subsubsection\"></span></p><h4>Stage 0</h4>\n<ul>\nCall sync() three times.\n\n<p>Call getpwnam() on yourself, this should cause a connect to happen.\n</p></ul>\n\n<p><span class=\"subsubsection\"></span></p><h4>Stage 1</h4>\n<ul>\nCall sync() once\n\n<p>Print out \"BEGIN Stage 1\"\n\n</p><p>Write a select time loop which waits on the stdout fd, but times out\nafter .5 seconds, if the socket comes back ready, print a period, if it times out, print an X. In both cases, resume the loop. The entire loop should execute for 2 hours (use gettimeofday() to compute how long the loop has been running)\n\n</p><p>Print out \"END Stage 1\"\n</p></ul>\n\n<p><span class=\"subsubsection\"></span></p><h4>Stage 2</h4>\n<ul>\nCall sync() once\n\n<p>Print out \"BEGIN Stage 2\"\n\n</p><p>Write a tight loop which, using gettimeofday() to limit it to 2 hours, that\nsimply adds some numbers together and doesn't print anything out.\n\n</p><p>Print out \"END Stage 2\"\n</p></ul>\n\n<p>Now, at this point, the two stages called back into glibc via\ngettimeofday() and technically gives glibc an opportunity to close the\nsocket since we are not using the nscd service during the two previous\nstages. Whether or not it does is the open question. The next does not\nprovide an opportunity to go back into glibc.\n\n</p><p><span class=\"subsubsection\"></span></p><h4>Stage 3</h4>\n<ul>\nCall sync() once\n\n<p>Print out \"BEGIN Stage 3\"\n\n</p><p>Write a tight nested for loop to waste time, hand tweak it until it\nruns for two hours on your machine. A hint on how to do this is write a\ndifferent small program to count how long it takes to count to UINT_MAX/2\nand then to UINT_MAX and linearly interpolate that to how long you'd\nhave to count to get to two hours.\n\n</p><p>Print out \"END Stage 3\"\n</p></ul>\n\n<p><span class=\"subsubsection\"></span></p><h4>Stage 4</h4>\n<ul>\nCall sync() three times.\n\n<p>Call exit(EXIT_SUCCESS)\n</p></ul>\n\n<p><span class=\"subsection\"></span></p><h3>Analysis </h3>\n\n<p>Once you get this program written and it works like how you expect,\nthis is what you do.\n\n</p><p>Run (adjusting for your shell)\n</p><div class=\"code\">\n<pre class=\"code\">strace -ttt -e trace=open,connect,close,sync,exit_group your_prog &gt;&amp; output\n</pre></div>\n\n\n<p>which will save a long inorder sequence of open,connect,close,sync calls that\nyour program is doing. Once the program finishes, this is the final output\nwhich needs to be analyzed for when the socket in question gets closed.\nEnsure that the connect to <code>/var/run/nscd/socket</code> returns 0, which means your\nprogram is actively using the nscd daemon.\n\n</p><p>Perform the analysis by telling me when the <code>/var/run/nscd/socket</code> fd is\nopened and when it is closed with respect to the stages. You can use the\nsync() barrier calls to determine what stage you are in.</p></blockquote>", "remarks": "<blockquote>\n<em>2009-Feb-19 14:01:57 by psilord:</em> <br/>\n\nAfter I get the analysis, I may have you tweak the program somewhat to extract more detail out of the problem. Once we settle on the final version of the program, it should be attached to this ticket so others can see it and try it out.\n\n<p></p><hr/>\n<em>2009-Feb-19 14:24:21 by psilord:</em> <br/>\n\nI updated my hastily written requirements a bit to make sense in the stage with the select loop.\n\n<p></p><hr/>\n<em>2009-Feb-23 20:26:56 by mccardel:</em> <br/>\n\nStarted to look over the manpages for all the functions listed in the ticket. Will get to actual coding tomorrow.\n\n<p></p><hr/>\n<em>2009-Feb-24 10:42:44 by psilord:</em> <br/>\n\nOk, if you start getting stuck, let me know and I'll help out.\n\n<p></p><hr/>\n<em>2009-Feb-24 18:57:27 by mccardel:</em> <br/>\n\nStages 0, 1 and 2 are mostly complete. I wrote them, just testing on my machine. Thus I can't really be certain they work as they're supposed to, but they seem to! I'm also thinking about how to make the computer run for 2 hours without using any glibc calls. I'm sure 2 hours isn't exactly how long it should run, but rather a rough estimate. Will probably resume work on it tomorrow or thursday.\n\n<p></p><hr/>\n<em>2009-Feb-25 14:34:32 by psilord:</em> <br/>\n\nThanks for the update. As for having it run for a couple hours without calling into glibc, that's basically done with nested for loops, just keep nesting them, counting up to UINT_MAX or some fraction of it until you get about two hours worth of computation.\n\n<p></p><hr/>\n<em>2009-Feb-27 00:00:24 by mccardel:</em> <br/>\n\nAlright, wrote a program to figure out what I had to do to get it to count to 2 hours. Counting to UINT_MAX took 8 seconds. Making the int an unsigned volatile made it take 10 seconds. This is going to require a lot of for-loops. Also learned that for some reason the emperor lab computers don't actually have the correct version of &lt;sys/time.h&gt;. They don't have timersub or any of those other useful macros... I'll be finishing this up over the weekend.\n\n<p></p><hr/>\n<em>2009-Feb-27 09:47:11 by matt:</em> <br/>\n\n2 hours = 120 minutes = 7200 seconds / 8 seconds = 900 iterations to UINT_MAX\n\n<p>for 1 to 900 do for 1 to UINT_MAX do ...\n\n</p><p>Be careful, the variability in your 8 second estimate will be magnified 900 times\n\n</p><p></p><hr/>\n<em>2009-Mar-02 15:37:49 by mccardel:</em> <br/>\n\nFixed an odd bug where functions that were previously being found were suddenly not being found. Currently figuring out nmi and will then run the program to see how long it'll take to count to UINT_MAX on all 4 target architectures. I'll modify the program as needed, and then actually test this out.\n\n<p></p><hr/>\n<em>2009-Mar-03 14:23:58 by psilord:</em> <br/>\n\nIf you could try out RHEL 3 and 4 on x86/x86_64 as well, that'd be great.\n\n<p></p><hr/>\n<em>2009-Mar-03 18:29:39 by mccardel:</em> <br/>\n\nDebian 5.0 32 bit and 64 bit done. Waiting on nmi to put nscd on their Red Hat machines before I can test those out. For both of these cases, the socket is being opened and closed in stage 0.\n\n<p></p><hr/>\n<em>2009-Mar-05 15:34:41 by psilord:</em> <br/>\n\n<a class=\"external\" href=\"https://bugzilla.redhat.com/show_bug.cgi?id=432706\">https://bugzilla.redhat.com/show_bug.cgi?id=432706</a>\n\n<p>That is an interesting little link. :)\n\n</p><p></p><hr/>\n<em>2009-Mar-05 16:29:57 by mccardel:</em> <br/>\n\nAh right. Just to keep an official record here. Red Hat 5.0 with both 32 and 64 bits both ran the same as the Debian case. That is to say that the socket for nscd was opened in stage 0, and was closed in stage 0 as well shortly after.</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2021-Oct-05 13:11</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=64601\">[64601]</a></span>: Merged <span class=\"chng\"><a href=\"chngview?cn=63736\">[63736]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63738\">[63738]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63749\">[63749]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63762\">[63762]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63766\">[63766]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63768\">[63768]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63772\">[63772]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63786\">[63786]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63788\">[63788]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63793\">[63793]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63794\">[63794]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63795\">[63795]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63796\">[63796]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63798\">[63798]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63800\">[63800]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63801\">[63801]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63802\">[63802]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63803\">[63803]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63804\">[63804]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63805\">[63805]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63806\">[63806]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63810\">[63810]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63812\">[63812]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63815\">[63815]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63816\">[63816]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=63921\">[63921]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=64127\">[64127]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=64128\">[64128]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=64129\">[64129]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=64130\">[64130]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=64174\">[64174]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=64175\">[64175]</a></span>, <span class=\"chng\"><a href=\"chngview?cn=64207\">[64207]</a></span>,\u00a0[...]\n (By Todd L Miller )</td></tr>\n</tbody></table>", "type": "todo", "last_change": "2009-Dec-26 20:17", "status": "resolved", "created": "2009-Feb-19 11:49", "fixed_version": "2009-Feb-19 11:49", "broken_version": "", "priority": "2", "subsystem": "Unknown", "assigned_to": "mccardel", "derived_from": "", "creator": "psilord", "rust": "", "customer_group": "other", "visibility": "public", "notify": "matt@cs.wisc.edu, psilord@cs.wisc.edu", "due_date": ""}