{"id": 395, "title": "Ticket #395: EventLog.lock fd leak and submission events are bogus", "description": "<blockquote>\n<a class=\"external\" href=\"https://bugzilla.redhat.com/show_bug.cgi?id=496432\">https://bugzilla.redhat.com/show_bug.cgi?id=496432</a>\n\n<p>All the gory details are in the BZ above. The general issue is when the EVENT_LOG is configured in the condor_schedd, the schedd leaks fds to the event log's lock file whenever a cluster is submitted. The result is the schedd runs out of fds and EXCEPTs.\n\n</p><p>The workaround for this is to not use the EVENT_LOG.</p></blockquote>", "remarks": "<blockquote>\n<em>2009-Apr-20 15:19:18 by matt:</em> <br/>\n\nHere are two interesting pieces from valgrind's output...\n\n<p></p><div class=\"verbatim\">\n<pre>==11993== Warning: invalid file descriptor -1 in syscall close()\n==11993==    at 0x3902EC55D7: (within /lib64/libc-2.5.so)\n==11993==    by 0x5A13D9: UserLog::~UserLog() (in /usr/sbin/condor_schedd)\n==11993==    by 0x4DB938: Scheduler::makeReconnectRecords(PROC_ID*, ClassAd const*) (in /usr/sbin/condor_schedd)\n==11993==    by 0x4DBDC2: Scheduler::checkReconnectQueue() (in /usr/sbin/condor_schedd)\n==11993==    by 0x57349E: TimerManager::Timeout() (in /usr/sbin/condor_schedd)\n==11993==    by 0x55FB26: DaemonCore::Driver() (in /usr/sbin/condor_schedd)\n==11993==    by 0x56AECE: main (in /usr/sbin/condor_schedd)\n</pre></div>\n\n\n<p></p><div class=\"verbatim\">\n<pre>==12136== Open file descriptor 250: /mnt/pool/spool/EventLog.lock\n==12136==    at 0x3902EC503F: open64 (in /lib64/libc-2.5.so)\n==12136==    by 0x605281: safe_open_no_create (in /usr/sbin/condor_schedd)\n==12136==    by 0x605431: safe_create_keep_if_exists (in /usr/sbin/condor_schedd)\n==12136==    by 0x60551C: safe_open_wrapper (in /usr/sbin/condor_schedd)\n==12136==    by 0x5A0AE6: UserLog::Configure() (in /usr/sbin/condor_schedd)\n==12136==    by 0x5A0D21: UserLog::initialize(int, int, int, char const*) (in /usr/sbin/condor_schedd)\n==12136==    by 0x4FBDF3: CloseConnection() (in /usr/sbin/condor_schedd)\n==12136==    by 0x4FF080: do_Q_request(ReliSock*, bool&amp;) (in /usr/sbin/condor_schedd)\n==12136==    by 0x4FAC9C: handle_q(Service*, int, Stream*) (in /usr/sbin/condor_schedd)\n==12136==    by 0x54CB80: DaemonCore::CallCommandHandler(int, Stream*, bool) (in /usr/sbin/condor_schedd)\n==12136==    by 0x55E85C: DaemonCore::HandleReq(Stream*) (in /usr/sbin/condor_schedd)\n==12136==    by 0x55EBE9: DaemonCore::HandleReq(int) (in /usr/sbin/condor_schedd)\n==12136==    by 0x55F1E2: DaemonCore::CallSocketHandler(int&amp;, bool) (in /usr/sbin/condor_schedd)\n==12136==    by 0x560A7D: DaemonCore::Driver() (in /usr/sbin/condor_schedd)\n==12136==    by 0x56AECE: main (in /usr/sbin/condor_schedd)\n</pre></div>\n\n\n<p></p><hr/>\n<em>2009-Apr-20 15:31:17 by matt:</em> <br/>\n\nAnyway, looks like those two snippets are different issues.\n\n<p></p><hr/>\n<em>2009-Apr-20 15:49:26 by matt:</em> <br/>\n\nAnother fun one...\n\n<p></p><div class=\"verbatim\">\n<pre>==12136== 129 errors in context 9 of 9:\n==12136== Mismatched free() / delete / delete []\n==12136==    at 0x4A0541E: free (vg_replace_malloc.c:233)\n==12136==    by 0x5A139C: UserLog::~UserLog() (in /usr/sbin/condor_schedd)\n==12136==    by 0x4DB938: Scheduler::makeReconnectRecords(PROC_ID*, ClassAd cons\nt*) (in /usr/sbin/condor_schedd)\n==12136==    by 0x4DBDC2: Scheduler::checkReconnectQueue() (in /usr/sbin/condor_\nschedd)\n==12136==    by 0x57349E: TimerManager::Timeout() (in /usr/sbin/condor_schedd)\n==12136==    by 0x55FB26: DaemonCore::Driver() (in /usr/sbin/condor_schedd)\n==12136==    by 0x56AECE: main (in /usr/sbin/condor_schedd)\n==12136==  Address 0x4C60940 is 0 bytes inside a block of size 112 alloc'd\n==12136==    at 0x4A06019: operator new(unsigned long) (vg_replace_malloc.c:167)\n==12136==    by 0x5A09EA: UserLog::Configure() (in /usr/sbin/condor_schedd)\n==12136==    by 0x5A0D21: UserLog::initialize(int, int, int, char const*) (in /u\nsr/sbin/condor_schedd)\n==12136==    by 0x5A0F69: UserLog::initialize(char const*, int, int, int, char c\nonst*) (in /usr/sbin/condor_schedd)\n==12136==    by 0x5A100B: UserLog::initialize(char const*, char const*, char con\nst*, int, int, int, char const*) (in /usr/sbin/condor_schedd)\n==12136==    by 0x4C78AB: Scheduler::InitializeUserLog(PROC_ID) (in /usr/sbin/co\nndor_schedd)\n==12136==    by 0x4DB887: Scheduler::makeReconnectRecords(PROC_ID*, ClassAd cons\nt*) (in /usr/sbin/condor_schedd)\n==12136==    by 0x4DBDC2: Scheduler::checkReconnectQueue() (in /usr/sbin/condor_\nschedd)\n==12136==    by 0x57349E: TimerManager::Timeout() (in /usr/sbin/condor_schedd)\n==12136==    by 0x55FB26: DaemonCore::Driver() (in /usr/sbin/condor_schedd)\n==12136==    by 0x56AECE: main (in /usr/sbin/condor_schedd)\n</pre></div>\n\n\n<p></p><hr/>\n<em>2009-Apr-20 15:50:20 by matt:</em> <br/>\n\nMore more!\n\n<p></p><div class=\"verbatim\">\n<pre>==12136== Mismatched free() / delete / delete []\n==12136==    at 0x4A0541E: free (vg_replace_malloc.c:233)\n==12136==    by 0x5A1582: UserLog::~UserLog() (in /usr/sbin/condor_schedd)\n==12136==    by 0x4FBE9C: CloseConnection() (in /usr/sbin/condor_schedd)\n==12136==    by 0x4FF080: do_Q_request(ReliSock*, bool&amp;) (in /usr/sbin/condor_sc\nhedd)\n==12136==    by 0x4FAC9C: handle_q(Service*, int, Stream*) (in /usr/sbin/condor_\nschedd)\n==12136==    by 0x54CB80: DaemonCore::CallCommandHandler(int, Stream*, bool) (in\n /usr/sbin/condor_schedd)\n==12136==    by 0x55E85C: DaemonCore::HandleReq(Stream*) (in /usr/sbin/condor_sc\nhedd)\n==12136==    by 0x55EBE9: DaemonCore::HandleReq(int) (in /usr/sbin/condor_schedd\n)\n==12136==    by 0x55F1E2: DaemonCore::CallSocketHandler(int&amp;, bool) (in /usr/sbi\nn/condor_schedd)\n==12136==    by 0x560A7D: DaemonCore::Driver() (in /usr/sbin/condor_schedd)\n==12136==    by 0x56AECE: main (in /usr/sbin/condor_schedd)\n==12136==  Address 0xCB06758 is 0 bytes inside a block of size 112 alloc'd\n==12136==    at 0x4A06019: operator new(unsigned long) (vg_replace_malloc.c:167)\n==12136==    by 0x5A09EA: UserLog::Configure() (in /usr/sbin/condor_schedd)\n==12136==    by 0x5A0D21: UserLog::initialize(int, int, int, char const*) (in /u\nsr/sbin/condor_schedd)\n==12136==    by 0x4FBDF3: CloseConnection() (in /usr/sbin/condor_schedd)\n==12136==    by 0x4FF080: do_Q_request(ReliSock*, bool&amp;) (in /usr/sbin/condor_sc\nhedd)\n==12136==    by 0x4FAC9C: handle_q(Service*, int, Stream*) (in /usr/sbin/condor_\nschedd)\n==12136==    by 0x54CB80: DaemonCore::CallCommandHandler(int, Stream*, bool) (in\n /usr/sbin/condor_schedd)\n==12136==    by 0x55E85C: DaemonCore::HandleReq(Stream*) (in /usr/sbin/condor_sc\nhedd)\n==12136==    by 0x55EBE9: DaemonCore::HandleReq(int) (in /usr/sbin/condor_schedd\n)\n==12136==    by 0x55F1E2: DaemonCore::CallSocketHandler(int&amp;, bool) (in /usr/sbi\nn/condor_schedd)\n==12136==    by 0x560A7D: DaemonCore::Driver() (in /usr/sbin/condor_schedd)\n==12136==    by 0x56AECE: main (in /usr/sbin/condor_schedd)\n</pre></div>\n\n\n<p></p><hr/>\n<em>2009-Apr-20 16:04:41 by nleroy:</em> <br/>\n\nThe mismatched new/free is fixed in 1e592b427fbe26742ed6ff881e4b21b054a9edcd\n\n<p></p><hr/>\n<em>2009-Apr-20 16:12:38 by matt:</em> <br/>\n\nMore...\n\n<p></p><div class=\"verbatim\">\n<pre>04/20 16:56:10 (pid:9184) Unable to open event rotation lock file /mnt/pool/spoo\nl/EventLog.lock\n</pre></div>\n\n\n<p></p><hr/>\n<em>2009-Apr-20 23:35:09 by nleroy:</em> <br/>\n\nI believe that this was fixed in the checkins today.  At least, I've been unable to reproduce the FD leak while running the schedd under valgrind.\n\n<p></p><hr/>\n<em>2009-Apr-21 07:27:40 by matt:</em> <br/>\n\nNo dice, fds are still leaked.\n\n<p>There are also some new leaks it would seem...\n\n</p><p></p><div class=\"verbatim\">\n<pre>==26142== 655,469 (55,888 direct, 599,581 indirect) bytes in 499 blocks are defi\nnitely lost in loss record 102 of 107\n==26142==    at 0x4A06019: operator new(unsigned long) (vg_replace_malloc.c:167)\n==26142==    by 0x5A1798: UserLog::Configure() (user_log.cpp:215)\n==26142==    by 0x5A1AFB: UserLog::initialize(int, int, int, char const*) (user_\nlog.cpp:186)\n==26142==    by 0x4FC92F: CloseConnection() (qmgmt.cpp:2405)\n==26142==    by 0x4FFBBC: do_Q_request(ReliSock*, bool&amp;) (qmgmt_receivers.cpp:40\n4)\n==26142==    by 0x4FB7D8: handle_q(Service*, int, Stream*) (qmgmt.cpp:1303)\n==26142==    by 0x54D6C8: DaemonCore::CallCommandHandler(int, Stream*, bool) (da\nemon_core.cpp:3250)\n==26142==    by 0x55F438: DaemonCore::HandleReq(Stream*) (daemon_core.cpp:4580)\n==26142==    by 0x56175F: DaemonCore::HandleReqSocketHandler(Stream*) (daemon_co\nre.cpp:3398)\n==26142==    by 0x55FD8D: DaemonCore::CallSocketHandler(int&amp;, bool) (daemon_core\n.cpp:3170)\n==26142==    by 0x56166E: DaemonCore::Driver() (daemon_core.cpp:3098)\n==26142==    by 0x56BAEC: main (daemon_core_main.cpp:2100)\n\n==26142== 14,970 bytes in 499 blocks are definitely lost in loss record 70 of 10\n7\n==26142==    at 0x4A05809: malloc (vg_replace_malloc.c:149)\n==26142==    by 0x5A1846: UserLog::Configure() (user_log.cpp:219)\n==26142==    by 0x5A1AFB: UserLog::initialize(int, int, int, char const*) (user_\nlog.cpp:186)\n==26142==    by 0x4FC92F: CloseConnection() (qmgmt.cpp:2405)\n==26142==    by 0x4FFBBC: do_Q_request(ReliSock*, bool&amp;) (qmgmt_receivers.cpp:40\n4)\n==26142==    by 0x4FB7D8: handle_q(Service*, int, Stream*) (qmgmt.cpp:1303)\n==26142==    by 0x54D6C8: DaemonCore::CallCommandHandler(int, Stream*, bool) (da\nemon_core.cpp:3250)\n==26142==    by 0x55F438: DaemonCore::HandleReq(Stream*) (daemon_core.cpp:4580)\n==26142==    by 0x56175F: DaemonCore::HandleReqSocketHandler(Stream*) (daemon_co\nre.cpp:3398)\n==26142==    by 0x55FD8D: DaemonCore::CallSocketHandler(int&amp;, bool) (daemon_core\n.cpp:3170)\n==26142==    by 0x56166E: DaemonCore::Driver() (daemon_core.cpp:3098)\n==26142==    by 0x56BAEC: main (daemon_core_main.cpp:2100)\n\n==26142== 12,475 bytes in 499 blocks are definitely lost in loss record 69 of 10\n7\n==26142==    at 0x4A05809: malloc (vg_replace_malloc.c:149)\n==26142==    by 0x5AB113: expand_macro (config.cpp:694)\n==26142==    by 0x5AC94A: param (condor_config.cpp:1406)\n==26142==    by 0x5A176A: UserLog::Configure() (user_log.cpp:211)\n==26142==    by 0x5A1AFB: UserLog::initialize(int, int, int, char const*) (user_\nlog.cpp:186)\n==26142==    by 0x4FC92F: CloseConnection() (qmgmt.cpp:2405)\n==26142==    by 0x4FFBBC: do_Q_request(ReliSock*, bool&amp;) (qmgmt_receivers.cpp:40\n4)\n==26142==    by 0x4FB7D8: handle_q(Service*, int, Stream*) (qmgmt.cpp:1303)\n==26142==    by 0x54D6C8: DaemonCore::CallCommandHandler(int, Stream*, bool) (da\nemon_core.cpp:3250)\n==26142==    by 0x55F438: DaemonCore::HandleReq(Stream*) (daemon_core.cpp:4580)\n==26142==    by 0x56175F: DaemonCore::HandleReqSocketHandler(Stream*) (daemon_co\nre.cpp:3398)\n==26142==    by 0x55FD8D: DaemonCore::CallSocketHandler(int&amp;, bool) (daemon_core\n.cpp:3170)\n==26142==    by 0x56166E: DaemonCore::Driver() (daemon_core.cpp:3098)\n==26142==    by 0x56BAEC: main (daemon_core_main.cpp:2100)\n\n==26142== 192 bytes in 1 blocks are possibly lost in loss record 37 of 107\n==26142==    at 0x4A06019: operator new(unsigned long) (vg_replace_malloc.c:167)\n==26142==    by 0x582FFB: StatWrapper::init() (stat_wrapper.cpp:200)\n==26142==    by 0x5833D3: StatWrapper::StatWrapper(char const*, StatWrapper::Sta\ntOpType) (stat_wrapper.cpp:150)\n==26142==    by 0x5A17B2: UserLog::Configure() (user_log.cpp:215)\n==26142==    by 0x5A1AFB: UserLog::initialize(int, int, int, char const*) (user_\nlog.cpp:186)\n==26142==    by 0x4FC92F: CloseConnection() (qmgmt.cpp:2405)\n==26142==    by 0x4FFBBC: do_Q_request(ReliSock*, bool&amp;) (qmgmt_receivers.cpp:40\n4)\n==26142==    by 0x4FB7D8: handle_q(Service*, int, Stream*) (qmgmt.cpp:1303)\n==26142==    by 0x54D6C8: DaemonCore::CallCommandHandler(int, Stream*, bool) (da\nemon_core.cpp:3250)\n==26142==    by 0x55F438: DaemonCore::HandleReq(Stream*) (daemon_core.cpp:4580)\n==26142==    by 0x56175F: DaemonCore::HandleReqSocketHandler(Stream*) (daemon_co\nre.cpp:3398)\n==26142==    by 0x55FD8D: DaemonCore::CallSocketHandler(int&amp;, bool) (daemon_core\n.cpp:3170)\n==26142==    by 0x56166E: DaemonCore::Driver() (daemon_core.cpp:3098)\n==26142==    by 0x56BAEC: main (daemon_core_main.cpp:2100)\n\n==26142== Open file descriptor 510: /mnt/pool/spool/EventLog.lock\n==26142==    at 0x3902EC4FD2: open64 (in /lib64/libc-2.5.so)\n==26142==    by 0x606359: safe_open_no_create (condor_open.cpp:190)\n==26142==    by 0x606509: safe_create_keep_if_exists (condor_open.cpp:162)\n==26142==    by 0x6065F4: safe_open_wrapper (condor_open.cpp:77)\n==26142==    by 0x5A1894: UserLog::Configure() (user_log.cpp:224)\n==26142==    by 0x5A1AFB: UserLog::initialize(int, int, int, char const*) (user_\nlog.cpp:186)\n==26142==    by 0x4FC92F: CloseConnection() (qmgmt.cpp:2405)\n==26142==    by 0x4FFBBC: do_Q_request(ReliSock*, bool&amp;) (qmgmt_receivers.cpp:40\n4)\n==26142==    by 0x4FB7D8: handle_q(Service*, int, Stream*) (qmgmt.cpp:1303)\n==26142==    by 0x54D6C8: DaemonCore::CallCommandHandler(int, Stream*, bool) (da\nemon_core.cpp:3250)\n==26142==    by 0x55F438: DaemonCore::HandleReq(Stream*) (daemon_core.cpp:4580)\n==26142==    by 0x56175F: DaemonCore::HandleReqSocketHandler(Stream*) (daemon_co\nre.cpp:3398)\n==26142==    by 0x55FD8D: DaemonCore::CallSocketHandler(int&amp;, bool) (daemon_core\n.cpp:3170)\n==26142==    by 0x56166E: DaemonCore::Driver() (daemon_core.cpp:3098)\n==26142==    by 0x56BAEC: main (daemon_core_main.cpp:2100)\n</pre></div>\n\n\n<p>The many Warnings about closing fd -1 are gone, and an \"Unable to open event rotation log\" still exists, but only one. I tested with a single submission of 500 jobs.\n\n</p><p></p><hr/>\n<em>2009-Apr-21 08:52:20 by matt:</em> <br/>\n\nI'm running valgrind 3.2.1 with...\n<div class=\"verbatim\">\n<pre>env _CONDOR_USE_PROCD=FALSE valgrind --tool=memcheck --num-callers=24 -v -v --leak-check=full --track-fds=yes condor_schedd -t -f\n</pre></div>\n\n\n<p></p><hr/>\n<em>2009-Apr-21 11:41:35 by matt:</em> <br/>\n\nWhen would we have multiple writers to the EVENT_LOG?\n\n<p></p><hr/>\n<em>2009-Apr-21 12:32:13 by matt:</em> <br/>\n\nNo dice from the latest patch, submitted 15 jobs:\n\n<p></p><div class=\"verbatim\">\n<pre>==14498== FILE DESCRIPTORS: 18 open at exit.\n</pre></div>\n\n\n<p>14 of which are the EventLog.lock\n\n</p><p></p><hr/>\n<em>2009-Apr-21 12:34:00 by matt:</em> <br/>\n\nThe last patch seems to clean up a number of memory issues though, the obvious one that's left:\n\n<p></p><div class=\"verbatim\">\n<pre>==14498== 18,396 (1,568 direct, 16,828 indirect) bytes in 14 blocks are definite\nly lost in loss record 97 of 104\n==14498==    at 0x4A06019: operator new(unsigned long) (vg_replace_malloc.c:167)\n==14498==    by 0x5A17A0: UserLog::Configure() (user_log.cpp:215)\n==14498==    by 0x5A1B59: UserLog::initialize(int, int, int, char const*) (user_\nlog.cpp:186)\n==14498==    by 0x4FC937: CloseConnection() (qmgmt.cpp:2405)\n==14498==    by 0x4FFBC4: do_Q_request(ReliSock*, bool&amp;) (qmgmt_receivers.cpp:40\n4)\n==14498==    by 0x4FB7E0: handle_q(Service*, int, Stream*) (qmgmt.cpp:1303)\n==14498==    by 0x54D6D0: DaemonCore::CallCommandHandler(int, Stream*, bool) (da\nemon_core.cpp:3250)\n==14498==    by 0x55F440: DaemonCore::HandleReq(Stream*) (daemon_core.cpp:4580)\n==14498==    by 0x55F7CD: DaemonCore::HandleReq(int) (daemon_core.cpp:3472)\n==14498==    by 0x55FDD0: DaemonCore::CallSocketHandler(int&amp;, bool) (daemon_core\n.cpp:3178)\n==14498==    by 0x561676: DaemonCore::Driver() (daemon_core.cpp:3098)\n==14498==    by 0x56BAF4: main (daemon_core_main.cpp:2100)\n</pre></div>\n\n\n<p></p><hr/>\n<em>2009-Apr-25 17:35:47 by matt:</em> <br/>\n\nAttached are two strace logs, one with the EVENT_LOG on NFS and the other not...\n\n<p>The NFS log shows FDs 11,13,14,15 being leaked.\n\n</p><p>It appears that the lock is opened as fd 11, then the log is opened as fd 12. The header is written to fd 12. Then for each job in the cluster I submitted, queue 5, the lock is reopened though it exists, and that new fd is leaked. Finally at the end of the submission the last lock fd is closed, 16, and the fd to the log, 12, is closed.\n\n</p><p>In the non-NFS case, the trace looks pretty similar, except the opens on the lock file fail, and thus can't be leaked.\n\n</p><p>It seems the qmgmt.cpp::CloseConnection doesn't properly clean up the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=UserLog\" title=\"User Log\">UserLog</a></span> usr_log. It initializes it multiple times, and each initialization would leak the fd.\n\n</p><p>This raises another question, do the events get written if a job is submitted via SOAP?\n\n</p><p></p><hr/>\n<em>2009-Apr-27 07:52:03 by matt:</em> <br/>\n\nWith my last commit, c2cfbff08, I think this is resolved. The issue was qmgmt.cpp's <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=CloseConnection\" title=\"Close Connection\">CloseConnection</a></span> would call UserLog::initialize for each proc in the submitted cluster. It did so purely (or so it seemed) to change the cluster/proc id held by the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=UserLog\" title=\"User Log\">UserLog</a></span>. However, because of a change back in May '08, the initialize call would also initialize lock fds. The result of init+init+init... meant that only the last init's fds were cleaned up when the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=UserLog\" title=\"User Log\">UserLog</a></span> was deleted. The fix I implemented for this was to init the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=UserLog\" title=\"User Log\">UserLog</a></span> once and then call setGlobalCluster/Proc to set the cluster/proc.\n\n<p>The reason this did not leak on a local fs was because opening the lock file was failing with EACCESS, and the lock fd was never recorded on the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=UserLog\" title=\"User Log\">UserLog</a></span>. This is kinda scary because it means the lock wasn't really acquired and yet writing to the log went ahead. On NFS the open succeeded and subsequent inits would overwrite it.\n\n</p><p>A separate issue here is why the open was failing on a local fs and if locking is happening properly on NFS, but that's another ticket that should be filed - likely by Nick.</p></blockquote>", "derived_tickets": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">\n<span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=451\" onclick=\"get_ticket_and_populate_wrapper('451'); return false;\" title=\"Event Log writer leaks when re-initialized\">#451</a></span></td>\n<td align=\"center\" valign=\"center\" width=\"30\">\n<span class=\"icon ptr1\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\">\nEvent Log writer leaks when re-initialized</td></tr>\n</tbody></table>", "attachments": "<html><head></head><body><blockquote>\n<ul>\n<li><a href=\"../files/52/el.strace\">el.strace</a>\n5742 bytes added by matt on 2009-Apr-25 22:36:34 UTC.\n<br/>\nstrace with EVENT_LOG on NFS<br/>\n</li><li><a href=\"../files/53/el.nonnfs.strace\">el.nonnfs.strace</a>\n6866 bytes added by matt on 2009-Apr-25 22:36:56 UTC.\n<br/>\nstrace with EVENT_LOG not on NFS<br/>\n</li></ul>\n</blockquote></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2009-Apr-26 19:32</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=14554\">[14554]</a></span>: Resolved bug introduced in previous quick fix for <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=395\" onclick=\"get_ticket_and_populate_wrapper('395'); return false;\" title=\"EventLog.lock fd leak and submission events are bogus\">#395</a></span> Avoid intializing the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=UserLog\" title=\"User Log\">UserLog</a></span> with uninit variables, just use bogus 0s to start. Then use setGlobalCluster/Proc instead of re-initializing for each submit event.  (By Matthew Farrellee )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2009-Apr-25 23:14</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=14553\">[14553]</a></span>: Quick fix for fd leak when EVENT_LOG is on NFS, possibly incomplete (<span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=395\" onclick=\"get_ticket_and_populate_wrapper('395'); return false;\" title=\"EventLog.lock fd leak and submission events are bogus\">#395</a></span>) This fix only prevents the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=UserLog\" title=\"User Log\">UserLog</a></span> from being initialized multiple times, causing an FD leak. It does not handle failure of the initialization, which was also not handled by the previous code.  (By Matthew Farrellee )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2009-Apr-21 16:57</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=14529\">[14529]</a></span>: Fixed handling of EVENT_LOG_ROTATION_LOCK parameter (<span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=395\" onclick=\"get_ticket_and_populate_wrapper('395'); return false;\" title=\"EventLog.lock fd leak and submission events are bogus\">#395</a></span>)  (By Nick <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=LeRoy\" title=\"Le Roy\">LeRoy</a></span> )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2009-Apr-21 09:41</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=14526\">[14526]</a></span>: Log writer: don't instantiate a <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=FileLock\" title=\"File Lock\">FileLock</a></span> when we fail to create the lock file (<span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=395\" onclick=\"get_ticket_and_populate_wrapper('395'); return false;\" title=\"EventLog.lock fd leak and submission events are bogus\">#395</a></span>)  (By Nick <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=LeRoy\" title=\"Le Roy\">LeRoy</a></span> )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2009-Apr-20 16:15</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=14519\">[14519]</a></span>: Fixed a bug in the event log writer in which it will try to close a -1 fd if it fails to open the rotation lock file. (<span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=395\" onclick=\"get_ticket_and_populate_wrapper('395'); return false;\" title=\"EventLog.lock fd leak and submission events are bogus\">#395</a></span>)  (By Nick <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=LeRoy\" title=\"Le Roy\">LeRoy</a></span> )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2009-Apr-20 15:37</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=14516\">[14516]</a></span>: Fixed a bug in which the log writer was free()ing memory instead of delete. (gittrac <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=395\" onclick=\"get_ticket_and_populate_wrapper('395'); return false;\" title=\"EventLog.lock fd leak and submission events are bogus\">#395</a></span>)  (By Nick <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=LeRoy\" title=\"Le Roy\">LeRoy</a></span> )</td></tr>\n</tbody></table>", "type": "defect", "last_change": "2009-Dec-23 11:39", "status": "resolved", "created": "2009-Apr-20 13:06", "fixed_version": "2009-Apr-20 13:06", "broken_version": "v070300", "priority": "2", "subsystem": "Daemons", "assigned_to": "matt", "derived_from": "", "creator": "matt", "rust": "", "customer_group": "other", "visibility": "public", "notify": "matt@cs.wisc.edu, tannenba@cs.wisc.edu, nleroy@cs.wisc.edu", "due_date": ""}