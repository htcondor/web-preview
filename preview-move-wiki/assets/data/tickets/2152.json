{"id": 2152, "title": "Ticket #2152: Introduce multiple concurrent claim activations", "description": "<blockquote>\n<span class=\"section\"><h2>Motivation </h2></span>\nCondor needs a way to deal with multiple concurrent claim activations: as\nthings currently stand, we are able to have one Shadow/Starter per claim at a\ngiven time. Being able to support more concurrent Shadow/Starter pairs per\nclaim would allow for streamlining input/output transfers, overlapping I/O and\nexecution (see sandbox manager project), or even to run multiple, low-resource\njobs at once.\nVarious changes in Startd and Schedd are needed in order to accomodate\nthis.\n\n<p><span class=\"section\"></span></p><h2>Involved objects</h2>\n<span class=\"subsection\"><h3>Match </h3></span>\nA match is created by the negotiator between a user's job and a Startd's resource (\"slot\"). The negotiator informs both the startd and the schedd about the match.\nIn Condor's current startd implementation, the match is manifested as a state (\"matched state\") in a resource's claim object. The lifetime of a match ends with the expiration\nof a claim (if a claim takes place), or times out. The scope of this work will not\nactually affect or modify the matching protocols or data structures.\n<span class=\"subsection\"><h3>Claim </h3></span>\nA claim represents a provisioned resource. When a schedd is notified about a match, it typically proceeds to claim the resource. A claim object is maintained by the Schedd\nand the Startd. It contains information including the claim ID that was generated by the startd and passed to the schedd via the negotiator, and claim lease - a claim expires after\na period of time if the lease is not renewed. A startd slot enters the Claimed/Idle state/activity upon being completion of the claiming protocol between the schedd and the startd.\n<span class=\"subsection\"><h3>Claim activation</h3></span>\nOnce a match has been made and a resource is marked as claimed (aka provisioned), the claim is <em>activated</em>\nto indicate the instantiation of an activity on the resource. The claim activation protocol is typically initiated by the shadow contacting the startd; upon completion the startd slot is said to be Claimed/Active and the startd spawns a starter to manage the activation. <em>Deactivation</em> of a claim places the startd slot back into Claimed/Idle state. A Startd can still reject the activation\nif circumstances changed. This would lead to the Schedd relinquishing the claim. In order to make\nclaim activation more explicit (and to allow multiple activations per claim), we propose to implement an activation object\ncontaining an activation ID, which will be scoped within a claim ID. An activation without\na claim is meaningless. A more detailed description of what is needed within an explicit activation\nobject can be found in the \"design\" part of this document.\n\n<p><span class=\"section\"></span></p><h2>Current claim activation protocol</h2>\nThe Startd side maintains interleaved claim and resource objects. Each claim object contains a Starter object if the claim is activated. The schedd side maintains a\nmatch record for each claim, managing information such as the current state of the claim, a shadow record if the claim is active containing information about a spawned shadow, a copy of the resource ad as sent from the negotiator at match time, address of a matched startd, and a claim id. Relevant for this work is what happens <em>after</em> a\nresource has been claimed by the Schedd; in other words, we do not propose any changes to the code that manages matching or claiming.\n\n<p>Given that the schedd already has a claimed resource and has identified a job it wants to launch on the resource, an the schedd initiates activation as follows:\n</p><ol>\n<li>Schedd spawns a Shadow, and passes to the shadow a copy of the job ad augmented with some additional attributes that includes the startd address and the claim ID.\n</li><li>Shadow sends a claim activate command to Startd, passing to the startd the claim ID and a copy of the job classad.\n</li><li>The startd re-evaluates its policy expressions within the context of the job classad from the shadow and an updated machine ad; if policy decides the resource is no longer available, the Startd rejects the activation request, the Shadow shuts down, and\nSchedd relinquishes the claim.\n</li><li>If Startd is will to activate the claim, it forks off a Starter to run the job, and passes the tcp socket initiated by the shadow to the starter. Thus the starter is born with a tcp socket connected back to the shadow.\n</li><li>Once the jobs's execution and output data transfer are completed, the\nStarter sends the final update to the Shadow. The shadow then updates the final information in the job queue, and sends a deactivate command to the startd, resulting in the startd telling the starter to shutdown.\n</li><li>While the job is running, the starter is sending <em>update classads</em> containing run-time information to both the shadow (for job policy enforcement) <em>and</em> the startd (so machine policy can refer to updated job attributes such as <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ImageSize\" title=\"Image Size\">ImageSize</a></span>).\n</li><li>Starter exit triggers the Startd to change claim/resource state into CLAIMED/IDLE\n</li><li>Shadow exit triggers match record update in Schedd\n</li><li>Schedd tries to find next matching job for claim and spawns the next\nShadow (which leads to the next activation)\n</li><li>If no new job for claim can be found, the schedd tells the startd that the claim is relinquished, match record in Schedd deleted, and claim object in Startd destroyed.\n</li></ol>\n\n<p><span class=\"section\"></span></p><h2>Proposed Design</h2>\nIn this section we describe the proposed design changes in Startd and Schedd with associated objects\nto facilitate concurrent claim activations. The overall high-level change is the\nintroduction of an explicit activation object, scoped and owned by the claim object. As before, there will be one shadow/starter instance pair per activation - but now a single claim may have X simultaneous shadow/starter pairs.\n\n<p>With regards to startd policy, all policy expressions will continue to operate at the claim level, not at the individual activation level. However, we propose one <em>circuit breaker</em> startd enforced limit on the number of activations allowed per claim as a property that can be set per slot.\n\n</p><p><span class=\"subsection\"></span></p><h3>Activation object</h3>\nThe activation object needs to contain a unique ID (only needs to be unique within claim) and a field for a Starter sinful string, which is currently maintained by the claim object.  We propose the activation ID will be the current public-part of the claim ID with an additional field appended - this will minimize code disruption and assist in backwards compatibility.\n\n<p><span class=\"subsection\"></span></p><h3>Changes to the Startd</h3>\nWhile in state CLAIMED/RUNNING, the Startd must be able to accept further\nactivations on a claim.\n\n<p></p><ul>\n<li>In the startd, a Resource Claim object contains a Starter object and is responsible for activating a claim, managing a condor_starter, etc. Therefore, the Claim object needs to maintain a set of Activation objects. When a shadow is spawned, the schedd will generate an activation ID and pass it along to the shadow in the same manner as the claim ID. Requests from the shadow to the startd for activation (job launch) and deactivation (e.g. job held, removed, completed) need to include an activation ID, such that the appropriate Starter can be addressed. Activation does not necessarily imply spawning of a Starter but can and in the common case will.\n</li><li>The activation object therefore maintains the activation ID and a Starter sinful string (may be NULL)\n</li><li>Functions that address Starter object (such as <code>Claim::setStarter</code> or <code>Claim::spawnStarter</code>) will need to accept the activation ID as an additional argument - should default to 0 for backwards compatibility\n</li><li>It may make sense to introduce a new startd RPC to deactivate all activations associated with a claim: this would be an iteration over all activations.\n</li><li>Note that the process of vacating, suspending, continuing jobs would become an iteration over all activations, as startd policy expression always operate at the claim level.\n</li><li>Starters advertise information back to both the shadow and the Startd. For update ads sent back to the startd, it will be the Startd's responsibility to aggregate that information across all starters associated with the same claim. Optionally, we may consider the startd advertising non-aggregated activation-specific information as well, perhaps by leveraging nested classads.\n</li><li>Open issue: startd job hooks... we should allow job hooks to have multiple activations, but in terms of development milestones, we hope to postpone exposure of multi-activations to job hooks as future work. Part of our concern is we do not want to perturb the existing job hook API, as changing the API could cause hardship for clients.\n</li></ul>\n\n<p>Advantage: Starter remains unchanged, no new object is introduced\n\n</p><p>Disadvantage: Claim object needs to be extended by a list of activation objects, Startd behavior on claim activation/deactivation needs to be adjusted\n\n</p><p><span class=\"subsection\"></span></p><h3>Other possible approaches and motivation for chosen design</h3>\n\n<p>1) Modify the startd to support an array of starters.\nIn this case, the starter changes very little if at all, and the startd changes\nonly to support managing and signalling multiple starters.  There is exactly\none activation per starter, but potentially multiple starters per claim.\n\n</p><p>2) Modify the starter to support an array of activations.\nHere, there would be one starter per claim, and it would track the activations\ninternally.  There already exists this concept in the starter, but none of the\nexisting code uses it.\n\n</p><p>3) Introduce a new daemon between the startd and starter(s) that manages the\nactivations for a given claim.  Here there would again be one starter per\nactivation, all under the new daemon which represents a claim to the startd.\nThis daemon would manage and the starters.\n\n</p><p>in all options, changes are needed to the startd (or more specifically, the Claim object) to accomodate multiple\nactivations, reconnect, signalling all and/or specific activations, and combining the resources used into one set of resources so that policy enforcement can be applied at the claim level.\n\n</p><p>in option 2, more changes are needed to the starter in addition to the above,\nand in option 3 an entirely new daemon would be created.  given that, it seems\nthat option 1 requires changing fewer components in the condor system as a\nwhole and leaves the starter largely untouched.</p></blockquote>", "remarks": "<blockquote>\n<em>2011-May-11 17:37:29 by cweiss:</em> <br/>\n\nI will use the body of this ticket for the design document. That avoids emailing it back and forth.\n\n<p></p><hr/>\n<em>2011-Jul-21 12:46:37 by tstclair:</em> <br/>\n\nHow does it deal with claim reuse/recycling?\n\n<p>1 Shadow per activation?\n\n</p><p></p><hr/>\n<em>2011-Jul-21 13:12:37 by tannenba:</em> <br/>\n\nRe Tim's question above, added the following clarification into the document:\n<em>As before, there will be one shadow/starter instance pair per activation - but now a single claim may have X simultaneous shadow/starter pairs.</em></blockquote>", "derived_tickets": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">\n<span class=\"ticket\"><a class=\"defer\" href=\"/tickets?ticket=2362\" onclick=\"get_ticket_and_populate_wrapper('2362'); return false;\" title=\"write design document for multiple claims and subclaims\">#2362</a></span></td>\n<td align=\"center\" valign=\"center\" width=\"30\">\n<span class=\"icon ptr1\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\">\nwrite design document for multiple claims and subclaims</td></tr>\n</tbody></table>", "attachments": "", "check_ins": "", "type": "enhance", "last_change": "2012-Dec-17 13:59", "status": "defer", "created": "2011-May-11 17:36", "fixed_version": "2011-May-11 17:36", "broken_version": "v070000", "priority": "4", "subsystem": "", "assigned_to": "zmiller", "derived_from": "#1742", "creator": "tannenba", "rust": "", "customer_group": "other", "visibility": "public", "notify": "tannenba@cs.wisc.edu , zmiller@cs.wisc.edu bbockelm@cse.unl.edu,  tstclair@redhat.com, dan@hep.wisc.edu, parag@fnal.gov, cweiss@cs.wisc.edu, zmiller@cs.wisc.edu", "due_date": ""}