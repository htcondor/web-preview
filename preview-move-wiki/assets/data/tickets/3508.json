{"id": 3508, "title": "Ticket #3508: Jobs which fail to remove their keypairs don't go on hold.", "description": "<blockquote>\nWe presently just log an error message if the grid manager fails to delete a keypair it created on a job's behalf.  This potentially leaks keypairs.\n\n<p>We can't presently put the job on hold (our usual response) because at the time we reach GM_DELETE, the remote job ID(s) may have all already been forgotten (if they ever existed).\n\n</p><p>One option would be to add an explicit \"cleanup\" state.  This may be the most logically consistent approach, but would be complicated by the requirement that no other code could decide it was safe to forget about a job (and other code currently does).\n\n</p><p>A second option would be to instead construct a synthetic remote job ID in GM_DELETE.  If all we're trying to do is delete the keypair, we don't actually need to know the job's ID, just the resource's, which we ought to be able to obtain, given that we just asked it to delete a keypair.  The grid manager could then recognize this synthetic remote job ID (e.g., 'ec2 url://path remove-keypair' and jump back to GM_DELETE; as long as GM_DELETE doesn't remove the keypair attributes before it's certain it's done, we don't have to add a new state.</p></blockquote>", "remarks": "<blockquote>\n</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "defect", "last_change": "2013-Sep-09 10:45", "status": "new", "created": "2013-Feb-21 15:08", "fixed_version": "2013-Feb-21 15:08", "broken_version": "v070904", "priority": "4", "subsystem": "Grid", "assigned_to": "tlmiller", "derived_from": "#3477", "creator": "tlmiller", "rust": "", "customer_group": "other", "visibility": "public", "notify": "jfrey@cs.wisc.edu", "due_date": ""}