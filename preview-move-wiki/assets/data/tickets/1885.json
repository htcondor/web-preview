{"id": 1885, "title": "Ticket #1885: optimize fetching of ads by negotiator from collector", "description": "<blockquote>\nEvery negotiation cycle, the negotiator fetches all ads from the collector.  For very large pools, this can take considerable time and chew up a lot of memory.\n\n<p>Ads of any type other than startd, schedd, and submitter are fetched but not used for any purpose by the negotiator.\n\n</p><p>When the negotiator is not considering preemption, the claimed ads are thrown away after getting the total count.  The total count is used in the resource allocation algorithm.  If there were a more efficient way for the negotiator to count the ads without actually fetching them, this process could be much more efficient.</p></blockquote>", "remarks": "<blockquote>\n<em>2011-Jan-28 16:53:14 by matt:</em> <br/>\n\nOne idea that has been discussed previously is turning the Negotiator into a Collector, make it a sink like a view collector.\n\n<p>Check with eje for exact numbers, but the query phase during negotiation is very much non-trivial overhead.\n\n</p><p></p><hr/>\n<em>2011-Jan-28 17:01:05 by matt:</em> <br/>\n\nOr better yet, ask your own Negotiator -\n\n<p>A quiet negotiator -\n\n</p><p></p><div class=\"verbatim\">\n<pre>$ condor_status -neg -l | grep Phase\nLastNegotiationCyclePhase1Duration0 = 0\nLastNegotiationCyclePhase2Duration0 = 0\nLastNegotiationCyclePhase3Duration0 = 0\nLastNegotiationCyclePhase4Duration0 = 0\n</pre></div>\n\n\n<p></p><hr/>\n<em>2012-Dec-10 10:01:19 by danb:</em> <br/>\n\nSince the negotiator spends a lot of time in the matchmaking code and is thus not very responsive to network activity, I'd be worried about lots of ads getting dropped if it were trying to keep up with updates from a large pool.  Anybody have evidence that this is not a problem?\n\n<p></p><hr/>\n<em>2012-Dec-10 10:32:09 by sfiligoi:</em> <br/>\n\nMaking the Negotiator a Collector would not really save you much;\nall <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAds\" title=\"Class Ads\">ClassAds</a></span> are updated (on average) every 5 minutes.\n\n<p>In my experience, one does not re-negotiator much more often than once every 5 mins, so the Negotiator would still process (close to) ALL the ads...\n\n</p><p>And gathering the data would of course be worse; instead of a orderly query, it would have to process the updates in a highly chaotic bursts.\n\n</p><p></p><hr/>\n<em>2012-Dec-10 14:18:59 by matt:</em> <br/>\n\n@danb The negotiator is already partially async during the negotiation cycle. A direct melding of collector engine + negotiator would not work because the matchmaking code currently assumes an immutable set of machine ads. The melding would need to replicate that feature of the machine set, which can be achieved with parallel sets. Outside a cycle there is one set, setA, at the start of a cycle a second set, setB, is created and async populated as updates arrive, matchmaking can operate on setA, at the end of the cycle setB can be merged into setA. This is an operable step toward an even more async negotiator. Or a negotiator that maintains ads in a form already prepared for matchmaking, e.g. filtered, sorted and sig attr calculated. I am not aware of evidence that consuming updates is an expensive operation on the collector engine. Additionally, invalidating ads has an constant time implementation. Anecdotally observing \"Query info\" data, I postulate that the bulk of the collector engine's work is spent servicing queries and encoding classads. With Tim's <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span> optimizations, that cost should be reduced.\n\n<p>@sfiligoi Negotiation in most of our environments is a near continuous process, with only a 20 lag between cycles to let Match information to propagate. The cost of query + process dominates the cycle. Once a pool is at high utilization the negotiator only sees a small % of resources as available, with spikes associated with claim worklife expiration. However, each cycle the negotiator must gather and process the entire pools worth of machine ads.\n\n</p><p></p><hr/>\n<em>2012-Dec-10 14:58:26 by danb:</em> <br/>\n\nPresumably the two sets of machine ads that you propose would share memory with copy-on-write semantics.  Perhaps the recent classad expression caching work would be enough?  Without some sort of copy-on-write, I fear the memory allocation overhead could make things worse.\n\n<p>If the negotiation cycle is quite long compared to the machine ad update interval, the classad sink overhead in the negotiator could be higher when directly receiving updates than the bulk query case.  If it is acceptable to increase the update interval, then this effect could be controlled somewhat.  However, state changes can trigger a new update at any time.\n\n</p><p>If the negotiation cycle is short compared to the average update interval, the bulk query could be optimized to take advantage of that: \"send me all ads that have been updated since time T\".\n\n</p><p>Since the negotiator probably doesn't care about a lot of the attributes in the ads, perhaps the forwarding mechanism would benefit from the same sort of attribute white-list as the query mechanism.\n\n</p><p></p><hr/>\n<em>2012-Dec-11 14:46:57 by matt:</em> <br/>\n\n@danb -\n\n<p>Re CoW: Not having CoW would be no worse than what currently exists, which is Collector serializing entire contents of memory to the wire followed by the Negotiator deserializing the wire into memory. This commonly happens on a single machine.\n\n</p><p>Re update rate: Yes, the real update rate (periodic plus edge triggered) will dictate the elbow in the performance curve.\n\n</p><p>Re MODIFIED-SINCE queries: That sounds like a reasonable step, which keeps the collecting role in the Collector and allows for merging in the Negotiator. For long delays between cycles, it will tend to a full dump. A high real update rate will accelerate the tendency. I posit the delays are decreasing rather than increasing, both wrt claim eviction and MTTS for new jobs.\n\n</p><p>Re query projection: The Negotiator does not know upfront what attributes are present in job Requirements &amp; Rank and may miss w/ a projection.\n\n</p><p></p><hr/>\n<em>2012-Dec-11 14:53:04 by sfiligoi:</em> <br/>\n\nRe query projection:\nThere are some use cases where the attributes used for the requirements are uniform in a Condor pool... e.g. the glidein pools CMS is using.\n\n<p>So we should put in place autoclustering of machine ads, similarly to what is done in the schedd. Not sure where this should be done; maybe the Negotiator could just incrementally learn (with occasional re-query on wrong assumption).\n\n</p><p>The other option, of course, is for the admin to tell the Negotiator to only look at the ones that are expected. Could be a short term solution, like it was for the schedd clustering.\n\n</p><p></p><hr/>\n<em>2012-Dec-12 11:53:25 by danb:</em> <br/>\n\nRegarding projection: the collector already expands the projection to include all dependencies.  So if the negotiator asks for requirements and rank, it will also get all attributes referenced by those expressions.  This sounds like a non-trivial amount of work per ad, but it's probably still a big win for over sending full ads to the negotiator.</blockquote>", "derived_tickets": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">\n<span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=3366\" onclick=\"get_ticket_and_populate_wrapper('3366'); return false;\" title=\"scaling higher when NEGOTIATOR_CONSIDER_PREMPTION=False\">#3366</a></span></td>\n<td align=\"center\" valign=\"center\" width=\"30\">\n<span class=\"icon ptr1\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\">\nscaling higher when NEGOTIATOR_CONSIDER_PREMPTION=False</td></tr>\n</tbody></table>", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "enhance", "last_change": "2013-Jul-25 19:14", "status": "new", "created": "2011-Jan-28 16:31", "fixed_version": "2011-Jan-28 16:31", "broken_version": "v070000", "priority": "4", "subsystem": "", "assigned_to": "danb", "derived_from": "", "creator": "danb", "rust": "", "customer_group": "cms", "visibility": "public", "notify": "sfiligoi@fnal.gov,dan@hep.wisc.edu,matt@cs.wisc.edu, tstclair@redhat.com", "due_date": ""}