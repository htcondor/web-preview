{"id": 2208, "title": "Ticket #2208: Don't crash GDB in daemon core", "description": "<blockquote>\nFor the most part, GDB crashes in daemon core when condor forks.  This is due to the fact that it uses libthread_db to get internal state information from libpthread.\n\n<p>We use clone() without asking the kernel to set up new thread level storage (TLS).  Having the parent's TLS, but being in a different TGID, causes a corruption in gdb's state.  This corruption appears to happen when gdb is notified of the exec invocation.\n\n</p><p>I propose to ask the kernel to create new TLS for the child, use the parent's TLS for any non-locking call (when traced, the parent holds an internal pthreads lock; calls in the child where glibc internally tries to grab the same lock such as seteuid end badly), and return to the child's TLS for the exec.\n\n</p><p>Patch forthcoming.</p></blockquote>", "remarks": "<blockquote>\n<em>2011-Jun-02 17:32:50 by bbockelm:</em> <br/>\n\nAdditional narrative:\n\n<p>I think Condor is the only batch system \"lucky\" enough to be able to crash GDB during normal running.\n\n</p><p>Basically, the use of clone() and pthreads is causing this; gdb uses a library, libthread_db, that talks to libpthreads, to support threaded debugging.  This allows pthreads to trigger breakpoints in the debugger whenever significant events occur in the lifetime of a process.\n\n</p><p>When we call clone(), we copy the parent's thread local storage which includes pthread's thread state information but the PID changes (making the information invalid).  When GDB gets the signal when exec is called, it will retrieve the thread state information, but find it is invalid and assert (boom!).\n\n</p><p>The naive solution is have the kernel create a default, empty TLS.  Unfortunately, this causes various glibc functions to SIGSEGV, such as malloc (I believe because glibc started using pthread information and isn't prepared for it to disappear; malloc uses TLS for lock-free allocations, for example).\n\n</p><p>In the child, we can restore the parent's TLS for everything but the exec call (which is when GDB asserts), but a few glibc calls will try to hold the TLS's mutex (seteuid is one used by condor).  When in tracing mode, the parent also holds said lock and, as we use CLONE_VFORK, the parent doesn't release the mutex until after the child exits... causing a deadlock.\n\n</p><p>The attached patch carefully weaves a combination of using the child and parent's TLS when in the child in order to avoid pthreads deadlocks, GDB asserts, and glibc segfaults.\n\n</p><p>It's tricky.</p></blockquote>", "derived_tickets": "", "attachments": "<blockquote>\n<ul>\n<li><a href=\"attach_get/367/condor_gdb_noworries.patch\">condor_gdb_noworries.patch</a>\n2332 bytes added by bbockelm on 2011-Jun-02 22:17:50 UTC.\n</li></ul>\n</blockquote>", "check_ins": "", "type": "todo", "last_change": "2012-Oct-17 13:19", "status": "new", "created": "2011-Jun-02 17:17", "fixed_version": "2011-Jun-02 17:17", "broken_version": "", "priority": "4", "subsystem": "Daemons", "assigned_to": "", "derived_from": "", "creator": "bbockelm", "rust": "", "customer_group": "other", "visibility": "public", "notify": "eje@cs.wisc.edu", "due_date": ""}