{"id": 4499, "title": "Ticket #4499: Potential null pointer dereference in InitCommandSocket", "description": "<blockquote>\nCoverity correctly points out that <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=InitCommandSockets\" title=\"Init Command Sockets\">InitCommandSockets</a></span> (<a class=\"file\" href=\"rlog?f=src/condor_daemon_core.V6/daemon_core.cpp\">/src/condor_daemon_core.V6/daemon_core.cpp</a> around line 9676) implies that it's valid to pass in a sock_pair with a null <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ReliSock\" title=\"Reli Sock\">ReliSock</a></span>. If that's the case, later code dereferences it in unsafe ways. There are no known cases where this actively happens, but it is a landmine that could surprise future code.\n\n<p></p><div class=\"code\">\n<pre class=\"code\">  9734                // Ensure we have a socket, setsockopt doesn't work otherwise.\n At conditional (1): \"rsock\" taking the false branch.\n CID 10511: Dereference after null check (FORWARD_NULL)\n Comparing \"rsock\" to null implies that \"rsock\" might be null.\n  9735                if(rsock) {\n  9736                        if(!assign_sock(proto, rsock, fatal)) { return false; }\n  9737                }\n At conditional (2): \"ssock\" taking the true branch.\n  9738                if(ssock) {\n At conditional (3): \"!assign_sock(proto, ssock, fatal)\" taking the false branch.\n  9739                        if(!assign_sock(proto, ssock, fatal)) { return false; }\n  9740                }\n  9741\n  9742#if defined ( WIN32 )\n  9743                /** To better match the *nix semantics of SO_REUSEADDR we\n  9744                        enable MSs SO_EXCLUSIVEADDRUSE option, which prohibits\n  9745                        multiple process/identities/etc. from binding to the\n  9746                        same address (which is just crazy behaviour!).\n  9747\n  9748                        For further details refer to ticket #288. */\n  9749                so_option = SO_EXCLUSIVEADDRUSE;\n  9750#endif\n  9751\n  9752                        // Set options on this socket, SO_REUSEADDR, so that\n  9753                        // if we are binding to a well known port, and we\n  9754                        // crash, we can be restarted and still bind ok back\n  9755                        // to this same port. -Todd T, 11/97\n Passing null variable \"rsock\" to function \"Sock::setsockopt(int, int, void const *, int)\", which\ndereferences it. [show details]\n  9756                if( !rsock-&gt;setsockopt(SOL_SOCKET, so_option,\n  9757                                                           (char*)&amp;on, sizeof(on)) ) {\n  9758                        if (fatal) {\n</pre></div>\n\n\n<p>Proposed fix: restructure the code so that all interactions with rsock occur inside of the \"if(rsock)\" test. For symmetry, do so for ssock as well.</p></blockquote>", "remarks": "<blockquote>\n</blockquote>", "derived_tickets": "", "attachments": "", "check_ins": "", "type": "defect", "last_change": "2014-Jul-30 16:28", "status": "new", "created": "2014-Jul-30 16:28", "fixed_version": "2014-Jul-30 16:28", "broken_version": "v080106", "priority": "4", "subsystem": "", "assigned_to": "adesmet", "derived_from": "", "creator": "adesmet", "rust": "", "customer_group": "other", "visibility": "public", "notify": "", "due_date": ""}