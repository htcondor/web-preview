{"id": 3677, "title": "Ticket #3677: StarterWaitForDebug / ShadowWaitForDebug easily abused", "description": "<blockquote>\nIf a job ad contains StarterWaitForDebug=1 or ShadowWaitForDebug=1, the respective daemon will enter an infinite loop until the parent daemon gives up and kills it.  The intent is to provide an opportunity to attach with a debugger, clear the value, and move on.  However, this is an easy way to, at least briefly, denial of service a slot and to chew up a lot of CPU on a submit machine.  The harm is relatively minor; a user can, naturally, just run jobs that are infinite loops, and eventually the parent daemon will deem the starter/shadow non-responsive and kill it.  But it seems like we could do better.  In particular, the daemon in question becomes unresponsive.  This means that policy for the slot may be ignored for a while as the starter is unwilling to help.  It's also possible to do this accidentally and end up tying up machines you can't fix yourself.\n\n<p>Possible improvements:\n\n</p><p></p><ul>\n<li>At least have the loops call sleep(0), so we don't chew up so much CPU.\n</li><li>A knob to turn off the functionality that defaults to off?\n</li><li>The ability to restrict which users can use the functionality?</li></ul>\n</blockquote>", "remarks": "<blockquote>\n</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "enhance", "last_change": "2013-Jun-04 17:02", "status": "new", "created": "2013-Jun-04 17:02", "fixed_version": "2013-Jun-04 17:02", "broken_version": "v080000", "priority": "4", "subsystem": "Security", "assigned_to": "", "derived_from": "", "creator": "adesmet", "rust": "", "customer_group": "other", "visibility": "public", "notify": "", "due_date": ""}