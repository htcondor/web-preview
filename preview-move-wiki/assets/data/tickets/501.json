{"id": 501, "title": "Ticket #501: Turn the Condor static libraries on Windows into DLLs", "description": "<blockquote>\nAfter the upgrade from VS6 to VS2K8 the Condor executables for Windows almost doubled in size and have increased their memory footprint.  It is likely that we can decrease both these sizes by converting all of the Condor static libraries into DLLs.\n\n<p><span class=\"subsection\"></span></p><h3>Milestones </h3>\n\n<p><span class=\"subsubsection\"></span></p><h4>1. Decorate library source code [For Z]</h4>\n\n<p></p><ul>\n<li>Create a new branch from the master;\n</li><li>For each library, identify each symbol it \"exports\" (i.e. other libraries, tools use) and decorate them accordingly;\n</li><li>For decoration styles, see the \"Decoration Samples\" subsection bellow.\n</li></ul>\n\n<p><span class=\"subsubsection\"></span></p><h4>2. Create new dynamic link library targets</h4>\n\n<p></p><ul>\n<li>Have the Visual Studio Project files create DLLs instead of static libraries from the current library code.\n</li></ul>\n\n<p><span class=\"subsubsection\"></span></p><h4>3. Refractor libraries</h4>\n\n<p></p><ul>\n<li>Not all library code is used in every tool, so there may be a way to save even more runtime space by making smaller cousins to the existing libraries that cater to very specialized needs, like, for example, security.\n</li></ul>\n\n<p><span class=\"subsection\"></span></p><h3>Decoration Samples</h3>\n\n<p><span class=\"subsubsection\"></span></p><h4>Linux Decoration Samples</h4>\n\n<p></p><ul>\n<li><a class=\"external\" href=\"http://people.redhat.com/drepper/dsohowto.pdf\">http://people.redhat.com/drepper/dsohowto.pdf</a>\n</li></ul>\n\n<p><span class=\"subsubsection\"></span></p><h4>Windows Decoration Samples</h4>\n\n<p></p><pre>\t/**\tDLL import/export definitions. */\n\t#ifdef CONDOR_DLL\n\t#define CONDOR_API\t\t__declspec(dllexport)\n\t#define CONDOR_INSTANTIATE\n\t#else\n\t#define CONDOR_API\t\t__declspec(dllimport)\n\t#define CONDOR_INSTANTIATE\texport\n\t#endif\n</pre>\n\n<p></p><pre>\t/**\tA sample class. */\n\tclass CONDOR_API Daemon {\n\tpublic:\n\t\tDaemon ();\n\t};\n</pre>\n\n<p></p><pre>\t/**\tA sample template. */\n\ttemplate&lt;class T&gt;\n\tclass CONDOR_API Vector {\n\tpublic:\n\t\tVector ();\n\t\tsize_t Length () const;\n\t\t/**\t... */\n\t};\n</pre>\n\n<p></p><pre>\t/**\tA sample template instance. This does not create an object.\n\t\tIt only forces the generation of all of the members of the\n\t\tclass. It exports them from the DLL and imports them into\n\t\tthe executable file. Ugly, I know. */\n\tCONDOR_INSTANTIATE template class CONDOR_API Vector&lt;int&gt;;\n</pre>\n\n<p></p><pre>\t/**\tA sample basic symbol (can be any type). */\n\textern CONDOR_API int n;\n</pre>\n\n<p></p><pre>\t/**\tA sample function. */\n\tCONDOR_API int f ( int x );\n</pre>\n\n<p>I though about adding <code>CONDOR_CLASS</code> but I thought that maybe that was too cute.  Linux and UNIX systems will need to define <code>CONDOR_API</code> and <code>CONDOR_INSTANTIATE</code> as nothing, to avoid any compiler errors.  The above defines are to be included in the Windows only Condor system header file.</p></blockquote>", "remarks": "<blockquote>\n<em>2009-May-25 09:05:34 by tannenba:</em> <br/>\n\nThe conversion of static libs into dynamic libraries would be useful on more than just Win32 imho.  All the benefits you talk about would be welcome on Linux etc as well.\n\n<p>Also, imho I am not certain there is much benefit to having a while pile of shared libs.  What benefit is there to having a util lib, c++ util lib, cedar lib, dc lib, qmgmt lib, etc, etc?  Since practically all Condor binaries want to link w/ all libs anyhow, and since <span class=\"quote\">ClassAds</span> is really the only library of interest outside of Condor, perhaps we should just have libclassads and one big libcondor.[so|dll] and be done with it.\n\n</p><p></p><hr/>\n<em>2009-Jul-10 21:09:19 by burnett:</em> <br/>\n\nI'd like to see a few separate ones to begin with.  Not all the tools depend on all the libraries, so it would be a pity to strap on that extra baggage.  Second, once they are converted, I'd like to look at how they should be combined or further separated (if necessary). It seems reasonable right now to combine condor_util and cpp_util, but most tool/daemons use very little of each library all at once (well, the cpp library anyway).  Maybe it makes sense to divvy up the cpp library in to meaningful modules... unless we cannot justify the time... which I think we can, if we can slim down the starters, shadows and make sure that a Windows CM can actually scale to some respectable size (even if it still does not compete with the Linux one).\n\n<p></p><hr/>\n<em>2009-Jul-17 14:00:16 by burnett:</em> <br/>\n\nBellow is response from a newsgroup.  Most of the information we already know, but I'm just posting it so that we have an explicit record, in case someone who does not know all the details is reading this.\n\n<p>\"Ben Burnett\" wrote:\n\n</p><p>&gt; Has anyone converted a large number of static libraries to DLLs using an automated method (or semi-automated)?\n\n</p><p>I'm not sure it is possible to do it automatically unless you have\nhighly sofisticated parser tool which can patch the files\naccording to predefined rules. In order to make a DLL from LIB you\nneed to do the following steps:\n\n</p><p>1. Go through all headers and add calling convention and\n__declspec(dllimport/dllexport) modifiers for each function\ndeclaration. You can spare __declspec(dllimport/dllexport) if you\nstrive for cross platform code, however you will need to add .DEF\nfile to the project with all exported names. Alternatively, you\ncan define a macro that will expand to __declspec(dllimport) for\nclient builds, to __declspec(dllexport) for the DLL build and to\nnothing for Unix builds.\n\n</p><p>2. Change the project type to DLL instead of LIB. I think the\neasiest way is to create new DLL project with VC++ and add to it\nexisting source files.\n\n</p><p>This was the easy part. Then you will need to think out the types\ntransferred between DLL and its callers. If these types require\nallocation/freeing memory, then both DLL and its client must use\nDLL version of CRT in order to preserve memory heap integrity. The\nother way is to export additional functions that will within DLL\nfree whatever was allocated there. Or you can fall back to\nfundamental C types in the same way as Win32 API does, for\nexample.\n\n</p><p></p><hr/>\n<em>2009-Jul-17 14:07:21 by burnett:</em> <br/>\n\nPotential Pitfall\n\n<p>Microsoft Visual C++ compilers do not allow the linking controll that the GNU linker \"ld\" allows (i.e. --whole-archive, -no-whole-archive). All symbols need to be resolved by the VC++ compiler for both the loadable library and the application executable individually and thus it can cause duplication of libraries when the library is loaded. This is especially bad when using static variables (i.e. used in singleton patterns) as you will get two memory locations for the static variable, one used by the loadable library and the other used by the program executable. This breaks the whole static variable concept and the singleton pattern. Thus you can not use a static variable which is referenced by by both the loadable library and the application executable as they will be unique and different. To use a unique static variable, you must pass a pointer to that static variable to the other module so that each module (main executable and DLL library) can use the same instatiation. On MS/Windows you can use shared memory or a memory mapped file so that the main executable and DLL library can share a pointer to an address they both will use.\n\n</p><p>From: <a class=\"external\" href=\"http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html\">http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html</a>\n\n</p><p></p><hr/>\n<em>2009-Oct-21 15:36:33 by psilord:</em> <br/>\n\nBen Burnett has left the Condor Project. This ticket is being unassigned.\n<hr/>\n<em>2010-Oct-20 15:59:08 by jfrey:</em> <br/>\n\nBulk change of target version from v070504 to v070505 using ./ticket-target-mover.\n<hr/>\n<em>2011-Jan-27 14:21:33 by danb:</em> <br/>\n\nBulk change of target version from v070505 to v070506 using ./ticket-target-mover.\n<hr/>\n<em>2011-Feb-01 14:49:30 by tannenba:</em> <br/>\n\nBulk change of target version from v070506 to NULL using ./ticket-target-mover.</blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "enhance", "last_change": "2011-May-27 13:44", "status": "new", "created": "2009-May-21 10:31", "fixed_version": "2009-May-21 10:31", "broken_version": "v070300", "priority": "3", "subsystem": "Libs", "assigned_to": "", "derived_from": "#1135", "creator": "tannenba", "rust": "", "customer_group": "other", "visibility": "public", "notify": "willb@redhat.com, pmackinn@redhat.com, tannenba@cs.wisc.edu, ziliang@cs.wisc.edu", "due_date": ""}