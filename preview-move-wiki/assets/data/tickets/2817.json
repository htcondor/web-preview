{"id": 2817, "title": "Ticket #2817: deadlock between the schedd and collector", "description": "<blockquote>\nWe have observed several incidents in which the glideinWMS factory collector becomes unresponsive.  It is invariably stuck waiting for a client to respond during authentication.  This operation times out after 20s, but it often repeats soon after.\n\n<p>In one incident, we managed to find the culprit client: a schedd.  The schedd was stuck in a blocking query to the collector.  It was trying to look up the address of the negotiator.  It had previously initiated an asynchronous attempt to send an update to the collector.  This update was via UDP, but the security session must have expired, because the schedd had then initiated an asynchronous attempt to establish a new security session via TCP.\n\n</p><p>The underlying problem is that we have a mixture of blocking and non-blocking protocols in a single-threaded system.  It is possible for the schedd to initiate a non-blocking request that causes the collector to block (on the authentication phase), and the schedd does not respond to the collector, because it has gone ahead and started a new blocking query to the collector.  Even before the introduction of partially non-blocking protocols (i.e. when most protocols were fully blocking), this problem existed in cases where two daemons could initiate blocking requests to each other at the same time (schedd/shadow, schedd/negotiator, schedd/startd).\n\n</p><p>The decision, after getting part of the way down the path of converting protocols to non-blocking, was to address the remaining blocking parts of the protocol by using threads.  This work was mostly completed.  The work remaining to make it useable in the collector is very likely less than the work required to convert the authentication protocol to be non-blocking in the single-threaded implementation.  I am less sure about a more complicated daemon such as the schedd.\n\n</p><p>The specific deadlock that was observed has a workaround: set the address of the negotiator with NEGOTIATOR_HOST.  This allows the schedd to skip the query to the collector.\n\n</p><p>I don't yet understand why we are observing this problem now and did not notice it before.  Perhaps NEGOTIATOR_HOST was set in the configuration previously?\n\n</p><p>Igor says a negotiator isn't even needed in the glidein factory.  I don't think turning off the negotiator would make the problem go away, but I'm not 100% sure.</p></blockquote>", "remarks": "<blockquote>\n<em>2012-Feb-09 13:52:41 by bbockelm:</em> <br/>\n\nHi,\n\n<p>To some extent, this is a security issue.  If a collector can be contacted via the WAN, any client can do a very efficient DoS, as it can block the collector for up to 5s at a time by initiating an authentication and simply stop responding.  In fact, this can be done with any <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCore\" title=\"Daemon Core\">DaemonCore</a></span> daemon that you can talk to.\n\n</p><p>(We accidentally did DoS our condor infrastructure last week; a client-side DNS outage caused all GSI connections to timeout, taking down the entire cluster.  Still a sore point with the sysadmins)\n\n</p><p>The question is how many resources are you willing to give to an unauthenticated client?  An unauthenticated client must not be able to block a daemon.  Do you dedicate a thread?  An entry in a hash map?\n\n</p><p>Once things are authenticated, blocking is still not desired, but at least more acceptable.\n\n</p><p>From what I've seen in the Condor code base, going the threaded route may be the simpler to implement (finish, really), but will be far less maintainable.  Last year, I did a huge amount of debugging with globus in both threaded and non-threaded modes (with the caveat that Globus had a much more liberal threading policy).  Debugging a single-threaded, asynchronous program is at least an order magnitude easier than a threaded program, even in the more limited model Condor has.\n\n</p><p>Sorry to hijack the ticket a bit, but I think this is the underlying cause - this particular deadlock is the symptom.\n\n</p><p>Brian\n\n</p><p></p><hr/>\n<em>2012-Feb-09 14:50:25 by danb:</em> <br/>\n\nAgreed, Brian.  Also, Condor does not do host-based authorization before authentication.  Therefore, Condor configuration cannot be used to block authentication attempts by IP.\n\n<p></p><hr/>\n<em>2012-Feb-10 09:02:29 by tstclair:</em> <br/>\n\nAre there any performance stat's that help to diagnose this issue a little easier?  I think I've fallen into a similar situation in <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=2974\" onclick=\"get_ticket_and_populate_wrapper('2974'); return false;\" title=\"Support Eucalyptus 3.x in EC2 GAHP\">#2974</a></span>.\n\n<p></p><hr/>\n<em>2012-Mar-01 17:21:27 by danb:</em> <br/>\n\nI have made a patch to <code>DaemonCore</code> that makes the server do an asynchronous read before beginning the authentication protocol.  We are therefore assured that the server has the full attention of the client once the server enters authenticate(), because the arrival of data indicates that the client has also entered authenticate().\n\n<p>This solves the type of deadlock encountered in this ticket.  It should also make condor daemons slightly less vulnerable to latency in response time.  This patch does <em>not</em> make the rest of the authentication protocol non-blocking, so it is not a complete solution to network latency issues.\n\n</p><p>Question for Todd: will you accept this patch?  I had to refactor <code>HandleReq()</code> similarly to how I previously unwound <code>StartCommand()</code>.  In my opinion, breaking the monstrously huge <code>HandleReq()</code> function into several pieces is not a bad thing, but I know you are hoping to avoid unnecessary unwinding in general.\n\n</p><p></p><hr/>\n<em>2012-Mar-03 17:27:01 by bbockelm:</em> <br/>\n\nHi Dan,\n\n<p>I'm sitting down to poke at the patch.  A few comments (orthogonal to whether Todd will take it):\n</p><ul>\n<li>Please split <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCommandProtocol\" title=\"Daemon Command Protocol\">DaemonCommandProtocol</a></span> into a separate file.  daemon_core.cpp is already 12k lines.\n</li><li>It would be nice to have a state diagram of some sort; at least, in the comments for each function, we should probably label the expected incoming state and the possible outgoing states for success/failure.\n</li><li>In <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ReadCommand\" title=\"Read Command\">ReadCommand</a></span>, please break the \"if (m_req == DC_AUTHENTICATE) {\" block up a bit.  I think I counted a maximum of 8 nested code blocks - extremely hard to follow.  It would be nice to also explain the \"big picture\" a bit.  At least, for \"if\" statements that span more than 50 lines, denote what conditional is closed at the end.\n<ul>\n<li>Would also be nice to break up \"if (!using_cookie) {\" a bit too.\n</li></ul>\n</li><li>Some of the indentation is wrong, or uses a mixture of hard tabs and spaces.  Please fix.\n</li><li>The \"<span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=KeyCacheEntry\" title=\"Key Cache Entry\">KeyCacheEntry</a></span> tmp_key\" causes quite a bit of memory churn in the profiler; can we implement a \"swap\" command when it is inserted into the session cache?  Or, you could switch Condor to C++11 and implement move semantics :)\n</li></ul>\n\n<p>In the end, it appears unauthenticated users can now block <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCore\" title=\"Daemon Core\">DaemonCore</a></span> two places:\n</p><ul>\n<li>In reading of the initial <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span>.\n</li><li>In m_sock-&gt;authenticate.\n</li></ul>\n\n<p>I don't see any easy fix for either.  The <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAd\" title=\"Class Ad\">ClassAd</a></span> parsing code appears especially fun; looks like it can use an arbitrary amount of memory.  m_sock-&gt;authenticate appears to be more tractable.  Still, this is re-org is definitely a pre-req for finishing off these further tasks.\n\n</p><p>Brian\n\n</p><p></p><hr/>\n<em>2012-Mar-05 18:01:07 by danb:</em> <br/>\n\nThanks for the feedback, Brian.  I made the changes you suggested.\n\n<p>Todd gave his blessing, so I have pushed the code to the master branch.</p></blockquote>", "derived_tickets": "", "attachments": "<html><head></head><body><blockquote>\n<ul>\n<li><a href=\"../files/537/async_handle_req.patch\">async_handle_req.patch</a>\n79059 bytes added by danb on 2012-Mar-01 23:21:46 UTC.\n</li></ul>\n</blockquote></body></html>", "check_ins": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">2012-Mar-15 22:41</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=30934\">[30934]</a></span>: Fix for leaking sockets. <span class=\"ticket\"><a class=\"review\" href=\"/tickets?ticket=2887\" onclick=\"get_ticket_and_populate_wrapper('2887'); return false;\" title=\"Collector leaks sockets, leaves them in CLOSE_WAIT state\">#2887</a></span> The problem was introduced in <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=2817\" onclick=\"get_ticket_and_populate_wrapper('2817'); return false;\" title=\"deadlock between the schedd and collector\">#2817</a></span>.  (By Dan Bradley )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2012-Mar-06 18:34</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=30842\">[30842]</a></span>: Documented reduction of blocking i/o in the daemon command protocol. ===GT=== <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=2817\" onclick=\"get_ticket_and_populate_wrapper('2817'); return false;\" title=\"deadlock between the schedd and collector\">#2817</a></span> ===VersionHistory:Complete===  (By Dan Bradley )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2012-Mar-06 18:30</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=30841\">[30841]</a></span>: Fixed a bug in <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCommand\" title=\"Daemon Command\">DaemonCommand</a></span>. <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=2817\" onclick=\"get_ticket_and_populate_wrapper('2817'); return false;\" title=\"deadlock between the schedd and collector\">#2817</a></span> In some cases, the accepted socket was being deleted twice.  (By Dan Bradley )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2012-Mar-05 17:57</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=30813\">[30813]</a></span>: Refactored DaemonCore's <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=HandleReq\" title=\"Handle Req\">HandleReq</a></span> into an asynchronous protocol object. <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=2817\" onclick=\"get_ticket_and_populate_wrapper('2817'); return false;\" title=\"deadlock between the schedd and collector\">#2817</a></span> The first read by the server during authentication is now done asynchronously: the server selects for read before calling authenticate().  (By Dan Bradley )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2012-Mar-05 17:57</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=30814\">[30814]</a></span>: Cleaned up <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCommand\" title=\"Daemon Command\">DaemonCommand</a></span> code and prepared to move to daemon_command.cpp. <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=2817\" onclick=\"get_ticket_and_populate_wrapper('2817'); return false;\" title=\"deadlock between the schedd and collector\">#2817</a></span>  (By Dan Bradley )</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">2012-Mar-05 17:57</td>\n<td align=\"center\" valign=\"top\" width=\"30\">\n<span class=\"icon dot\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\"> \nCheck-in <span class=\"chng\"><a href=\"chngview?cn=30815\">[30815]</a></span>: Moved <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=DaemonCommand\" title=\"Daemon Command\">DaemonCommand</a></span> into daemon_command.cpp. <span class=\"ticket\"><a class=\"resolved\" href=\"/tickets?ticket=2817\" onclick=\"get_ticket_and_populate_wrapper('2817'); return false;\" title=\"deadlock between the schedd and collector\">#2817</a></span>  (By Dan Bradley )</td></tr>\n</tbody></table>", "type": "defect", "last_change": "2012-May-07 15:28", "status": "resolved", "created": "2012-Feb-09 12:30", "fixed_version": "2012-Feb-09 12:30", "broken_version": "v070600", "priority": "2", "subsystem": "", "assigned_to": "danb", "derived_from": "", "creator": "danb", "rust": "", "customer_group": "osg", "visibility": "public", "notify": "isfiligoi@ucsd.edu dan@hep.wisc.edu burt@fnal.gov bbockelm@cse.unl.edu tannenba@cs.wisc.edu tstclair@redhat.com matt@cs.wisc.edu", "due_date": ""}