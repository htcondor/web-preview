{"id": 988, "title": "Ticket #988: Grand unified param() system: Phase 2", "description": "<blockquote>\n<span class=\"section\"><h2>What is phase 2? </h2></span>\n\n<p>This ticket describes the second phase of the new param() system. We have learned <strong>much</strong> since checking in phase 1 as described in <span class=\"ticket\"><a class=\"new\" href=\"/tickets?ticket=123\" onclick=\"get_ticket_and_populate_wrapper('123'); return false;\" title=\"Grand unified param() system: Phase 1\">#123</a></span> and <span class=\"ticket\"><a class=\"stalled\" href=\"/tickets?ticket=767\" onclick=\"get_ticket_and_populate_wrapper('767'); return false;\" title=\"Updating some of 7.4 parameter defaults to modern machines\">#767</a></span>. Phase 2 builds upon that knowledge and will possibly provide a different underlying implementation than the previous, but one that models our needs more precisely.\n\n</p><p><strong>The specification in the ticket is a work in progress, but it is 99% solidified.</strong>\n\n</p><p><span class=\"section\"></span></p><h2>Milestones </h2>\nWork order is bottom to top.\n\n<p></p><ul>\n<li>1 Week\n<ul>\n<li>Change each difficult param invocation to use the new/fixed API.\n</li></ul>\n\n<p></p></li><li>1-2 Weeks\n<ul>\n<li>Fill in the holes in the API our param conversion to the table discovered.\n</li><li>Write generator code to convert default table into non-naive memory optimized C++ API code.\n</li></ul>\n\n<p></p></li><li>2 Weeks\n<ul>\n<li>Tag the master for reference purposes when inspecting code.\n</li><li>Create default table representation for all known parameters.\n<ul>\n<li>Change each easy param invocation to use the new API.\n<ul>\n<li>This involes manually inspecting each invocation.\n</li></ul>\n</li><li>Note any params which can't be modeled by our API and why.\n</li></ul>\n</li></ul>\n\n<p></p></li><li>1 Week\n<ul>\n<li>Get familiar with the New Classad C++ API.\n</li><li>Write generator codes to check/convert default table into naive C++ API code.\n</li></ul>\n\n<p></p></li><li>04/06/2010 [DONE]\n<ul>\n<li>Figure out what default table actually looks like, add in real examples.\n</li></ul>\n\n<p></p></li><li>03/05/2010 [DONE]\n<ul>\n<li>Present current ideas to FW, get feedback [DONE]\n</li></ul>\n\n<p></p></li><li>1/21/2010 [DONE]\n<ul>\n<li>Meet with willb to remember what we have to do with this task. [DONE]\n</li><li>Write up what we remembered from the previous meetings we've had. [DONE]\n</li></ul>\n</li></ul>\n\n<p><span class=\"section\"></span></p><h2>What is the theory of operation?</h2>\n\n<p></p><ul>\n<li>All parameter values are evaluable expressions which must result in a\nknown and expected type.\n</li><li>All option names which are known a priori will have a compile time interface.\n</li><li>All options are built up, following a well-known order of definitions where\nlater definitions overwrite previous ones, into a canonical evaluation\nexpression.\n</li><li>We shall strive to minimize the heap usage of the param system within\nreasonable cost bounds.\n</li><li>Evaluation of a parameter's expression will occur with respect to\nan \"environment\" classad which fills in details like subsystem, full\nhostname--or any \"instant value\" needed directly at evaluation time.\nThese \"instant values\" are to be documented as in the namespace of the\nparam language. Such examples are <strong>Opsys</strong>, <strong>Arch</strong>, <strong>Subsys</strong>, <strong>Local</strong>, <strong>Now</strong>.\n</li><li>There is an <strong>options</strong> object which contains everything about the association of names and values. C and C++ interfaces will be provided or C code will be converted to compile with C++ in cases where providing an interface is too difficult.\n</li></ul>\n\n<p><span class=\"section\"></span></p><h2>What is the API?</h2>\n\n<p><span class=\"subsection\"></span></p><h3>Options which have an a priori name at compile time</h3>\n\n<p>Each of these parameters uses a default classad environment to evaluate\nthe expression. This interface is algorithmically generated and will\nreturn the correct type of the parameter in question. Possibilities\ninclude returning STL Lists for collections of values, like <strong>FOO = A,\nB, C, D</strong> would result in an STL List containing the right types for A,\nB, C, D in lexical analysis order.\n\n</p><p></p><ul>\n<li>Getting an option Value\n<ul>\n<li>options.X.value()\n</li><li>options.X.value(env)\n</li></ul>\n\n<p></p></li><li>Setting an option Value\n<ul>\n<li>options.X.set_value()\n</li><li>options.X.set_value(env)\n</li></ul>\n\n<p></p></li><li>Checking to see of an option has a defined value\n<ul>\n<li>options.X.is_defined()\n</li><li>options.X.is_defined(env)\n</li></ul>\n</li></ul>\n\n<p>Existence checking is performed by the compiler at compile time for these\na priori options.\n\n</p><p><span class=\"subsection\"></span></p><h3>Options which have a name known only at runtime.</h3>\n\n<p></p><ul>\n<li>Getting an option Value\n<ul>\n<li>options.param_value(name)\n</li><li>options.param_value(name,env)\n</li></ul>\n\n<p></p></li><li>Setting an option Value\n<ul>\n<li>options.param_set_value(name)\n</li><li>options.param_set_value(name,env)\n</li></ul>\n\n<p></p></li><li>Checking to see of an option has a defined value\n<ul>\n<li>options.param_is_defined(name)\n</li><li>options.param_is_defined(name,env)\n</li></ul>\n\n<p></p></li><li>Checking to see of an option exists in the options table.\n<ul>\n<li>options.param_exists(name)\n</li></ul>\n</li></ul>\n\n<p><span class=\"subsection\"></span></p><h3>Consistency checks in the API</h3>\n\n<p>TODO\n\n</p><p><span class=\"section\"></span></p><h2>What is the well-known order of definition?</h2>\n\n<p>Starting from lowest, going to highest definitional layer:\n\n</p><p>unknown -&gt; static default table -&gt; simple runtime default table -&gt; config files -&gt; administrator settings with -rset -&gt; environment variable -&gt; complex runtime defaults\n\n</p><p>Following the well-known order of definition, each scoping tree name\n(something like <code>schedd.X</code> or <code>schedd.hawkeye.X</code>) that directly matches\na previous scoping tree name overwrites it until no more overwrites\noccur.\n\n</p><p>At this point the finalized forest of scoping trees associated with an\noption are converted into the canonical expression and assigned to the\noption name for evaluation against the environmental classad. The scoping names\nused in the scope portion of the name become environmental attributes\nin the environment classad against which the expression is evaluated.\nThe scoping names are somewhat hard coded to be classified under the correct\nattribute in the environmental classad. For example, <code>schedd.haykeye</code> in the above examples means that in\nthe canonical form, <code>(Subsys <span class=\"quote\">==</span> \"schedd\" <span class=\"quote\">&amp;&amp;</span> Local <span class=\"quote\">==</span> \"hawkeye\")</code> will appear as a conditional selector for that value, and so on.\n\n</p><p><span class=\"section\"></span></p><h2>How do we write down entries into the default table?</h2>\n\n<p>XXX This code needs markup.\n\n</p><p></p><div class=\"verbatim\">\n<pre>Strawman default table layout.\n\nA main problem one must consider is that the elements and types of the\nconfig file language are not necessarily the same elements and types of the\nrepresentation language, in this case new classads. This means that config\nfile elements must be explicitly represented as values in new classads. Of\nparticular note, and one that isn't fully solved, is the use of is* functions\nin the type domain equations.\n\nThe full specification of a trivial config parameter:\n\n[\n    // The name of the attribute\n    Name = \"USE_VISIBLE_DESKTOP\";\n\n    // What is the current viewpoint of this param in accordance to being\n    // supported by the current revision of Condor?\n    // Can be \"supported\", \"deprecated\", \"obselete\", \"abort\".\n    // Defaults to \"supported\";\n    Status = \"supported\";\n\n    // what type the evaluator should expect the definition to be\n    Type = \"bool\";\n\n    // Once we've computed the value, does it fall into the domain we are\n    // expecting? Evaled in context of ENV ad.\n    // If specified, the expression denoted is the one actually used.\n    // If not specified, then it'll be something like below, derived from the\n    // Type attribute.\n    Domain = IsBool(val)\n\n    // After I evaluate the parameter in whatever definitional layer that ended\n    // up being the final version, this expression converts it into some\n    // transform of itself. In this example, it is identity. We would use it to\n    // implement clamping of a value or other transforms.\n    // Evaled in context of ENV ad.\n    // If specified, the expression denoted is the one actually used.\n    // If not specified, it'll be what is below.\n    Transform = val;\n\n    // Once we finish the transform, we validate the operation to ensure it is\n    // what we expect it to be:\n    // If not specified it'll be what is below, derived from Type.\n    Validate = isBool(val);\n\n    // There are two concerns with the evaluation of a variable:\n    // 1. When is the definition updated: RedefineWhen\n    // 2. How often is it evaluated (per definition change): EvalWhen\n\n    // Valid values are: \"never\", \"startup\", \"reconfig\", \"full-reconfig\"\n    // defaults to reconfig if not specified\n    RedefineWhen = \"reconfig\";\n\n    // Valid values are:\n    // \"once\" -&gt; memoize the value\n    // \"always\" -&gt; re-eval expression each time\n    // defaults to once if not specified.\n    EvalWhen = \"once\";\n\n    // There is always a default role, others can be specified.\n    // This is the *full* specification.\n    // There is a shortcut described later...\n    Role = [\n        Default = [\n            // If we were to restrict (via conjuction with the master domain\n            // function) the general domain to only be false, I can do this. A\n            // failure of the domain expression reuslts in an EXCEPT.\n            RestrictDomainBy = { val == false };\n\n            // The right hand side must be either a string, or a classad.\n            // I'll show what happens if it is a clasad later.\n            Definition = \"FALSE\";\n        ];\n    ];\n\n    // The below are optional attributes to be added as desired...\n\n    // It is easy to associate whatever metadata we want with an attribute\n    // grouping of parameters into possibly intersecting sets\n    Tags = { \"windows\", \"admin\" };\n\n    // Interesting info about the param\n    Usage = \"If set to TRUE, then run the job on the visible desktop.\";\n];\n\nA trivial config parameter with defaults:\n\n[\n    Name = \"CREATE_CORE_FILES\";\n    Type = \"bool\";\n    Definition = \"TRUE\";\n]\n\nA trivial config parameter whose definition changes under different roles:\n\n[\n    Name = \"CCB_POLLING_INTERVAL\";\n    Type = \"integer\";\n\n    Role = [\n        Default = [\n            Definition = \"25\";\n        ];\n\n        VDT = [\n            Definition = \"30\";\n\n            // I can define a completely new range for this definition\n            // specific to a role. This implements a clamp function.\n            Transform =\n                val &lt; 20 ? 20 : (val &gt; 40 ? 40 : val)\n        ];\n\n        OSG = [\n            Definition = \"15\";\n\n            // if the user sets the variable to higher than 40, we EXCEPT\n            // with an error about it!\n            RestrictDomainBy = val &lt; 40;\n        ];\n    ];\n];\n\nA definition of something that uses another config file definition:\n\n[\n    Name = \"SCHEDD\";\n    Type = \"string\"\n\n    // Do an interesting thing with the validator.\n    Validator = isString(val) &amp;&amp; FileExists(val);\n\n    // If the attribute 'Role' is not defined, then this is the shortcut\n    // for the default domain and definition specification.\n    Definition = \"$(SBIN)/condor_schedd\";\n]\n\nA non-trivial example. On unix, this is false, on windows, true.\n\n[\n    Name = \"FAKE_CREATE_THREAD\";\n    Type = \"bool\";\n\n    Definition = \"IfThenElse(\\\"OPSYS == WINDOWS\\\", \\\"TRUE\\\", \\\"FALSE\\\")\";\n];\n\nA non-trivial example. Insert PID into the config table.\nCheck out condor_config.cpp, reinsert_specials().\nThis may be a candidate to go into the Environmental Classad....\n\n[\n    Name = \"PID\";\n    Type = \"integer\";\n\n    // Since the domain expression is evaluated in the env ad, then I\n    // can do this, which solves very interesting problems....\n    Domain = IsInteger(val) &amp;&amp;\n                (SUBSYS==\"HPUX\" ?\n                    (val &gt; -32768 &amp;&amp; val &lt; 32768) :\n                    val &gt; 0);\n\n    RedefineWhen = \"Never\";\n\n    // If the RHS is a classad, then it means we're describing a function that\n    // has to be called in order to compute the string return value.  If the\n    // attr in the classad is \"call\" it means call a 'char (*)(void)' function\n    // to get the value. If the attr is \"call_in_context\" it means call a 'char\n    // (*)(ClassAd *Definition, ClassAd *Env)' function to figure out\n    // what the value should be.\n\n    // The memory returned by this pointer should be a char * allocated with\n    // strdup. The memory becomes owned by the config layer.\n\n    Definition = [ call = \"get_my_pid\" ];\n];\n</pre></div>\n\n\n<p><span class=\"section\"></span></p><h2>What does the canonical form of a param value expression look like?</h2>\n\n<p>Expressions are built up from \"scoping trees\" into a final form. A\nscoping tree is written like this for an option called OPTION, and is\nconsidered in order from specific to general:\n\n</p><p><strong>SUBSYS.LOCAL.OPTION</strong>, <strong>LOCAL.OPTION</strong>, <strong>SUBSYS.OPTION</strong>, <strong>OPTION</strong>.\n\n</p><p>A default for an option named FOO might be:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">STARTD.HAWKEYE.FOO = 40\nHAWKEYE.FOO = 41\nCRONDOR.FOO = 42\nSTARTD.FOO = 43\nSHADOW.FOO = 44\nSCHEDD.FOO = 45\nSTARTER.HAWKEYE.FOO = 46\nFOO = 10\n</pre></div>\n\n\n<p>This is converted into a canonical form like this:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">FOO =\n/* these are really specific, they come first */\nIfThenElse(SUBSYS == \"STARTD\" &amp;&amp; LOCAL == \"HAWKEYE\", 40\n IfThenElse(SUBSYS == \"STARTER\" &amp;&amp; LOCAL == \"HAWKEYE\", 46\n /* local is more specific than subsys */\n  IfThenElse(LOCAL == \"HAWKEYE\", 41,\n   IfThenElse(LOCAL == \"CRONDOR\", 42,\n    /* next comes subsys stuff */\n    IfThenElse(SUBSYS == \"STARTD\", 43,\n     IfThenElse(SUBSYS == \"SHADOW\", 44,\n      IfThenElse(SUBSYS == \"SCHEDD\", 45,\n       /* and the default */\n       10)))))))\n</pre></div>\n\n\n<p>We use the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=IfThenElse\" title=\"If Then Else\">IfThenElse</a></span> to make it <strong>much</strong> easier to have the result of its\nevaluation be an object of the correct value and type. Doing the above in\nboolean logic is very painful.\n\n</p><p>We specifically mean, by \"considered in order from specific to general\"\nthat we specify the most specific scoping tree first in the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=IfThenElse\" title=\"If Then Else\">IfThenElse</a></span>\nconstruct moving towards the least specific one.\n\n</p><p>Then <strong>FOO</strong> is evaluated in the context of this classad (suppose in a regular\nschedd):\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">ENV = [SUBSYS = \"SCHEDD\", OPSYS = \"LINUX\", ARCH = \"INTEL\", LOCAL = \"\", NOW = 12345678]\n</pre></div>\n\n\n<p>To produce the answer.\n\n</p><p><span class=\"section\"></span></p><h2>How do we handle param expansion in definitions?</h2>\n\n<p>Consider the following example definitions:\n\n</p><p></p><div class=\"code\">\n<pre class=\"code\">SBIN = /path/to/somewhere\nSCHEDD = $(SBIN)/condor_schedd\n</pre></div>\n\n\n<p>Here <code>SCHEDD</code> depends on the value of <code>SBIN</code>.  We can encode this dependence in several different ways, all of which are conceptually straightforward since we disallow circular definitions.  Here are sketches of two possibilities:\n\n</p><p></p><ul>\n<li><em>Dependence lifting</em>.  We can determine a priori what params some param <code>P</code> depends on by examining all of the clauses in which <code>P</code> is defined.  We could then lift these params to the environment in which the definition of <code>P</code> is evaluated.\n</li><li><em>Macro expansion</em>.  We could simply replace a reference to <code>P1</code> on the right-hand side of the definition of <code>P</code> with the definition of <code>P1</code>.  In simple cases, such as the one above, this would be a literal value.  In more complex cases, it would be an expression.  This approach would increase the size of definitions, although it would be straightforward to distribute the clauses of <code>P1</code> over the clauses of <code>P</code> in order to prune contradictory or redundant clauses.\n</li></ul>\n\n<p><span class=\"subsection\"></span></p><h3>Eager Evaluation</h3>\nParam expansion in definitions introduces a potential backdoor around\nthe type constraint system. This happens because the actual value of\nthe param is a string and may be expanded into other expressions before\nhaving its constraint system invoked upon it.\n\n<p>We try to catch these violations before any Condor code uses the <code>options</code>\nobject by eagerly evaluating the params after the final definition is\ncalculated. If we lazily evaluated, say at runtime, then there would be\nmeans by which a constraint violation could happen and noone could know.\n\n</p><p>Due to the practice of eager evaluation, a larger set than necessary\nmight be flagged as an error due to cascading errors.\n\n</p><p>An example is this:\n\n</p><p>Suppose we have this in the default table:\n\n</p><p></p><div class=\"verbatim\">\n<pre>[\n    Name = \"FOO\";\n    Type = \"integer\";\n    Validator = val != 140;\n\n    Definition = \"100\";\n]\n\n[\n    Name = \"BAR\";\n    Type = \"integer\";\n    Validator = val != 1400\n    Definition = \"10 * $(FOO)\";\n]\n</pre></div>\n\n\n<p>And the user puts this into their config file:\n\n</p><p></p><div class=\"verbatim\">\n<pre>FOO = 140\n</pre></div>\n\n\n<p>or, more pathologically,\n\n</p><p></p><div class=\"verbatim\">\n<pre>FOO = 4\nFOO = $(FOO)0\nFOO = 1$(FOO)\n</pre></div>\n\n\n<p>What happens? What are the values of FOO and BAR?\n\n</p><p></p><ol>\n<li>All definitional layers are resolved first using the present macro\nexpansion codes to produce the final definitions for FOO and BAR. This\nwould make FOO = \"140\" and BAR = \"10 * 140\".\n\n<p></p></li><li>All attributes are now eagerly evaluated and their results stored in the\n<code>options</code> object.\n\n<p></p></li><li>This will eventually cause FOO and BAR to <strong>both</strong> be flagged as having\nfailed their Validator functions.\n\n<p></p></li><li>Unless we keep track of the expansion history of a parameter, there is no\nway to know that BAR was only made illegal because FOO was illegal. We can't\nnarrow down the true source of the error precisely.\n</li></ol>\n\n<p>The problem with lazy evaluation shows up in this example:\n\n</p><p></p><div class=\"verbatim\">\n<pre>[\n    Name = \"FOO\";\n    Type = \"integer\";\n    Validator = val != 140;\n\n    Definition = \"100\";\n]\n\n[\n    Name = \"BAR\";\n    Type = \"integer\";\n    // notice no validator\n    Definition = \"10 * $(FOO)\";\n]\n</pre></div>\n\n\n<p>And the user puts this into their config file:\n\n</p><p></p><div class=\"verbatim\">\n<pre>FOO = 140\n</pre></div>\n\n\n<p>At this point, if the Condor code happens not to ask for <code>options.FOO()</code>\nfor a very long time, but quickly asks for <code>options.BAR()</code>,\n<code>options.BAR()</code> will return 1400 as a value, even though it had been\nincorrect to do so since the dataflow had gone through an invalid parameter!\n\n</p><p>We <strong>missed</strong> an error we should have caught!\n\n</p><p>The other problem with lazy evaluation is that we'd likely need to keep\ntrack of the <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ExprTree\" title=\"Expr Tree\">ExprTree</a></span> of the parsed expression in order to evaluate\nit later, which means much more heap utilization--a thing we're trying\nto minimize.</p></blockquote>", "remarks": "<blockquote>\n<em>2010-Mar-03 11:44:26 by adesmet:</em> <br/>\n\n<ul>\n<li>Regarding param expansion, remember that the following is valid, useful, and should probably continue working.  We call them macros because they function as macros.  Weird macros, mind you...\n<div class=\"code\">\n<pre class=\"code\">DAEMON_LIST=MASTER\nDAEMON_LIST=$(DAEMON_LIST),SCHEDD\nDAEMON_LIST=$(DAEMON_LIST),STARTD\nDAEMON_LIST=$(DAEMON_LIST),COLLECTOR,NEGOTIATOR\n</pre></div>\n\n\n<p></p></li><li>I'm also with willb, value() and is_defined() read better to me.\n\n<p></p></li><li>I'm assuming that the defaults will be stored inside the binaries, not just the canonical forms.  Specifically, if I ask \"condor_config_val -dump\" I'm hoping to get\n<div class=\"code\">\n<pre class=\"code\">SCHEDD.FOO = 45\nFOO = 10\n</pre></div>\n\nnot\n<div class=\"code\">\n<pre class=\"code\">IfThenElse(SUBSYS == \"STARTD\", 45, 10)\n</pre></div>\n\nMore generally, I don't think users should ever see the canonical form unless they're digging into the darker places of Condor, say D_FULLDEBUG.  The canonical form creates a disconnect between configuration as it appears in the configuration file and how Condor thinks about it.  That's fine for implementation, but bad for user understanding.\n\n<p></p></li><li>Will things set in the configuration file, environment, etc, be included in the canonical form, or is it a matter of \"Check the environment. Not there? Check the configuration. Not there? Check the canonical form.\"\n</li></ul>\n\n<p></p><hr/>\n<em>2010-Mar-05 17:07:41 by adesmet:</em> <br/>\n\nMore random thoughts, based on the meeting.\n\n<p></p><ul>\n<li>The file format for the param table should be extensible to include arbitrary blocks of text per param name for future use.  This might include documentation made available via condor_config_val --describe, we might use it to create comments in an automatically generated condor_config.generic, and perhaps in some sort of crazy world we might might generate the relevant manual sections from it.\n\n<p></p></li><li>Based on what has been described, the LOCAL and SUBSYS option sets may not overlap at all.  As such, it might be easier to toss those modifiers into a stringlist and use stringListMember to test for their presence.  This allows things like STARTD.HAWKEYE.INTEL.LINUX.TUESDAY without needing to identify the individual parts as SUBSYS, LOCAL, ARCH, or OPSYS.\n<div class=\"code\">\n<pre class=\"code\">FOO = IfThenElse(stringListMember(PARAM_MODIFIER_LIST, 'STARTD') &amp;&amp; \\\n stringListMember(PARAM_MODIFIER_LIST, 'HAWKEYE'), 40, 50)\n</pre></div>\n\n  Or not.\n\n<p></p></li><li>We discussed possibly allowing Arch and <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=OpSys\" title=\"Op Sys\">OpSys</a></span> to appear as modifiers similar to LOCAL and SUBSYS.  However, the increases the number of sets that don't overlap as well as the complexity.  Given the change, perhaps just encode them as the values?\n<div class=\"code\">\n<pre class=\"code\">COLLECTOR.USE_THREADS=IfThenElse(OpSys=='Win32',FALSE,TRUE)\nUSE_THREADS=FALSE\n</pre></div>\n\nWhile slightly noisier, it leverages existing knowledge of <span class=\"wiki\"><a class=\"missing\" href=\"wiki?p=ClassAds\" title=\"Class Ads\">ClassAds</a></span> and doesn't add yet another special case to params.\n\n<p></p></li><li>What is the return type for options.param_get_value()?  I am expecting to have options.param_value_int(), options.param_value_string(), options.param_value_float(), and so on.\n\n<p></p></li><li>Goals should include:\n<ul>\n<li>Then new system should not use significantly more heap and stack than the existing system.  Keep in mind that a user may have thousand of daemons running at once.\n</li><li>The new system should be so fast and convenient that other code might call into it repeatedly instead of calling it and keeping a local copy.\n</li></ul>\n\n<p></p></li><li>Probably longer term work than the immediate task, but once the new system in place: new code should strongly prefer to call into the param system every time it needs a value, even if it's repeatedly.  The new code should avoid caching the output.  Old code should be slowly transitioned to doing so.  This should reduce memory usage by a bit but more importantly it will reduce the cases where condor_reconfig doesn't work.\n\n<p></p></li><li>This is implied by the description but to be clear something like this would be nice: Given this input file\n<div class=\"code\">\n<pre class=\"code\">ENABLE_HISTORY_ROTATION, boolean, TRUE\nMAX_HISTORY_LOG, int, 20971520\n</pre></div>\n\nYou will end up with an interface like so:\n<div class=\"code\">\n<pre class=\"code\">bool options.enable_history_rotation.value();\nbool options.enable_history_rotation.value(const environment &amp; e);\nint options.max_history_log.value();\nint options.max_history_log.value(const environment &amp; e);\n</pre></div>\n\n</li></ul>\n\n<p></p><hr/>\n<em>2010-Mar-17 14:16:19 by psilord:</em> <br/>\n\nSome attributes in the current config system are treated very specially.\nThey are found in condor_config.cpp:reinsert_specials()\n\n<p>They are: TILDE HOSTNAME FULL_HOSTNAME SUBSYSTEM USERNAME REAL_UID REAL_GID PID PPID IP_ADDRESS\n\n</p><p>Some of these are actual config file parameters, and others should be in the\nenvironmental classad we evaluate against. How do we decide?\n\n</p><p></p><hr/>\n<em>2010-Mar-17 14:21:00 by psilord:</em> <br/>\n\nGiven my last remark, it turns out there are more that are\n<a class=\"external\" href=\"http://www.cs.wisc.edu/condor/manual/v7.5/3_3Configuration.html#SECTION00431500000000000000\">pre-defined</a>.\n\n<p>This is a super set of what reinsert_specials() performs.\n\n</p><p></p><hr/>\n<em>2010-May-06 16:40:11 by psilord:</em> <br/>\n\nPresented to Miron. It didn't go well.\n\n<p>The fundamental reason is that the proposed solution must evaluate, at runtime,\nthe default expression in order to determine the value of the option. Miron argues that if anything goes wrong with this evaluation, and is opinion is that in the field it will, it will generate a support nightmare.\n\n</p><p>He specifically desires a static (as best can be create) table of default values which are known a priori so there can be no circumstance under which the value of a default parameter is unevaluable.\n</p><hr/>\n<em>2010-Oct-20 16:03:30 by jfrey:</em> <br/>\n\nBulk change of target version from v070504 to v070505 using ./ticket-target-mover.\n<hr/>\n<em>2011-Jan-27 14:46:04 by danb:</em> <br/>\n\nBulk change of target version from v070505 to v070506 using ./ticket-target-mover.\n<hr/>\n<em>2011-Feb-01 14:49:30 by tannenba:</em> <br/>\n\nBulk change of target version from v070506 to NULL using ./ticket-target-mover.</blockquote>", "derived_tickets": "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n<tbody><tr><td align=\"right\" valign=\"top\" width=\"160\">\n<span class=\"ticket\"><a class=\"defer\" href=\"/tickets?ticket=1158\" onclick=\"get_ticket_and_populate_wrapper('1158'); return false;\" title=\"Condor Daemon Log can't grow beyond 2GB\">#1158</a></span></td>\n<td align=\"center\" valign=\"center\" width=\"30\">\n<span class=\"icon ptr1\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\">\nCondor Daemon Log can't grow beyond 2GB</td></tr>\n<tr><td align=\"right\" valign=\"top\" width=\"160\">\n<span class=\"ticket\"><a class=\"new\" href=\"/tickets?ticket=1175\" onclick=\"get_ticket_and_populate_wrapper('1175'); return false;\" title=\"Good error messages for invalid configuration settings\">#1175</a></span></td>\n<td align=\"center\" valign=\"center\" width=\"30\">\n<span class=\"icon ptr1\">\u00a0</span></td>\n<td align=\"left\" valign=\"top\">\nGood error messages for invalid configuration settings</td></tr>\n</tbody></table>", "attachments": "<html><head></head><body></body></html>", "check_ins": "", "type": "enhance", "last_change": "2011-Mar-30 11:59", "status": "stalled", "created": "2009-Nov-20 11:44", "fixed_version": "2009-Nov-20 11:44", "broken_version": "", "priority": "4", "subsystem": "", "assigned_to": "psilord", "derived_from": "#123", "creator": "psilord", "rust": "", "customer_group": "other", "visibility": "public", "notify": "psilord@cs.wisc.edu, willb@redhat.com, adesmet@cs.wisc.edu", "due_date": ""}